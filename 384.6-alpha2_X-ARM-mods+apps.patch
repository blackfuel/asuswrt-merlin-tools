--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/config_base.6a
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/config_base.6a
@@ -416,7 +416,7 @@
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 CONFIG_IP_ADVANCED_ROUTER=y
-# CONFIG_IP_MROUTE_MULTIPLE_TABLES is not set
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
 CONFIG_ASK_IP_FIB_HASH=y
 # CONFIG_IP_FIB_TRIE is not set
 CONFIG_IP_FIB_HASH=y
@@ -486,7 +486,7 @@
 CONFIG_NETFILTER_NETLINK_LOG=y
 CONFIG_NF_CONNTRACK=y
 CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
+CONFIG_NF_CONNTRACK_EVENTS=y
 # CONFIG_NF_CT_PROTO_DCCP is not set
 CONFIG_NF_CT_PROTO_GRE=m
 # CONFIG_NF_CT_PROTO_SCTP is not set
@@ -533,12 +533,13 @@
 CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
 # CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
 # CONFIG_NETFILTER_XT_MATCH_LAYER7 is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG is not set
 
 #
 # Xtables matches
 #
 # CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
-# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not
 CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
 CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
 CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
@@ -567,7 +568,7 @@
 # CONFIG_NETFILTER_XT_MATCH_SCTP is not set
 # CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
 CONFIG_NETFILTER_XT_MATCH_STATE=y
-# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
 CONFIG_NETFILTER_XT_MATCH_STRING=y
 CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
 CONFIG_NETFILTER_XT_MATCH_TIME=y
@@ -1032,7 +1033,28 @@
 # CONFIG_SCSI_DH is not set
 # CONFIG_SCSI_OSD_INITIATOR is not set
 # CONFIG_ATA is not set
-# CONFIG_MD is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MULTICORE_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=m
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_MULTIPATH_QL is not set
+# CONFIG_DM_MULTIPATH_ST is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
 # CONFIG_FUSION is not set
 
 #
@@ -1245,7 +1267,10 @@
 #
 # PPS support
 #
-# CONFIG_PPS is not set
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_LDISC=m
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -1432,13 +1457,13 @@
 # CONFIG_USB_SERIAL_AIRCABLE is not set
 # CONFIG_USB_SERIAL_ARK3116 is not set
 # CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
+CONFIG_USB_SERIAL_CH341=m
 # CONFIG_USB_SERIAL_WHITEHEAT is not set
 # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_CP210X is not set
+CONFIG_USB_SERIAL_CP210X=m
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
 # CONFIG_USB_SERIAL_FUNSOFT is not set
 # CONFIG_USB_SERIAL_VISOR is not set
 # CONFIG_USB_SERIAL_IPAQ is not set
@@ -1457,7 +1482,7 @@
 # CONFIG_USB_SERIAL_MOS7840 is not set
 # CONFIG_USB_SERIAL_MOTOROLA is not set
 # CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
+CONFIG_USB_SERIAL_PL2303=m
 # CONFIG_USB_SERIAL_OTI6858 is not set
 # CONFIG_USB_SERIAL_QCAUX is not set
 # CONFIG_USB_SERIAL_QUALCOMM is not set
@@ -1582,8 +1607,11 @@
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
@@ -1631,11 +1659,12 @@
 # CONFIG_JFFS2_CMODE_SIZE is not set
 # CONFIG_JFFS2_CMODE_FAVOURLZO is not set
 # CONFIG_LOGFS is not set
-# CONFIG_CRAMFS is not set
+CONFIG_CRAMFS=m
 CONFIG_SQUASHFS=y
 # CONFIG_SQUASHFS_XATTR is not set
 # CONFIG_SQUASHFS_LZO is not set
 CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
 CONFIG_SQUASHFS_EMBEDDED=y
 CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
 # CONFIG_VXFS_FS is not set
@@ -1828,7 +1857,7 @@
 CONFIG_CRYPTO_ECB=y
 # CONFIG_CRYPTO_LRW is not set
 # CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
+CONFIG_CRYPTO_XTS=m
 
 #
 # Hash modes
@@ -1845,41 +1874,42 @@
 # CONFIG_CRYPTO_MD4 is not set
 CONFIG_CRYPTO_MD5=y
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
 CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
 
 #
 # Ciphers
 #
 CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ANUBIS=m
 CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_DES=m
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
 
 #
 # Compression
 #
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=m
 
 #
 # Random Number Generation
@@ -1887,9 +1917,17 @@
 CONFIG_CRYPTO_ANSI_CPRNG=y
 CONFIG_CRYPTO_HW=y
 # CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X_RNG is not set
 # CONFIG_BINARY_PRINTF is not set
 
 #
+# User-space algorithms
+#
+CONFIG_CRYPTO_USER_API=m
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+
+#
 # Library routines
 #
 CONFIG_BITREVERSE=y
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
@@ -1868,8 +1868,20 @@
 	   are only processed once.  */
 	status = packet[0] & FTDI_STATUS_B0_MASK;
 	if (status != priv->prev_status) {
-		priv->diff_status |= status ^ priv->prev_status;
-		wake_up_interruptible(&priv->delta_msr_wait);
+                char diff_status = status ^ priv->prev_status;
+                priv->diff_status |= diff_status;
+        
+                if (diff_status & FTDI_RS0_RLSD) {
+                        struct tty_struct *tty;
+ 
+                        tty = tty_port_tty_get(&port->port);
+                        if (tty)
+                                usb_serial_handle_dcd_change(port, tty,
+                                                status & FTDI_RS0_RLSD);
+                        tty_kref_put(tty);
+                }
+
+                wake_up_interruptible(&priv->delta_msr_wait);
 		priv->prev_status = status;
 	}
 
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/serial/generic.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/serial/generic.c
@@ -491,6 +491,15 @@
 	struct tty_port *port = &usb_port->port;
 
 	dbg("%s - port %d, status %d", __func__, usb_port->number, status);
+        if (tty) {
+               struct tty_ldisc *ld = tty_ldisc_ref(tty);
+
+               if (ld) {
+                       if (ld->ops->dcd_change)
+                               ld->ops->dcd_change(tty, status, NULL);
+                       tty_ldisc_deref(ld);
+               }
+        }
 
 	if (status)
 		wake_up_interruptible(&port->open_wait);
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/Kconfig
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/Kconfig
@@ -66,6 +66,28 @@
 
 	  If unsure, say N.
 
+config SQUASHFS_4K_DEVBLK_SIZE
+	bool "Use 4K device block size?"
+	depends on SQUASHFS
+	help
+	  By default Squashfs sets the dev block size (sb_min_blocksize)
+	  to 1K or the smallest block size supported by the block device
+	  (if larger).  This, because blocks are packed together and
+	  unaligned in Squashfs, should reduce latency.
+
+	  This, however, gives poor performance on MTD NAND devices where
+	  the optimal I/O size is 4K (even though the devices can support
+	  smaller block sizes).
+
+	  Using a 4K device block size may also improve overall I/O
+	  performance for some file access patterns (e.g. sequential
+	  accesses of files in filesystem order) on all media.
+
+	  Setting this option will force Squashfs to use a 4K device block
+	  size by default.
+
+	  If unsure, say N.
+
 config SQUASHFS_EMBEDDED
 	bool "Additional option for memory-constrained systems"
 	depends on SQUASHFS
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
@@ -37,6 +37,13 @@
 #define SQUASHFS_FILE_SIZE		131072
 #define SQUASHFS_FILE_LOG		17
 
+/* default size of block device I/O */
+#ifdef CONFIG_SQUASHFS_4K_DEVBLK_SIZE
+#define SQUASHFS_DEVBLK_SIZE 4096
+#else
+#define SQUASHFS_DEVBLK_SIZE 1024
+#endif
+
 #define SQUASHFS_FILE_MAX_SIZE		1048576
 #define SQUASHFS_FILE_MAX_LOG		20
 
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/super.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/super.c
@@ -102,7 +102,7 @@
 		goto failure;
 	}
 
-	msblk->devblksize = sb_min_blocksize(sb, BLOCK_SIZE);
+	msblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);
 	msblk->devblksize_log2 = ffz(~msblk->devblksize);
 
 	mutex_init(&msblk->read_data_mutex);
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/Makefile
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/Makefile
@@ -85,6 +85,9 @@
 obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
 obj-$(CONFIG_CRYPTO_GHASH) += ghash-generic.o
+obj-$(CONFIG_CRYPTO_USER_API) += af_alg.o
+obj-$(CONFIG_CRYPTO_USER_API_HASH) += algif_hash.o
+obj-$(CONFIG_CRYPTO_USER_API_SKCIPHER) += algif_skcipher.o
 
 #
 # generic algorithms and the async_tx api
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/Kconfig
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/Kconfig
@@ -842,6 +842,27 @@
 	  ANSI X9.31 A.2.4. Note that this option must be enabled if
 	  CRYPTO_FIPS is selected
 
+config CRYPTO_USER_API
+	tristate
+
+config CRYPTO_USER_API_HASH
+	tristate "User-space interface for hash algorithms"
+	depends on NET
+	select CRYPTO_HASH
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for hash
+	  algorithms.
+
+config CRYPTO_USER_API_SKCIPHER
+	tristate "User-space interface for symmetric key cipher algorithms"
+	depends on NET
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for symmetric
+	  key cipher algorithms.
+
 source "drivers/crypto/Kconfig"
 
 endif	# if CRYPTO
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/af_alg.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/af_alg.c
@@ -0,0 +1,483 @@
+/*
+ * af_alg: User-space algorithm interface
+ *
+ * This file provides the user-space API for algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <asm/atomic.h>
+#include <crypto/if_alg.h>
+#include <linux/crypto.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/rwsem.h>
+
+struct alg_type_list {
+	const struct af_alg_type *type;
+	struct list_head list;
+};
+
+static atomic_long_t alg_memory_allocated;
+
+static struct proto alg_proto = {
+	.name			= "ALG",
+	.owner			= THIS_MODULE,
+	.memory_allocated	= &alg_memory_allocated,
+	.obj_size		= sizeof(struct alg_sock),
+};
+
+static LIST_HEAD(alg_types);
+static DECLARE_RWSEM(alg_types_sem);
+
+static const struct af_alg_type *alg_get_type(const char *name)
+{
+	const struct af_alg_type *type = ERR_PTR(-ENOENT);
+	struct alg_type_list *node;
+
+	down_read(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, name))
+			continue;
+
+		if (try_module_get(node->type->owner))
+			type = node->type;
+		break;
+	}
+	up_read(&alg_types_sem);
+
+	return type;
+}
+
+int af_alg_register_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -EEXIST;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (!strcmp(node->type->name, type->name))
+			goto unlock;
+	}
+
+	node = kmalloc(sizeof(*node), GFP_KERNEL);
+	err = -ENOMEM;
+	if (!node)
+		goto unlock;
+
+	type->ops->owner = THIS_MODULE;
+	node->type = type;
+	list_add(&node->list, &alg_types);
+	err = 0;
+
+unlock:
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_register_type);
+
+int af_alg_unregister_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -ENOENT;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, type->name))
+			continue;
+
+		list_del(&node->list);
+		kfree(node);
+		err = 0;
+		break;
+	}
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_unregister_type);
+
+static void alg_do_release(const struct af_alg_type *type, void *private)
+{
+	if (!type)
+		return;
+
+	type->release(private);
+	module_put(type->owner);
+}
+
+int af_alg_release(struct socket *sock)
+{
+	if (sock->sk)
+		sock_put(sock->sk);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_release);
+
+static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct sockaddr_alg *sa = (void *)uaddr;
+	const struct af_alg_type *type;
+	void *private;
+
+	if (sock->state == SS_CONNECTED)
+		return -EINVAL;
+
+	if (addr_len != sizeof(*sa))
+		return -EINVAL;
+
+	sa->salg_type[sizeof(sa->salg_type) - 1] = 0;
+	sa->salg_name[sizeof(sa->salg_name) - 1] = 0;
+
+	type = alg_get_type(sa->salg_type);
+	if (IS_ERR(type) && PTR_ERR(type) == -ENOENT) {
+		request_module("algif-%s", sa->salg_type);
+		type = alg_get_type(sa->salg_type);
+	}
+
+	if (IS_ERR(type))
+		return PTR_ERR(type);
+
+	private = type->bind(sa->salg_name, sa->salg_feat, sa->salg_mask);
+	if (IS_ERR(private)) {
+		module_put(type->owner);
+		return PTR_ERR(private);
+	}
+
+	lock_sock(sk);
+
+	swap(ask->type, type);
+	swap(ask->private, private);
+
+	release_sock(sk);
+
+	alg_do_release(type, private);
+
+	return 0;
+}
+
+static int alg_setkey(struct sock *sk, char __user *ukey,
+		      unsigned int keylen)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type = ask->type;
+	u8 *key;
+	int err;
+
+	key = sock_kmalloc(sk, keylen, GFP_KERNEL);
+	if (!key)
+		return -ENOMEM;
+
+	err = -EFAULT;
+	if (copy_from_user(key, ukey, keylen))
+		goto out;
+
+	err = type->setkey(ask->private, key, keylen);
+
+out:
+	sock_kfree_s(sk, key, keylen);
+
+	return err;
+}
+
+static int alg_setsockopt(struct socket *sock, int level, int optname,
+			  char __user *optval, unsigned int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	int err = -ENOPROTOOPT;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	if (level != SOL_ALG || !type)
+		goto unlock;
+
+	switch (optname) {
+	case ALG_SET_KEY:
+		if (sock->state == SS_CONNECTED)
+			goto unlock;
+		if (!type->setkey)
+			goto unlock;
+
+		err = alg_setkey(sk, optval, optlen);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+
+int af_alg_accept(struct sock *sk, struct socket *newsock)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	struct sock *sk2;
+	int err;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	err = -EINVAL;
+	if (!type)
+		goto unlock;
+
+	sk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto);
+	err = -ENOMEM;
+	if (!sk2)
+		goto unlock;
+
+	sock_init_data(newsock, sk2);
+	sock_graft(sk2, newsock);
+
+	err = type->accept(ask->private, sk2);
+	if (err) {
+		sk_free(sk2);
+		goto unlock;
+	}
+
+	sk2->sk_family = PF_ALG;
+
+	sock_hold(sk);
+	alg_sk(sk2)->parent = sk;
+	alg_sk(sk2)->type = type;
+
+	newsock->ops = type->ops;
+	newsock->state = SS_CONNECTED;
+
+	err = 0;
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_accept);
+
+static int alg_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	return af_alg_accept(sock->sk, newsock);
+}
+
+static const struct proto_ops alg_proto_ops = {
+	.family		=	PF_ALG,
+	.owner		=	THIS_MODULE,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.sendpage	=	sock_no_sendpage,
+	.sendmsg	=	sock_no_sendmsg,
+	.recvmsg	=	sock_no_recvmsg,
+	.poll		=	sock_no_poll,
+
+	.bind		=	alg_bind,
+	.release	=	af_alg_release,
+	.setsockopt	=	alg_setsockopt,
+	.accept		=	alg_accept,
+};
+
+static void alg_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+
+	alg_do_release(ask->type, ask->private);
+}
+
+static int alg_create(struct net *net, struct socket *sock, int protocol,
+		      int kern)
+{
+	struct sock *sk;
+	int err;
+
+	if (sock->type != SOCK_SEQPACKET)
+		return -ESOCKTNOSUPPORT;
+	if (protocol != 0)
+		return -EPROTONOSUPPORT;
+
+	err = -ENOMEM;
+	sk = sk_alloc(net, PF_ALG, GFP_KERNEL, &alg_proto);
+	if (!sk)
+		goto out;
+
+	sock->ops = &alg_proto_ops;
+	sock_init_data(sock, sk);
+
+	sk->sk_family = PF_ALG;
+	sk->sk_destruct = alg_sock_destruct;
+
+	return 0;
+out:
+	return err;
+}
+
+static const struct net_proto_family alg_family = {
+	.family	=	PF_ALG,
+	.create	=	alg_create,
+	.owner	=	THIS_MODULE,
+};
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write)
+{
+	unsigned long from = (unsigned long)addr;
+	unsigned long npages;
+	unsigned off;
+	int err;
+	int i;
+
+	err = -EFAULT;
+	if (!access_ok(write ? VERIFY_READ : VERIFY_WRITE, addr, len))
+		goto out;
+
+	off = from & ~PAGE_MASK;
+	npages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	if (npages > ALG_MAX_PAGES)
+		npages = ALG_MAX_PAGES;
+
+	err = get_user_pages_fast(from, npages, write, sgl->pages);
+	if (err < 0)
+		goto out;
+
+	npages = err;
+	err = -EINVAL;
+	if (WARN_ON(npages == 0))
+		goto out;
+
+	err = 0;
+
+	sg_init_table(sgl->sg, npages);
+
+	for (i = 0; i < npages; i++) {
+		int plen = min_t(int, len, PAGE_SIZE - off);
+
+		sg_set_page(sgl->sg + i, sgl->pages[i], plen, off);
+
+		off = 0;
+		len -= plen;
+		err += plen;
+	}
+
+out:
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_make_sg);
+
+void af_alg_free_sg(struct af_alg_sgl *sgl)
+{
+	int i;
+
+	i = 0;
+	do {
+		put_page(sgl->pages[i]);
+	} while (!sg_is_last(sgl->sg + (i++)));
+}
+EXPORT_SYMBOL_GPL(af_alg_free_sg);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con)
+{
+	struct cmsghdr *cmsg;
+
+	for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
+		if (!CMSG_OK(msg, cmsg))
+			return -EINVAL;
+		if (cmsg->cmsg_level != SOL_ALG)
+			continue;
+
+		switch(cmsg->cmsg_type) {
+		case ALG_SET_IV:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(*con->iv)))
+				return -EINVAL;
+			con->iv = (void *)CMSG_DATA(cmsg);
+			if (cmsg->cmsg_len < CMSG_LEN(con->iv->ivlen +
+						      sizeof(*con->iv)))
+				return -EINVAL;
+			break;
+
+		case ALG_SET_OP:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))
+				return -EINVAL;
+			con->op = *(u32 *)CMSG_DATA(cmsg);
+			break;
+
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_cmsg_send);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion)
+{
+	switch (err) {
+	case -EINPROGRESS:
+	case -EBUSY:
+		wait_for_completion(&completion->completion);
+		INIT_COMPLETION(completion->completion);
+		err = completion->err;
+		break;
+	};
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_wait_for_completion);
+
+void af_alg_complete(struct crypto_async_request *req, int err)
+{
+	struct af_alg_completion *completion = req->data;
+
+	completion->err = err;
+	complete(&completion->completion);
+}
+EXPORT_SYMBOL_GPL(af_alg_complete);
+
+static int __init af_alg_init(void)
+{
+	int err = proto_register(&alg_proto, 0);
+
+	if (err)
+		goto out;
+
+	err = sock_register(&alg_family);
+	if (err != 0)
+		goto out_unregister_proto;
+
+out:
+	return err;
+
+out_unregister_proto:
+	proto_unregister(&alg_proto);
+	goto out;
+}
+
+static void __exit af_alg_exit(void)
+{
+	sock_unregister(PF_ALG);
+	proto_unregister(&alg_proto);
+}
+
+module_init(af_alg_init);
+module_exit(af_alg_exit);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_NETPROTO(AF_ALG);
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/algif_hash.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/algif_hash.c
@@ -0,0 +1,319 @@
+/*
+ * algif_hash: User-space interface for hash algorithms
+ *
+ * This file provides the user-space API for hash algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/hash.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct hash_ctx {
+	struct af_alg_sgl sgl;
+
+	u8 *result;
+
+	struct af_alg_completion completion;
+
+	unsigned int len;
+	bool more;
+
+	struct ahash_request req;
+};
+
+static int hash_sendmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t ignored)
+{
+	int limit = ALG_MAX_PAGES * PAGE_SIZE;
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned long iovlen;
+	struct iovec *iov;
+	long copied = 0;
+	int err;
+
+	if (limit > sk->sk_sndbuf)
+		limit = sk->sk_sndbuf;
+
+	lock_sock(sk);
+	if (!ctx->more) {
+		err = crypto_ahash_init(&ctx->req);
+		if (err)
+			goto unlock;
+	}
+
+	ctx->more = 0;
+
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			int len = min_t(unsigned long, seglen, limit);
+			int newlen;
+
+			newlen = af_alg_make_sg(&ctx->sgl, from, len, 0);
+			if (newlen < 0)
+				goto unlock;
+
+			ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL,
+						newlen);
+
+			err = af_alg_wait_for_completion(
+				crypto_ahash_update(&ctx->req),
+				&ctx->completion);
+
+			af_alg_free_sg(&ctx->sgl);
+
+			if (err)
+				goto unlock;
+
+			seglen -= newlen;
+			from += newlen;
+			copied += newlen;
+		}
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more) {
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err ?: copied;
+}
+
+static ssize_t hash_sendpage(struct socket *sock, struct page *page,
+			     int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	int err;
+
+	lock_sock(sk);
+	sg_init_table(ctx->sgl.sg, 1);
+	sg_set_page(ctx->sgl.sg, page, size, offset);
+
+	ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, ctx->result, size);
+
+	if (!(flags & MSG_MORE)) {
+		if (ctx->more)
+			err = crypto_ahash_finup(&ctx->req);
+		else
+			err = crypto_ahash_digest(&ctx->req);
+	} else {
+		if (!ctx->more) {
+			err = crypto_ahash_init(&ctx->req);
+			if (err)
+				goto unlock;
+		}
+
+		err = crypto_ahash_update(&ctx->req);
+	}
+
+	err = af_alg_wait_for_completion(err, &ctx->completion);
+	if (err)
+		goto unlock;
+
+	ctx->more = flags & MSG_MORE;
+
+unlock:
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t len, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
+	int err;
+
+	if (len > ds)
+		len = ds;
+	else if (len < ds)
+		msg->msg_flags |= MSG_TRUNC;
+
+	lock_sock(sk);
+	if (ctx->more) {
+		ctx->more = 0;
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+		if (err)
+			goto unlock;
+	}
+
+	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);
+
+unlock:
+	release_sock(sk);
+
+	return err ?: len;
+}
+
+static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	struct ahash_request *req = &ctx->req;
+	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];
+	struct sock *sk2;
+	struct alg_sock *ask2;
+	struct hash_ctx *ctx2;
+	int err;
+
+	err = crypto_ahash_export(req, state);
+	if (err)
+		return err;
+
+	err = af_alg_accept(ask->parent, newsock);
+	if (err)
+		return err;
+
+	sk2 = newsock->sk;
+	ask2 = alg_sk(sk2);
+	ctx2 = ask2->private;
+	ctx2->more = 1;
+
+	err = crypto_ahash_import(&ctx2->req, state);
+	if (err) {
+		sock_orphan(sk2);
+		sock_put(sk2);
+	}
+
+	return err;
+}
+
+static struct proto_ops algif_hash_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.setsockopt	=	sock_no_setsockopt,
+	.poll		=	sock_no_poll,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	hash_sendmsg,
+	.sendpage	=	hash_sendpage,
+	.recvmsg	=	hash_recvmsg,
+	.accept		=	hash_accept,
+};
+
+static void *hash_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ahash(name, type, mask);
+}
+
+static void hash_release(void *private)
+{
+	crypto_free_ahash(private);
+}
+
+static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ahash_setkey(private, key, keylen);
+}
+
+static void hash_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+
+	sock_kfree_s(sk, ctx->result,
+		     crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int hash_accept_parent(void *private, struct sock *sk)
+{
+	struct hash_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);
+	unsigned ds = crypto_ahash_digestsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);
+	if (!ctx->result) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->result, 0, ds);
+
+	ctx->len = len;
+	ctx->more = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ahash_request_set_tfm(&ctx->req, private);
+	ahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				   af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = hash_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_hash = {
+	.bind		=	hash_bind,
+	.release	=	hash_release,
+	.setkey		=	hash_setkey,
+	.accept		=	hash_accept_parent,
+	.ops		=	&algif_hash_ops,
+	.name		=	"hash",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_hash_init(void)
+{
+	return af_alg_register_type(&algif_type_hash);
+}
+
+static void __exit algif_hash_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_hash);
+	BUG_ON(err);
+}
+
+module_init(algif_hash_init);
+module_exit(algif_hash_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/algif_skcipher.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/algif_skcipher.c
@@ -0,0 +1,632 @@
+/*
+ * algif_skcipher: User-space interface for skcipher algorithms
+ *
+ * This file provides the user-space API for symmetric key ciphers.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/scatterwalk.h>
+#include <crypto/skcipher.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct skcipher_sg_list {
+	struct list_head list;
+
+	int cur;
+
+	struct scatterlist sg[0];
+};
+
+struct skcipher_ctx {
+	struct list_head tsgl;
+	struct af_alg_sgl rsgl;
+
+	void *iv;
+
+	struct af_alg_completion completion;
+
+	unsigned used;
+
+	unsigned int len;
+	bool more;
+	bool merge;
+	bool enc;
+
+	struct ablkcipher_request req;
+};
+
+#define MAX_SGL_ENTS ((PAGE_SIZE - sizeof(struct skcipher_sg_list)) / \
+		      sizeof(struct scatterlist) - 1)
+
+static inline int skcipher_sndbuf(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	return max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -
+			  ctx->used, 0);
+}
+
+static inline bool skcipher_writable(struct sock *sk)
+{
+	return PAGE_SIZE <= skcipher_sndbuf(sk);
+}
+
+static int skcipher_alloc_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg = NULL;
+
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+	if (!list_empty(&ctx->tsgl))
+		sg = sgl->sg;
+
+	if (!sg || sgl->cur >= MAX_SGL_ENTS) {
+		sgl = sock_kmalloc(sk, sizeof(*sgl) +
+				       sizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),
+				   GFP_KERNEL);
+		if (!sgl)
+			return -ENOMEM;
+
+		sg_init_table(sgl->sg, MAX_SGL_ENTS + 1);
+		sgl->cur = 0;
+
+		if (sg)
+			scatterwalk_sg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);
+
+		list_add_tail(&sgl->list, &ctx->tsgl);
+	}
+
+	return 0;
+}
+
+static void skcipher_pull_sgl(struct sock *sk, int used)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	int i;
+
+	while (!list_empty(&ctx->tsgl)) {
+		sgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,
+				       list);
+		sg = sgl->sg;
+
+		for (i = 0; i < sgl->cur; i++) {
+			int plen = min_t(int, used, sg[i].length);
+
+			if (!sg_page(sg + i))
+				continue;
+
+			sg[i].length -= plen;
+			sg[i].offset += plen;
+
+			used -= plen;
+			ctx->used -= plen;
+
+			if (sg[i].length)
+				return;
+
+			put_page(sg_page(sg + i));
+			sg_assign_page(sg + i, NULL);
+		}
+
+		list_del(&sgl->list);
+		sock_kfree_s(sk, sgl,
+			     sizeof(*sgl) + sizeof(sgl->sg[0]) *
+					    (MAX_SGL_ENTS + 1));
+	}
+
+	if (!ctx->used)
+		ctx->merge = 0;
+}
+
+static void skcipher_free_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	skcipher_pull_sgl(sk, ctx->used);
+}
+
+static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)
+{
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT)
+		return -EAGAIN;
+
+	set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	return err;
+}
+
+static void skcipher_wmem_wakeup(struct sock *sk)
+{
+	struct socket_wq *wq;
+
+	if (!skcipher_writable(sk))
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLIN |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
+	rcu_read_unlock();
+}
+
+static int skcipher_wait_for_data(struct sock *sk, unsigned flags)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT) {
+		return -EAGAIN;
+	}
+
+	set_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, ctx->used)) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	return err;
+}
+
+static void skcipher_data_wakeup(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct socket_wq *wq;
+
+	if (!ctx->used)
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLOUT |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);
+	rcu_read_unlock();
+}
+
+static int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+	unsigned ivsize = crypto_ablkcipher_ivsize(tfm);
+	struct skcipher_sg_list *sgl;
+	struct af_alg_control con = {};
+	long copied = 0;
+	bool enc = 0;
+	int err;
+	int i;
+
+	if (msg->msg_controllen) {
+		err = af_alg_cmsg_send(msg, &con);
+		if (err)
+			return err;
+
+		switch (con.op) {
+		case ALG_OP_ENCRYPT:
+			enc = 1;
+			break;
+		case ALG_OP_DECRYPT:
+			enc = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (con.iv && con.iv->ivlen != ivsize)
+			return -EINVAL;
+	}
+
+	err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!ctx->used) {
+		ctx->enc = enc;
+		if (con.iv)
+			memcpy(ctx->iv, con.iv->iv, ivsize);
+	}
+
+	while (size) {
+		struct scatterlist *sg;
+		unsigned long len = size;
+		int plen;
+
+		if (ctx->merge) {
+			sgl = list_entry(ctx->tsgl.prev,
+					 struct skcipher_sg_list, list);
+			sg = sgl->sg + sgl->cur - 1;
+			len = min_t(unsigned long, len,
+				    PAGE_SIZE - sg->offset - sg->length);
+
+			err = memcpy_fromiovec(page_address(sg_page(sg)) +
+					       sg->offset + sg->length,
+					       msg->msg_iov, len);
+			if (err)
+				goto unlock;
+
+			sg->length += len;
+			ctx->merge = (sg->offset + sg->length) &
+				     (PAGE_SIZE - 1);
+
+			ctx->used += len;
+			copied += len;
+			size -= len;
+			continue;
+		}
+
+		if (!skcipher_writable(sk)) {
+			err = skcipher_wait_for_wmem(sk, msg->msg_flags);
+			if (err)
+				goto unlock;
+		}
+
+		len = min_t(unsigned long, len, skcipher_sndbuf(sk));
+
+		err = skcipher_alloc_sgl(sk);
+		if (err)
+			goto unlock;
+
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+		sg = sgl->sg;
+		do {
+			i = sgl->cur;
+			plen = min_t(int, len, PAGE_SIZE);
+
+			sg_assign_page(sg + i, alloc_page(GFP_KERNEL));
+			err = -ENOMEM;
+			if (!sg_page(sg + i))
+				goto unlock;
+
+			err = memcpy_fromiovec(page_address(sg_page(sg + i)),
+					       msg->msg_iov, plen);
+			if (err) {
+				__free_page(sg_page(sg + i));
+				sg_assign_page(sg + i, NULL);
+				goto unlock;
+			}
+
+			sg[i].length = plen;
+			len -= plen;
+			ctx->used += plen;
+			copied += plen;
+			size -= plen;
+			sgl->cur++;
+		} while (len && sgl->cur < MAX_SGL_ENTS);
+
+		ctx->merge = plen & (PAGE_SIZE - 1);
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+static ssize_t skcipher_sendpage(struct socket *sock, struct page *page,
+				 int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	int err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!size)
+		goto done;
+
+	if (!skcipher_writable(sk)) {
+		err = skcipher_wait_for_wmem(sk, flags);
+		if (err)
+			goto unlock;
+	}
+
+	err = skcipher_alloc_sgl(sk);
+	if (err)
+		goto unlock;
+
+	ctx->merge = 0;
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+	get_page(page);
+	sg_set_page(sgl->sg + sgl->cur, page, size, offset);
+	sgl->cur++;
+	ctx->used += size;
+
+done:
+	ctx->more = flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t ignored, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(
+		&ctx->req));
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	unsigned long iovlen;
+	struct iovec *iov;
+	int err = -EAGAIN;
+	int used;
+	long copied = 0;
+
+	lock_sock(sk);
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			sgl = list_first_entry(&ctx->tsgl,
+					       struct skcipher_sg_list, list);
+			sg = sgl->sg;
+
+			while (!sg->length)
+				sg++;
+
+			used = ctx->used;
+			if (!used) {
+				err = skcipher_wait_for_data(sk, flags);
+				if (err)
+					goto unlock;
+			}
+
+			used = min_t(unsigned long, used, seglen);
+
+			used = af_alg_make_sg(&ctx->rsgl, from, used, 1);
+			err = used;
+			if (err < 0)
+				goto unlock;
+
+			if (ctx->more || used < ctx->used)
+				used -= used % bs;
+
+			err = -EINVAL;
+			if (!used)
+				goto free;
+
+			ablkcipher_request_set_crypt(&ctx->req, sg,
+						     ctx->rsgl.sg, used,
+						     ctx->iv);
+
+			err = af_alg_wait_for_completion(
+				ctx->enc ?
+					crypto_ablkcipher_encrypt(&ctx->req) :
+					crypto_ablkcipher_decrypt(&ctx->req),
+				&ctx->completion);
+
+free:
+			af_alg_free_sg(&ctx->rsgl);
+
+			if (err)
+				goto unlock;
+
+			copied += used;
+			from += used;
+			seglen -= used;
+			skcipher_pull_sgl(sk, used);
+		}
+	}
+
+	err = 0;
+
+unlock:
+	skcipher_wmem_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+
+static unsigned int skcipher_poll(struct file *file, struct socket *sock,
+				  poll_table *wait)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned int mask;
+
+	sock_poll_wait(file, sk_sleep(sk), wait);
+	mask = 0;
+
+	if (ctx->used)
+		mask |= POLLIN | POLLRDNORM;
+
+	if (skcipher_writable(sk))
+		mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
+
+	return mask;
+}
+
+static struct proto_ops algif_skcipher_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.accept		=	sock_no_accept,
+	.setsockopt	=	sock_no_setsockopt,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	skcipher_sendmsg,
+	.sendpage	=	skcipher_sendpage,
+	.recvmsg	=	skcipher_recvmsg,
+	.poll		=	skcipher_poll,
+};
+
+static void *skcipher_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ablkcipher(name, type, mask);
+}
+
+static void skcipher_release(void *private)
+{
+	crypto_free_ablkcipher(private);
+}
+
+static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ablkcipher_setkey(private, key, keylen);
+}
+
+static void skcipher_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+
+	skcipher_free_sgl(sk);
+	sock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int skcipher_accept_parent(void *private, struct sock *sk)
+{
+	struct skcipher_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),
+			       GFP_KERNEL);
+	if (!ctx->iv) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));
+
+	INIT_LIST_HEAD(&ctx->tsgl);
+	ctx->len = len;
+	ctx->used = 0;
+	ctx->more = 0;
+	ctx->merge = 0;
+	ctx->enc = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ablkcipher_request_set_tfm(&ctx->req, private);
+	ablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = skcipher_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_skcipher = {
+	.bind		=	skcipher_bind,
+	.release	=	skcipher_release,
+	.setkey		=	skcipher_setkey,
+	.accept		=	skcipher_accept_parent,
+	.ops		=	&algif_skcipher_ops,
+	.name		=	"skcipher",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_skcipher_init(void)
+{
+	return af_alg_register_type(&algif_type_skcipher);
+}
+
+static void __exit algif_skcipher_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_skcipher);
+	BUG_ON(err);
+}
+
+module_init(algif_skcipher_init);
+module_exit(algif_skcipher_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/core/sock.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/core/sock.c
@@ -157,7 +157,7 @@
   "sk_lock-27"       , "sk_lock-28"          , "sk_lock-AF_CAN"      ,
   "sk_lock-AF_TIPC"  , "sk_lock-AF_BLUETOOTH", "sk_lock-IUCV"        ,
   "sk_lock-AF_RXRPC" , "sk_lock-AF_ISDN"     , "sk_lock-AF_PHONET"   ,
-  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" ,
+  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" , "sk_lock-AF_ALG"      ,
   "sk_lock-AF_MAX"
 };
 static const char *const af_family_slock_key_strings[AF_MAX+1] = {
@@ -173,7 +173,7 @@
   "slock-27"       , "slock-28"          , "slock-AF_CAN"      ,
   "slock-AF_TIPC"  , "slock-AF_BLUETOOTH", "slock-AF_IUCV"     ,
   "slock-AF_RXRPC" , "slock-AF_ISDN"     , "slock-AF_PHONET"   ,
-  "slock-AF_IEEE802154", "slock-AF_CAIF" ,
+  "slock-AF_IEEE802154", "slock-AF_CAIF" , "slock-AF_ALG"      ,
   "slock-AF_MAX"
 };
 static const char *const af_family_clock_key_strings[AF_MAX+1] = {
@@ -189,7 +189,7 @@
   "clock-27"       , "clock-28"          , "clock-AF_CAN"      ,
   "clock-AF_TIPC"  , "clock-AF_BLUETOOTH", "clock-AF_IUCV"     ,
   "clock-AF_RXRPC" , "clock-AF_ISDN"     , "clock-AF_PHONET"   ,
-  "clock-AF_IEEE802154", "clock-AF_CAIF" ,
+  "clock-AF_IEEE802154", "clock-AF_CAIF" , "clock-AF_ALG"      ,
   "clock-AF_MAX"
 };
 
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/crypto/if_alg.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/crypto/if_alg.h
@@ -0,0 +1,92 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _CRYPTO_IF_ALG_H
+#define _CRYPTO_IF_ALG_H
+
+#include <linux/compiler.h>
+#include <linux/completion.h>
+#include <linux/if_alg.h>
+#include <linux/types.h>
+#include <net/sock.h>
+
+#define ALG_MAX_PAGES			16
+
+struct crypto_async_request;
+
+struct alg_sock {
+	/* struct sock must be the first member of struct alg_sock */
+	struct sock sk;
+
+	struct sock *parent;
+
+	const struct af_alg_type *type;
+	void *private;
+};
+
+struct af_alg_completion {
+	struct completion completion;
+	int err;
+};
+
+struct af_alg_control {
+	struct af_alg_iv *iv;
+	int op;
+};
+
+struct af_alg_type {
+	void *(*bind)(const char *name, u32 type, u32 mask);
+	void (*release)(void *private);
+	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
+	int (*accept)(void *private, struct sock *sk);
+
+	struct proto_ops *ops;
+	struct module *owner;
+	char name[14];
+};
+
+struct af_alg_sgl {
+	struct scatterlist sg[ALG_MAX_PAGES];
+	struct page *pages[ALG_MAX_PAGES];
+};
+
+int af_alg_register_type(const struct af_alg_type *type);
+int af_alg_unregister_type(const struct af_alg_type *type);
+
+int af_alg_release(struct socket *sock);
+int af_alg_accept(struct sock *sk, struct socket *newsock);
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write);
+void af_alg_free_sg(struct af_alg_sgl *sgl);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion);
+void af_alg_complete(struct crypto_async_request *req, int err);
+
+static inline struct alg_sock *alg_sk(struct sock *sk)
+{
+	return (struct alg_sock *)sk;
+}
+
+static inline void af_alg_release_parent(struct sock *sk)
+{
+	sock_put(alg_sk(sk)->parent);
+}
+
+static inline void af_alg_init_completion(struct af_alg_completion *completion)
+{
+	init_completion(&completion->completion);
+}
+
+#endif	/* _CRYPTO_IF_ALG_H */
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/crypto/scatterwalk.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/crypto/scatterwalk.h
@@ -68,6 +68,21 @@
 	return (++sg)->length ? sg : (void *)sg_page(sg);
 }
 
+static inline void scatterwalk_crypto_chain(struct scatterlist *head,
+					    struct scatterlist *sg,
+					    int chain, int num)
+{
+	if (chain) {
+		head->length += sg->length;
+		sg = scatterwalk_sg_next(sg);
+	}
+
+	if (sg)
+		scatterwalk_sg_chain(head, num, sg);
+	else
+		sg_mark_end(head);
+}
+
 static inline unsigned long scatterwalk_samebuf(struct scatter_walk *walk_in,
 						struct scatter_walk *walk_out)
 {
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/if_alg.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/if_alg.h
@@ -0,0 +1,40 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _LINUX_IF_ALG_H
+#define _LINUX_IF_ALG_H
+
+#include <linux/types.h>
+
+struct sockaddr_alg {
+	__u16	salg_family;
+	__u8	salg_type[14];
+	__u32	salg_feat;
+	__u32	salg_mask;
+	__u8	salg_name[64];
+};
+
+struct af_alg_iv {
+	__u32	ivlen;
+	__u8	iv[0];
+};
+
+/* Socket options */
+#define ALG_SET_KEY			1
+#define ALG_SET_IV			2
+#define ALG_SET_OP			3
+
+/* Operations */
+#define ALG_OP_DECRYPT			0
+#define ALG_OP_ENCRYPT			1
+
+#endif	/* _LINUX_IF_ALG_H */
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/socket.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/socket.h
@@ -193,7 +193,8 @@
 #define AF_PHONET	35	/* Phonet sockets		*/
 #define AF_IEEE802154	36	/* IEEE802154 sockets		*/
 #define AF_CAIF		37	/* CAIF sockets			*/
-#define AF_MAX		38	/* For now.. */
+#define AF_ALG		38	/* Algorithm sockets		*/
+#define AF_MAX		39	/* For now.. */
 
 /* Protocol families, same as address families. */
 #define PF_UNSPEC	AF_UNSPEC
@@ -234,6 +235,7 @@
 #define PF_PHONET	AF_PHONET
 #define PF_IEEE802154	AF_IEEE802154
 #define PF_CAIF		AF_CAIF
+#define PF_ALG		AF_ALG
 #define PF_MAX		AF_MAX
 
 /* Maximum queue length specifiable by listen.  */
@@ -310,6 +312,7 @@
 #define SOL_RDS		276
 #define SOL_IUCV	277
 #define SOL_CAIF	278
+#define SOL_ALG		279
 
 /* IPX options */
 #define IPX_TYPE	1
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/random.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/random.h
@@ -1,3 +1,8 @@
+///////////////////////////////////////////////////////////////////////////////
+// Entropy backport from Linux 3.16.43 to AsusWrt
+//
+// SOURCE: Linux 3.16.43, include/linux/random.h
+///////////////////////////////////////////////////////////////////////////////
 /*
  * include/linux/random.h
  *
@@ -11,6 +16,411 @@
 #include <linux/ioctl.h>
 #include <linux/irqnr.h>
 
+///////////////////////////////////////////////////////////////////////////////
+// random_get_entropy
+//
+// SOURCE: Linux 3.16.43, include/linux/timex.h
+//
+#ifndef random_get_entropy
+/*
+ * The random_get_entropy() function is used by the /dev/random driver
+ * in order to extract entropy via the relative unpredictability of
+ * when an interrupt takes places versus a high speed, fine-grained
+ * timing source or cycle counter.  Since it will be occurred on every
+ * single interrupt, it must have a very low cost/overhead.
+ *
+ * By default we use get_cycles() for this purpose, but individual
+ * architectures may override this in their asm/timex.h header file.
+ */
+#define random_get_entropy()	get_cycles()
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+// memzero_explicit
+//
+// SOURCE: AsusWrt, release/src-rt-6.x.4708/linux/linux-2.6.36/arch/arm/include/asm/string.h
+//
+#ifndef memzero_explicit
+#define memzero_explicit(p,n)						\
+	({								\
+	 	void *__p = (p); size_t __n = n;			\
+		if ((__n) != 0) {					\
+				__memzero((__p),(__n));			\
+		}							\
+		(__p);							\
+	})
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+// SHA1 transform
+//
+// SOURCE: Linux 3.16.43, lib/sha1.c
+//
+#include <linux/bitops.h>
+#include <linux/cryptohash.h>
+#include <asm/unaligned.h>
+/*
+ * If you have 32 registers or more, the compiler can (and should)
+ * try to change the array[] accesses into registers. However, on
+ * machines with less than ~25 registers, that won't really work,
+ * and at least gcc will make an unholy mess of it.
+ *
+ * So to avoid that mess which just slows things down, we force
+ * the stores to memory to actually happen (we might be better off
+ * with a 'W(t)=(val);asm("":"+m" (W(t))' there instead, as
+ * suggested by Artur Skawina - that will also make gcc unable to
+ * try to do the silly "optimize away loads" part because it won't
+ * see what the value will be).
+ *
+ * Ben Herrenschmidt reports that on PPC, the C version comes close
+ * to the optimized asm with this (ie on PPC you don't want that
+ * 'volatile', since there are lots of registers).
+ *
+ * On ARM we get the best code generation by forcing a full memory barrier
+ * between each SHA_ROUND, otherwise gcc happily get wild with spilling and
+ * the stack frame size simply explode and performance goes down the drain.
+ */
+
+#ifdef CONFIG_X86
+  #define setW(x, val) (*(volatile __u32 *)&W(x) = (val))
+#elif defined(CONFIG_ARM)
+  #define setW(x, val) do { W(x) = (val); __asm__("":::"memory"); } while (0)
+#else
+  #define setW(x, val) (W(x) = (val))
+#endif
+
+/* This "rolls" over the 512-bit array */
+#define W(x) (array[(x)&15])
+
+/*
+ * Where do we get the source from? The first 16 iterations get it from
+ * the input data, the next mix it from the 512-bit array.
+ */
+#define SHA_SRC(t) get_unaligned_be32((__u32 *)data + t)
+#define SHA_MIX(t) rol32(W(t+13) ^ W(t+8) ^ W(t+2) ^ W(t), 1)
+
+#define SHA_ROUND(t, input, fn, constant, A, B, C, D, E) do { \
+	__u32 TEMP = input(t); setW(t, TEMP); \
+	E += TEMP + rol32(A,5) + (fn) + (constant); \
+	B = ror32(B, 2); } while (0)
+
+#define T_0_15(t, A, B, C, D, E)  SHA_ROUND(t, SHA_SRC, (((C^D)&B)^D) , 0x5a827999, A, B, C, D, E )
+#define T_16_19(t, A, B, C, D, E) SHA_ROUND(t, SHA_MIX, (((C^D)&B)^D) , 0x5a827999, A, B, C, D, E )
+#define T_20_39(t, A, B, C, D, E) SHA_ROUND(t, SHA_MIX, (B^C^D) , 0x6ed9eba1, A, B, C, D, E )
+#define T_40_59(t, A, B, C, D, E) SHA_ROUND(t, SHA_MIX, ((B&C)+(D&(B^C))) , 0x8f1bbcdc, A, B, C, D, E )
+#define T_60_79(t, A, B, C, D, E) SHA_ROUND(t, SHA_MIX, (B^C^D) ,  0xca62c1d6, A, B, C, D, E )
+
+/**
+ * sha_transform_inline - single block SHA1 transform
+ *
+ * @digest: 160 bit digest to update
+ * @data:   512 bits of data to hash
+ * @array:  16 words of workspace (see note)
+ *
+ * This function generates a SHA1 digest for a single 512-bit block.
+ * Be warned, it does not handle padding and message digest, do not
+ * confuse it with the full FIPS 180-1 digest algorithm for variable
+ * length messages.
+ *
+ * Note: If the hash is security sensitive, the caller should be sure
+ * to clear the workspace. This is left to the caller to avoid
+ * unnecessary clears between chained hashing operations.
+ */
+static inline void sha_transform_inline(__u32 *digest, const char *data, __u32 *array)
+{
+	__u32 A, B, C, D, E;
+
+	A = digest[0];
+	B = digest[1];
+	C = digest[2];
+	D = digest[3];
+	E = digest[4];
+
+	/* Round 1 - iterations 0-16 take their input from 'data' */
+	T_0_15( 0, A, B, C, D, E);
+	T_0_15( 1, E, A, B, C, D);
+	T_0_15( 2, D, E, A, B, C);
+	T_0_15( 3, C, D, E, A, B);
+	T_0_15( 4, B, C, D, E, A);
+	T_0_15( 5, A, B, C, D, E);
+	T_0_15( 6, E, A, B, C, D);
+	T_0_15( 7, D, E, A, B, C);
+	T_0_15( 8, C, D, E, A, B);
+	T_0_15( 9, B, C, D, E, A);
+	T_0_15(10, A, B, C, D, E);
+	T_0_15(11, E, A, B, C, D);
+	T_0_15(12, D, E, A, B, C);
+	T_0_15(13, C, D, E, A, B);
+	T_0_15(14, B, C, D, E, A);
+	T_0_15(15, A, B, C, D, E);
+
+	/* Round 1 - tail. Input from 512-bit mixing array */
+	T_16_19(16, E, A, B, C, D);
+	T_16_19(17, D, E, A, B, C);
+	T_16_19(18, C, D, E, A, B);
+	T_16_19(19, B, C, D, E, A);
+
+	/* Round 2 */
+	T_20_39(20, A, B, C, D, E);
+	T_20_39(21, E, A, B, C, D);
+	T_20_39(22, D, E, A, B, C);
+	T_20_39(23, C, D, E, A, B);
+	T_20_39(24, B, C, D, E, A);
+	T_20_39(25, A, B, C, D, E);
+	T_20_39(26, E, A, B, C, D);
+	T_20_39(27, D, E, A, B, C);
+	T_20_39(28, C, D, E, A, B);
+	T_20_39(29, B, C, D, E, A);
+	T_20_39(30, A, B, C, D, E);
+	T_20_39(31, E, A, B, C, D);
+	T_20_39(32, D, E, A, B, C);
+	T_20_39(33, C, D, E, A, B);
+	T_20_39(34, B, C, D, E, A);
+	T_20_39(35, A, B, C, D, E);
+	T_20_39(36, E, A, B, C, D);
+	T_20_39(37, D, E, A, B, C);
+	T_20_39(38, C, D, E, A, B);
+	T_20_39(39, B, C, D, E, A);
+
+	/* Round 3 */
+	T_40_59(40, A, B, C, D, E);
+	T_40_59(41, E, A, B, C, D);
+	T_40_59(42, D, E, A, B, C);
+	T_40_59(43, C, D, E, A, B);
+	T_40_59(44, B, C, D, E, A);
+	T_40_59(45, A, B, C, D, E);
+	T_40_59(46, E, A, B, C, D);
+	T_40_59(47, D, E, A, B, C);
+	T_40_59(48, C, D, E, A, B);
+	T_40_59(49, B, C, D, E, A);
+	T_40_59(50, A, B, C, D, E);
+	T_40_59(51, E, A, B, C, D);
+	T_40_59(52, D, E, A, B, C);
+	T_40_59(53, C, D, E, A, B);
+	T_40_59(54, B, C, D, E, A);
+	T_40_59(55, A, B, C, D, E);
+	T_40_59(56, E, A, B, C, D);
+	T_40_59(57, D, E, A, B, C);
+	T_40_59(58, C, D, E, A, B);
+	T_40_59(59, B, C, D, E, A);
+
+	/* Round 4 */
+	T_60_79(60, A, B, C, D, E);
+	T_60_79(61, E, A, B, C, D);
+	T_60_79(62, D, E, A, B, C);
+	T_60_79(63, C, D, E, A, B);
+	T_60_79(64, B, C, D, E, A);
+	T_60_79(65, A, B, C, D, E);
+	T_60_79(66, E, A, B, C, D);
+	T_60_79(67, D, E, A, B, C);
+	T_60_79(68, C, D, E, A, B);
+	T_60_79(69, B, C, D, E, A);
+	T_60_79(70, A, B, C, D, E);
+	T_60_79(71, E, A, B, C, D);
+	T_60_79(72, D, E, A, B, C);
+	T_60_79(73, C, D, E, A, B);
+	T_60_79(74, B, C, D, E, A);
+	T_60_79(75, A, B, C, D, E);
+	T_60_79(76, E, A, B, C, D);
+	T_60_79(77, D, E, A, B, C);
+	T_60_79(78, C, D, E, A, B);
+	T_60_79(79, B, C, D, E, A);
+
+	digest[0] += A;
+	digest[1] += B;
+	digest[2] += C;
+	digest[3] += D;
+	digest[4] += E;
+}
+
+/**
+ * sha_init - initialize the vectors for a SHA1 digest
+ * @buf: vector to initialize
+ */
+static inline void sha_init_inline(__u32 *buf)
+{
+	buf[0] = 0x67452301;
+	buf[1] = 0xefcdab89;
+	buf[2] = 0x98badcfe;
+	buf[3] = 0x10325476;
+	buf[4] = 0xc3d2e1f0;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// MD4 transform
+//
+// SOURCE: Linux 3.16.43, lib/halfmd4.c
+//
+/* F, G and H are basic MD4 functions: selection, majority, parity */
+#define F(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))
+#define G(x, y, z) (((x) & (y)) + (((x) ^ (y)) & (z)))
+#define H(x, y, z) ((x) ^ (y) ^ (z))
+
+/*
+ * The generic round function.  The application is so specific that
+ * we don't bother protecting all the arguments with parens, as is generally
+ * good macro practice, in favor of extra legibility.
+ * Rotation is separate from addition to prevent recomputation
+ */
+#define ROUND(f, a, b, c, d, x, s)	\
+	(a += f(b, c, d) + x, a = (a << s) | (a >> (32 - s)))
+#define K1 0
+#define K2 013240474631UL
+#define K3 015666365641UL
+
+/*
+ * Basic cut-down MD4 transform.  Returns only 32 bits of result.
+ */
+static inline __u32 half_md4_transform_inline(__u32 buf[4], __u32 const in[8])
+{
+	__u32 a = buf[0], b = buf[1], c = buf[2], d = buf[3];
+
+	/* Round 1 */
+	ROUND(F, a, b, c, d, in[0] + K1,  3);
+	ROUND(F, d, a, b, c, in[1] + K1,  7);
+	ROUND(F, c, d, a, b, in[2] + K1, 11);
+	ROUND(F, b, c, d, a, in[3] + K1, 19);
+	ROUND(F, a, b, c, d, in[4] + K1,  3);
+	ROUND(F, d, a, b, c, in[5] + K1,  7);
+	ROUND(F, c, d, a, b, in[6] + K1, 11);
+	ROUND(F, b, c, d, a, in[7] + K1, 19);
+
+	/* Round 2 */
+	ROUND(G, a, b, c, d, in[1] + K2,  3);
+	ROUND(G, d, a, b, c, in[3] + K2,  5);
+	ROUND(G, c, d, a, b, in[5] + K2,  9);
+	ROUND(G, b, c, d, a, in[7] + K2, 13);
+	ROUND(G, a, b, c, d, in[0] + K2,  3);
+	ROUND(G, d, a, b, c, in[2] + K2,  5);
+	ROUND(G, c, d, a, b, in[4] + K2,  9);
+	ROUND(G, b, c, d, a, in[6] + K2, 13);
+
+	/* Round 3 */
+	ROUND(H, a, b, c, d, in[3] + K3,  3);
+	ROUND(H, d, a, b, c, in[7] + K3,  9);
+	ROUND(H, c, d, a, b, in[2] + K3, 11);
+	ROUND(H, b, c, d, a, in[6] + K3, 15);
+	ROUND(H, a, b, c, d, in[1] + K3,  3);
+	ROUND(H, d, a, b, c, in[5] + K3,  9);
+	ROUND(H, c, d, a, b, in[0] + K3, 11);
+	ROUND(H, b, c, d, a, in[4] + K3, 15);
+
+	buf[0] += a;
+	buf[1] += b;
+	buf[2] += c;
+	buf[3] += d;
+
+	return buf[1]; /* "most hashed" word */
+}
+#undef ROUND
+#undef F
+#undef G
+#undef H
+#undef K1
+#undef K2
+#undef K3
+
+///////////////////////////////////////////////////////////////////////////////
+// MD5 transform
+//
+// SOURCE: Linux 3.16.43, lib/md5.c
+//
+#define MD5_DIGEST_WORDS 4
+#define MD5_MESSAGE_BYTES 64
+#define F1(x, y, z)	(z ^ (x & (y ^ z)))
+#define F2(x, y, z)	F1(z, x, y)
+#define F3(x, y, z)	(x ^ y ^ z)
+#define F4(x, y, z)	(y ^ (x | ~z))
+
+#define MD5STEP(f, w, x, y, z, in, s) \
+	(w += f(x, y, z) + in, w = (w<<s | w>>(32-s)) + x)
+
+static inline void md5_transform_inline(__u32 *hash, __u32 const *in)
+{
+	u32 a, b, c, d;
+
+	a = hash[0];
+	b = hash[1];
+	c = hash[2];
+	d = hash[3];
+
+	MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
+	MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
+	MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
+	MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
+	MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
+	MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
+	MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
+	MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
+	MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
+	MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
+	MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
+	MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
+	MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
+	MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
+	MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
+	MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
+
+	MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
+	MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
+	MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
+	MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
+	MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
+	MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
+	MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
+	MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
+	MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
+	MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
+	MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
+	MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
+	MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
+	MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
+	MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
+	MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
+
+	MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
+	MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
+	MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
+	MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
+	MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
+	MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
+	MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
+	MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
+	MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
+	MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
+	MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
+	MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
+	MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
+	MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
+	MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
+	MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
+
+	MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
+	MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
+	MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
+	MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
+	MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
+	MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
+	MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
+	MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
+	MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
+	MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
+	MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
+	MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
+	MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
+	MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
+	MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
+	MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
+
+	hash[0] += a;
+	hash[1] += b;
+	hash[2] += c;
+	hash[3] += d;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
 /* ioctl()'s for the random number generator */
 
 /* Get the entropy count. */
@@ -41,21 +451,21 @@
 };
 
 struct rnd_state {
-	__u32 s1, s2, s3;
+	__u32 s1, s2, s3, s4;
 };
 
 /* Exported functions */
 
 #ifdef __KERNEL__
 
-extern void rand_initialize_irq(int irq);
-
+extern void add_device_randomness(const void *, unsigned int);
 extern void add_input_randomness(unsigned int type, unsigned int code,
 				 unsigned int value);
-extern void add_interrupt_randomness(int irq);
+extern void add_interrupt_randomness(int irq, int irq_flags);
 
 extern void get_random_bytes(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
+extern int random_int_secret_init(void);
 
 extern __u32 secure_ip_id(__be32 daddr);
 extern u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport);
@@ -79,9 +489,32 @@
 void srandom32(u32 seed);
 
 u32 prandom_u32(void);
+void prandom_bytes(void *buf, int nbytes);
 
 u32 prandom32(struct rnd_state *);
 
+void prandom_reseed_late(void);
+
+u32 prandom_u32_state(struct rnd_state *state);
+void prandom_bytes_state(struct rnd_state *state, void *buf, int nbytes);
+
+/**
+ * prandom_u32_max - returns a pseudo-random number in interval [0, ep_ro)
+ * @ep_ro: right open interval endpoint
+ *
+ * Returns a pseudo-random number that is in interval [0, ep_ro). Note
+ * that the result depends on PRNG being well distributed in [0, ~0U]
+ * u32 space. Here we use maximally equidistributed combined Tausworthe
+ * generator, that is, prandom_u32(). This is useful when requesting a
+ * random index of an array containing ep_ro elements, for example.
+ *
+ * Returns: pseudo-random number in interval [0, ep_ro)
+ */
+static inline u32 prandom_u32_max(u32 ep_ro)
+{
+	return (u32)(((u64) prandom_u32() * ep_ro) >> 32);
+}
+
 /*
  * Handle minimum values for seeds
  */
@@ -99,9 +532,45 @@
 {
 	u32 i = (seed >> 32) ^ (seed << 10) ^ seed;
 
-	state->s1 = __seed(i, 1);
-	state->s2 = __seed(i, 7);
-	state->s3 = __seed(i, 15);
+	state->s1 = __seed(i,   2U);
+	state->s2 = __seed(i,   8U);
+	state->s3 = __seed(i,  16U);
+	state->s4 = __seed(i, 128U);
+}
+
+#ifdef CONFIG_ARCH_RANDOM
+# include <asm/archrandom.h>
+#else
+static inline int arch_get_random_long(unsigned long *v)
+{
+	return 0;
+}
+static inline int arch_get_random_int(unsigned int *v)
+{
+	return 0;
+}
+static inline int arch_has_random(void)
+{
+	return 0;
+}
+static inline int arch_get_random_seed_long(unsigned long *v)
+{
+	return 0;
+}
+static inline int arch_get_random_seed_int(unsigned int *v)
+{
+	return 0;
+}
+static inline int arch_has_random_seed(void)
+{
+	return 0;
+}
+#endif
+
+/* Pseudo random number generator from numerical recipes. */
+static inline u32 next_pseudo_random32(u32 seed)
+{
+	return seed * 1664525 + 1013904223;
 }
 
 #endif /* __KERNEL___ */
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/char/random.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/char/random.c
@@ -1,3 +1,8 @@
+///////////////////////////////////////////////////////////////////////////////
+// Entropy backport from Linux 3.16.43 to AsusWrt
+//
+// SOURCE: Linux 3.16.43, drivers/char/random.c
+///////////////////////////////////////////////////////////////////////////////
 /*
  * random.c -- A strong random number generator
  *
@@ -125,20 +130,32 @@
  * The current exported interfaces for gathering environmental noise
  * from the devices are:
  *
+ *	void add_device_randomness(const void *buf, unsigned int size);
  * 	void add_input_randomness(unsigned int type, unsigned int code,
  *                                unsigned int value);
- * 	void add_interrupt_randomness(int irq);
+ *	void add_interrupt_randomness(int irq, int irq_flags);
+ * 	void add_disk_randomness(struct gendisk *disk);
+ *
+ * add_device_randomness() is for adding data to the random pool that
+ * is likely to differ between two devices (or possibly even per boot).
+ * This would be things like MAC addresses or serial numbers, or the
+ * read-out of the RTC. This does *not* add any actual entropy to the
+ * pool, but it initializes the pool to different values for devices
+ * that might otherwise be identical and have very little entropy
+ * available to them (particularly common in the embedded world).
  *
  * add_input_randomness() uses the input layer interrupt timing, as well as
  * the event type information from the hardware.
  *
- * add_interrupt_randomness() uses the inter-interrupt timing as random
- * inputs to the entropy pool.  Note that not all interrupts are good
- * sources of randomness!  For example, the timer interrupts is not a
- * good choice, because the periodicity of the interrupts is too
- * regular, and hence predictable to an attacker.  Disk interrupts are
- * a better measure, since the timing of the disk interrupts are more
- * unpredictable.
+ * add_interrupt_randomness() uses the interrupt timing as random
+ * inputs to the entropy pool. Using the cycle counters and the irq source
+ * as inputs, it feeds the randomness roughly once a second.
+ *
+ * add_disk_randomness() uses what amounts to the seek time of block
+ * layer request events, on a per-disk_devt basis, as input to the
+ * entropy pool. Note that high-speed solid state drives with very low
+ * seek times do not make for good sources of entropy, as their seek
+ * times are usually fairly consistent.
  *
  * All of these routines try to estimate how many bits of randomness a
  * particular randomness source.  They do this by keeping track of the
@@ -241,109 +258,148 @@
 #include <linux/percpu.h>
 #include <linux/cryptohash.h>
 #include <linux/fips.h>
-
-#ifdef CONFIG_GENERIC_HARDIRQS
-# include <linux/irq.h>
-#endif
+#include <linux/ptrace.h>
+#include <linux/kmemcheck.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
 
 #include <asm/processor.h>
 #include <asm/uaccess.h>
 #include <asm/irq.h>
+#include <asm/irq_regs.h>
 #include <asm/io.h>
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/random.h>
+
 /*
  * Configuration information
  */
-#define INPUT_POOL_WORDS 128
-#define OUTPUT_POOL_WORDS 32
-#define SEC_XFER_SIZE 512
-#define EXTRACT_SIZE 10
+#define INPUT_POOL_SHIFT	12
+#define INPUT_POOL_WORDS	(1 << (INPUT_POOL_SHIFT-5))
+#define OUTPUT_POOL_SHIFT	10
+#define OUTPUT_POOL_WORDS	(1 << (OUTPUT_POOL_SHIFT-5))
+#define SEC_XFER_SIZE		512
+#define EXTRACT_SIZE		10
+
+#define DEBUG_RANDOM_BOOT 0
+
+#define LONGS(x) (((x) + sizeof(unsigned long) - 1)/sizeof(unsigned long))
+
+/*
+ * To allow fractional bits to be tracked, the entropy_count field is
+ * denominated in units of 1/8th bits.
+ *
+ * 2*(ENTROPY_SHIFT + log2(poolbits)) must <= 31, or the multiply in
+ * credit_entropy_bits() needs to be 64 bits wide.
+ */
+#define ENTROPY_SHIFT 3
+#define ENTROPY_BITS(r) ((r)->entropy_count >> ENTROPY_SHIFT)
 
 /*
  * The minimum number of bits of entropy before we wake up a read on
  * /dev/random.  Should be enough to do a significant reseed.
  */
-static int random_read_wakeup_thresh = 64;
+static int random_read_wakeup_bits = 64;
 
 /*
  * If the entropy count falls under this number of bits, then we
  * should wake up processes which are selecting or polling on write
  * access to /dev/random.
  */
-static int random_write_wakeup_thresh = 128;
-
-/*
- * When the input pool goes over trickle_thresh, start dropping most
- * samples to avoid wasting CPU time and reduce lock contention.
- */
-
-static int trickle_thresh __read_mostly = INPUT_POOL_WORDS * 28;
-
-static DEFINE_PER_CPU(int, trickle_count);
+static int random_write_wakeup_bits = 28 * OUTPUT_POOL_WORDS;
 
 /*
- * A pool of size .poolwords is stirred with a primitive polynomial
- * of degree .poolwords over GF(2).  The taps for various sizes are
- * defined below.  They are chosen to be evenly spaced (minimum RMS
- * distance from evenly spaced; the numbers in the comments are a
- * scaled squared error sum) except for the last tap, which is 1 to
- * get the twisting happening as fast as possible.
+ * The minimum number of seconds between urandom pool reseeding.  We
+ * do this to limit the amount of entropy that can be drained from the
+ * input pool even if there are heavy demands on /dev/urandom.
  */
-static struct poolinfo {
-	int poolwords;
-	int tap1, tap2, tap3, tap4, tap5;
-} poolinfo_table[] = {
-	/* x^128 + x^103 + x^76 + x^51 +x^25 + x + 1 -- 105 */
-	{ 128,	103,	76,	51,	25,	1 },
-	/* x^32 + x^26 + x^20 + x^14 + x^7 + x + 1 -- 15 */
-	{ 32,	26,	20,	14,	7,	1 },
-};
-
-#define POOLBITS	poolwords*32
-#define POOLBYTES	poolwords*4
+static int random_min_urandom_seed = 60;
 
 /*
- * For the purposes of better mixing, we use the CRC-32 polynomial as
- * well to make a twisted Generalized Feedback Shift Reigster
+ * Originally, we used a primitive polynomial of degree .poolwords
+ * over GF(2).  The taps for various sizes are defined below.  They
+ * were chosen to be evenly spaced except for the last tap, which is 1
+ * to get the twisting happening as fast as possible.
  *
- * (See M. Matsumoto & Y. Kurita, 1992.  Twisted GFSR generators.  ACM
- * Transactions on Modeling and Computer Simulation 2(3):179-194.
- * Also see M. Matsumoto & Y. Kurita, 1994.  Twisted GFSR generators
- * II.  ACM Transactions on Mdeling and Computer Simulation 4:254-266)
+ * For the purposes of better mixing, we use the CRC-32 polynomial as
+ * well to make a (modified) twisted Generalized Feedback Shift
+ * Register.  (See M. Matsumoto & Y. Kurita, 1992.  Twisted GFSR
+ * generators.  ACM Transactions on Modeling and Computer Simulation
+ * 2(3):179-194.  Also see M. Matsumoto & Y. Kurita, 1994.  Twisted
+ * GFSR generators II.  ACM Transactions on Modeling and Computer
+ * Simulation 4:254-266)
  *
  * Thanks to Colin Plumb for suggesting this.
  *
- * We have not analyzed the resultant polynomial to prove it primitive;
- * in fact it almost certainly isn't.  Nonetheless, the irreducible factors
- * of a random large-degree polynomial over GF(2) are more than large enough
- * that periodicity is not a concern.
- *
- * The input hash is much less sensitive than the output hash.  All
- * that we want of it is that it be a good non-cryptographic hash;
- * i.e. it not produce collisions when fed "random" data of the sort
- * we expect to see.  As long as the pool state differs for different
- * inputs, we have preserved the input entropy and done a good job.
- * The fact that an intelligent attacker can construct inputs that
- * will produce controlled alterations to the pool's state is not
- * important because we don't consider such inputs to contribute any
- * randomness.  The only property we need with respect to them is that
- * the attacker can't increase his/her knowledge of the pool's state.
- * Since all additions are reversible (knowing the final state and the
- * input, you can reconstruct the initial state), if an attacker has
- * any uncertainty about the initial state, he/she can only shuffle
- * that uncertainty about, but never cause any collisions (which would
+ * The mixing operation is much less sensitive than the output hash,
+ * where we use SHA-1.  All that we want of mixing operation is that
+ * it be a good non-cryptographic hash; i.e. it not produce collisions
+ * when fed "random" data of the sort we expect to see.  As long as
+ * the pool state differs for different inputs, we have preserved the
+ * input entropy and done a good job.  The fact that an intelligent
+ * attacker can construct inputs that will produce controlled
+ * alterations to the pool's state is not important because we don't
+ * consider such inputs to contribute any randomness.  The only
+ * property we need with respect to them is that the attacker can't
+ * increase his/her knowledge of the pool's state.  Since all
+ * additions are reversible (knowing the final state and the input,
+ * you can reconstruct the initial state), if an attacker has any
+ * uncertainty about the initial state, he/she can only shuffle that
+ * uncertainty about, but never cause any collisions (which would
  * decrease the uncertainty).
  *
- * The chosen system lets the state of the pool be (essentially) the input
- * modulo the generator polymnomial.  Now, for random primitive polynomials,
- * this is a universal class of hash functions, meaning that the chance
- * of a collision is limited by the attacker's knowledge of the generator
- * polynomail, so if it is chosen at random, an attacker can never force
- * a collision.  Here, we use a fixed polynomial, but we *can* assume that
- * ###--> it is unknown to the processes generating the input entropy. <-###
- * Because of this important property, this is a good, collision-resistant
- * hash; hash collisions will occur no more often than chance.
+ * Our mixing functions were analyzed by Lacharme, Roeck, Strubel, and
+ * Videau in their paper, "The Linux Pseudorandom Number Generator
+ * Revisited" (see: http://eprint.iacr.org/2012/251.pdf).  In their
+ * paper, they point out that we are not using a true Twisted GFSR,
+ * since Matsumoto & Kurita used a trinomial feedback polynomial (that
+ * is, with only three taps, instead of the six that we are using).
+ * As a result, the resulting polynomial is neither primitive nor
+ * irreducible, and hence does not have a maximal period over
+ * GF(2**32).  They suggest a slight change to the generator
+ * polynomial which improves the resulting TGFSR polynomial to be
+ * irreducible, which we have made here.
  */
+static struct poolinfo {
+	int poolbitshift, poolwords, poolbytes, poolbits, poolfracbits;
+#define S(x) ilog2(x)+5, (x), (x)*4, (x)*32, (x) << (ENTROPY_SHIFT+5)
+	int tap1, tap2, tap3, tap4, tap5;
+} poolinfo_table[] = {
+	/* was: x^128 + x^103 + x^76 + x^51 +x^25 + x + 1 */
+	/* x^128 + x^104 + x^76 + x^51 +x^25 + x + 1 */
+	{ S(128),	104,	76,	51,	25,	1 },
+	/* was: x^32 + x^26 + x^20 + x^14 + x^7 + x + 1 */
+	/* x^32 + x^26 + x^19 + x^14 + x^7 + x + 1 */
+	{ S(32),	26,	19,	14,	7,	1 },
+#if 0
+	/* x^2048 + x^1638 + x^1231 + x^819 + x^411 + x + 1  -- 115 */
+	{ S(2048),	1638,	1231,	819,	411,	1 },
+
+	/* x^1024 + x^817 + x^615 + x^412 + x^204 + x + 1 -- 290 */
+	{ S(1024),	817,	615,	412,	204,	1 },
+
+	/* x^1024 + x^819 + x^616 + x^410 + x^207 + x^2 + 1 -- 115 */
+	{ S(1024),	819,	616,	410,	207,	2 },
+
+	/* x^512 + x^411 + x^308 + x^208 + x^104 + x + 1 -- 225 */
+	{ S(512),	411,	308,	208,	104,	1 },
+
+	/* x^512 + x^409 + x^307 + x^206 + x^102 + x^2 + 1 -- 95 */
+	{ S(512),	409,	307,	206,	102,	2 },
+	/* x^512 + x^409 + x^309 + x^205 + x^103 + x^2 + 1 -- 95 */
+	{ S(512),	409,	309,	205,	103,	2 },
+
+	/* x^256 + x^205 + x^155 + x^101 + x^52 + x + 1 -- 125 */
+	{ S(256),	205,	155,	101,	52,	1 },
+
+	/* x^128 + x^103 + x^78 + x^51 + x^27 + x^2 + 1 -- 70 */
+	{ S(128),	103,	78,	51,	27,	2 },
+
+	/* x^64 + x^52 + x^39 + x^26 + x^14 + x + 1 -- 15 */
+	{ S(64),	52,	39,	26,	14,	1 },
+#endif
+};
 
 /*
  * Static global variables
@@ -352,8 +408,6 @@
 static DECLARE_WAIT_QUEUE_HEAD(random_write_wait);
 static struct fasync_struct *fasync;
 
-#define DEBUG_ENT(fmt, arg...) do {} while (0)
-
 /**********************************************************************
  *
  * OS independent entropy store.   Here are the functions which handle
@@ -364,20 +418,26 @@
 struct entropy_store;
 struct entropy_store {
 	/* read-only data: */
-	struct poolinfo *poolinfo;
+	const struct poolinfo *poolinfo;
 	__u32 *pool;
 	const char *name;
 	struct entropy_store *pull;
-	int limit;
+	struct work_struct push_work;
 
 	/* read-write data: */
+	unsigned long last_pulled;
 	spinlock_t lock;
-	unsigned add_ptr;
+	unsigned short add_ptr;
+	unsigned short input_rotate;
 	int entropy_count;
-	int input_rotate;
+	int entropy_total;
+	unsigned int initialized:1;
+	unsigned int limit:1;
+	unsigned int last_data_init:1;
 	__u8 last_data[EXTRACT_SIZE];
 };
 
+static void push_to_pool(struct work_struct *work);
 static __u32 input_pool_data[INPUT_POOL_WORDS];
 static __u32 blocking_pool_data[OUTPUT_POOL_WORDS];
 static __u32 nonblocking_pool_data[OUTPUT_POOL_WORDS];
@@ -386,7 +446,7 @@
 	.poolinfo = &poolinfo_table[0],
 	.name = "input",
 	.limit = 1,
-	.lock = __SPIN_LOCK_UNLOCKED(&input_pool.lock),
+	.lock = __SPIN_LOCK_UNLOCKED(input_pool.lock),
 	.pool = input_pool_data
 };
 
@@ -395,18 +455,26 @@
 	.name = "blocking",
 	.limit = 1,
 	.pull = &input_pool,
-	.lock = __SPIN_LOCK_UNLOCKED(&blocking_pool.lock),
-	.pool = blocking_pool_data
+	.lock = __SPIN_LOCK_UNLOCKED(blocking_pool.lock),
+	.pool = blocking_pool_data,
+	.push_work = __WORK_INITIALIZER(blocking_pool.push_work,
+					push_to_pool),
 };
 
 static struct entropy_store nonblocking_pool = {
 	.poolinfo = &poolinfo_table[1],
 	.name = "nonblocking",
 	.pull = &input_pool,
-	.lock = __SPIN_LOCK_UNLOCKED(&nonblocking_pool.lock),
-	.pool = nonblocking_pool_data
+	.lock = __SPIN_LOCK_UNLOCKED(nonblocking_pool.lock),
+	.pool = nonblocking_pool_data,
+	.push_work = __WORK_INITIALIZER(nonblocking_pool.push_work,
+					push_to_pool),
 };
 
+static __u32 const twist_table[8] = {
+	0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
+	0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };
+
 /*
  * This function adds bytes into the entropy "pool".  It does not
  * update the entropy estimate.  The caller should call
@@ -417,33 +485,28 @@
  * it's cheap to do so and helps slightly in the expected case where
  * the entropy is concentrated in the low-order bits.
  */
-static void mix_pool_bytes_extract(struct entropy_store *r, const void *in,
-				   int nbytes, __u8 out[64])
+static void _mix_pool_bytes(struct entropy_store *r, const void *in,
+			    int nbytes, __u8 out[64])
 {
-	static __u32 const twist_table[8] = {
-		0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
-		0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };
 	unsigned long i, j, tap1, tap2, tap3, tap4, tap5;
 	int input_rotate;
 	int wordmask = r->poolinfo->poolwords - 1;
 	const char *bytes = in;
 	__u32 w;
-	unsigned long flags;
 
-	/* Taps are constant, so we can load them without holding r->lock.  */
 	tap1 = r->poolinfo->tap1;
 	tap2 = r->poolinfo->tap2;
 	tap3 = r->poolinfo->tap3;
 	tap4 = r->poolinfo->tap4;
 	tap5 = r->poolinfo->tap5;
 
-	spin_lock_irqsave(&r->lock, flags);
-	input_rotate = r->input_rotate;
-	i = r->add_ptr;
+	smp_rmb();
+	input_rotate = ACCESS_ONCE(r->input_rotate);
+	i = ACCESS_ONCE(r->add_ptr);
 
 	/* mix one byte at a time to simplify size handling and churn faster */
 	while (nbytes--) {
-		w = rol32(*bytes++, input_rotate & 31);
+		w = rol32(*bytes++, input_rotate);
 		i = (i - 1) & wordmask;
 
 		/* XOR in the various taps */
@@ -463,53 +526,192 @@
 		 * rotation, so that successive passes spread the
 		 * input bits across the pool evenly.
 		 */
-		input_rotate += i ? 7 : 14;
+		input_rotate = (input_rotate + (i ? 7 : 14)) & 31;
 	}
 
-	r->input_rotate = input_rotate;
-	r->add_ptr = i;
+	ACCESS_ONCE(r->input_rotate) = input_rotate;
+	ACCESS_ONCE(r->add_ptr) = i;
+	smp_wmb();
 
 	if (out)
 		for (j = 0; j < 16; j++)
 			((__u32 *)out)[j] = r->pool[(i - j) & wordmask];
+}
 
-	spin_unlock_irqrestore(&r->lock, flags);
+static void __mix_pool_bytes(struct entropy_store *r, const void *in,
+			     int nbytes, __u8 out[64])
+{
+	trace_mix_pool_bytes_nolock(r->name, nbytes, _RET_IP_);
+	_mix_pool_bytes(r, in, nbytes, out);
 }
 
-static void mix_pool_bytes(struct entropy_store *r, const void *in, int bytes)
+static void mix_pool_bytes(struct entropy_store *r, const void *in,
+			   int nbytes, __u8 out[64])
 {
-       mix_pool_bytes_extract(r, in, bytes, NULL);
+	unsigned long flags;
+
+	trace_mix_pool_bytes(r->name, nbytes, _RET_IP_);
+	spin_lock_irqsave(&r->lock, flags);
+	_mix_pool_bytes(r, in, nbytes, out);
+	spin_unlock_irqrestore(&r->lock, flags);
+}
+
+struct fast_pool {
+	__u32		pool[4];
+	unsigned long	last;
+	unsigned short	count;
+	unsigned char	rotate;
+	unsigned char	last_timer_intr;
+};
+
+/*
+ * This is a fast mixing routine used by the interrupt randomness
+ * collector.  It's hardcoded for an 128 bit pool and assumes that any
+ * locks that might be needed are taken by the caller.
+ */
+static void fast_mix(struct fast_pool *f, __u32 input[4])
+{
+	__u32		w;
+	unsigned	input_rotate = f->rotate;
+
+	w = rol32(input[0], input_rotate) ^ f->pool[0] ^ f->pool[3];
+	f->pool[0] = (w >> 3) ^ twist_table[w & 7];
+	input_rotate = (input_rotate + 14) & 31;
+	w = rol32(input[1], input_rotate) ^ f->pool[1] ^ f->pool[0];
+	f->pool[1] = (w >> 3) ^ twist_table[w & 7];
+	input_rotate = (input_rotate + 7) & 31;
+	w = rol32(input[2], input_rotate) ^ f->pool[2] ^ f->pool[1];
+	f->pool[2] = (w >> 3) ^ twist_table[w & 7];
+	input_rotate = (input_rotate + 7) & 31;
+	w = rol32(input[3], input_rotate) ^ f->pool[3] ^ f->pool[2];
+	f->pool[3] = (w >> 3) ^ twist_table[w & 7];
+	input_rotate = (input_rotate + 7) & 31;
+
+	f->rotate = input_rotate;
+	f->count++;
 }
 
 /*
- * Credit (or debit) the entropy store with n bits of entropy
+ * Credit (or debit) the entropy store with n bits of entropy.
+ * Use credit_entropy_bits_safe() if the value comes from userspace
+ * or otherwise should be checked for extreme values.
  */
 static void credit_entropy_bits(struct entropy_store *r, int nbits)
 {
-	unsigned long flags;
-	int entropy_count;
+	int entropy_count, orig;
+	const int pool_size = r->poolinfo->poolfracbits;
+	int nfrac = nbits << ENTROPY_SHIFT;
 
 	if (!nbits)
 		return;
 
-	spin_lock_irqsave(&r->lock, flags);
+retry:
+	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
+	if (nfrac < 0) {
+		/* Debit */
+		entropy_count += nfrac;
+	} else {
+		/*
+		 * Credit: we have to account for the possibility of
+		 * overwriting already present entropy.	 Even in the
+		 * ideal case of pure Shannon entropy, new contributions
+		 * approach the full value asymptotically:
+		 *
+		 * entropy <- entropy + (pool_size - entropy) *
+		 *	(1 - exp(-add_entropy/pool_size))
+		 *
+		 * For add_entropy <= pool_size/2 then
+		 * (1 - exp(-add_entropy/pool_size)) >=
+		 *    (add_entropy/pool_size)*0.7869...
+		 * so we can approximate the exponential with
+		 * 3/4*add_entropy/pool_size and still be on the
+		 * safe side by adding at most pool_size/2 at a time.
+		 *
+		 * The use of pool_size-2 in the while statement is to
+		 * prevent rounding artifacts from making the loop
+		 * arbitrarily long; this limits the loop to log2(pool_size)*2
+		 * turns no matter how large nbits is.
+		 */
+		int pnfrac = nfrac;
+		const int s = r->poolinfo->poolbitshift + ENTROPY_SHIFT + 2;
+		/* The +2 corresponds to the /4 in the denominator */
+
+		do {
+			unsigned int anfrac = min(pnfrac, pool_size/2);
+			unsigned int add =
+				((pool_size - entropy_count)*anfrac*3) >> s;
+
+			entropy_count += add;
+			pnfrac -= anfrac;
+		} while (unlikely(entropy_count < pool_size-2 && pnfrac));
+	}
 
-	DEBUG_ENT("added %d entropy credits to %s\n", nbits, r->name);
-	entropy_count = r->entropy_count;
-	entropy_count += nbits;
-	if (entropy_count < 0) {
-		DEBUG_ENT("negative entropy/overflow\n");
+	if (unlikely(entropy_count < 0)) {
+		pr_warn("random: negative entropy/overflow: pool %s count %d\n",
+			r->name, entropy_count);
+		WARN_ON(1);
 		entropy_count = 0;
-	} else if (entropy_count > r->poolinfo->POOLBITS)
-		entropy_count = r->poolinfo->POOLBITS;
-	r->entropy_count = entropy_count;
-
-	/* should we wake readers? */
-	if (r == &input_pool && entropy_count >= random_read_wakeup_thresh) {
-		wake_up_interruptible(&random_read_wait);
-		kill_fasync(&fasync, SIGIO, POLL_IN);
+	} else if (entropy_count > pool_size)
+		entropy_count = pool_size;
+	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
+		goto retry;
+
+	r->entropy_total += nbits;
+	if (!r->initialized && r->entropy_total > 128) {
+		r->initialized = 1;
+		r->entropy_total = 0;
+		if (r == &nonblocking_pool) {
+			prandom_reseed_late();
+			pr_notice("random: %s pool is initialized\n", r->name);
+		}
+	}
+
+	trace_credit_entropy_bits(r->name, nbits,
+				  entropy_count >> ENTROPY_SHIFT,
+				  r->entropy_total, _RET_IP_);
+
+	if (r == &input_pool) {
+		int entropy_bits = entropy_count >> ENTROPY_SHIFT;
+
+		/* should we wake readers? */
+		if (entropy_bits >= random_read_wakeup_bits) {
+			wake_up_interruptible(&random_read_wait);
+			kill_fasync(&fasync, SIGIO, POLL_IN);
+		}
+		/* If the input pool is getting full, send some
+		 * entropy to the two output pools, flipping back and
+		 * forth between them, until the output pools are 75%
+		 * full.
+		 */
+		if (entropy_bits > random_write_wakeup_bits &&
+		    r->initialized &&
+		    r->entropy_total >= 2*random_read_wakeup_bits) {
+			static struct entropy_store *last = &blocking_pool;
+			struct entropy_store *other = &blocking_pool;
+
+			if (last == &blocking_pool)
+				other = &nonblocking_pool;
+			if (other->entropy_count <=
+			    3 * other->poolinfo->poolfracbits / 4)
+				last = other;
+			if (last->entropy_count <=
+			    3 * last->poolinfo->poolfracbits / 4) {
+				schedule_work(&last->push_work);
+				r->entropy_total = 0;
+			}
+		}
 	}
-	spin_unlock_irqrestore(&r->lock, flags);
+}
+
+static void credit_entropy_bits_safe(struct entropy_store *r, int nbits)
+{
+	const int nbits_max = (int)(~0U >> (ENTROPY_SHIFT + 1));
+
+	/* Cap the value to avoid overflows */
+	nbits = min(nbits,  nbits_max);
+	nbits = max(nbits, -nbits_max);
+
+	credit_entropy_bits(r, nbits);
 }
 
 /*********************************************************************
@@ -525,44 +727,35 @@
 	unsigned dont_count_entropy:1;
 };
 
-#ifndef CONFIG_GENERIC_HARDIRQS
-
-static struct timer_rand_state *irq_timer_state[NR_IRQS];
-
-static struct timer_rand_state *get_timer_rand_state(unsigned int irq)
-{
-	return irq_timer_state[irq];
-}
-
-static void set_timer_rand_state(unsigned int irq,
-				 struct timer_rand_state *state)
-{
-	irq_timer_state[irq] = state;
-}
-
-#else
-
-static struct timer_rand_state *get_timer_rand_state(unsigned int irq)
-{
-	struct irq_desc *desc;
-
-	desc = irq_to_desc(irq);
+#define INIT_TIMER_RAND_STATE { INITIAL_JIFFIES, };
 
-	return desc->timer_rand_state;
-}
-
-static void set_timer_rand_state(unsigned int irq,
-				 struct timer_rand_state *state)
+/*
+ * Add device- or boot-specific data to the input and nonblocking
+ * pools to help initialize them to unique values.
+ *
+ * None of this adds any entropy, it is meant to avoid the
+ * problem of the nonblocking pool having similar initial state
+ * across largely identical devices.
+ */
+void add_device_randomness(const void *buf, unsigned int size)
 {
-	struct irq_desc *desc;
-
-	desc = irq_to_desc(irq);
+	unsigned long time = random_get_entropy() ^ jiffies;
+	unsigned long flags;
 
-	desc->timer_rand_state = state;
+	trace_add_device_randomness(size, _RET_IP_);
+	spin_lock_irqsave(&input_pool.lock, flags);
+	_mix_pool_bytes(&input_pool, buf, size, NULL);
+	_mix_pool_bytes(&input_pool, &time, sizeof(time), NULL);
+	spin_unlock_irqrestore(&input_pool.lock, flags);
+
+	spin_lock_irqsave(&nonblocking_pool.lock, flags);
+	_mix_pool_bytes(&nonblocking_pool, buf, size, NULL);
+	_mix_pool_bytes(&nonblocking_pool, &time, sizeof(time), NULL);
+	spin_unlock_irqrestore(&nonblocking_pool.lock, flags);
 }
-#endif
+EXPORT_SYMBOL(add_device_randomness);
 
-static struct timer_rand_state input_timer_state;
+static struct timer_rand_state input_timer_state = INIT_TIMER_RAND_STATE;
 
 /*
  * This function adds entropy to the entropy "pool" by using timing
@@ -576,23 +769,21 @@
  */
 static void add_timer_randomness(struct timer_rand_state *state, unsigned num)
 {
+	struct entropy_store	*r;
 	struct {
-		cycles_t cycles;
 		long jiffies;
+		unsigned cycles;
 		unsigned num;
 	} sample;
 	long delta, delta2, delta3;
 
 	preempt_disable();
-	/* if over the trickle threshold, use only 1 in 4096 samples */
-	if (input_pool.entropy_count > trickle_thresh &&
-	    (__get_cpu_var(trickle_count)++ & 0xfff))
-		goto out;
 
 	sample.jiffies = jiffies;
-	sample.cycles = get_cycles();
+	sample.cycles = random_get_entropy();
 	sample.num = num;
-	mix_pool_bytes(&input_pool, &sample, sizeof(sample));
+	r = nonblocking_pool.initialized ? &input_pool : &nonblocking_pool;
+	mix_pool_bytes(r, &sample, sizeof(sample), NULL);
 
 	/*
 	 * Calculate number of bits of randomness we probably added.
@@ -626,10 +817,8 @@
 		 * Round down by 1 bit on general principles,
 		 * and limit entropy entimate to 12 bits.
 		 */
-		credit_entropy_bits(&input_pool,
-				    min_t(int, fls(delta>>1), 11));
+		credit_entropy_bits(r, min_t(int, fls(delta>>1), 11));
 	}
-out:
 	preempt_enable();
 }
 
@@ -642,25 +831,73 @@
 	if (value == last_value)
 		return;
 
-	DEBUG_ENT("input event\n");
 	last_value = value;
 	add_timer_randomness(&input_timer_state,
 			     (type << 4) ^ code ^ (code >> 4) ^ value);
+	trace_add_input_randomness(ENTROPY_BITS(&input_pool));
 }
 EXPORT_SYMBOL_GPL(add_input_randomness);
 
-void add_interrupt_randomness(int irq)
+static DEFINE_PER_CPU(struct fast_pool, irq_randomness);
+
+void add_interrupt_randomness(int irq, int irq_flags)
 {
-	struct timer_rand_state *state;
+	struct entropy_store	*r;
+	struct fast_pool	*fast_pool = &__get_cpu_var(irq_randomness);
+	struct pt_regs		*regs = get_irq_regs();
+	unsigned long		now = jiffies;
+	cycles_t		cycles = random_get_entropy();
+	__u32			input[4], c_high, j_high;
+	__u64			ip;
+	unsigned long		seed;
+	int			credit;
+
+	c_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;
+	j_high = (sizeof(now) > 4) ? now >> 32 : 0;
+	input[0] = cycles ^ j_high ^ irq;
+	input[1] = now ^ c_high;
+	ip = regs ? instruction_pointer(regs) : _RET_IP_;
+	input[2] = ip;
+	input[3] = ip >> 32;
 
-	state = get_timer_rand_state(irq);
+	fast_mix(fast_pool, input);
 
-	if (state == NULL)
+	if ((fast_pool->count & 63) && !time_after(now, fast_pool->last + HZ))
 		return;
 
-	DEBUG_ENT("irq event %d\n", irq);
-	add_timer_randomness(state, 0x100 + irq);
+	fast_pool->last = now;
+
+	r = nonblocking_pool.initialized ? &input_pool : &nonblocking_pool;
+	__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool), NULL);
+
+	/*
+	 * If we don't have a valid cycle counter, and we see
+	 * back-to-back timer interrupts, then skip giving credit for
+	 * any entropy, otherwise credit 1 bit.
+	 */
+	credit = 1;
+	if (cycles == 0) {
+		if (irq_flags & __IRQF_TIMER) {
+			if (fast_pool->last_timer_intr)
+				credit = 0;
+			fast_pool->last_timer_intr = 1;
+		} else
+			fast_pool->last_timer_intr = 0;
+	}
+
+	/*
+	 * If we have architectural seed generator, produce a seed and
+	 * add it to the pool.  For the sake of paranoia count it as
+	 * 50% entropic.
+	 */
+	if (arch_get_random_seed_long(&seed)) {
+		__mix_pool_bytes(r, &seed, sizeof(seed), NULL);
+		credit += sizeof(seed) * 4;
+	}
+
+	credit_entropy_bits(r, credit);
 }
+EXPORT_SYMBOL_GPL(add_interrupt_randomness);
 
 #ifdef CONFIG_BLOCK
 void add_disk_randomness(struct gendisk *disk)
@@ -668,11 +905,10 @@
 	if (!disk || !disk->random)
 		return;
 	/* first major is 1, so we get >= 0x200 here */
-	DEBUG_ENT("disk event %d:%d\n",
-		  MAJOR(disk_devt(disk)), MINOR(disk_devt(disk)));
-
 	add_timer_randomness(disk->random, 0x100 + disk_devt(disk));
+	trace_add_disk_randomness(disk_devt(disk), ENTROPY_BITS(&input_pool));
 }
+//EXPORT_SYMBOL_GPL(add_disk_randomness);
 #endif
 
 /*********************************************************************
@@ -685,97 +921,149 @@
 			       size_t nbytes, int min, int rsvd);
 
 /*
- * This utility inline function is responsible for transfering entropy
+ * This utility inline function is responsible for transferring entropy
  * from the primary pool to the secondary extraction pool. We make
  * sure we pull enough for a 'catastrophic reseed'.
  */
+static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes);
 static void xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
 {
-	__u32 tmp[OUTPUT_POOL_WORDS];
+	if (r->limit == 0 && random_min_urandom_seed) {
+		unsigned long now = jiffies;
+
+		if (time_before(now,
+				r->last_pulled + random_min_urandom_seed * HZ))
+			return;
+		r->last_pulled = now;
+	}
+	if (r->pull &&
+	    r->entropy_count < (nbytes << (ENTROPY_SHIFT + 3)) &&
+	    r->entropy_count < r->poolinfo->poolfracbits)
+		_xfer_secondary_pool(r, nbytes);
+}
 
-	if (r->pull && r->entropy_count < nbytes * 8 &&
-	    r->entropy_count < r->poolinfo->POOLBITS) {
-		/* If we're limited, always leave two wakeup worth's BITS */
-		int rsvd = r->limit ? 0 : random_read_wakeup_thresh/4;
-		int bytes = nbytes;
+static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
+{
+	__u32	tmp[OUTPUT_POOL_WORDS];
 
-		/* pull at least as many as BYTES as wakeup BITS */
-		bytes = max_t(int, bytes, random_read_wakeup_thresh / 8);
-		/* but never more than the buffer size */
-		bytes = min_t(int, bytes, sizeof(tmp));
+	/* For /dev/random's pool, always leave two wakeups' worth */
+	int rsvd_bytes = r->limit ? 0 : random_read_wakeup_bits / 4;
+	int bytes = nbytes;
 
-		DEBUG_ENT("going to reseed %s with %d bits "
-			  "(%d of %d requested)\n",
-			  r->name, bytes * 8, nbytes * 8, r->entropy_count);
+	/* pull at least as much as a wakeup */
+	bytes = max_t(int, bytes, random_read_wakeup_bits / 8);
+	/* but never more than the buffer size */
+	bytes = min_t(int, bytes, sizeof(tmp));
 
-		bytes = extract_entropy(r->pull, tmp, bytes,
-					random_read_wakeup_thresh / 8, rsvd);
-		mix_pool_bytes(r, tmp, bytes);
-		credit_entropy_bits(r, bytes*8);
-	}
+	trace_xfer_secondary_pool(r->name, bytes * 8, nbytes * 8,
+				  ENTROPY_BITS(r), ENTROPY_BITS(r->pull));
+	bytes = extract_entropy(r->pull, tmp, bytes,
+				random_read_wakeup_bits / 8, rsvd_bytes);
+	mix_pool_bytes(r, tmp, bytes, NULL);
+	credit_entropy_bits(r, bytes*8);
 }
 
 /*
- * These functions extracts randomness from the "entropy pool", and
- * returns it in a buffer.
- *
- * The min parameter specifies the minimum amount we can pull before
- * failing to avoid races that defeat catastrophic reseeding while the
- * reserved parameter indicates how much entropy we must leave in the
- * pool after each pull to avoid starving other readers.
- *
- * Note: extract_entropy() assumes that .poolwords is a multiple of 16 words.
+ * Used as a workqueue function so that when the input pool is getting
+ * full, we can "spill over" some entropy to the output pools.  That
+ * way the output pools can store some of the excess entropy instead
+ * of letting it go to waste.
  */
+static void push_to_pool(struct work_struct *work)
+{
+	struct entropy_store *r = container_of(work, struct entropy_store,
+					      push_work);
+	BUG_ON(!r);
+	_xfer_secondary_pool(r, random_read_wakeup_bits/8);
+	trace_push_to_pool(r->name, r->entropy_count >> ENTROPY_SHIFT,
+			   r->pull->entropy_count >> ENTROPY_SHIFT);
+}
 
+/*
+ * This function decides how many bytes to actually take from the
+ * given pool, and also debits the entropy count accordingly.
+ */
 static size_t account(struct entropy_store *r, size_t nbytes, int min,
 		      int reserved)
 {
-	unsigned long flags;
-
-	/* Hold lock while accounting */
-	spin_lock_irqsave(&r->lock, flags);
+	int entropy_count, orig;
+	size_t ibytes, nfrac;
 
-	BUG_ON(r->entropy_count > r->poolinfo->POOLBITS);
-	DEBUG_ENT("trying to extract %d bits from %s\n",
-		  nbytes * 8, r->name);
+	BUG_ON(r->entropy_count > r->poolinfo->poolfracbits);
 
 	/* Can we pull enough? */
-	if (r->entropy_count / 8 < min + reserved) {
-		nbytes = 0;
-	} else {
-		/* If limited, never pull more than available */
-		if (r->limit && nbytes + reserved >= r->entropy_count / 8)
-			nbytes = r->entropy_count/8 - reserved;
-
-		if (r->entropy_count / 8 >= nbytes + reserved)
-			r->entropy_count -= nbytes*8;
-		else
-			r->entropy_count = reserved;
-
-		if (r->entropy_count < random_write_wakeup_thresh) {
-			wake_up_interruptible(&random_write_wait);
-			kill_fasync(&fasync, SIGIO, POLL_OUT);
-		}
+retry:
+	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
+	ibytes = nbytes;
+	/* If limited, never pull more than available */
+	if (r->limit) {
+		int have_bytes = entropy_count >> (ENTROPY_SHIFT + 3);
+
+		if ((have_bytes -= reserved) < 0)
+			have_bytes = 0;
+		ibytes = min_t(size_t, ibytes, have_bytes);
 	}
+	if (ibytes < min)
+		ibytes = 0;
 
-	DEBUG_ENT("debiting %d entropy credits from %s%s\n",
-		  nbytes * 8, r->name, r->limit ? "" : " (unlimited)");
+	if (unlikely(entropy_count < 0)) {
+		pr_warn("random: negative entropy count: pool %s count %d\n",
+			r->name, entropy_count);
+		WARN_ON(1);
+		entropy_count = 0;
+	}
+	nfrac = ibytes << (ENTROPY_SHIFT + 3);
+	if ((size_t) entropy_count > nfrac)
+		entropy_count -= nfrac;
+	else
+		entropy_count = 0;
 
-	spin_unlock_irqrestore(&r->lock, flags);
+	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
+		goto retry;
 
-	return nbytes;
+	trace_debit_entropy(r->name, 8 * ibytes);
+	if (ibytes &&
+	    (r->entropy_count >> ENTROPY_SHIFT) < random_write_wakeup_bits) {
+		wake_up_interruptible(&random_write_wait);
+		kill_fasync(&fasync, SIGIO, POLL_OUT);
+	}
+
+	return ibytes;
 }
 
+/*
+ * This function does the actual extraction for extract_entropy and
+ * extract_entropy_user.
+ *
+ * Note: we assume that .poolwords is a multiple of 16 words.
+ */
 static void extract_buf(struct entropy_store *r, __u8 *out)
 {
 	int i;
-	__u32 hash[5], workspace[SHA_WORKSPACE_WORDS];
+	union {
+		__u32 w[5];
+		unsigned long l[LONGS(20)];
+	} hash;
+	__u32 workspace[SHA_WORKSPACE_WORDS];
 	__u8 extract[64];
+	unsigned long flags;
+
+	/*
+	 * If we have an architectural hardware random number
+	 * generator, use it for SHA's initial vector
+	 */
+	sha_init_inline(hash.w);
+	for (i = 0; i < LONGS(20); i++) {
+		unsigned long v;
+		if (!arch_get_random_long(&v))
+			break;
+		hash.l[i] = v;
+	}
 
 	/* Generate a hash across the pool, 16 words (512 bits) at a time */
-	sha_init(hash);
+	spin_lock_irqsave(&r->lock, flags);
 	for (i = 0; i < r->poolinfo->poolwords; i += 16)
-		sha_transform(hash, (__u8 *)(r->pool + i), workspace);
+		sha_transform_inline(hash.w, (__u8 *)(r->pool + i), workspace);
 
 	/*
 	 * We mix the hash back into the pool to prevent backtracking
@@ -786,35 +1074,63 @@
 	 * brute-forcing the feedback as hard as brute-forcing the
 	 * hash.
 	 */
-	mix_pool_bytes_extract(r, hash, sizeof(hash), extract);
+	__mix_pool_bytes(r, hash.w, sizeof(hash.w), extract);
+	spin_unlock_irqrestore(&r->lock, flags);
 
 	/*
 	 * To avoid duplicates, we atomically extract a portion of the
 	 * pool while mixing, and hash one final time.
 	 */
-	sha_transform(hash, extract, workspace);
-	memset(extract, 0, sizeof(extract));
-	memset(workspace, 0, sizeof(workspace));
+	sha_transform_inline(hash.w, extract, workspace);
+	memzero_explicit(extract, sizeof(extract));
+	memzero_explicit(workspace, sizeof(workspace));
 
 	/*
 	 * In case the hash function has some recognizable output
 	 * pattern, we fold it in half. Thus, we always feed back
 	 * twice as much data as we output.
 	 */
-	hash[0] ^= hash[3];
-	hash[1] ^= hash[4];
-	hash[2] ^= rol32(hash[2], 16);
-	memcpy(out, hash, EXTRACT_SIZE);
-	memset(hash, 0, sizeof(hash));
+	hash.w[0] ^= hash.w[3];
+	hash.w[1] ^= hash.w[4];
+	hash.w[2] ^= rol32(hash.w[2], 16);
+
+	memcpy(out, &hash, EXTRACT_SIZE);
+	memzero_explicit(&hash, sizeof(hash));
 }
 
+/*
+ * This function extracts randomness from the "entropy pool", and
+ * returns it in a buffer.
+ *
+ * The min parameter specifies the minimum amount we can pull before
+ * failing to avoid races that defeat catastrophic reseeding while the
+ * reserved parameter indicates how much entropy we must leave in the
+ * pool after each pull to avoid starving other readers.
+ */
 static ssize_t extract_entropy(struct entropy_store *r, void *buf,
-			       size_t nbytes, int min, int reserved)
+				 size_t nbytes, int min, int reserved)
 {
 	ssize_t ret = 0, i;
 	__u8 tmp[EXTRACT_SIZE];
 	unsigned long flags;
 
+	/* if last_data isn't primed, we need EXTRACT_SIZE extra bytes */
+	if (fips_enabled) {
+		spin_lock_irqsave(&r->lock, flags);
+		if (!r->last_data_init) {
+			r->last_data_init = 1;
+			spin_unlock_irqrestore(&r->lock, flags);
+			trace_extract_entropy(r->name, EXTRACT_SIZE,
+					      ENTROPY_BITS(r), _RET_IP_);
+			xfer_secondary_pool(r, EXTRACT_SIZE);
+			extract_buf(r, tmp);
+			spin_lock_irqsave(&r->lock, flags);
+			memcpy(r->last_data, tmp, EXTRACT_SIZE);
+		}
+		spin_unlock_irqrestore(&r->lock, flags);
+	}
+
+	trace_extract_entropy(r->name, nbytes, ENTROPY_BITS(r), _RET_IP_);
 	xfer_secondary_pool(r, nbytes);
 	nbytes = account(r, nbytes, min, reserved);
 
@@ -836,17 +1152,22 @@
 	}
 
 	/* Wipe data just returned from memory */
-	memset(tmp, 0, sizeof(tmp));
+	memzero_explicit(tmp, sizeof(tmp));
 
 	return ret;
 }
 
+/*
+ * This function extracts randomness from the "entropy pool", and
+ * returns it in a userspace buffer.
+ */
 static ssize_t extract_entropy_user(struct entropy_store *r, void __user *buf,
 				    size_t nbytes)
 {
 	ssize_t ret = 0, i;
 	__u8 tmp[EXTRACT_SIZE];
 
+	trace_extract_entropy_user(r->name, nbytes, ENTROPY_BITS(r), _RET_IP_);
 	xfer_secondary_pool(r, nbytes);
 	nbytes = account(r, nbytes, 0, 0);
 
@@ -873,23 +1194,66 @@
 	}
 
 	/* Wipe data just returned from memory */
-	memset(tmp, 0, sizeof(tmp));
+	memzero_explicit(tmp, sizeof(tmp));
 
 	return ret;
 }
 
 /*
  * This function is the exported kernel interface.  It returns some
- * number of good random numbers, suitable for seeding TCP sequence
- * numbers, etc.
+ * number of good random numbers, suitable for key generation, seeding
+ * TCP sequence numbers, etc.  It does not rely on the hardware random
+ * number generator.  For random bytes direct from the hardware RNG
+ * (when available), use get_random_bytes_arch().
  */
 void get_random_bytes(void *buf, int nbytes)
 {
+#if DEBUG_RANDOM_BOOT > 0
+	if (unlikely(nonblocking_pool.initialized == 0))
+		printk(KERN_NOTICE "random: %pF get_random_bytes called "
+		       "with %d bits of entropy available\n",
+		       (void *) _RET_IP_,
+		       nonblocking_pool.entropy_total);
+#endif
+	trace_get_random_bytes(nbytes, _RET_IP_);
 	extract_entropy(&nonblocking_pool, buf, nbytes, 0, 0);
 }
 EXPORT_SYMBOL(get_random_bytes);
 
 /*
+ * This function will use the architecture-specific hardware random
+ * number generator if it is available.  The arch-specific hw RNG will
+ * almost certainly be faster than what we can do in software, but it
+ * is impossible to verify that it is implemented securely (as
+ * opposed, to, say, the AES encryption of a sequence number using a
+ * key known by the NSA).  So it's useful if we need the speed, but
+ * only if we're willing to trust the hardware manufacturer not to
+ * have put in a back door.
+ */
+void get_random_bytes_arch(void *buf, int nbytes)
+{
+	char *p = buf;
+
+	trace_get_random_bytes_arch(nbytes, _RET_IP_);
+	while (nbytes) {
+		unsigned long v;
+		int chunk = min(nbytes, (int)sizeof(unsigned long));
+
+		if (!arch_get_random_long(&v))
+			break;
+		
+		memcpy(p, &v, chunk);
+		p += chunk;
+		nbytes -= chunk;
+	}
+
+	if (nbytes)
+		extract_entropy(&nonblocking_pool, p, nbytes, 0, 0);
+}
+//EXPORT_SYMBOL(get_random_bytes_arch);
+
+
+/*
  * init_std_data - initialize pool with system data
  *
  * @r: pool to initialize
@@ -900,18 +1264,31 @@
  */
 static void init_std_data(struct entropy_store *r)
 {
-	ktime_t now;
-	unsigned long flags;
-
-	spin_lock_irqsave(&r->lock, flags);
-	r->entropy_count = 0;
-	spin_unlock_irqrestore(&r->lock, flags);
+	int i;
+	ktime_t now = ktime_get_real();
+	unsigned long rv;
 
-	now = ktime_get_real();
-	mix_pool_bytes(r, &now, sizeof(now));
-	mix_pool_bytes(r, utsname(), sizeof(*(utsname())));
+	r->last_pulled = jiffies;
+	mix_pool_bytes(r, &now, sizeof(now), NULL);
+	for (i = r->poolinfo->poolbytes; i > 0; i -= sizeof(rv)) {
+		if (!arch_get_random_seed_long(&rv) &&
+		    !arch_get_random_long(&rv))
+			rv = random_get_entropy();
+		mix_pool_bytes(r, &rv, sizeof(rv), NULL);
+	}
+	mix_pool_bytes(r, utsname(), sizeof(*(utsname())), NULL);
 }
 
+/*
+ * Note that setup_arch() may call add_device_randomness()
+ * long before we get here. This allows seeding of the pools
+ * with some platform dependent data very early in the boot
+ * process. But it limits our options here. We must use
+ * statically allocated structures that already have all
+ * initializations complete at compile time. We should also
+ * take care not to overwrite the precious per platform data
+ * we were given.
+ */
 static int rand_initialize(void)
 {
 	init_std_data(&input_pool);
@@ -919,25 +1296,7 @@
 	init_std_data(&nonblocking_pool);
 	return 0;
 }
-module_init(rand_initialize);
-
-void rand_initialize_irq(int irq)
-{
-	struct timer_rand_state *state;
-
-	state = get_timer_rand_state(irq);
-
-	if (state)
-		return;
-
-	/*
-	 * If kzalloc returns null, we just won't use that entropy
-	 * source.
-	 */
-	state = kzalloc(sizeof(struct timer_rand_state), GFP_KERNEL);
-	if (state)
-		set_timer_rand_state(irq, state);
-}
+early_initcall(rand_initialize);
 
 #ifdef CONFIG_BLOCK
 void rand_initialize_disk(struct gendisk *disk)
@@ -949,71 +1308,100 @@
 	 * source.
 	 */
 	state = kzalloc(sizeof(struct timer_rand_state), GFP_KERNEL);
-	if (state)
+	if (state) {
+		state->last_time = INITIAL_JIFFIES;
 		disk->random = state;
+	}
 }
 #endif
 
-static ssize_t
-random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
+/*
+ * Attempt an emergency refill using arch_get_random_seed_long().
+ *
+ * As with add_interrupt_randomness() be paranoid and only
+ * credit the output as 50% entropic.
+ */
+static int arch_random_refill(void)
 {
-	ssize_t n, retval = 0, count = 0;
+	const unsigned int nlongs = 64;	/* Arbitrary number */
+	unsigned int n = 0;
+	unsigned int i;
+	unsigned long buf[nlongs];
 
-	if (nbytes == 0)
+	if (!arch_has_random_seed())
 		return 0;
 
-	while (nbytes > 0) {
-		n = nbytes;
-		if (n > SEC_XFER_SIZE)
-			n = SEC_XFER_SIZE;
-
-		DEBUG_ENT("reading %d bits\n", n*8);
+	for (i = 0; i < nlongs; i++) {
+		if (arch_get_random_seed_long(&buf[n]))
+			n++;
+	}
 
-		n = extract_entropy_user(&blocking_pool, buf, n);
+	if (n) {
+		unsigned int rand_bytes = n * sizeof(unsigned long);
 
-		DEBUG_ENT("read got %d bits (%d still needed)\n",
-			  n*8, (nbytes-n)*8);
+		mix_pool_bytes(&input_pool, buf, rand_bytes, NULL);
+		credit_entropy_bits(&input_pool, rand_bytes*4);
+	}
 
-		if (n == 0) {
-			if (file->f_flags & O_NONBLOCK) {
-				retval = -EAGAIN;
-				break;
-			}
+	return n;
+}
 
-			DEBUG_ENT("sleeping?\n");
+static ssize_t
+random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
+{
+	ssize_t n;
 
-			wait_event_interruptible(random_read_wait,
-				input_pool.entropy_count >=
-						 random_read_wakeup_thresh);
+	if (nbytes == 0)
+		return 0;
 
-			DEBUG_ENT("awake\n");
+	nbytes = min_t(size_t, nbytes, SEC_XFER_SIZE);
+	while (1) {
+		n = extract_entropy_user(&blocking_pool, buf, nbytes);
+		if (n < 0)
+			return n;
+		trace_random_read(n*8, (nbytes-n)*8,
+				  ENTROPY_BITS(&blocking_pool),
+				  ENTROPY_BITS(&input_pool));
+		if (n > 0)
+			return n;
 
-			if (signal_pending(current)) {
-				retval = -ERESTARTSYS;
-				break;
-			}
+		/* Pool is (near) empty.  Maybe wait and retry. */
 
+		/* First try an emergency refill */
+		if (arch_random_refill())
 			continue;
-		}
 
-		if (n < 0) {
-			retval = n;
-			break;
-		}
-		count += n;
-		buf += n;
-		nbytes -= n;
-		break;		/* This break makes the device work */
-				/* like a named pipe */
-	}
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
 
-	return (count ? count : retval);
+		wait_event_interruptible(random_read_wait,
+			ENTROPY_BITS(&input_pool) >=
+			random_read_wakeup_bits);
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+	}
 }
 
 static ssize_t
 urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 {
-	return extract_entropy_user(&nonblocking_pool, buf, nbytes);
+	static int maxwarn = 10;
+	int ret;
+
+	if (unlikely(nonblocking_pool.initialized == 0) &&
+	    maxwarn > 0) {
+		maxwarn--;
+		printk(KERN_NOTICE "random: %s: uninitialized urandom read "
+		       "(%zd bytes read, %d bits of entropy available)\n",
+		       current->comm, nbytes, nonblocking_pool.entropy_total);
+	}
+
+	nbytes = min_t(size_t, nbytes, INT_MAX >> (ENTROPY_SHIFT + 3));
+	ret = extract_entropy_user(&nonblocking_pool, buf, nbytes);
+
+	trace_urandom_read(8 * nbytes, ENTROPY_BITS(&nonblocking_pool),
+			   ENTROPY_BITS(&input_pool));
+	return ret;
 }
 
 static unsigned int
@@ -1024,9 +1412,9 @@
 	poll_wait(file, &random_read_wait, wait);
 	poll_wait(file, &random_write_wait, wait);
 	mask = 0;
-	if (input_pool.entropy_count >= random_read_wakeup_thresh)
+	if (ENTROPY_BITS(&input_pool) >= random_read_wakeup_bits)
 		mask |= POLLIN | POLLRDNORM;
-	if (input_pool.entropy_count < random_write_wakeup_thresh)
+	if (ENTROPY_BITS(&input_pool) < random_write_wakeup_bits)
 		mask |= POLLOUT | POLLWRNORM;
 	return mask;
 }
@@ -1046,7 +1434,7 @@
 		count -= bytes;
 		p += bytes;
 
-		mix_pool_bytes(r, buf, bytes);
+		mix_pool_bytes(r, buf, bytes, NULL);
 		cond_resched();
 	}
 
@@ -1077,7 +1465,8 @@
 	switch (cmd) {
 	case RNDGETENTCNT:
 		/* inherently racy, no point locking */
-		if (put_user(input_pool.entropy_count, p))
+		ent_count = ENTROPY_BITS(&input_pool);
+		if (put_user(ent_count, p))
 			return -EFAULT;
 		return 0;
 	case RNDADDTOENTCNT:
@@ -1085,7 +1474,7 @@
 			return -EPERM;
 		if (get_user(ent_count, p))
 			return -EFAULT;
-		credit_entropy_bits(&input_pool, ent_count);
+		credit_entropy_bits_safe(&input_pool, ent_count);
 		return 0;
 	case RNDADDENTROPY:
 		if (!capable(CAP_SYS_ADMIN))
@@ -1100,14 +1489,19 @@
 				    size);
 		if (retval < 0)
 			return retval;
-		credit_entropy_bits(&input_pool, ent_count);
+		credit_entropy_bits_safe(&input_pool, ent_count);
 		return 0;
 	case RNDZAPENTCNT:
 	case RNDCLEARPOOL:
-		/* Clear the entropy pool counters. */
+		/*
+		 * Clear the entropy pool counters. We no longer clear
+		 * the entropy pool, as that's silly.
+		 */
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
-		rand_initialize();
+		input_pool.entropy_count = 0;
+		nonblocking_pool.entropy_count = 0;
+		blocking_pool.entropy_count = 0;
 		return 0;
 	default:
 		return -EINVAL;
@@ -1125,6 +1519,7 @@
 	.poll  = random_poll,
 	.unlocked_ioctl = random_ioctl,
 	.fasync = random_fasync,
+	.llseek = noop_llseek,
 };
 
 const struct file_operations urandom_fops = {
@@ -1132,6 +1527,7 @@
 	.write = random_write,
 	.unlocked_ioctl = random_ioctl,
 	.fasync = random_fasync,
+	.llseek = noop_llseek,
 };
 
 /***************************************************************
@@ -1165,32 +1561,37 @@
 #include <linux/sysctl.h>
 
 static int min_read_thresh = 8, min_write_thresh;
-static int max_read_thresh = INPUT_POOL_WORDS * 32;
+static int max_read_thresh = OUTPUT_POOL_WORDS * 32;
 static int max_write_thresh = INPUT_POOL_WORDS * 32;
 static char sysctl_bootid[16];
 
 /*
- * These functions is used to return both the bootid UUID, and random
+ * This function is used to return both the bootid UUID, and random
  * UUID.  The difference is in whether table->data is NULL; if it is,
  * then a new UUID is generated and returned to the user.
  *
- * If the user accesses this via the proc interface, it will be returned
- * as an ASCII string in the standard UUID format.  If accesses via the
- * sysctl system call, it is returned as 16 bytes of binary data.
+ * If the user accesses this via the proc interface, the UUID will be
+ * returned as an ASCII string in the standard UUID format; if via the
+ * sysctl system call, as 16 bytes of binary data.
  */
-static int proc_do_uuid(ctl_table *table, int write,
+static int proc_do_uuid(struct ctl_table *table, int write,
 			void __user *buffer, size_t *lenp, loff_t *ppos)
 {
-	ctl_table fake_table;
+	struct ctl_table fake_table;
 	unsigned char buf[64], tmp_uuid[16], *uuid;
 
 	uuid = table->data;
 	if (!uuid) {
 		uuid = tmp_uuid;
-		uuid[8] = 0;
-	}
-	if (uuid[8] == 0)
 		generate_random_uuid(uuid);
+	} else {
+		static DEFINE_SPINLOCK(bootid_spinlock);
+
+		spin_lock(&bootid_spinlock);
+		if (!uuid[8])
+			generate_random_uuid(uuid);
+		spin_unlock(&bootid_spinlock);
+	}
 
 	sprintf(buf, "%pU", uuid);
 
@@ -1200,8 +1601,26 @@
 	return proc_dostring(&fake_table, write, buffer, lenp, ppos);
 }
 
+/*
+ * Return entropy available scaled to integral bits
+ */
+static int proc_do_entropy(struct ctl_table *table, int write,
+			   void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	struct ctl_table fake_table;
+	int entropy_count;
+
+	entropy_count = *(int *)table->data >> ENTROPY_SHIFT;
+
+	fake_table.data = &entropy_count;
+	fake_table.maxlen = sizeof(entropy_count);
+
+	return proc_dointvec(&fake_table, write, buffer, lenp, ppos);
+}
+
 static int sysctl_poolsize = INPUT_POOL_WORDS * 32;
-ctl_table random_table[] = {
+extern struct ctl_table random_table[];
+struct ctl_table random_table[] = {
 	{
 		.procname	= "poolsize",
 		.data		= &sysctl_poolsize,
@@ -1213,12 +1632,12 @@
 		.procname	= "entropy_avail",
 		.maxlen		= sizeof(int),
 		.mode		= 0444,
-		.proc_handler	= proc_dointvec,
+		.proc_handler	= proc_do_entropy,
 		.data		= &input_pool.entropy_count,
 	},
 	{
 		.procname	= "read_wakeup_threshold",
-		.data		= &random_read_wakeup_thresh,
+		.data		= &random_read_wakeup_bits,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec_minmax,
@@ -1227,7 +1646,7 @@
 	},
 	{
 		.procname	= "write_wakeup_threshold",
-		.data		= &random_write_wakeup_thresh,
+		.data		= &random_write_wakeup_bits,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec_minmax,
@@ -1235,6 +1654,13 @@
 		.extra2		= &max_write_thresh,
 	},
 	{
+		.procname	= "urandom_min_reseed_secs",
+		.data		= &random_min_urandom_seed,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
 		.procname	= "boot_id",
 		.data		= &sysctl_bootid,
 		.maxlen		= 16,
@@ -1471,7 +1897,7 @@
 	hash[2] = keyptr->secret[10];
 	hash[3] = keyptr->secret[11];
 
-	return half_md4_transform(hash, keyptr->secret);
+	return half_md4_transform_inline(hash, keyptr->secret);
 }
 
 #ifdef CONFIG_INET
@@ -1494,7 +1920,7 @@
 	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
 	hash[3] = keyptr->secret[11];
 
-	seq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;
+	seq = half_md4_transform_inline(hash, keyptr->secret) & HASH_MASK;
 	seq += keyptr->count;
 	/*
 	 *	As close as possible to RFC 793, which
@@ -1526,7 +1952,7 @@
 	hash[2] = (__force u32)dport ^ keyptr->secret[10];
 	hash[3] = keyptr->secret[11];
 
-	return half_md4_transform(hash, keyptr->secret);
+	return half_md4_transform_inline(hash, keyptr->secret);
 }
 EXPORT_SYMBOL_GPL(secure_ipv4_port_ephemeral);
 
@@ -1562,7 +1988,7 @@
 	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
 	hash[3] = keyptr->secret[11];
 
-	seq = half_md4_transform(hash, keyptr->secret);
+	seq = half_md4_transform_inline(hash, keyptr->secret);
 	seq |= ((u64)keyptr->count) << (32 - HASH_BITS);
 
 	seq += ktime_to_ns(ktime_get_real());
@@ -1576,23 +2002,34 @@
 #endif /* CONFIG_INET */
 
 
+static u32 random_int_secret[MD5_MESSAGE_BYTES / 4] ____cacheline_aligned;
+
+int random_int_secret_init(void)
+{
+	get_random_bytes(random_int_secret, sizeof(random_int_secret));
+	return 0;
+}
+
 /*
  * Get a random word for internal kernel use only. Similar to urandom but
  * with the goal of minimal entropy pool depletion. As a result, the random
  * value is not cryptographically secure but for several uses the cost of
  * depleting entropy is too high
  */
-DEFINE_PER_CPU(__u32 [4], get_random_int_hash);
+static DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], get_random_int_hash);
 unsigned int get_random_int(void)
 {
-	struct keydata *keyptr;
-	__u32 *hash = get_cpu_var(get_random_int_hash);
-	int ret;
+	__u32 *hash;
+	unsigned int ret;
 
-	keyptr = get_keyptr();
-	hash[0] += current->pid + jiffies + get_cycles();
+	if (arch_get_random_int(&ret))
+		return ret;
+
+	hash = get_cpu_var(get_random_int_hash);
 
-	ret = half_md4_transform(hash, keyptr->secret);
+	hash[0] += current->pid + jiffies + random_get_entropy();
+	md5_transform_inline(hash, random_int_secret);
+	ret = hash[0];
 	put_cpu_var(get_random_int_hash);
 
 	return ret;
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/lib/random32.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/lib/random32.c
@@ -1,43 +1,51 @@
+///////////////////////////////////////////////////////////////////////////////
+// Entropy backport from Linux 3.16.43 to AsusWrt
+//
+// SOURCE: Linux 3.16.43, lib/random32.c
+///////////////////////////////////////////////////////////////////////////////
 /*
-  This is a maximally equidistributed combined Tausworthe generator
-  based on code from GNU Scientific Library 1.5 (30 Jun 2004)
-
-   x_n = (s1_n ^ s2_n ^ s3_n)
-
-   s1_{n+1} = (((s1_n & 4294967294) <<12) ^ (((s1_n <<13) ^ s1_n) >>19))
-   s2_{n+1} = (((s2_n & 4294967288) << 4) ^ (((s2_n << 2) ^ s2_n) >>25))
-   s3_{n+1} = (((s3_n & 4294967280) <<17) ^ (((s3_n << 3) ^ s3_n) >>11))
-
-   The period of this generator is about 2^88.
-
-   From: P. L'Ecuyer, "Maximally Equidistributed Combined Tausworthe
-   Generators", Mathematics of Computation, 65, 213 (1996), 203--213.
-
-   This is available on the net from L'Ecuyer's home page,
-
-   http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme.ps
-   ftp://ftp.iro.umontreal.ca/pub/simulation/lecuyer/papers/tausme.ps
-
-   There is an erratum in the paper "Tables of Maximally
-   Equidistributed Combined LFSR Generators", Mathematics of
-   Computation, 68, 225 (1999), 261--269:
-   http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme2.ps
-
-        ... the k_j most significant bits of z_j must be non-
-        zero, for each j. (Note: this restriction also applies to the
-        computer code given in [4], but was mistakenly not mentioned in
-        that paper.)
-
-   This affects the seeding procedure by imposing the requirement
-   s1 > 1, s2 > 7, s3 > 15.
-
-*/
+ * This is a maximally equidistributed combined Tausworthe generator
+ * based on code from GNU Scientific Library 1.5 (30 Jun 2004)
+ *
+ * lfsr113 version:
+ *
+ * x_n = (s1_n ^ s2_n ^ s3_n ^ s4_n)
+ *
+ * s1_{n+1} = (((s1_n & 4294967294) << 18) ^ (((s1_n <<  6) ^ s1_n) >> 13))
+ * s2_{n+1} = (((s2_n & 4294967288) <<  2) ^ (((s2_n <<  2) ^ s2_n) >> 27))
+ * s3_{n+1} = (((s3_n & 4294967280) <<  7) ^ (((s3_n << 13) ^ s3_n) >> 21))
+ * s4_{n+1} = (((s4_n & 4294967168) << 13) ^ (((s4_n <<  3) ^ s4_n) >> 12))
+ *
+ * The period of this generator is about 2^113 (see erratum paper).
+ *
+ * From: P. L'Ecuyer, "Maximally Equidistributed Combined Tausworthe
+ * Generators", Mathematics of Computation, 65, 213 (1996), 203--213:
+ * http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme.ps
+ * ftp://ftp.iro.umontreal.ca/pub/simulation/lecuyer/papers/tausme.ps
+ *
+ * There is an erratum in the paper "Tables of Maximally Equidistributed
+ * Combined LFSR Generators", Mathematics of Computation, 68, 225 (1999),
+ * 261--269: http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme2.ps
+ *
+ *      ... the k_j most significant bits of z_j must be non-zero,
+ *      for each j. (Note: this restriction also applies to the
+ *      computer code given in [4], but was mistakenly not mentioned
+ *      in that paper.)
+ *
+ * This affects the seeding procedure by imposing the requirement
+ * s1 > 1, s2 > 7, s3 > 15, s4 > 127.
+ */
 
 #include <linux/types.h>
 #include <linux/percpu.h>
 #include <linux/module.h>
 #include <linux/jiffies.h>
 #include <linux/random.h>
+#include <linux/sched.h>
+
+#ifdef CONFIG_RANDOM32_SELFTEST
+static void __init prandom_state_selftest(void);
+#endif
 
 static DEFINE_PER_CPU(struct rnd_state, net_rand_state);
 
@@ -50,13 +58,7 @@
  */
 u32 prandom32(struct rnd_state *state)
 {
-#define TAUSWORTHE(s,a,b,c,d) ((s&c)<<d) ^ (((s <<a) ^ s)>>b)
-
-	state->s1 = TAUSWORTHE(state->s1, 13, 19, 4294967294UL, 12);
-	state->s2 = TAUSWORTHE(state->s2, 2, 25, 4294967288UL, 4);
-	state->s3 = TAUSWORTHE(state->s3, 3, 11, 4294967280UL, 17);
-
-	return (state->s1 ^ state->s2 ^ state->s3);
+	return prandom_u32_state(state);
 }
 EXPORT_SYMBOL(prandom32);
 
@@ -69,11 +71,7 @@
  */
 u32 random32(void)
 {
-	unsigned long r;
-	struct rnd_state *state = &get_cpu_var(net_rand_state);
-	r = prandom32(state);
-	put_cpu_var(state);
-	return r;
+	return prandom_u32();
 }
 EXPORT_SYMBOL(random32);
 
@@ -87,12 +85,14 @@
  */
 u32 prandom_u32_state(struct rnd_state *state)
 {
-#define TAUSWORTHE(s, a, b, c, d) ((s & c) << d) ^ (((s << a) ^ s) >> b)
+#define TAUSWORTHE(s,a,b,c,d) ((s&c)<<d) ^ (((s <<a) ^ s)>>b)
+
 	state->s1 = TAUSWORTHE(state->s1,  6U, 13U, 4294967294U, 18U);
 	state->s2 = TAUSWORTHE(state->s2,  2U, 27U, 4294967288U,  2U);
 	state->s3 = TAUSWORTHE(state->s3, 13U, 21U, 4294967280U,  7U);
+	state->s4 = TAUSWORTHE(state->s4,  3U, 12U, 4294967168U, 13U);
 
-	return (state->s1 ^ state->s2 ^ state->s3);
+	return (state->s1 ^ state->s2 ^ state->s3 ^ state->s4);
 }
 EXPORT_SYMBOL(prandom_u32_state);
 
@@ -116,10 +116,91 @@
 EXPORT_SYMBOL(prandom_u32);
 
 /**
+ *	prandom_bytes_state - get the requested number of pseudo-random bytes
+ *
+ *	@state: pointer to state structure holding seeded state.
+ *	@buf: where to copy the pseudo-random bytes to
+ *	@bytes: the requested number of bytes
+ *
+ *	This is used for pseudo-randomness with no outside seeding.
+ *	For more random results, use prandom_bytes().
+ */
+void prandom_bytes_state(struct rnd_state *state, void *buf, int bytes)
+{
+	unsigned char *p = buf;
+	int i;
+
+	for (i = 0; i < round_down(bytes, sizeof(u32)); i += sizeof(u32)) {
+		u32 random = prandom_u32_state(state);
+		int j;
+
+		for (j = 0; j < sizeof(u32); j++) {
+			p[i + j] = random;
+			random >>= BITS_PER_BYTE;
+		}
+	}
+	if (i < bytes) {
+		u32 random = prandom_u32_state(state);
+
+		for (; i < bytes; i++) {
+			p[i] = random;
+			random >>= BITS_PER_BYTE;
+		}
+	}
+}
+//EXPORT_SYMBOL(prandom_bytes_state);
+
+/**
+ *	prandom_bytes - get the requested number of pseudo-random bytes
+ *	@buf: where to copy the pseudo-random bytes to
+ *	@bytes: the requested number of bytes
+ */
+void prandom_bytes(void *buf, int bytes)
+{
+	struct rnd_state *state = &get_cpu_var(net_rand_state);
+
+	prandom_bytes_state(state, buf, bytes);
+	put_cpu_var(state);
+}
+//EXPORT_SYMBOL(prandom_bytes);
+
+static void prandom_warmup(struct rnd_state *state)
+{
+	/* Calling RNG ten times to satify recurrence condition */
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+}
+
+static void prandom_seed_very_weak(struct rnd_state *state, u32 seed)
+{
+	/* Note: This sort of seeding is ONLY used in test cases and
+	 * during boot at the time from core_initcall until late_initcall
+	 * as we don't have a stronger entropy source available yet.
+	 * After late_initcall, we reseed entire state, we have to (!),
+	 * otherwise an attacker just needs to search 32 bit space to
+	 * probe for our internal 128 bit state if he knows a couple
+	 * of prandom32 outputs!
+	 */
+#define LCG(x)	((x) * 69069U)	/* super-duper LCG */
+	state->s1 = __seed(LCG(seed),        2U);
+	state->s2 = __seed(LCG(state->s1),   8U);
+	state->s3 = __seed(LCG(state->s2),  16U);
+	state->s4 = __seed(LCG(state->s3), 128U);
+}
+
+/**
  *	srandom32 - add entropy to pseudo random number generator
  *	@seed: seed value
  *
- *	Add some additional seeding to the random32() pool.
+ *	Add some additional seeding to the prandom pool.
  */
 void srandom32(u32 entropy)
 {
@@ -130,59 +211,277 @@
 	 */
 	for_each_possible_cpu (i) {
 		struct rnd_state *state = &per_cpu(net_rand_state, i);
-		state->s1 = __seed(state->s1 ^ entropy, 1);
+
+		state->s1 = __seed(state->s1 ^ entropy, 2U);
+		prandom_warmup(state);
 	}
 }
 EXPORT_SYMBOL(srandom32);
 
 /*
  *	Generate some initially weak seeding values to allow
- *	to start the random32() engine.
+ *	to start the prandom_u32() engine.
  */
-static int __init random32_init(void)
+static int __init prandom_init(void)
 {
 	int i;
 
+#ifdef CONFIG_RANDOM32_SELFTEST
+	prandom_state_selftest();
+#endif
+
 	for_each_possible_cpu(i) {
 		struct rnd_state *state = &per_cpu(net_rand_state,i);
 
-#define LCG(x)	((x) * 69069)	/* super-duper LCG */
-		state->s1 = __seed(LCG(i + jiffies), 1);
-		state->s2 = __seed(LCG(state->s1), 7);
-		state->s3 = __seed(LCG(state->s2), 15);
-
-		/* "warm it up" */
-		prandom32(state);
-		prandom32(state);
-		prandom32(state);
-		prandom32(state);
-		prandom32(state);
-		prandom32(state);
+		prandom_seed_very_weak(state, (i + jiffies) ^ random_get_entropy());
+		prandom_warmup(state);
 	}
+
 	return 0;
 }
-core_initcall(random32_init);
+core_initcall(prandom_init);
+
+static void __prandom_timer(unsigned long dontcare);
+static DEFINE_TIMER(seed_timer, __prandom_timer, 0, 0);
+
+static void __prandom_timer(unsigned long dontcare)
+{
+	u32 entropy;
+	unsigned long expires;
+
+	get_random_bytes(&entropy, sizeof(entropy));
+	srandom32(entropy);
+
+	/* reseed every ~60 seconds, in [40 .. 80) interval with slack */
+	expires = 40 + (prandom_u32() % 40);
+	seed_timer.expires = jiffies + msecs_to_jiffies(expires * MSEC_PER_SEC);
+
+	add_timer(&seed_timer);
+}
+
+static void __init __prandom_start_seed_timer(void)
+{
+	set_timer_slack(&seed_timer, HZ);
+	seed_timer.expires = jiffies + msecs_to_jiffies(40 * MSEC_PER_SEC);
+	add_timer(&seed_timer);
+}
 
 /*
  *	Generate better values after random number generator
  *	is fully initialized.
  */
-static int __init random32_reseed(void)
+static void __prandom_reseed(bool late)
 {
 	int i;
+	unsigned long flags;
+	static bool latch = false;
+	static DEFINE_SPINLOCK(lock);
+
+	/* Asking for random bytes might result in bytes getting
+	 * moved into the nonblocking pool and thus marking it
+	 * as initialized. In this case we would double back into
+	 * this function and attempt to do a late reseed.
+	 * Ignore the pointless attempt to reseed again if we're
+	 * already waiting for bytes when the nonblocking pool
+	 * got initialized.
+	 */
+
+	/* only allow initial seeding (late == false) once */
+	if (!spin_trylock_irqsave(&lock, flags))
+		return;
+
+	if (latch && !late)
+		goto out;
+
+	latch = true;
 
 	for_each_possible_cpu(i) {
 		struct rnd_state *state = &per_cpu(net_rand_state,i);
-		u32 seeds[3];
+		u32 seeds[4];
 
 		get_random_bytes(&seeds, sizeof(seeds));
-		state->s1 = __seed(seeds[0], 1);
-		state->s2 = __seed(seeds[1], 7);
-		state->s3 = __seed(seeds[2], 15);
+		state->s1 = __seed(seeds[0],   2U);
+		state->s2 = __seed(seeds[1],   8U);
+		state->s3 = __seed(seeds[2],  16U);
+		state->s4 = __seed(seeds[3], 128U);
 
-		/* mix it in */
-		prandom32(state);
+		prandom_warmup(state);
 	}
+out:
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+void prandom_reseed_late(void)
+{
+	__prandom_reseed(true);
+}
+
+static int __init prandom_reseed(void)
+{
+	__prandom_reseed(false);
+	__prandom_start_seed_timer();
 	return 0;
 }
-late_initcall(random32_reseed);
+late_initcall(prandom_reseed);
+
+#ifdef CONFIG_RANDOM32_SELFTEST
+static struct prandom_test1 {
+	u32 seed;
+	u32 result;
+} test1[] = {
+	{ 1U, 3484351685U },
+	{ 2U, 2623130059U },
+	{ 3U, 3125133893U },
+	{ 4U,  984847254U },
+};
+
+static struct prandom_test2 {
+	u32 seed;
+	u32 iteration;
+	u32 result;
+} test2[] = {
+	/* Test cases against taus113 from GSL library. */
+	{  931557656U, 959U, 2975593782U },
+	{ 1339693295U, 876U, 3887776532U },
+	{ 1545556285U, 961U, 1615538833U },
+	{  601730776U, 723U, 1776162651U },
+	{ 1027516047U, 687U,  511983079U },
+	{  416526298U, 700U,  916156552U },
+	{ 1395522032U, 652U, 2222063676U },
+	{  366221443U, 617U, 2992857763U },
+	{ 1539836965U, 714U, 3783265725U },
+	{  556206671U, 994U,  799626459U },
+	{  684907218U, 799U,  367789491U },
+	{ 2121230701U, 931U, 2115467001U },
+	{ 1668516451U, 644U, 3620590685U },
+	{  768046066U, 883U, 2034077390U },
+	{ 1989159136U, 833U, 1195767305U },
+	{  536585145U, 996U, 3577259204U },
+	{ 1008129373U, 642U, 1478080776U },
+	{ 1740775604U, 939U, 1264980372U },
+	{ 1967883163U, 508U,   10734624U },
+	{ 1923019697U, 730U, 3821419629U },
+	{  442079932U, 560U, 3440032343U },
+	{ 1961302714U, 845U,  841962572U },
+	{ 2030205964U, 962U, 1325144227U },
+	{ 1160407529U, 507U,  240940858U },
+	{  635482502U, 779U, 4200489746U },
+	{ 1252788931U, 699U,  867195434U },
+	{ 1961817131U, 719U,  668237657U },
+	{ 1071468216U, 983U,  917876630U },
+	{ 1281848367U, 932U, 1003100039U },
+	{  582537119U, 780U, 1127273778U },
+	{ 1973672777U, 853U, 1071368872U },
+	{ 1896756996U, 762U, 1127851055U },
+	{  847917054U, 500U, 1717499075U },
+	{ 1240520510U, 951U, 2849576657U },
+	{ 1685071682U, 567U, 1961810396U },
+	{ 1516232129U, 557U,    3173877U },
+	{ 1208118903U, 612U, 1613145022U },
+	{ 1817269927U, 693U, 4279122573U },
+	{ 1510091701U, 717U,  638191229U },
+	{  365916850U, 807U,  600424314U },
+	{  399324359U, 702U, 1803598116U },
+	{ 1318480274U, 779U, 2074237022U },
+	{  697758115U, 840U, 1483639402U },
+	{ 1696507773U, 840U,  577415447U },
+	{ 2081979121U, 981U, 3041486449U },
+	{  955646687U, 742U, 3846494357U },
+	{ 1250683506U, 749U,  836419859U },
+	{  595003102U, 534U,  366794109U },
+	{   47485338U, 558U, 3521120834U },
+	{  619433479U, 610U, 3991783875U },
+	{  704096520U, 518U, 4139493852U },
+	{ 1712224984U, 606U, 2393312003U },
+	{ 1318233152U, 922U, 3880361134U },
+	{  855572992U, 761U, 1472974787U },
+	{   64721421U, 703U,  683860550U },
+	{  678931758U, 840U,  380616043U },
+	{  692711973U, 778U, 1382361947U },
+	{  677703619U, 530U, 2826914161U },
+	{   92393223U, 586U, 1522128471U },
+	{ 1222592920U, 743U, 3466726667U },
+	{  358288986U, 695U, 1091956998U },
+	{ 1935056945U, 958U,  514864477U },
+	{  735675993U, 990U, 1294239989U },
+	{ 1560089402U, 897U, 2238551287U },
+	{   70616361U, 829U,   22483098U },
+	{  368234700U, 731U, 2913875084U },
+	{   20221190U, 879U, 1564152970U },
+	{  539444654U, 682U, 1835141259U },
+	{ 1314987297U, 840U, 1801114136U },
+	{ 2019295544U, 645U, 3286438930U },
+	{  469023838U, 716U, 1637918202U },
+	{ 1843754496U, 653U, 2562092152U },
+	{  400672036U, 809U, 4264212785U },
+	{  404722249U, 965U, 2704116999U },
+	{  600702209U, 758U,  584979986U },
+	{  519953954U, 667U, 2574436237U },
+	{ 1658071126U, 694U, 2214569490U },
+	{  420480037U, 749U, 3430010866U },
+	{  690103647U, 969U, 3700758083U },
+	{ 1029424799U, 937U, 3787746841U },
+	{ 2012608669U, 506U, 3362628973U },
+	{ 1535432887U, 998U,   42610943U },
+	{ 1330635533U, 857U, 3040806504U },
+	{ 1223800550U, 539U, 3954229517U },
+	{ 1322411537U, 680U, 3223250324U },
+	{ 1877847898U, 945U, 2915147143U },
+	{ 1646356099U, 874U,  965988280U },
+	{  805687536U, 744U, 4032277920U },
+	{ 1948093210U, 633U, 1346597684U },
+	{  392609744U, 783U, 1636083295U },
+	{  690241304U, 770U, 1201031298U },
+	{ 1360302965U, 696U, 1665394461U },
+	{ 1220090946U, 780U, 1316922812U },
+	{  447092251U, 500U, 3438743375U },
+	{ 1613868791U, 592U,  828546883U },
+	{  523430951U, 548U, 2552392304U },
+	{  726692899U, 810U, 1656872867U },
+	{ 1364340021U, 836U, 3710513486U },
+	{ 1986257729U, 931U,  935013962U },
+	{  407983964U, 921U,  728767059U },
+};
+
+static void __init prandom_state_selftest(void)
+{
+	int i, j, errors = 0, runs = 0;
+	bool error = false;
+
+	for (i = 0; i < ARRAY_SIZE(test1); i++) {
+		struct rnd_state state;
+
+		prandom_seed_very_weak(&state, test1[i].seed);
+		prandom_warmup(&state);
+
+		if (test1[i].result != prandom_u32_state(&state))
+			error = true;
+	}
+
+	if (error)
+		pr_warn("prandom: seed boundary self test failed\n");
+	else
+		pr_info("prandom: seed boundary self test passed\n");
+
+	for (i = 0; i < ARRAY_SIZE(test2); i++) {
+		struct rnd_state state;
+
+		prandom_seed_very_weak(&state, test2[i].seed);
+		prandom_warmup(&state);
+
+		for (j = 0; j < test2[i].iteration - 1; j++)
+			prandom_u32_state(&state);
+
+		if (test2[i].result != prandom_u32_state(&state))
+			errors++;
+
+		runs++;
+		cond_resched();
+	}
+
+	if (errors)
+		pr_warn("prandom: %d/%d self tests failed\n", errors, runs);
+	else
+		pr_info("prandom: %d self tests passed\n", runs);
+}
+#endif
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/trace/events/random.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/trace/events/random.h
@@ -0,0 +1,320 @@
+///////////////////////////////////////////////////////////////////////////////
+// Entropy backport from Linux 3.16.43 to AsusWrt
+//
+// SOURCE: Linux 3.16.43, include/trace/events/random.h
+///////////////////////////////////////////////////////////////////////////////
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM random
+
+#if !defined(_TRACE_RANDOM_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_RANDOM_H
+
+#include <linux/writeback.h>
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(add_device_randomness,
+	TP_PROTO(int bytes, unsigned long IP),
+
+	TP_ARGS(bytes, IP),
+
+	TP_STRUCT__entry(
+		__field(	  int,	bytes			)
+		__field(unsigned long,	IP			)
+	),
+
+	TP_fast_assign(
+		__entry->bytes		= bytes;
+		__entry->IP		= IP;
+	),
+
+	TP_printk("bytes %d caller %pF",
+		__entry->bytes, (void *)__entry->IP)
+);
+
+DECLARE_EVENT_CLASS(random__mix_pool_bytes,
+	TP_PROTO(const char *pool_name, int bytes, unsigned long IP),
+
+	TP_ARGS(pool_name, bytes, IP),
+
+	TP_STRUCT__entry(
+		__field( const char *,	pool_name		)
+		__field(	  int,	bytes			)
+		__field(unsigned long,	IP			)
+	),
+
+	TP_fast_assign(
+		__entry->pool_name	= pool_name;
+		__entry->bytes		= bytes;
+		__entry->IP		= IP;
+	),
+
+	TP_printk("%s pool: bytes %d caller %pF",
+		  __entry->pool_name, __entry->bytes, (void *)__entry->IP)
+);
+
+DEFINE_EVENT(random__mix_pool_bytes, mix_pool_bytes,
+	TP_PROTO(const char *pool_name, int bytes, unsigned long IP),
+
+	TP_ARGS(pool_name, bytes, IP)
+);
+
+DEFINE_EVENT(random__mix_pool_bytes, mix_pool_bytes_nolock,
+	TP_PROTO(const char *pool_name, int bytes, unsigned long IP),
+
+	TP_ARGS(pool_name, bytes, IP)
+);
+
+TRACE_EVENT(credit_entropy_bits,
+	TP_PROTO(const char *pool_name, int bits, int entropy_count,
+		 int entropy_total, unsigned long IP),
+
+	TP_ARGS(pool_name, bits, entropy_count, entropy_total, IP),
+
+	TP_STRUCT__entry(
+		__field( const char *,	pool_name		)
+		__field(	  int,	bits			)
+		__field(	  int,	entropy_count		)
+		__field(	  int,	entropy_total		)
+		__field(unsigned long,	IP			)
+	),
+
+	TP_fast_assign(
+		__entry->pool_name	= pool_name;
+		__entry->bits		= bits;
+		__entry->entropy_count	= entropy_count;
+		__entry->entropy_total	= entropy_total;
+		__entry->IP		= IP;
+	),
+
+	TP_printk("%s pool: bits %d entropy_count %d entropy_total %d "
+		  "caller %pF", __entry->pool_name, __entry->bits,
+		  __entry->entropy_count, __entry->entropy_total,
+		  (void *)__entry->IP)
+);
+
+TRACE_EVENT(push_to_pool,
+	TP_PROTO(const char *pool_name, int pool_bits, int input_bits),
+
+	TP_ARGS(pool_name, pool_bits, input_bits),
+
+	TP_STRUCT__entry(
+		__field( const char *,	pool_name		)
+		__field(	  int,	pool_bits		)
+		__field(	  int,	input_bits		)
+	),
+
+	TP_fast_assign(
+		__entry->pool_name	= pool_name;
+		__entry->pool_bits	= pool_bits;
+		__entry->input_bits	= input_bits;
+	),
+
+	TP_printk("%s: pool_bits %d input_pool_bits %d",
+		  __entry->pool_name, __entry->pool_bits,
+		  __entry->input_bits)
+);
+
+TRACE_EVENT(debit_entropy,
+	TP_PROTO(const char *pool_name, int debit_bits),
+
+	TP_ARGS(pool_name, debit_bits),
+
+	TP_STRUCT__entry(
+		__field( const char *,	pool_name		)
+		__field(	  int,	debit_bits		)
+	),
+
+	TP_fast_assign(
+		__entry->pool_name	= pool_name;
+		__entry->debit_bits	= debit_bits;
+	),
+
+	TP_printk("%s: debit_bits %d", __entry->pool_name,
+		  __entry->debit_bits)
+);
+
+TRACE_EVENT(add_input_randomness,
+	TP_PROTO(int input_bits),
+
+	TP_ARGS(input_bits),
+
+	TP_STRUCT__entry(
+		__field(	  int,	input_bits		)
+	),
+
+	TP_fast_assign(
+		__entry->input_bits	= input_bits;
+	),
+
+	TP_printk("input_pool_bits %d", __entry->input_bits)
+);
+
+TRACE_EVENT(add_disk_randomness,
+	TP_PROTO(dev_t dev, int input_bits),
+
+	TP_ARGS(dev, input_bits),
+
+	TP_STRUCT__entry(
+		__field(	dev_t,	dev			)
+		__field(	  int,	input_bits		)
+	),
+
+	TP_fast_assign(
+		__entry->dev		= dev;
+		__entry->input_bits	= input_bits;
+	),
+
+	TP_printk("dev %d,%d input_pool_bits %d", MAJOR(__entry->dev),
+		  MINOR(__entry->dev), __entry->input_bits)
+);
+
+TRACE_EVENT(xfer_secondary_pool,
+	TP_PROTO(const char *pool_name, int xfer_bits, int request_bits,
+		 int pool_entropy, int input_entropy),
+
+	TP_ARGS(pool_name, xfer_bits, request_bits, pool_entropy,
+		input_entropy),
+
+	TP_STRUCT__entry(
+		__field( const char *,	pool_name		)
+		__field(	  int,	xfer_bits		)
+		__field(	  int,	request_bits		)
+		__field(	  int,	pool_entropy		)
+		__field(	  int,	input_entropy		)
+	),
+
+	TP_fast_assign(
+		__entry->pool_name	= pool_name;
+		__entry->xfer_bits	= xfer_bits;
+		__entry->request_bits	= request_bits;
+		__entry->pool_entropy	= pool_entropy;
+		__entry->input_entropy	= input_entropy;
+	),
+
+	TP_printk("pool %s xfer_bits %d request_bits %d pool_entropy %d "
+		  "input_entropy %d", __entry->pool_name, __entry->xfer_bits,
+		  __entry->request_bits, __entry->pool_entropy,
+		  __entry->input_entropy)
+);
+
+DECLARE_EVENT_CLASS(random__get_random_bytes,
+	TP_PROTO(int nbytes, unsigned long IP),
+
+	TP_ARGS(nbytes, IP),
+
+	TP_STRUCT__entry(
+		__field(	  int,	nbytes			)
+		__field(unsigned long,	IP			)
+	),
+
+	TP_fast_assign(
+		__entry->nbytes		= nbytes;
+		__entry->IP		= IP;
+	),
+
+	TP_printk("nbytes %d caller %pF", __entry->nbytes, (void *)__entry->IP)
+);
+
+DEFINE_EVENT(random__get_random_bytes, get_random_bytes,
+	TP_PROTO(int nbytes, unsigned long IP),
+
+	TP_ARGS(nbytes, IP)
+);
+
+DEFINE_EVENT(random__get_random_bytes, get_random_bytes_arch,
+	TP_PROTO(int nbytes, unsigned long IP),
+
+	TP_ARGS(nbytes, IP)
+);
+
+DECLARE_EVENT_CLASS(random__extract_entropy,
+	TP_PROTO(const char *pool_name, int nbytes, int entropy_count,
+		 unsigned long IP),
+
+	TP_ARGS(pool_name, nbytes, entropy_count, IP),
+
+	TP_STRUCT__entry(
+		__field( const char *,	pool_name		)
+		__field(	  int,	nbytes			)
+		__field(	  int,	entropy_count		)
+		__field(unsigned long,	IP			)
+	),
+
+	TP_fast_assign(
+		__entry->pool_name	= pool_name;
+		__entry->nbytes		= nbytes;
+		__entry->entropy_count	= entropy_count;
+		__entry->IP		= IP;
+	),
+
+	TP_printk("%s pool: nbytes %d entropy_count %d caller %pF",
+		  __entry->pool_name, __entry->nbytes, __entry->entropy_count,
+		  (void *)__entry->IP)
+);
+
+
+DEFINE_EVENT(random__extract_entropy, extract_entropy,
+	TP_PROTO(const char *pool_name, int nbytes, int entropy_count,
+		 unsigned long IP),
+
+	TP_ARGS(pool_name, nbytes, entropy_count, IP)
+);
+
+DEFINE_EVENT(random__extract_entropy, extract_entropy_user,
+	TP_PROTO(const char *pool_name, int nbytes, int entropy_count,
+		 unsigned long IP),
+
+	TP_ARGS(pool_name, nbytes, entropy_count, IP)
+);
+
+TRACE_EVENT(random_read,
+	TP_PROTO(int got_bits, int need_bits, int pool_left, int input_left),
+
+	TP_ARGS(got_bits, need_bits, pool_left, input_left),
+
+	TP_STRUCT__entry(
+		__field(	  int,	got_bits		)
+		__field(	  int,	need_bits		)
+		__field(	  int,	pool_left		)
+		__field(	  int,	input_left		)
+	),
+
+	TP_fast_assign(
+		__entry->got_bits	= got_bits;
+		__entry->need_bits	= need_bits;
+		__entry->pool_left	= pool_left;
+		__entry->input_left	= input_left;
+	),
+
+	TP_printk("got_bits %d still_needed_bits %d "
+		  "blocking_pool_entropy_left %d input_entropy_left %d",
+		  __entry->got_bits, __entry->got_bits, __entry->pool_left,
+		  __entry->input_left)
+);
+
+TRACE_EVENT(urandom_read,
+	TP_PROTO(int got_bits, int pool_left, int input_left),
+
+	TP_ARGS(got_bits, pool_left, input_left),
+
+	TP_STRUCT__entry(
+		__field(	  int,	got_bits		)
+		__field(	  int,	pool_left		)
+		__field(	  int,	input_left		)
+	),
+
+	TP_fast_assign(
+		__entry->got_bits	= got_bits;
+		__entry->pool_left	= pool_left;
+		__entry->input_left	= input_left;
+	),
+
+	TP_printk("got_bits %d nonblocking_pool_entropy_left %d "
+		  "input_entropy_left %d", __entry->got_bits,
+		  __entry->pool_left, __entry->input_left)
+);
+
+#endif /* _TRACE_RANDOM_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/kernel/irq/handle.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/kernel/irq/handle.c
@@ -445,8 +445,8 @@
 		action = action->next;
 	} while (action);
 
-	if (status & IRQF_SAMPLE_RANDOM)
-		add_interrupt_randomness(irq);
+	add_interrupt_randomness(irq, status);
+
 	local_irq_disable();
 
 	return retval;
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/kernel/irq/manage.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/kernel/irq/manage.c
@@ -659,22 +659,6 @@
 
 	if (desc->chip == &no_irq_chip)
 		return -ENOSYS;
-	/*
-	 * Some drivers like serial.c use request_irq() heavily,
-	 * so we have to be careful not to interfere with a
-	 * running system.
-	 */
-	if (new->flags & IRQF_SAMPLE_RANDOM) {
-		/*
-		 * This function might sleep, we want to call it first,
-		 * outside of the atomic block.
-		 * Yes, this might clear the entropy pool if the wrong
-		 * driver is attempted to be loaded, without actually
-		 * installing a new handler, but is this really a problem,
-		 * only the sysadmin is able to do this.
-		 */
-		rand_initialize_irq(irq);
-	}
 
 	/* Oneshot interrupts are not allowed with shared */
 	if ((new->flags & IRQF_ONESHOT) && (new->flags & IRQF_SHARED))
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/kernel/posix-cpu-timers.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/kernel/posix-cpu-timers.c
@@ -9,6 +9,7 @@
 #include <asm/uaccess.h>
 #include <linux/kernel_stat.h>
 #include <trace/events/timer.h>
+#include <linux/random.h>
 
 /*
  * Called after updating RLIMIT_CPU to run cpu timer and update
@@ -507,6 +508,8 @@
  */
 void posix_cpu_timers_exit(struct task_struct *tsk)
 {
+	add_device_randomness((const void*) &tsk->se.sum_exec_runtime,
+						sizeof(unsigned long long));
 	cleanup_timers(tsk->cpu_timers,
 		       tsk->utime, tsk->stime, tsk->se.sum_exec_runtime);
 
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/core/hub.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/core/hub.c
@@ -24,6 +24,7 @@
 #include <linux/kthread.h>
 #include <linux/mutex.h>
 #include <linux/freezer.h>
+#include <linux/random.h>
 #include <linux/pm_runtime.h>
 
 #include <asm/uaccess.h>
@@ -1837,6 +1838,14 @@
 	/* Tell the world! */
 	announce_device(udev);
 
+	if (udev->serial)
+		add_device_randomness(udev->serial, strlen(udev->serial));
+	if (udev->product)
+		add_device_randomness(udev->product, strlen(udev->product));
+	if (udev->manufacturer)
+		add_device_randomness(udev->manufacturer,
+				      strlen(udev->manufacturer));
+
 	device_enable_async_suspend(&udev->dev);
 	/* Register the device.  The device driver is responsible
 	 * for configuring the device and invoking the add-device
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/core/dev.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/core/dev.c
@@ -1185,6 +1185,8 @@
 		 *	Wakeup transmit queue engine
 		 */
 		dev_activate(dev);
+
+		add_device_randomness(dev->dev_addr, dev->addr_len);
 	}
 
 	return ret;
@@ -4425,6 +4427,7 @@
 	err = ops->ndo_set_mac_address(dev, sa);
 	if (!err)
 		call_netdevice_notifiers(NETDEV_CHANGEADDR, dev);
+	add_device_randomness(dev->dev_addr, dev->addr_len);
 	return err;
 }
 EXPORT_SYMBOL(dev_set_mac_address);
@@ -5088,6 +5091,7 @@
 	dev_init_scheduler(dev);
 	dev_hold(dev);
 	list_netdevice(dev);
+	add_device_randomness(dev->dev_addr, dev->addr_len);
 
 	/* Notify protocols, that a new device appeared. */
 	ret = call_netdevice_notifiers(NETDEV_REGISTER, dev);
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/config_base.6a
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/config_base.6a
@@ -501,7 +501,7 @@
 CONFIG_NETFILTER_NETLINK_LOG=y
 CONFIG_NF_CONNTRACK=y
 CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
+CONFIG_NF_CONNTRACK_EVENTS=y
 # CONFIG_NF_CT_PROTO_DCCP is not set
 CONFIG_NF_CT_PROTO_GRE=m
 # CONFIG_NF_CT_PROTO_SCTP is not set
@@ -547,6 +547,8 @@
 # CONFIG_NETFILTER_XT_TARGET_TRACE is not set
 CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
 # CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7 is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG is not set
 
 #
 # Xtables matches
@@ -581,7 +583,7 @@
 # CONFIG_NETFILTER_XT_MATCH_SCTP is not set
 # CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
 CONFIG_NETFILTER_XT_MATCH_STATE=y
-# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
 CONFIG_NETFILTER_XT_MATCH_STRING=y
 CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
 CONFIG_NETFILTER_XT_MATCH_TIME=y
@@ -1060,7 +1062,28 @@
 # CONFIG_SATA_INIC162X is not set
 # CONFIG_SATA_SIL24 is not set
 # CONFIG_ATA_SFF is not set
-# CONFIG_MD is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MULTICORE_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=m
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_MULTIPATH_QL is not set
+# CONFIG_DM_MULTIPATH_ST is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
 # CONFIG_FUSION is not set
 
 #
@@ -1275,7 +1298,10 @@
 #
 # PPS support
 #
-# CONFIG_PPS is not set
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_LDISC=m
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -1462,13 +1488,13 @@
 # CONFIG_USB_SERIAL_AIRCABLE is not set
 # CONFIG_USB_SERIAL_ARK3116 is not set
 # CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
+CONFIG_USB_SERIAL_CH341=m
 # CONFIG_USB_SERIAL_WHITEHEAT is not set
 # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_CP210X is not set
+CONFIG_USB_SERIAL_CP210X=m
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
 # CONFIG_USB_SERIAL_FUNSOFT is not set
 # CONFIG_USB_SERIAL_VISOR is not set
 # CONFIG_USB_SERIAL_IPAQ is not set
@@ -1487,7 +1513,7 @@
 # CONFIG_USB_SERIAL_MOS7840 is not set
 # CONFIG_USB_SERIAL_MOTOROLA is not set
 # CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
+CONFIG_USB_SERIAL_PL2303=m
 # CONFIG_USB_SERIAL_OTI6858 is not set
 # CONFIG_USB_SERIAL_QCAUX is not set
 # CONFIG_USB_SERIAL_QUALCOMM is not set
@@ -1612,8 +1638,11 @@
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
@@ -1662,11 +1691,12 @@
 # CONFIG_JFFS2_CMODE_SIZE is not set
 # CONFIG_JFFS2_CMODE_FAVOURLZO is not set
 # CONFIG_LOGFS is not set
-# CONFIG_CRAMFS is not set
+CONFIG_CRAMFS=m
 CONFIG_SQUASHFS=y
 # CONFIG_SQUASHFS_XATTR is not set
 # CONFIG_SQUASHFS_LZO is not set
 CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
 CONFIG_SQUASHFS_EMBEDDED=y
 CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
 # CONFIG_VXFS_FS is not set
@@ -1859,7 +1889,7 @@
 CONFIG_CRYPTO_ECB=y
 # CONFIG_CRYPTO_LRW is not set
 # CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
+CONFIG_CRYPTO_XTS=m
 
 #
 # Hash modes
@@ -1876,41 +1906,42 @@
 # CONFIG_CRYPTO_MD4 is not set
 CONFIG_CRYPTO_MD5=y
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
 CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
 
 #
 # Ciphers
 #
 CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ANUBIS=m
 CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_DES=m
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
 
 #
 # Compression
 #
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=m
 
 #
 # Random Number Generation
@@ -1918,9 +1949,17 @@
 CONFIG_CRYPTO_ANSI_CPRNG=y
 CONFIG_CRYPTO_HW=y
 # CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X_RNG is not set
 # CONFIG_BINARY_PRINTF is not set
 
 #
+# User-space algorithms
+#
+CONFIG_CRYPTO_USER_API=m
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+
+#
 # Library routines
 #
 CONFIG_BITREVERSE=y
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
@@ -1868,8 +1868,20 @@
 	   are only processed once.  */
 	status = packet[0] & FTDI_STATUS_B0_MASK;
 	if (status != priv->prev_status) {
-		priv->diff_status |= status ^ priv->prev_status;
-		wake_up_interruptible(&priv->delta_msr_wait);
+                char diff_status = status ^ priv->prev_status;
+                priv->diff_status |= diff_status;
+        
+                if (diff_status & FTDI_RS0_RLSD) {
+                        struct tty_struct *tty;
+ 
+                        tty = tty_port_tty_get(&port->port);
+                        if (tty)
+                                usb_serial_handle_dcd_change(port, tty,
+                                                status & FTDI_RS0_RLSD);
+                        tty_kref_put(tty);
+                }
+
+                wake_up_interruptible(&priv->delta_msr_wait);
 		priv->prev_status = status;
 	}
 
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/serial/generic.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/serial/generic.c
@@ -491,6 +491,15 @@
 	struct tty_port *port = &usb_port->port;
 
 	dbg("%s - port %d, status %d", __func__, usb_port->number, status);
+        if (tty) {
+               struct tty_ldisc *ld = tty_ldisc_ref(tty);
+
+               if (ld) {
+                       if (ld->ops->dcd_change)
+                               ld->ops->dcd_change(tty, status, NULL);
+                       tty_ldisc_deref(ld);
+               }
+        }
 
 	if (status)
 		wake_up_interruptible(&port->open_wait);
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/Kconfig
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/Kconfig
@@ -66,6 +66,28 @@
 
 	  If unsure, say N.
 
+config SQUASHFS_4K_DEVBLK_SIZE
+	bool "Use 4K device block size?"
+	depends on SQUASHFS
+	help
+	  By default Squashfs sets the dev block size (sb_min_blocksize)
+	  to 1K or the smallest block size supported by the block device
+	  (if larger).  This, because blocks are packed together and
+	  unaligned in Squashfs, should reduce latency.
+
+	  This, however, gives poor performance on MTD NAND devices where
+	  the optimal I/O size is 4K (even though the devices can support
+	  smaller block sizes).
+
+	  Using a 4K device block size may also improve overall I/O
+	  performance for some file access patterns (e.g. sequential
+	  accesses of files in filesystem order) on all media.
+
+	  Setting this option will force Squashfs to use a 4K device block
+	  size by default.
+
+	  If unsure, say N.
+
 config SQUASHFS_EMBEDDED
 	bool "Additional option for memory-constrained systems"
 	depends on SQUASHFS
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
@@ -37,6 +37,13 @@
 #define SQUASHFS_FILE_SIZE		131072
 #define SQUASHFS_FILE_LOG		17
 
+/* default size of block device I/O */
+#ifdef CONFIG_SQUASHFS_4K_DEVBLK_SIZE
+#define SQUASHFS_DEVBLK_SIZE 4096
+#else
+#define SQUASHFS_DEVBLK_SIZE 1024
+#endif
+
 #define SQUASHFS_FILE_MAX_SIZE		1048576
 #define SQUASHFS_FILE_MAX_LOG		20
 
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/super.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/super.c
@@ -102,7 +102,7 @@
 		goto failure;
 	}
 
-	msblk->devblksize = sb_min_blocksize(sb, BLOCK_SIZE);
+	msblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);
 	msblk->devblksize_log2 = ffz(~msblk->devblksize);
 
 	mutex_init(&msblk->read_data_mutex);
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/Makefile
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/Makefile
@@ -85,6 +85,9 @@
 obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
 obj-$(CONFIG_CRYPTO_GHASH) += ghash-generic.o
+obj-$(CONFIG_CRYPTO_USER_API) += af_alg.o
+obj-$(CONFIG_CRYPTO_USER_API_HASH) += algif_hash.o
+obj-$(CONFIG_CRYPTO_USER_API_SKCIPHER) += algif_skcipher.o
 
 #
 # generic algorithms and the async_tx api
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/Kconfig
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/Kconfig
@@ -842,6 +842,27 @@
 	  ANSI X9.31 A.2.4. Note that this option must be enabled if
 	  CRYPTO_FIPS is selected
 
+config CRYPTO_USER_API
+	tristate
+
+config CRYPTO_USER_API_HASH
+	tristate "User-space interface for hash algorithms"
+	depends on NET
+	select CRYPTO_HASH
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for hash
+	  algorithms.
+
+config CRYPTO_USER_API_SKCIPHER
+	tristate "User-space interface for symmetric key cipher algorithms"
+	depends on NET
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for symmetric
+	  key cipher algorithms.
+
 source "drivers/crypto/Kconfig"
 
 endif	# if CRYPTO
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/af_alg.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/af_alg.c
@@ -0,0 +1,483 @@
+/*
+ * af_alg: User-space algorithm interface
+ *
+ * This file provides the user-space API for algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <asm/atomic.h>
+#include <crypto/if_alg.h>
+#include <linux/crypto.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/rwsem.h>
+
+struct alg_type_list {
+	const struct af_alg_type *type;
+	struct list_head list;
+};
+
+static atomic_long_t alg_memory_allocated;
+
+static struct proto alg_proto = {
+	.name			= "ALG",
+	.owner			= THIS_MODULE,
+	.memory_allocated	= &alg_memory_allocated,
+	.obj_size		= sizeof(struct alg_sock),
+};
+
+static LIST_HEAD(alg_types);
+static DECLARE_RWSEM(alg_types_sem);
+
+static const struct af_alg_type *alg_get_type(const char *name)
+{
+	const struct af_alg_type *type = ERR_PTR(-ENOENT);
+	struct alg_type_list *node;
+
+	down_read(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, name))
+			continue;
+
+		if (try_module_get(node->type->owner))
+			type = node->type;
+		break;
+	}
+	up_read(&alg_types_sem);
+
+	return type;
+}
+
+int af_alg_register_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -EEXIST;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (!strcmp(node->type->name, type->name))
+			goto unlock;
+	}
+
+	node = kmalloc(sizeof(*node), GFP_KERNEL);
+	err = -ENOMEM;
+	if (!node)
+		goto unlock;
+
+	type->ops->owner = THIS_MODULE;
+	node->type = type;
+	list_add(&node->list, &alg_types);
+	err = 0;
+
+unlock:
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_register_type);
+
+int af_alg_unregister_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -ENOENT;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, type->name))
+			continue;
+
+		list_del(&node->list);
+		kfree(node);
+		err = 0;
+		break;
+	}
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_unregister_type);
+
+static void alg_do_release(const struct af_alg_type *type, void *private)
+{
+	if (!type)
+		return;
+
+	type->release(private);
+	module_put(type->owner);
+}
+
+int af_alg_release(struct socket *sock)
+{
+	if (sock->sk)
+		sock_put(sock->sk);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_release);
+
+static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct sockaddr_alg *sa = (void *)uaddr;
+	const struct af_alg_type *type;
+	void *private;
+
+	if (sock->state == SS_CONNECTED)
+		return -EINVAL;
+
+	if (addr_len != sizeof(*sa))
+		return -EINVAL;
+
+	sa->salg_type[sizeof(sa->salg_type) - 1] = 0;
+	sa->salg_name[sizeof(sa->salg_name) - 1] = 0;
+
+	type = alg_get_type(sa->salg_type);
+	if (IS_ERR(type) && PTR_ERR(type) == -ENOENT) {
+		request_module("algif-%s", sa->salg_type);
+		type = alg_get_type(sa->salg_type);
+	}
+
+	if (IS_ERR(type))
+		return PTR_ERR(type);
+
+	private = type->bind(sa->salg_name, sa->salg_feat, sa->salg_mask);
+	if (IS_ERR(private)) {
+		module_put(type->owner);
+		return PTR_ERR(private);
+	}
+
+	lock_sock(sk);
+
+	swap(ask->type, type);
+	swap(ask->private, private);
+
+	release_sock(sk);
+
+	alg_do_release(type, private);
+
+	return 0;
+}
+
+static int alg_setkey(struct sock *sk, char __user *ukey,
+		      unsigned int keylen)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type = ask->type;
+	u8 *key;
+	int err;
+
+	key = sock_kmalloc(sk, keylen, GFP_KERNEL);
+	if (!key)
+		return -ENOMEM;
+
+	err = -EFAULT;
+	if (copy_from_user(key, ukey, keylen))
+		goto out;
+
+	err = type->setkey(ask->private, key, keylen);
+
+out:
+	sock_kfree_s(sk, key, keylen);
+
+	return err;
+}
+
+static int alg_setsockopt(struct socket *sock, int level, int optname,
+			  char __user *optval, unsigned int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	int err = -ENOPROTOOPT;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	if (level != SOL_ALG || !type)
+		goto unlock;
+
+	switch (optname) {
+	case ALG_SET_KEY:
+		if (sock->state == SS_CONNECTED)
+			goto unlock;
+		if (!type->setkey)
+			goto unlock;
+
+		err = alg_setkey(sk, optval, optlen);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+
+int af_alg_accept(struct sock *sk, struct socket *newsock)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	struct sock *sk2;
+	int err;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	err = -EINVAL;
+	if (!type)
+		goto unlock;
+
+	sk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto);
+	err = -ENOMEM;
+	if (!sk2)
+		goto unlock;
+
+	sock_init_data(newsock, sk2);
+	sock_graft(sk2, newsock);
+
+	err = type->accept(ask->private, sk2);
+	if (err) {
+		sk_free(sk2);
+		goto unlock;
+	}
+
+	sk2->sk_family = PF_ALG;
+
+	sock_hold(sk);
+	alg_sk(sk2)->parent = sk;
+	alg_sk(sk2)->type = type;
+
+	newsock->ops = type->ops;
+	newsock->state = SS_CONNECTED;
+
+	err = 0;
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_accept);
+
+static int alg_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	return af_alg_accept(sock->sk, newsock);
+}
+
+static const struct proto_ops alg_proto_ops = {
+	.family		=	PF_ALG,
+	.owner		=	THIS_MODULE,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.sendpage	=	sock_no_sendpage,
+	.sendmsg	=	sock_no_sendmsg,
+	.recvmsg	=	sock_no_recvmsg,
+	.poll		=	sock_no_poll,
+
+	.bind		=	alg_bind,
+	.release	=	af_alg_release,
+	.setsockopt	=	alg_setsockopt,
+	.accept		=	alg_accept,
+};
+
+static void alg_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+
+	alg_do_release(ask->type, ask->private);
+}
+
+static int alg_create(struct net *net, struct socket *sock, int protocol,
+		      int kern)
+{
+	struct sock *sk;
+	int err;
+
+	if (sock->type != SOCK_SEQPACKET)
+		return -ESOCKTNOSUPPORT;
+	if (protocol != 0)
+		return -EPROTONOSUPPORT;
+
+	err = -ENOMEM;
+	sk = sk_alloc(net, PF_ALG, GFP_KERNEL, &alg_proto);
+	if (!sk)
+		goto out;
+
+	sock->ops = &alg_proto_ops;
+	sock_init_data(sock, sk);
+
+	sk->sk_family = PF_ALG;
+	sk->sk_destruct = alg_sock_destruct;
+
+	return 0;
+out:
+	return err;
+}
+
+static const struct net_proto_family alg_family = {
+	.family	=	PF_ALG,
+	.create	=	alg_create,
+	.owner	=	THIS_MODULE,
+};
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write)
+{
+	unsigned long from = (unsigned long)addr;
+	unsigned long npages;
+	unsigned off;
+	int err;
+	int i;
+
+	err = -EFAULT;
+	if (!access_ok(write ? VERIFY_READ : VERIFY_WRITE, addr, len))
+		goto out;
+
+	off = from & ~PAGE_MASK;
+	npages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	if (npages > ALG_MAX_PAGES)
+		npages = ALG_MAX_PAGES;
+
+	err = get_user_pages_fast(from, npages, write, sgl->pages);
+	if (err < 0)
+		goto out;
+
+	npages = err;
+	err = -EINVAL;
+	if (WARN_ON(npages == 0))
+		goto out;
+
+	err = 0;
+
+	sg_init_table(sgl->sg, npages);
+
+	for (i = 0; i < npages; i++) {
+		int plen = min_t(int, len, PAGE_SIZE - off);
+
+		sg_set_page(sgl->sg + i, sgl->pages[i], plen, off);
+
+		off = 0;
+		len -= plen;
+		err += plen;
+	}
+
+out:
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_make_sg);
+
+void af_alg_free_sg(struct af_alg_sgl *sgl)
+{
+	int i;
+
+	i = 0;
+	do {
+		put_page(sgl->pages[i]);
+	} while (!sg_is_last(sgl->sg + (i++)));
+}
+EXPORT_SYMBOL_GPL(af_alg_free_sg);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con)
+{
+	struct cmsghdr *cmsg;
+
+	for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
+		if (!CMSG_OK(msg, cmsg))
+			return -EINVAL;
+		if (cmsg->cmsg_level != SOL_ALG)
+			continue;
+
+		switch(cmsg->cmsg_type) {
+		case ALG_SET_IV:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(*con->iv)))
+				return -EINVAL;
+			con->iv = (void *)CMSG_DATA(cmsg);
+			if (cmsg->cmsg_len < CMSG_LEN(con->iv->ivlen +
+						      sizeof(*con->iv)))
+				return -EINVAL;
+			break;
+
+		case ALG_SET_OP:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))
+				return -EINVAL;
+			con->op = *(u32 *)CMSG_DATA(cmsg);
+			break;
+
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_cmsg_send);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion)
+{
+	switch (err) {
+	case -EINPROGRESS:
+	case -EBUSY:
+		wait_for_completion(&completion->completion);
+		INIT_COMPLETION(completion->completion);
+		err = completion->err;
+		break;
+	};
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_wait_for_completion);
+
+void af_alg_complete(struct crypto_async_request *req, int err)
+{
+	struct af_alg_completion *completion = req->data;
+
+	completion->err = err;
+	complete(&completion->completion);
+}
+EXPORT_SYMBOL_GPL(af_alg_complete);
+
+static int __init af_alg_init(void)
+{
+	int err = proto_register(&alg_proto, 0);
+
+	if (err)
+		goto out;
+
+	err = sock_register(&alg_family);
+	if (err != 0)
+		goto out_unregister_proto;
+
+out:
+	return err;
+
+out_unregister_proto:
+	proto_unregister(&alg_proto);
+	goto out;
+}
+
+static void __exit af_alg_exit(void)
+{
+	sock_unregister(PF_ALG);
+	proto_unregister(&alg_proto);
+}
+
+module_init(af_alg_init);
+module_exit(af_alg_exit);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_NETPROTO(AF_ALG);
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/algif_hash.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/algif_hash.c
@@ -0,0 +1,319 @@
+/*
+ * algif_hash: User-space interface for hash algorithms
+ *
+ * This file provides the user-space API for hash algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/hash.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct hash_ctx {
+	struct af_alg_sgl sgl;
+
+	u8 *result;
+
+	struct af_alg_completion completion;
+
+	unsigned int len;
+	bool more;
+
+	struct ahash_request req;
+};
+
+static int hash_sendmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t ignored)
+{
+	int limit = ALG_MAX_PAGES * PAGE_SIZE;
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned long iovlen;
+	struct iovec *iov;
+	long copied = 0;
+	int err;
+
+	if (limit > sk->sk_sndbuf)
+		limit = sk->sk_sndbuf;
+
+	lock_sock(sk);
+	if (!ctx->more) {
+		err = crypto_ahash_init(&ctx->req);
+		if (err)
+			goto unlock;
+	}
+
+	ctx->more = 0;
+
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			int len = min_t(unsigned long, seglen, limit);
+			int newlen;
+
+			newlen = af_alg_make_sg(&ctx->sgl, from, len, 0);
+			if (newlen < 0)
+				goto unlock;
+
+			ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL,
+						newlen);
+
+			err = af_alg_wait_for_completion(
+				crypto_ahash_update(&ctx->req),
+				&ctx->completion);
+
+			af_alg_free_sg(&ctx->sgl);
+
+			if (err)
+				goto unlock;
+
+			seglen -= newlen;
+			from += newlen;
+			copied += newlen;
+		}
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more) {
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err ?: copied;
+}
+
+static ssize_t hash_sendpage(struct socket *sock, struct page *page,
+			     int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	int err;
+
+	lock_sock(sk);
+	sg_init_table(ctx->sgl.sg, 1);
+	sg_set_page(ctx->sgl.sg, page, size, offset);
+
+	ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, ctx->result, size);
+
+	if (!(flags & MSG_MORE)) {
+		if (ctx->more)
+			err = crypto_ahash_finup(&ctx->req);
+		else
+			err = crypto_ahash_digest(&ctx->req);
+	} else {
+		if (!ctx->more) {
+			err = crypto_ahash_init(&ctx->req);
+			if (err)
+				goto unlock;
+		}
+
+		err = crypto_ahash_update(&ctx->req);
+	}
+
+	err = af_alg_wait_for_completion(err, &ctx->completion);
+	if (err)
+		goto unlock;
+
+	ctx->more = flags & MSG_MORE;
+
+unlock:
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t len, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
+	int err;
+
+	if (len > ds)
+		len = ds;
+	else if (len < ds)
+		msg->msg_flags |= MSG_TRUNC;
+
+	lock_sock(sk);
+	if (ctx->more) {
+		ctx->more = 0;
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+		if (err)
+			goto unlock;
+	}
+
+	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);
+
+unlock:
+	release_sock(sk);
+
+	return err ?: len;
+}
+
+static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	struct ahash_request *req = &ctx->req;
+	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];
+	struct sock *sk2;
+	struct alg_sock *ask2;
+	struct hash_ctx *ctx2;
+	int err;
+
+	err = crypto_ahash_export(req, state);
+	if (err)
+		return err;
+
+	err = af_alg_accept(ask->parent, newsock);
+	if (err)
+		return err;
+
+	sk2 = newsock->sk;
+	ask2 = alg_sk(sk2);
+	ctx2 = ask2->private;
+	ctx2->more = 1;
+
+	err = crypto_ahash_import(&ctx2->req, state);
+	if (err) {
+		sock_orphan(sk2);
+		sock_put(sk2);
+	}
+
+	return err;
+}
+
+static struct proto_ops algif_hash_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.setsockopt	=	sock_no_setsockopt,
+	.poll		=	sock_no_poll,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	hash_sendmsg,
+	.sendpage	=	hash_sendpage,
+	.recvmsg	=	hash_recvmsg,
+	.accept		=	hash_accept,
+};
+
+static void *hash_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ahash(name, type, mask);
+}
+
+static void hash_release(void *private)
+{
+	crypto_free_ahash(private);
+}
+
+static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ahash_setkey(private, key, keylen);
+}
+
+static void hash_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+
+	sock_kfree_s(sk, ctx->result,
+		     crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int hash_accept_parent(void *private, struct sock *sk)
+{
+	struct hash_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);
+	unsigned ds = crypto_ahash_digestsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);
+	if (!ctx->result) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->result, 0, ds);
+
+	ctx->len = len;
+	ctx->more = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ahash_request_set_tfm(&ctx->req, private);
+	ahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				   af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = hash_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_hash = {
+	.bind		=	hash_bind,
+	.release	=	hash_release,
+	.setkey		=	hash_setkey,
+	.accept		=	hash_accept_parent,
+	.ops		=	&algif_hash_ops,
+	.name		=	"hash",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_hash_init(void)
+{
+	return af_alg_register_type(&algif_type_hash);
+}
+
+static void __exit algif_hash_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_hash);
+	BUG_ON(err);
+}
+
+module_init(algif_hash_init);
+module_exit(algif_hash_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/algif_skcipher.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/algif_skcipher.c
@@ -0,0 +1,632 @@
+/*
+ * algif_skcipher: User-space interface for skcipher algorithms
+ *
+ * This file provides the user-space API for symmetric key ciphers.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/scatterwalk.h>
+#include <crypto/skcipher.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct skcipher_sg_list {
+	struct list_head list;
+
+	int cur;
+
+	struct scatterlist sg[0];
+};
+
+struct skcipher_ctx {
+	struct list_head tsgl;
+	struct af_alg_sgl rsgl;
+
+	void *iv;
+
+	struct af_alg_completion completion;
+
+	unsigned used;
+
+	unsigned int len;
+	bool more;
+	bool merge;
+	bool enc;
+
+	struct ablkcipher_request req;
+};
+
+#define MAX_SGL_ENTS ((PAGE_SIZE - sizeof(struct skcipher_sg_list)) / \
+		      sizeof(struct scatterlist) - 1)
+
+static inline int skcipher_sndbuf(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	return max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -
+			  ctx->used, 0);
+}
+
+static inline bool skcipher_writable(struct sock *sk)
+{
+	return PAGE_SIZE <= skcipher_sndbuf(sk);
+}
+
+static int skcipher_alloc_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg = NULL;
+
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+	if (!list_empty(&ctx->tsgl))
+		sg = sgl->sg;
+
+	if (!sg || sgl->cur >= MAX_SGL_ENTS) {
+		sgl = sock_kmalloc(sk, sizeof(*sgl) +
+				       sizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),
+				   GFP_KERNEL);
+		if (!sgl)
+			return -ENOMEM;
+
+		sg_init_table(sgl->sg, MAX_SGL_ENTS + 1);
+		sgl->cur = 0;
+
+		if (sg)
+			scatterwalk_sg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);
+
+		list_add_tail(&sgl->list, &ctx->tsgl);
+	}
+
+	return 0;
+}
+
+static void skcipher_pull_sgl(struct sock *sk, int used)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	int i;
+
+	while (!list_empty(&ctx->tsgl)) {
+		sgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,
+				       list);
+		sg = sgl->sg;
+
+		for (i = 0; i < sgl->cur; i++) {
+			int plen = min_t(int, used, sg[i].length);
+
+			if (!sg_page(sg + i))
+				continue;
+
+			sg[i].length -= plen;
+			sg[i].offset += plen;
+
+			used -= plen;
+			ctx->used -= plen;
+
+			if (sg[i].length)
+				return;
+
+			put_page(sg_page(sg + i));
+			sg_assign_page(sg + i, NULL);
+		}
+
+		list_del(&sgl->list);
+		sock_kfree_s(sk, sgl,
+			     sizeof(*sgl) + sizeof(sgl->sg[0]) *
+					    (MAX_SGL_ENTS + 1));
+	}
+
+	if (!ctx->used)
+		ctx->merge = 0;
+}
+
+static void skcipher_free_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	skcipher_pull_sgl(sk, ctx->used);
+}
+
+static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)
+{
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT)
+		return -EAGAIN;
+
+	set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	return err;
+}
+
+static void skcipher_wmem_wakeup(struct sock *sk)
+{
+	struct socket_wq *wq;
+
+	if (!skcipher_writable(sk))
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLIN |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
+	rcu_read_unlock();
+}
+
+static int skcipher_wait_for_data(struct sock *sk, unsigned flags)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT) {
+		return -EAGAIN;
+	}
+
+	set_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, ctx->used)) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	return err;
+}
+
+static void skcipher_data_wakeup(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct socket_wq *wq;
+
+	if (!ctx->used)
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLOUT |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);
+	rcu_read_unlock();
+}
+
+static int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+	unsigned ivsize = crypto_ablkcipher_ivsize(tfm);
+	struct skcipher_sg_list *sgl;
+	struct af_alg_control con = {};
+	long copied = 0;
+	bool enc = 0;
+	int err;
+	int i;
+
+	if (msg->msg_controllen) {
+		err = af_alg_cmsg_send(msg, &con);
+		if (err)
+			return err;
+
+		switch (con.op) {
+		case ALG_OP_ENCRYPT:
+			enc = 1;
+			break;
+		case ALG_OP_DECRYPT:
+			enc = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (con.iv && con.iv->ivlen != ivsize)
+			return -EINVAL;
+	}
+
+	err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!ctx->used) {
+		ctx->enc = enc;
+		if (con.iv)
+			memcpy(ctx->iv, con.iv->iv, ivsize);
+	}
+
+	while (size) {
+		struct scatterlist *sg;
+		unsigned long len = size;
+		int plen;
+
+		if (ctx->merge) {
+			sgl = list_entry(ctx->tsgl.prev,
+					 struct skcipher_sg_list, list);
+			sg = sgl->sg + sgl->cur - 1;
+			len = min_t(unsigned long, len,
+				    PAGE_SIZE - sg->offset - sg->length);
+
+			err = memcpy_fromiovec(page_address(sg_page(sg)) +
+					       sg->offset + sg->length,
+					       msg->msg_iov, len);
+			if (err)
+				goto unlock;
+
+			sg->length += len;
+			ctx->merge = (sg->offset + sg->length) &
+				     (PAGE_SIZE - 1);
+
+			ctx->used += len;
+			copied += len;
+			size -= len;
+			continue;
+		}
+
+		if (!skcipher_writable(sk)) {
+			err = skcipher_wait_for_wmem(sk, msg->msg_flags);
+			if (err)
+				goto unlock;
+		}
+
+		len = min_t(unsigned long, len, skcipher_sndbuf(sk));
+
+		err = skcipher_alloc_sgl(sk);
+		if (err)
+			goto unlock;
+
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+		sg = sgl->sg;
+		do {
+			i = sgl->cur;
+			plen = min_t(int, len, PAGE_SIZE);
+
+			sg_assign_page(sg + i, alloc_page(GFP_KERNEL));
+			err = -ENOMEM;
+			if (!sg_page(sg + i))
+				goto unlock;
+
+			err = memcpy_fromiovec(page_address(sg_page(sg + i)),
+					       msg->msg_iov, plen);
+			if (err) {
+				__free_page(sg_page(sg + i));
+				sg_assign_page(sg + i, NULL);
+				goto unlock;
+			}
+
+			sg[i].length = plen;
+			len -= plen;
+			ctx->used += plen;
+			copied += plen;
+			size -= plen;
+			sgl->cur++;
+		} while (len && sgl->cur < MAX_SGL_ENTS);
+
+		ctx->merge = plen & (PAGE_SIZE - 1);
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+static ssize_t skcipher_sendpage(struct socket *sock, struct page *page,
+				 int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	int err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!size)
+		goto done;
+
+	if (!skcipher_writable(sk)) {
+		err = skcipher_wait_for_wmem(sk, flags);
+		if (err)
+			goto unlock;
+	}
+
+	err = skcipher_alloc_sgl(sk);
+	if (err)
+		goto unlock;
+
+	ctx->merge = 0;
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+	get_page(page);
+	sg_set_page(sgl->sg + sgl->cur, page, size, offset);
+	sgl->cur++;
+	ctx->used += size;
+
+done:
+	ctx->more = flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t ignored, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(
+		&ctx->req));
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	unsigned long iovlen;
+	struct iovec *iov;
+	int err = -EAGAIN;
+	int used;
+	long copied = 0;
+
+	lock_sock(sk);
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			sgl = list_first_entry(&ctx->tsgl,
+					       struct skcipher_sg_list, list);
+			sg = sgl->sg;
+
+			while (!sg->length)
+				sg++;
+
+			used = ctx->used;
+			if (!used) {
+				err = skcipher_wait_for_data(sk, flags);
+				if (err)
+					goto unlock;
+			}
+
+			used = min_t(unsigned long, used, seglen);
+
+			used = af_alg_make_sg(&ctx->rsgl, from, used, 1);
+			err = used;
+			if (err < 0)
+				goto unlock;
+
+			if (ctx->more || used < ctx->used)
+				used -= used % bs;
+
+			err = -EINVAL;
+			if (!used)
+				goto free;
+
+			ablkcipher_request_set_crypt(&ctx->req, sg,
+						     ctx->rsgl.sg, used,
+						     ctx->iv);
+
+			err = af_alg_wait_for_completion(
+				ctx->enc ?
+					crypto_ablkcipher_encrypt(&ctx->req) :
+					crypto_ablkcipher_decrypt(&ctx->req),
+				&ctx->completion);
+
+free:
+			af_alg_free_sg(&ctx->rsgl);
+
+			if (err)
+				goto unlock;
+
+			copied += used;
+			from += used;
+			seglen -= used;
+			skcipher_pull_sgl(sk, used);
+		}
+	}
+
+	err = 0;
+
+unlock:
+	skcipher_wmem_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+
+static unsigned int skcipher_poll(struct file *file, struct socket *sock,
+				  poll_table *wait)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned int mask;
+
+	sock_poll_wait(file, sk_sleep(sk), wait);
+	mask = 0;
+
+	if (ctx->used)
+		mask |= POLLIN | POLLRDNORM;
+
+	if (skcipher_writable(sk))
+		mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
+
+	return mask;
+}
+
+static struct proto_ops algif_skcipher_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.accept		=	sock_no_accept,
+	.setsockopt	=	sock_no_setsockopt,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	skcipher_sendmsg,
+	.sendpage	=	skcipher_sendpage,
+	.recvmsg	=	skcipher_recvmsg,
+	.poll		=	skcipher_poll,
+};
+
+static void *skcipher_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ablkcipher(name, type, mask);
+}
+
+static void skcipher_release(void *private)
+{
+	crypto_free_ablkcipher(private);
+}
+
+static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ablkcipher_setkey(private, key, keylen);
+}
+
+static void skcipher_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+
+	skcipher_free_sgl(sk);
+	sock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int skcipher_accept_parent(void *private, struct sock *sk)
+{
+	struct skcipher_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),
+			       GFP_KERNEL);
+	if (!ctx->iv) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));
+
+	INIT_LIST_HEAD(&ctx->tsgl);
+	ctx->len = len;
+	ctx->used = 0;
+	ctx->more = 0;
+	ctx->merge = 0;
+	ctx->enc = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ablkcipher_request_set_tfm(&ctx->req, private);
+	ablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = skcipher_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_skcipher = {
+	.bind		=	skcipher_bind,
+	.release	=	skcipher_release,
+	.setkey		=	skcipher_setkey,
+	.accept		=	skcipher_accept_parent,
+	.ops		=	&algif_skcipher_ops,
+	.name		=	"skcipher",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_skcipher_init(void)
+{
+	return af_alg_register_type(&algif_type_skcipher);
+}
+
+static void __exit algif_skcipher_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_skcipher);
+	BUG_ON(err);
+}
+
+module_init(algif_skcipher_init);
+module_exit(algif_skcipher_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/core/sock.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/core/sock.c
@@ -157,7 +157,7 @@
   "sk_lock-27"       , "sk_lock-28"          , "sk_lock-AF_CAN"      ,
   "sk_lock-AF_TIPC"  , "sk_lock-AF_BLUETOOTH", "sk_lock-IUCV"        ,
   "sk_lock-AF_RXRPC" , "sk_lock-AF_ISDN"     , "sk_lock-AF_PHONET"   ,
-  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" ,
+  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" , "sk_lock-AF_ALG"      ,
   "sk_lock-AF_MAX"
 };
 static const char *const af_family_slock_key_strings[AF_MAX+1] = {
@@ -173,7 +173,7 @@
   "slock-27"       , "slock-28"          , "slock-AF_CAN"      ,
   "slock-AF_TIPC"  , "slock-AF_BLUETOOTH", "slock-AF_IUCV"     ,
   "slock-AF_RXRPC" , "slock-AF_ISDN"     , "slock-AF_PHONET"   ,
-  "slock-AF_IEEE802154", "slock-AF_CAIF" ,
+  "slock-AF_IEEE802154", "slock-AF_CAIF" , "slock-AF_ALG"      ,
   "slock-AF_MAX"
 };
 static const char *const af_family_clock_key_strings[AF_MAX+1] = {
@@ -189,7 +189,7 @@
   "clock-27"       , "clock-28"          , "clock-AF_CAN"      ,
   "clock-AF_TIPC"  , "clock-AF_BLUETOOTH", "clock-AF_IUCV"     ,
   "clock-AF_RXRPC" , "clock-AF_ISDN"     , "clock-AF_PHONET"   ,
-  "clock-AF_IEEE802154", "clock-AF_CAIF" ,
+  "clock-AF_IEEE802154", "clock-AF_CAIF" , "clock-AF_ALG"      ,
   "clock-AF_MAX"
 };
 
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/crypto/if_alg.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/crypto/if_alg.h
@@ -0,0 +1,92 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _CRYPTO_IF_ALG_H
+#define _CRYPTO_IF_ALG_H
+
+#include <linux/compiler.h>
+#include <linux/completion.h>
+#include <linux/if_alg.h>
+#include <linux/types.h>
+#include <net/sock.h>
+
+#define ALG_MAX_PAGES			16
+
+struct crypto_async_request;
+
+struct alg_sock {
+	/* struct sock must be the first member of struct alg_sock */
+	struct sock sk;
+
+	struct sock *parent;
+
+	const struct af_alg_type *type;
+	void *private;
+};
+
+struct af_alg_completion {
+	struct completion completion;
+	int err;
+};
+
+struct af_alg_control {
+	struct af_alg_iv *iv;
+	int op;
+};
+
+struct af_alg_type {
+	void *(*bind)(const char *name, u32 type, u32 mask);
+	void (*release)(void *private);
+	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
+	int (*accept)(void *private, struct sock *sk);
+
+	struct proto_ops *ops;
+	struct module *owner;
+	char name[14];
+};
+
+struct af_alg_sgl {
+	struct scatterlist sg[ALG_MAX_PAGES];
+	struct page *pages[ALG_MAX_PAGES];
+};
+
+int af_alg_register_type(const struct af_alg_type *type);
+int af_alg_unregister_type(const struct af_alg_type *type);
+
+int af_alg_release(struct socket *sock);
+int af_alg_accept(struct sock *sk, struct socket *newsock);
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write);
+void af_alg_free_sg(struct af_alg_sgl *sgl);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion);
+void af_alg_complete(struct crypto_async_request *req, int err);
+
+static inline struct alg_sock *alg_sk(struct sock *sk)
+{
+	return (struct alg_sock *)sk;
+}
+
+static inline void af_alg_release_parent(struct sock *sk)
+{
+	sock_put(alg_sk(sk)->parent);
+}
+
+static inline void af_alg_init_completion(struct af_alg_completion *completion)
+{
+	init_completion(&completion->completion);
+}
+
+#endif	/* _CRYPTO_IF_ALG_H */
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/crypto/scatterwalk.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/crypto/scatterwalk.h
@@ -68,6 +68,21 @@
 	return (++sg)->length ? sg : (void *)sg_page(sg);
 }
 
+static inline void scatterwalk_crypto_chain(struct scatterlist *head,
+					    struct scatterlist *sg,
+					    int chain, int num)
+{
+	if (chain) {
+		head->length += sg->length;
+		sg = scatterwalk_sg_next(sg);
+	}
+
+	if (sg)
+		scatterwalk_sg_chain(head, num, sg);
+	else
+		sg_mark_end(head);
+}
+
 static inline unsigned long scatterwalk_samebuf(struct scatter_walk *walk_in,
 						struct scatter_walk *walk_out)
 {
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/if_alg.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/if_alg.h
@@ -0,0 +1,40 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _LINUX_IF_ALG_H
+#define _LINUX_IF_ALG_H
+
+#include <linux/types.h>
+
+struct sockaddr_alg {
+	__u16	salg_family;
+	__u8	salg_type[14];
+	__u32	salg_feat;
+	__u32	salg_mask;
+	__u8	salg_name[64];
+};
+
+struct af_alg_iv {
+	__u32	ivlen;
+	__u8	iv[0];
+};
+
+/* Socket options */
+#define ALG_SET_KEY			1
+#define ALG_SET_IV			2
+#define ALG_SET_OP			3
+
+/* Operations */
+#define ALG_OP_DECRYPT			0
+#define ALG_OP_ENCRYPT			1
+
+#endif	/* _LINUX_IF_ALG_H */
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/socket.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/socket.h
@@ -193,7 +193,8 @@
 #define AF_PHONET	35	/* Phonet sockets		*/
 #define AF_IEEE802154	36	/* IEEE802154 sockets		*/
 #define AF_CAIF		37	/* CAIF sockets			*/
-#define AF_MAX		38	/* For now.. */
+#define AF_ALG		38	/* Algorithm sockets		*/
+#define AF_MAX		39	/* For now.. */
 
 /* Protocol families, same as address families. */
 #define PF_UNSPEC	AF_UNSPEC
@@ -234,6 +235,7 @@
 #define PF_PHONET	AF_PHONET
 #define PF_IEEE802154	AF_IEEE802154
 #define PF_CAIF		AF_CAIF
+#define PF_ALG		AF_ALG
 #define PF_MAX		AF_MAX
 
 /* Maximum queue length specifiable by listen.  */
@@ -310,6 +312,7 @@
 #define SOL_RDS		276
 #define SOL_IUCV	277
 #define SOL_CAIF	278
+#define SOL_ALG		279
 
 /* IPX options */
 #define IPX_TYPE	1
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/random.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/random.h
@@ -1,3 +1,8 @@
+///////////////////////////////////////////////////////////////////////////////
+// Entropy backport from Linux 3.16.43 to AsusWrt
+//
+// SOURCE: Linux 3.16.43, include/linux/random.h
+///////////////////////////////////////////////////////////////////////////////
 /*
  * include/linux/random.h
  *
@@ -11,6 +16,411 @@
 #include <linux/ioctl.h>
 #include <linux/irqnr.h>
 
+///////////////////////////////////////////////////////////////////////////////
+// random_get_entropy
+//
+// SOURCE: Linux 3.16.43, include/linux/timex.h
+//
+#ifndef random_get_entropy
+/*
+ * The random_get_entropy() function is used by the /dev/random driver
+ * in order to extract entropy via the relative unpredictability of
+ * when an interrupt takes places versus a high speed, fine-grained
+ * timing source or cycle counter.  Since it will be occurred on every
+ * single interrupt, it must have a very low cost/overhead.
+ *
+ * By default we use get_cycles() for this purpose, but individual
+ * architectures may override this in their asm/timex.h header file.
+ */
+#define random_get_entropy()	get_cycles()
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+// memzero_explicit
+//
+// SOURCE: AsusWrt, release/src-rt-6.x.4708/linux/linux-2.6.36/arch/arm/include/asm/string.h
+//
+#ifndef memzero_explicit
+#define memzero_explicit(p,n)						\
+	({								\
+	 	void *__p = (p); size_t __n = n;			\
+		if ((__n) != 0) {					\
+				__memzero((__p),(__n));			\
+		}							\
+		(__p);							\
+	})
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+// SHA1 transform
+//
+// SOURCE: Linux 3.16.43, lib/sha1.c
+//
+#include <linux/bitops.h>
+#include <linux/cryptohash.h>
+#include <asm/unaligned.h>
+/*
+ * If you have 32 registers or more, the compiler can (and should)
+ * try to change the array[] accesses into registers. However, on
+ * machines with less than ~25 registers, that won't really work,
+ * and at least gcc will make an unholy mess of it.
+ *
+ * So to avoid that mess which just slows things down, we force
+ * the stores to memory to actually happen (we might be better off
+ * with a 'W(t)=(val);asm("":"+m" (W(t))' there instead, as
+ * suggested by Artur Skawina - that will also make gcc unable to
+ * try to do the silly "optimize away loads" part because it won't
+ * see what the value will be).
+ *
+ * Ben Herrenschmidt reports that on PPC, the C version comes close
+ * to the optimized asm with this (ie on PPC you don't want that
+ * 'volatile', since there are lots of registers).
+ *
+ * On ARM we get the best code generation by forcing a full memory barrier
+ * between each SHA_ROUND, otherwise gcc happily get wild with spilling and
+ * the stack frame size simply explode and performance goes down the drain.
+ */
+
+#ifdef CONFIG_X86
+  #define setW(x, val) (*(volatile __u32 *)&W(x) = (val))
+#elif defined(CONFIG_ARM)
+  #define setW(x, val) do { W(x) = (val); __asm__("":::"memory"); } while (0)
+#else
+  #define setW(x, val) (W(x) = (val))
+#endif
+
+/* This "rolls" over the 512-bit array */
+#define W(x) (array[(x)&15])
+
+/*
+ * Where do we get the source from? The first 16 iterations get it from
+ * the input data, the next mix it from the 512-bit array.
+ */
+#define SHA_SRC(t) get_unaligned_be32((__u32 *)data + t)
+#define SHA_MIX(t) rol32(W(t+13) ^ W(t+8) ^ W(t+2) ^ W(t), 1)
+
+#define SHA_ROUND(t, input, fn, constant, A, B, C, D, E) do { \
+	__u32 TEMP = input(t); setW(t, TEMP); \
+	E += TEMP + rol32(A,5) + (fn) + (constant); \
+	B = ror32(B, 2); } while (0)
+
+#define T_0_15(t, A, B, C, D, E)  SHA_ROUND(t, SHA_SRC, (((C^D)&B)^D) , 0x5a827999, A, B, C, D, E )
+#define T_16_19(t, A, B, C, D, E) SHA_ROUND(t, SHA_MIX, (((C^D)&B)^D) , 0x5a827999, A, B, C, D, E )
+#define T_20_39(t, A, B, C, D, E) SHA_ROUND(t, SHA_MIX, (B^C^D) , 0x6ed9eba1, A, B, C, D, E )
+#define T_40_59(t, A, B, C, D, E) SHA_ROUND(t, SHA_MIX, ((B&C)+(D&(B^C))) , 0x8f1bbcdc, A, B, C, D, E )
+#define T_60_79(t, A, B, C, D, E) SHA_ROUND(t, SHA_MIX, (B^C^D) ,  0xca62c1d6, A, B, C, D, E )
+
+/**
+ * sha_transform_inline - single block SHA1 transform
+ *
+ * @digest: 160 bit digest to update
+ * @data:   512 bits of data to hash
+ * @array:  16 words of workspace (see note)
+ *
+ * This function generates a SHA1 digest for a single 512-bit block.
+ * Be warned, it does not handle padding and message digest, do not
+ * confuse it with the full FIPS 180-1 digest algorithm for variable
+ * length messages.
+ *
+ * Note: If the hash is security sensitive, the caller should be sure
+ * to clear the workspace. This is left to the caller to avoid
+ * unnecessary clears between chained hashing operations.
+ */
+static inline void sha_transform_inline(__u32 *digest, const char *data, __u32 *array)
+{
+	__u32 A, B, C, D, E;
+
+	A = digest[0];
+	B = digest[1];
+	C = digest[2];
+	D = digest[3];
+	E = digest[4];
+
+	/* Round 1 - iterations 0-16 take their input from 'data' */
+	T_0_15( 0, A, B, C, D, E);
+	T_0_15( 1, E, A, B, C, D);
+	T_0_15( 2, D, E, A, B, C);
+	T_0_15( 3, C, D, E, A, B);
+	T_0_15( 4, B, C, D, E, A);
+	T_0_15( 5, A, B, C, D, E);
+	T_0_15( 6, E, A, B, C, D);
+	T_0_15( 7, D, E, A, B, C);
+	T_0_15( 8, C, D, E, A, B);
+	T_0_15( 9, B, C, D, E, A);
+	T_0_15(10, A, B, C, D, E);
+	T_0_15(11, E, A, B, C, D);
+	T_0_15(12, D, E, A, B, C);
+	T_0_15(13, C, D, E, A, B);
+	T_0_15(14, B, C, D, E, A);
+	T_0_15(15, A, B, C, D, E);
+
+	/* Round 1 - tail. Input from 512-bit mixing array */
+	T_16_19(16, E, A, B, C, D);
+	T_16_19(17, D, E, A, B, C);
+	T_16_19(18, C, D, E, A, B);
+	T_16_19(19, B, C, D, E, A);
+
+	/* Round 2 */
+	T_20_39(20, A, B, C, D, E);
+	T_20_39(21, E, A, B, C, D);
+	T_20_39(22, D, E, A, B, C);
+	T_20_39(23, C, D, E, A, B);
+	T_20_39(24, B, C, D, E, A);
+	T_20_39(25, A, B, C, D, E);
+	T_20_39(26, E, A, B, C, D);
+	T_20_39(27, D, E, A, B, C);
+	T_20_39(28, C, D, E, A, B);
+	T_20_39(29, B, C, D, E, A);
+	T_20_39(30, A, B, C, D, E);
+	T_20_39(31, E, A, B, C, D);
+	T_20_39(32, D, E, A, B, C);
+	T_20_39(33, C, D, E, A, B);
+	T_20_39(34, B, C, D, E, A);
+	T_20_39(35, A, B, C, D, E);
+	T_20_39(36, E, A, B, C, D);
+	T_20_39(37, D, E, A, B, C);
+	T_20_39(38, C, D, E, A, B);
+	T_20_39(39, B, C, D, E, A);
+
+	/* Round 3 */
+	T_40_59(40, A, B, C, D, E);
+	T_40_59(41, E, A, B, C, D);
+	T_40_59(42, D, E, A, B, C);
+	T_40_59(43, C, D, E, A, B);
+	T_40_59(44, B, C, D, E, A);
+	T_40_59(45, A, B, C, D, E);
+	T_40_59(46, E, A, B, C, D);
+	T_40_59(47, D, E, A, B, C);
+	T_40_59(48, C, D, E, A, B);
+	T_40_59(49, B, C, D, E, A);
+	T_40_59(50, A, B, C, D, E);
+	T_40_59(51, E, A, B, C, D);
+	T_40_59(52, D, E, A, B, C);
+	T_40_59(53, C, D, E, A, B);
+	T_40_59(54, B, C, D, E, A);
+	T_40_59(55, A, B, C, D, E);
+	T_40_59(56, E, A, B, C, D);
+	T_40_59(57, D, E, A, B, C);
+	T_40_59(58, C, D, E, A, B);
+	T_40_59(59, B, C, D, E, A);
+
+	/* Round 4 */
+	T_60_79(60, A, B, C, D, E);
+	T_60_79(61, E, A, B, C, D);
+	T_60_79(62, D, E, A, B, C);
+	T_60_79(63, C, D, E, A, B);
+	T_60_79(64, B, C, D, E, A);
+	T_60_79(65, A, B, C, D, E);
+	T_60_79(66, E, A, B, C, D);
+	T_60_79(67, D, E, A, B, C);
+	T_60_79(68, C, D, E, A, B);
+	T_60_79(69, B, C, D, E, A);
+	T_60_79(70, A, B, C, D, E);
+	T_60_79(71, E, A, B, C, D);
+	T_60_79(72, D, E, A, B, C);
+	T_60_79(73, C, D, E, A, B);
+	T_60_79(74, B, C, D, E, A);
+	T_60_79(75, A, B, C, D, E);
+	T_60_79(76, E, A, B, C, D);
+	T_60_79(77, D, E, A, B, C);
+	T_60_79(78, C, D, E, A, B);
+	T_60_79(79, B, C, D, E, A);
+
+	digest[0] += A;
+	digest[1] += B;
+	digest[2] += C;
+	digest[3] += D;
+	digest[4] += E;
+}
+
+/**
+ * sha_init - initialize the vectors for a SHA1 digest
+ * @buf: vector to initialize
+ */
+static inline void sha_init_inline(__u32 *buf)
+{
+	buf[0] = 0x67452301;
+	buf[1] = 0xefcdab89;
+	buf[2] = 0x98badcfe;
+	buf[3] = 0x10325476;
+	buf[4] = 0xc3d2e1f0;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// MD4 transform
+//
+// SOURCE: Linux 3.16.43, lib/halfmd4.c
+//
+/* F, G and H are basic MD4 functions: selection, majority, parity */
+#define F(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))
+#define G(x, y, z) (((x) & (y)) + (((x) ^ (y)) & (z)))
+#define H(x, y, z) ((x) ^ (y) ^ (z))
+
+/*
+ * The generic round function.  The application is so specific that
+ * we don't bother protecting all the arguments with parens, as is generally
+ * good macro practice, in favor of extra legibility.
+ * Rotation is separate from addition to prevent recomputation
+ */
+#define ROUND(f, a, b, c, d, x, s)	\
+	(a += f(b, c, d) + x, a = (a << s) | (a >> (32 - s)))
+#define K1 0
+#define K2 013240474631UL
+#define K3 015666365641UL
+
+/*
+ * Basic cut-down MD4 transform.  Returns only 32 bits of result.
+ */
+static inline __u32 half_md4_transform_inline(__u32 buf[4], __u32 const in[8])
+{
+	__u32 a = buf[0], b = buf[1], c = buf[2], d = buf[3];
+
+	/* Round 1 */
+	ROUND(F, a, b, c, d, in[0] + K1,  3);
+	ROUND(F, d, a, b, c, in[1] + K1,  7);
+	ROUND(F, c, d, a, b, in[2] + K1, 11);
+	ROUND(F, b, c, d, a, in[3] + K1, 19);
+	ROUND(F, a, b, c, d, in[4] + K1,  3);
+	ROUND(F, d, a, b, c, in[5] + K1,  7);
+	ROUND(F, c, d, a, b, in[6] + K1, 11);
+	ROUND(F, b, c, d, a, in[7] + K1, 19);
+
+	/* Round 2 */
+	ROUND(G, a, b, c, d, in[1] + K2,  3);
+	ROUND(G, d, a, b, c, in[3] + K2,  5);
+	ROUND(G, c, d, a, b, in[5] + K2,  9);
+	ROUND(G, b, c, d, a, in[7] + K2, 13);
+	ROUND(G, a, b, c, d, in[0] + K2,  3);
+	ROUND(G, d, a, b, c, in[2] + K2,  5);
+	ROUND(G, c, d, a, b, in[4] + K2,  9);
+	ROUND(G, b, c, d, a, in[6] + K2, 13);
+
+	/* Round 3 */
+	ROUND(H, a, b, c, d, in[3] + K3,  3);
+	ROUND(H, d, a, b, c, in[7] + K3,  9);
+	ROUND(H, c, d, a, b, in[2] + K3, 11);
+	ROUND(H, b, c, d, a, in[6] + K3, 15);
+	ROUND(H, a, b, c, d, in[1] + K3,  3);
+	ROUND(H, d, a, b, c, in[5] + K3,  9);
+	ROUND(H, c, d, a, b, in[0] + K3, 11);
+	ROUND(H, b, c, d, a, in[4] + K3, 15);
+
+	buf[0] += a;
+	buf[1] += b;
+	buf[2] += c;
+	buf[3] += d;
+
+	return buf[1]; /* "most hashed" word */
+}
+#undef ROUND
+#undef F
+#undef G
+#undef H
+#undef K1
+#undef K2
+#undef K3
+
+///////////////////////////////////////////////////////////////////////////////
+// MD5 transform
+//
+// SOURCE: Linux 3.16.43, lib/md5.c
+//
+#define MD5_DIGEST_WORDS 4
+#define MD5_MESSAGE_BYTES 64
+#define F1(x, y, z)	(z ^ (x & (y ^ z)))
+#define F2(x, y, z)	F1(z, x, y)
+#define F3(x, y, z)	(x ^ y ^ z)
+#define F4(x, y, z)	(y ^ (x | ~z))
+
+#define MD5STEP(f, w, x, y, z, in, s) \
+	(w += f(x, y, z) + in, w = (w<<s | w>>(32-s)) + x)
+
+static inline void md5_transform_inline(__u32 *hash, __u32 const *in)
+{
+	u32 a, b, c, d;
+
+	a = hash[0];
+	b = hash[1];
+	c = hash[2];
+	d = hash[3];
+
+	MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
+	MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
+	MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
+	MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
+	MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
+	MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
+	MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
+	MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
+	MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
+	MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
+	MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
+	MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
+	MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
+	MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
+	MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
+	MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
+
+	MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
+	MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
+	MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
+	MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
+	MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
+	MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
+	MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
+	MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
+	MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
+	MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
+	MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
+	MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
+	MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
+	MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
+	MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
+	MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
+
+	MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
+	MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
+	MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
+	MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
+	MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
+	MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
+	MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
+	MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
+	MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
+	MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
+	MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
+	MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
+	MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
+	MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
+	MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
+	MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
+
+	MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
+	MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
+	MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
+	MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
+	MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
+	MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
+	MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
+	MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
+	MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
+	MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
+	MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
+	MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
+	MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
+	MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
+	MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
+	MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
+
+	hash[0] += a;
+	hash[1] += b;
+	hash[2] += c;
+	hash[3] += d;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
 /* ioctl()'s for the random number generator */
 
 /* Get the entropy count. */
@@ -41,21 +451,21 @@
 };
 
 struct rnd_state {
-	__u32 s1, s2, s3;
+	__u32 s1, s2, s3, s4;
 };
 
 /* Exported functions */
 
 #ifdef __KERNEL__
 
-extern void rand_initialize_irq(int irq);
-
+extern void add_device_randomness(const void *, unsigned int);
 extern void add_input_randomness(unsigned int type, unsigned int code,
 				 unsigned int value);
-extern void add_interrupt_randomness(int irq);
+extern void add_interrupt_randomness(int irq, int irq_flags);
 
 extern void get_random_bytes(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
+extern int random_int_secret_init(void);
 
 extern __u32 secure_ip_id(__be32 daddr);
 extern u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport);
@@ -79,9 +489,32 @@
 void srandom32(u32 seed);
 
 u32 prandom_u32(void);
+void prandom_bytes(void *buf, int nbytes);
 
 u32 prandom32(struct rnd_state *);
 
+void prandom_reseed_late(void);
+
+u32 prandom_u32_state(struct rnd_state *state);
+void prandom_bytes_state(struct rnd_state *state, void *buf, int nbytes);
+
+/**
+ * prandom_u32_max - returns a pseudo-random number in interval [0, ep_ro)
+ * @ep_ro: right open interval endpoint
+ *
+ * Returns a pseudo-random number that is in interval [0, ep_ro). Note
+ * that the result depends on PRNG being well distributed in [0, ~0U]
+ * u32 space. Here we use maximally equidistributed combined Tausworthe
+ * generator, that is, prandom_u32(). This is useful when requesting a
+ * random index of an array containing ep_ro elements, for example.
+ *
+ * Returns: pseudo-random number in interval [0, ep_ro)
+ */
+static inline u32 prandom_u32_max(u32 ep_ro)
+{
+	return (u32)(((u64) prandom_u32() * ep_ro) >> 32);
+}
+
 /*
  * Handle minimum values for seeds
  */
@@ -99,9 +532,45 @@
 {
 	u32 i = (seed >> 32) ^ (seed << 10) ^ seed;
 
-	state->s1 = __seed(i, 1);
-	state->s2 = __seed(i, 7);
-	state->s3 = __seed(i, 15);
+	state->s1 = __seed(i,   2U);
+	state->s2 = __seed(i,   8U);
+	state->s3 = __seed(i,  16U);
+	state->s4 = __seed(i, 128U);
+}
+
+#ifdef CONFIG_ARCH_RANDOM
+# include <asm/archrandom.h>
+#else
+static inline int arch_get_random_long(unsigned long *v)
+{
+	return 0;
+}
+static inline int arch_get_random_int(unsigned int *v)
+{
+	return 0;
+}
+static inline int arch_has_random(void)
+{
+	return 0;
+}
+static inline int arch_get_random_seed_long(unsigned long *v)
+{
+	return 0;
+}
+static inline int arch_get_random_seed_int(unsigned int *v)
+{
+	return 0;
+}
+static inline int arch_has_random_seed(void)
+{
+	return 0;
+}
+#endif
+
+/* Pseudo random number generator from numerical recipes. */
+static inline u32 next_pseudo_random32(u32 seed)
+{
+	return seed * 1664525 + 1013904223;
 }
 
 #endif /* __KERNEL___ */
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/char/random.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/char/random.c
@@ -1,3 +1,8 @@
+///////////////////////////////////////////////////////////////////////////////
+// Entropy backport from Linux 3.16.43 to AsusWrt
+//
+// SOURCE: Linux 3.16.43, drivers/char/random.c
+///////////////////////////////////////////////////////////////////////////////
 /*
  * random.c -- A strong random number generator
  *
@@ -125,20 +130,32 @@
  * The current exported interfaces for gathering environmental noise
  * from the devices are:
  *
+ *	void add_device_randomness(const void *buf, unsigned int size);
  * 	void add_input_randomness(unsigned int type, unsigned int code,
  *                                unsigned int value);
- * 	void add_interrupt_randomness(int irq);
+ *	void add_interrupt_randomness(int irq, int irq_flags);
+ * 	void add_disk_randomness(struct gendisk *disk);
+ *
+ * add_device_randomness() is for adding data to the random pool that
+ * is likely to differ between two devices (or possibly even per boot).
+ * This would be things like MAC addresses or serial numbers, or the
+ * read-out of the RTC. This does *not* add any actual entropy to the
+ * pool, but it initializes the pool to different values for devices
+ * that might otherwise be identical and have very little entropy
+ * available to them (particularly common in the embedded world).
  *
  * add_input_randomness() uses the input layer interrupt timing, as well as
  * the event type information from the hardware.
  *
- * add_interrupt_randomness() uses the inter-interrupt timing as random
- * inputs to the entropy pool.  Note that not all interrupts are good
- * sources of randomness!  For example, the timer interrupts is not a
- * good choice, because the periodicity of the interrupts is too
- * regular, and hence predictable to an attacker.  Disk interrupts are
- * a better measure, since the timing of the disk interrupts are more
- * unpredictable.
+ * add_interrupt_randomness() uses the interrupt timing as random
+ * inputs to the entropy pool. Using the cycle counters and the irq source
+ * as inputs, it feeds the randomness roughly once a second.
+ *
+ * add_disk_randomness() uses what amounts to the seek time of block
+ * layer request events, on a per-disk_devt basis, as input to the
+ * entropy pool. Note that high-speed solid state drives with very low
+ * seek times do not make for good sources of entropy, as their seek
+ * times are usually fairly consistent.
  *
  * All of these routines try to estimate how many bits of randomness a
  * particular randomness source.  They do this by keeping track of the
@@ -241,109 +258,148 @@
 #include <linux/percpu.h>
 #include <linux/cryptohash.h>
 #include <linux/fips.h>
-
-#ifdef CONFIG_GENERIC_HARDIRQS
-# include <linux/irq.h>
-#endif
+#include <linux/ptrace.h>
+#include <linux/kmemcheck.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
 
 #include <asm/processor.h>
 #include <asm/uaccess.h>
 #include <asm/irq.h>
+#include <asm/irq_regs.h>
 #include <asm/io.h>
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/random.h>
+
 /*
  * Configuration information
  */
-#define INPUT_POOL_WORDS 128
-#define OUTPUT_POOL_WORDS 32
-#define SEC_XFER_SIZE 512
-#define EXTRACT_SIZE 10
+#define INPUT_POOL_SHIFT	12
+#define INPUT_POOL_WORDS	(1 << (INPUT_POOL_SHIFT-5))
+#define OUTPUT_POOL_SHIFT	10
+#define OUTPUT_POOL_WORDS	(1 << (OUTPUT_POOL_SHIFT-5))
+#define SEC_XFER_SIZE		512
+#define EXTRACT_SIZE		10
+
+#define DEBUG_RANDOM_BOOT 0
+
+#define LONGS(x) (((x) + sizeof(unsigned long) - 1)/sizeof(unsigned long))
+
+/*
+ * To allow fractional bits to be tracked, the entropy_count field is
+ * denominated in units of 1/8th bits.
+ *
+ * 2*(ENTROPY_SHIFT + log2(poolbits)) must <= 31, or the multiply in
+ * credit_entropy_bits() needs to be 64 bits wide.
+ */
+#define ENTROPY_SHIFT 3
+#define ENTROPY_BITS(r) ((r)->entropy_count >> ENTROPY_SHIFT)
 
 /*
  * The minimum number of bits of entropy before we wake up a read on
  * /dev/random.  Should be enough to do a significant reseed.
  */
-static int random_read_wakeup_thresh = 64;
+static int random_read_wakeup_bits = 64;
 
 /*
  * If the entropy count falls under this number of bits, then we
  * should wake up processes which are selecting or polling on write
  * access to /dev/random.
  */
-static int random_write_wakeup_thresh = 128;
-
-/*
- * When the input pool goes over trickle_thresh, start dropping most
- * samples to avoid wasting CPU time and reduce lock contention.
- */
-
-static int trickle_thresh __read_mostly = INPUT_POOL_WORDS * 28;
-
-static DEFINE_PER_CPU(int, trickle_count);
+static int random_write_wakeup_bits = 28 * OUTPUT_POOL_WORDS;
 
 /*
- * A pool of size .poolwords is stirred with a primitive polynomial
- * of degree .poolwords over GF(2).  The taps for various sizes are
- * defined below.  They are chosen to be evenly spaced (minimum RMS
- * distance from evenly spaced; the numbers in the comments are a
- * scaled squared error sum) except for the last tap, which is 1 to
- * get the twisting happening as fast as possible.
+ * The minimum number of seconds between urandom pool reseeding.  We
+ * do this to limit the amount of entropy that can be drained from the
+ * input pool even if there are heavy demands on /dev/urandom.
  */
-static struct poolinfo {
-	int poolwords;
-	int tap1, tap2, tap3, tap4, tap5;
-} poolinfo_table[] = {
-	/* x^128 + x^103 + x^76 + x^51 +x^25 + x + 1 -- 105 */
-	{ 128,	103,	76,	51,	25,	1 },
-	/* x^32 + x^26 + x^20 + x^14 + x^7 + x + 1 -- 15 */
-	{ 32,	26,	20,	14,	7,	1 },
-};
-
-#define POOLBITS	poolwords*32
-#define POOLBYTES	poolwords*4
+static int random_min_urandom_seed = 60;
 
 /*
- * For the purposes of better mixing, we use the CRC-32 polynomial as
- * well to make a twisted Generalized Feedback Shift Reigster
+ * Originally, we used a primitive polynomial of degree .poolwords
+ * over GF(2).  The taps for various sizes are defined below.  They
+ * were chosen to be evenly spaced except for the last tap, which is 1
+ * to get the twisting happening as fast as possible.
  *
- * (See M. Matsumoto & Y. Kurita, 1992.  Twisted GFSR generators.  ACM
- * Transactions on Modeling and Computer Simulation 2(3):179-194.
- * Also see M. Matsumoto & Y. Kurita, 1994.  Twisted GFSR generators
- * II.  ACM Transactions on Mdeling and Computer Simulation 4:254-266)
+ * For the purposes of better mixing, we use the CRC-32 polynomial as
+ * well to make a (modified) twisted Generalized Feedback Shift
+ * Register.  (See M. Matsumoto & Y. Kurita, 1992.  Twisted GFSR
+ * generators.  ACM Transactions on Modeling and Computer Simulation
+ * 2(3):179-194.  Also see M. Matsumoto & Y. Kurita, 1994.  Twisted
+ * GFSR generators II.  ACM Transactions on Modeling and Computer
+ * Simulation 4:254-266)
  *
  * Thanks to Colin Plumb for suggesting this.
  *
- * We have not analyzed the resultant polynomial to prove it primitive;
- * in fact it almost certainly isn't.  Nonetheless, the irreducible factors
- * of a random large-degree polynomial over GF(2) are more than large enough
- * that periodicity is not a concern.
- *
- * The input hash is much less sensitive than the output hash.  All
- * that we want of it is that it be a good non-cryptographic hash;
- * i.e. it not produce collisions when fed "random" data of the sort
- * we expect to see.  As long as the pool state differs for different
- * inputs, we have preserved the input entropy and done a good job.
- * The fact that an intelligent attacker can construct inputs that
- * will produce controlled alterations to the pool's state is not
- * important because we don't consider such inputs to contribute any
- * randomness.  The only property we need with respect to them is that
- * the attacker can't increase his/her knowledge of the pool's state.
- * Since all additions are reversible (knowing the final state and the
- * input, you can reconstruct the initial state), if an attacker has
- * any uncertainty about the initial state, he/she can only shuffle
- * that uncertainty about, but never cause any collisions (which would
+ * The mixing operation is much less sensitive than the output hash,
+ * where we use SHA-1.  All that we want of mixing operation is that
+ * it be a good non-cryptographic hash; i.e. it not produce collisions
+ * when fed "random" data of the sort we expect to see.  As long as
+ * the pool state differs for different inputs, we have preserved the
+ * input entropy and done a good job.  The fact that an intelligent
+ * attacker can construct inputs that will produce controlled
+ * alterations to the pool's state is not important because we don't
+ * consider such inputs to contribute any randomness.  The only
+ * property we need with respect to them is that the attacker can't
+ * increase his/her knowledge of the pool's state.  Since all
+ * additions are reversible (knowing the final state and the input,
+ * you can reconstruct the initial state), if an attacker has any
+ * uncertainty about the initial state, he/she can only shuffle that
+ * uncertainty about, but never cause any collisions (which would
  * decrease the uncertainty).
  *
- * The chosen system lets the state of the pool be (essentially) the input
- * modulo the generator polymnomial.  Now, for random primitive polynomials,
- * this is a universal class of hash functions, meaning that the chance
- * of a collision is limited by the attacker's knowledge of the generator
- * polynomail, so if it is chosen at random, an attacker can never force
- * a collision.  Here, we use a fixed polynomial, but we *can* assume that
- * ###--> it is unknown to the processes generating the input entropy. <-###
- * Because of this important property, this is a good, collision-resistant
- * hash; hash collisions will occur no more often than chance.
+ * Our mixing functions were analyzed by Lacharme, Roeck, Strubel, and
+ * Videau in their paper, "The Linux Pseudorandom Number Generator
+ * Revisited" (see: http://eprint.iacr.org/2012/251.pdf).  In their
+ * paper, they point out that we are not using a true Twisted GFSR,
+ * since Matsumoto & Kurita used a trinomial feedback polynomial (that
+ * is, with only three taps, instead of the six that we are using).
+ * As a result, the resulting polynomial is neither primitive nor
+ * irreducible, and hence does not have a maximal period over
+ * GF(2**32).  They suggest a slight change to the generator
+ * polynomial which improves the resulting TGFSR polynomial to be
+ * irreducible, which we have made here.
  */
+static struct poolinfo {
+	int poolbitshift, poolwords, poolbytes, poolbits, poolfracbits;
+#define S(x) ilog2(x)+5, (x), (x)*4, (x)*32, (x) << (ENTROPY_SHIFT+5)
+	int tap1, tap2, tap3, tap4, tap5;
+} poolinfo_table[] = {
+	/* was: x^128 + x^103 + x^76 + x^51 +x^25 + x + 1 */
+	/* x^128 + x^104 + x^76 + x^51 +x^25 + x + 1 */
+	{ S(128),	104,	76,	51,	25,	1 },
+	/* was: x^32 + x^26 + x^20 + x^14 + x^7 + x + 1 */
+	/* x^32 + x^26 + x^19 + x^14 + x^7 + x + 1 */
+	{ S(32),	26,	19,	14,	7,	1 },
+#if 0
+	/* x^2048 + x^1638 + x^1231 + x^819 + x^411 + x + 1  -- 115 */
+	{ S(2048),	1638,	1231,	819,	411,	1 },
+
+	/* x^1024 + x^817 + x^615 + x^412 + x^204 + x + 1 -- 290 */
+	{ S(1024),	817,	615,	412,	204,	1 },
+
+	/* x^1024 + x^819 + x^616 + x^410 + x^207 + x^2 + 1 -- 115 */
+	{ S(1024),	819,	616,	410,	207,	2 },
+
+	/* x^512 + x^411 + x^308 + x^208 + x^104 + x + 1 -- 225 */
+	{ S(512),	411,	308,	208,	104,	1 },
+
+	/* x^512 + x^409 + x^307 + x^206 + x^102 + x^2 + 1 -- 95 */
+	{ S(512),	409,	307,	206,	102,	2 },
+	/* x^512 + x^409 + x^309 + x^205 + x^103 + x^2 + 1 -- 95 */
+	{ S(512),	409,	309,	205,	103,	2 },
+
+	/* x^256 + x^205 + x^155 + x^101 + x^52 + x + 1 -- 125 */
+	{ S(256),	205,	155,	101,	52,	1 },
+
+	/* x^128 + x^103 + x^78 + x^51 + x^27 + x^2 + 1 -- 70 */
+	{ S(128),	103,	78,	51,	27,	2 },
+
+	/* x^64 + x^52 + x^39 + x^26 + x^14 + x + 1 -- 15 */
+	{ S(64),	52,	39,	26,	14,	1 },
+#endif
+};
 
 /*
  * Static global variables
@@ -352,8 +408,6 @@
 static DECLARE_WAIT_QUEUE_HEAD(random_write_wait);
 static struct fasync_struct *fasync;
 
-#define DEBUG_ENT(fmt, arg...) do {} while (0)
-
 /**********************************************************************
  *
  * OS independent entropy store.   Here are the functions which handle
@@ -364,20 +418,26 @@
 struct entropy_store;
 struct entropy_store {
 	/* read-only data: */
-	struct poolinfo *poolinfo;
+	const struct poolinfo *poolinfo;
 	__u32 *pool;
 	const char *name;
 	struct entropy_store *pull;
-	int limit;
+	struct work_struct push_work;
 
 	/* read-write data: */
+	unsigned long last_pulled;
 	spinlock_t lock;
-	unsigned add_ptr;
+	unsigned short add_ptr;
+	unsigned short input_rotate;
 	int entropy_count;
-	int input_rotate;
+	int entropy_total;
+	unsigned int initialized:1;
+	unsigned int limit:1;
+	unsigned int last_data_init:1;
 	__u8 last_data[EXTRACT_SIZE];
 };
 
+static void push_to_pool(struct work_struct *work);
 static __u32 input_pool_data[INPUT_POOL_WORDS];
 static __u32 blocking_pool_data[OUTPUT_POOL_WORDS];
 static __u32 nonblocking_pool_data[OUTPUT_POOL_WORDS];
@@ -386,7 +446,7 @@
 	.poolinfo = &poolinfo_table[0],
 	.name = "input",
 	.limit = 1,
-	.lock = __SPIN_LOCK_UNLOCKED(&input_pool.lock),
+	.lock = __SPIN_LOCK_UNLOCKED(input_pool.lock),
 	.pool = input_pool_data
 };
 
@@ -395,18 +455,26 @@
 	.name = "blocking",
 	.limit = 1,
 	.pull = &input_pool,
-	.lock = __SPIN_LOCK_UNLOCKED(&blocking_pool.lock),
-	.pool = blocking_pool_data
+	.lock = __SPIN_LOCK_UNLOCKED(blocking_pool.lock),
+	.pool = blocking_pool_data,
+	.push_work = __WORK_INITIALIZER(blocking_pool.push_work,
+					push_to_pool),
 };
 
 static struct entropy_store nonblocking_pool = {
 	.poolinfo = &poolinfo_table[1],
 	.name = "nonblocking",
 	.pull = &input_pool,
-	.lock = __SPIN_LOCK_UNLOCKED(&nonblocking_pool.lock),
-	.pool = nonblocking_pool_data
+	.lock = __SPIN_LOCK_UNLOCKED(nonblocking_pool.lock),
+	.pool = nonblocking_pool_data,
+	.push_work = __WORK_INITIALIZER(nonblocking_pool.push_work,
+					push_to_pool),
 };
 
+static __u32 const twist_table[8] = {
+	0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
+	0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };
+
 /*
  * This function adds bytes into the entropy "pool".  It does not
  * update the entropy estimate.  The caller should call
@@ -417,33 +485,28 @@
  * it's cheap to do so and helps slightly in the expected case where
  * the entropy is concentrated in the low-order bits.
  */
-static void mix_pool_bytes_extract(struct entropy_store *r, const void *in,
-				   int nbytes, __u8 out[64])
+static void _mix_pool_bytes(struct entropy_store *r, const void *in,
+			    int nbytes, __u8 out[64])
 {
-	static __u32 const twist_table[8] = {
-		0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
-		0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };
 	unsigned long i, j, tap1, tap2, tap3, tap4, tap5;
 	int input_rotate;
 	int wordmask = r->poolinfo->poolwords - 1;
 	const char *bytes = in;
 	__u32 w;
-	unsigned long flags;
 
-	/* Taps are constant, so we can load them without holding r->lock.  */
 	tap1 = r->poolinfo->tap1;
 	tap2 = r->poolinfo->tap2;
 	tap3 = r->poolinfo->tap3;
 	tap4 = r->poolinfo->tap4;
 	tap5 = r->poolinfo->tap5;
 
-	spin_lock_irqsave(&r->lock, flags);
-	input_rotate = r->input_rotate;
-	i = r->add_ptr;
+	smp_rmb();
+	input_rotate = ACCESS_ONCE(r->input_rotate);
+	i = ACCESS_ONCE(r->add_ptr);
 
 	/* mix one byte at a time to simplify size handling and churn faster */
 	while (nbytes--) {
-		w = rol32(*bytes++, input_rotate & 31);
+		w = rol32(*bytes++, input_rotate);
 		i = (i - 1) & wordmask;
 
 		/* XOR in the various taps */
@@ -463,53 +526,192 @@
 		 * rotation, so that successive passes spread the
 		 * input bits across the pool evenly.
 		 */
-		input_rotate += i ? 7 : 14;
+		input_rotate = (input_rotate + (i ? 7 : 14)) & 31;
 	}
 
-	r->input_rotate = input_rotate;
-	r->add_ptr = i;
+	ACCESS_ONCE(r->input_rotate) = input_rotate;
+	ACCESS_ONCE(r->add_ptr) = i;
+	smp_wmb();
 
 	if (out)
 		for (j = 0; j < 16; j++)
 			((__u32 *)out)[j] = r->pool[(i - j) & wordmask];
+}
 
-	spin_unlock_irqrestore(&r->lock, flags);
+static void __mix_pool_bytes(struct entropy_store *r, const void *in,
+			     int nbytes, __u8 out[64])
+{
+	trace_mix_pool_bytes_nolock(r->name, nbytes, _RET_IP_);
+	_mix_pool_bytes(r, in, nbytes, out);
 }
 
-static void mix_pool_bytes(struct entropy_store *r, const void *in, int bytes)
+static void mix_pool_bytes(struct entropy_store *r, const void *in,
+			   int nbytes, __u8 out[64])
 {
-       mix_pool_bytes_extract(r, in, bytes, NULL);
+	unsigned long flags;
+
+	trace_mix_pool_bytes(r->name, nbytes, _RET_IP_);
+	spin_lock_irqsave(&r->lock, flags);
+	_mix_pool_bytes(r, in, nbytes, out);
+	spin_unlock_irqrestore(&r->lock, flags);
+}
+
+struct fast_pool {
+	__u32		pool[4];
+	unsigned long	last;
+	unsigned short	count;
+	unsigned char	rotate;
+	unsigned char	last_timer_intr;
+};
+
+/*
+ * This is a fast mixing routine used by the interrupt randomness
+ * collector.  It's hardcoded for an 128 bit pool and assumes that any
+ * locks that might be needed are taken by the caller.
+ */
+static void fast_mix(struct fast_pool *f, __u32 input[4])
+{
+	__u32		w;
+	unsigned	input_rotate = f->rotate;
+
+	w = rol32(input[0], input_rotate) ^ f->pool[0] ^ f->pool[3];
+	f->pool[0] = (w >> 3) ^ twist_table[w & 7];
+	input_rotate = (input_rotate + 14) & 31;
+	w = rol32(input[1], input_rotate) ^ f->pool[1] ^ f->pool[0];
+	f->pool[1] = (w >> 3) ^ twist_table[w & 7];
+	input_rotate = (input_rotate + 7) & 31;
+	w = rol32(input[2], input_rotate) ^ f->pool[2] ^ f->pool[1];
+	f->pool[2] = (w >> 3) ^ twist_table[w & 7];
+	input_rotate = (input_rotate + 7) & 31;
+	w = rol32(input[3], input_rotate) ^ f->pool[3] ^ f->pool[2];
+	f->pool[3] = (w >> 3) ^ twist_table[w & 7];
+	input_rotate = (input_rotate + 7) & 31;
+
+	f->rotate = input_rotate;
+	f->count++;
 }
 
 /*
- * Credit (or debit) the entropy store with n bits of entropy
+ * Credit (or debit) the entropy store with n bits of entropy.
+ * Use credit_entropy_bits_safe() if the value comes from userspace
+ * or otherwise should be checked for extreme values.
  */
 static void credit_entropy_bits(struct entropy_store *r, int nbits)
 {
-	unsigned long flags;
-	int entropy_count;
+	int entropy_count, orig;
+	const int pool_size = r->poolinfo->poolfracbits;
+	int nfrac = nbits << ENTROPY_SHIFT;
 
 	if (!nbits)
 		return;
 
-	spin_lock_irqsave(&r->lock, flags);
+retry:
+	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
+	if (nfrac < 0) {
+		/* Debit */
+		entropy_count += nfrac;
+	} else {
+		/*
+		 * Credit: we have to account for the possibility of
+		 * overwriting already present entropy.	 Even in the
+		 * ideal case of pure Shannon entropy, new contributions
+		 * approach the full value asymptotically:
+		 *
+		 * entropy <- entropy + (pool_size - entropy) *
+		 *	(1 - exp(-add_entropy/pool_size))
+		 *
+		 * For add_entropy <= pool_size/2 then
+		 * (1 - exp(-add_entropy/pool_size)) >=
+		 *    (add_entropy/pool_size)*0.7869...
+		 * so we can approximate the exponential with
+		 * 3/4*add_entropy/pool_size and still be on the
+		 * safe side by adding at most pool_size/2 at a time.
+		 *
+		 * The use of pool_size-2 in the while statement is to
+		 * prevent rounding artifacts from making the loop
+		 * arbitrarily long; this limits the loop to log2(pool_size)*2
+		 * turns no matter how large nbits is.
+		 */
+		int pnfrac = nfrac;
+		const int s = r->poolinfo->poolbitshift + ENTROPY_SHIFT + 2;
+		/* The +2 corresponds to the /4 in the denominator */
+
+		do {
+			unsigned int anfrac = min(pnfrac, pool_size/2);
+			unsigned int add =
+				((pool_size - entropy_count)*anfrac*3) >> s;
+
+			entropy_count += add;
+			pnfrac -= anfrac;
+		} while (unlikely(entropy_count < pool_size-2 && pnfrac));
+	}
 
-	DEBUG_ENT("added %d entropy credits to %s\n", nbits, r->name);
-	entropy_count = r->entropy_count;
-	entropy_count += nbits;
-	if (entropy_count < 0) {
-		DEBUG_ENT("negative entropy/overflow\n");
+	if (unlikely(entropy_count < 0)) {
+		pr_warn("random: negative entropy/overflow: pool %s count %d\n",
+			r->name, entropy_count);
+		WARN_ON(1);
 		entropy_count = 0;
-	} else if (entropy_count > r->poolinfo->POOLBITS)
-		entropy_count = r->poolinfo->POOLBITS;
-	r->entropy_count = entropy_count;
-
-	/* should we wake readers? */
-	if (r == &input_pool && entropy_count >= random_read_wakeup_thresh) {
-		wake_up_interruptible(&random_read_wait);
-		kill_fasync(&fasync, SIGIO, POLL_IN);
+	} else if (entropy_count > pool_size)
+		entropy_count = pool_size;
+	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
+		goto retry;
+
+	r->entropy_total += nbits;
+	if (!r->initialized && r->entropy_total > 128) {
+		r->initialized = 1;
+		r->entropy_total = 0;
+		if (r == &nonblocking_pool) {
+			prandom_reseed_late();
+			pr_notice("random: %s pool is initialized\n", r->name);
+		}
+	}
+
+	trace_credit_entropy_bits(r->name, nbits,
+				  entropy_count >> ENTROPY_SHIFT,
+				  r->entropy_total, _RET_IP_);
+
+	if (r == &input_pool) {
+		int entropy_bits = entropy_count >> ENTROPY_SHIFT;
+
+		/* should we wake readers? */
+		if (entropy_bits >= random_read_wakeup_bits) {
+			wake_up_interruptible(&random_read_wait);
+			kill_fasync(&fasync, SIGIO, POLL_IN);
+		}
+		/* If the input pool is getting full, send some
+		 * entropy to the two output pools, flipping back and
+		 * forth between them, until the output pools are 75%
+		 * full.
+		 */
+		if (entropy_bits > random_write_wakeup_bits &&
+		    r->initialized &&
+		    r->entropy_total >= 2*random_read_wakeup_bits) {
+			static struct entropy_store *last = &blocking_pool;
+			struct entropy_store *other = &blocking_pool;
+
+			if (last == &blocking_pool)
+				other = &nonblocking_pool;
+			if (other->entropy_count <=
+			    3 * other->poolinfo->poolfracbits / 4)
+				last = other;
+			if (last->entropy_count <=
+			    3 * last->poolinfo->poolfracbits / 4) {
+				schedule_work(&last->push_work);
+				r->entropy_total = 0;
+			}
+		}
 	}
-	spin_unlock_irqrestore(&r->lock, flags);
+}
+
+static void credit_entropy_bits_safe(struct entropy_store *r, int nbits)
+{
+	const int nbits_max = (int)(~0U >> (ENTROPY_SHIFT + 1));
+
+	/* Cap the value to avoid overflows */
+	nbits = min(nbits,  nbits_max);
+	nbits = max(nbits, -nbits_max);
+
+	credit_entropy_bits(r, nbits);
 }
 
 /*********************************************************************
@@ -525,44 +727,35 @@
 	unsigned dont_count_entropy:1;
 };
 
-#ifndef CONFIG_GENERIC_HARDIRQS
-
-static struct timer_rand_state *irq_timer_state[NR_IRQS];
-
-static struct timer_rand_state *get_timer_rand_state(unsigned int irq)
-{
-	return irq_timer_state[irq];
-}
-
-static void set_timer_rand_state(unsigned int irq,
-				 struct timer_rand_state *state)
-{
-	irq_timer_state[irq] = state;
-}
-
-#else
-
-static struct timer_rand_state *get_timer_rand_state(unsigned int irq)
-{
-	struct irq_desc *desc;
-
-	desc = irq_to_desc(irq);
+#define INIT_TIMER_RAND_STATE { INITIAL_JIFFIES, };
 
-	return desc->timer_rand_state;
-}
-
-static void set_timer_rand_state(unsigned int irq,
-				 struct timer_rand_state *state)
+/*
+ * Add device- or boot-specific data to the input and nonblocking
+ * pools to help initialize them to unique values.
+ *
+ * None of this adds any entropy, it is meant to avoid the
+ * problem of the nonblocking pool having similar initial state
+ * across largely identical devices.
+ */
+void add_device_randomness(const void *buf, unsigned int size)
 {
-	struct irq_desc *desc;
-
-	desc = irq_to_desc(irq);
+	unsigned long time = random_get_entropy() ^ jiffies;
+	unsigned long flags;
 
-	desc->timer_rand_state = state;
+	trace_add_device_randomness(size, _RET_IP_);
+	spin_lock_irqsave(&input_pool.lock, flags);
+	_mix_pool_bytes(&input_pool, buf, size, NULL);
+	_mix_pool_bytes(&input_pool, &time, sizeof(time), NULL);
+	spin_unlock_irqrestore(&input_pool.lock, flags);
+
+	spin_lock_irqsave(&nonblocking_pool.lock, flags);
+	_mix_pool_bytes(&nonblocking_pool, buf, size, NULL);
+	_mix_pool_bytes(&nonblocking_pool, &time, sizeof(time), NULL);
+	spin_unlock_irqrestore(&nonblocking_pool.lock, flags);
 }
-#endif
+EXPORT_SYMBOL(add_device_randomness);
 
-static struct timer_rand_state input_timer_state;
+static struct timer_rand_state input_timer_state = INIT_TIMER_RAND_STATE;
 
 /*
  * This function adds entropy to the entropy "pool" by using timing
@@ -576,23 +769,21 @@
  */
 static void add_timer_randomness(struct timer_rand_state *state, unsigned num)
 {
+	struct entropy_store	*r;
 	struct {
-		cycles_t cycles;
 		long jiffies;
+		unsigned cycles;
 		unsigned num;
 	} sample;
 	long delta, delta2, delta3;
 
 	preempt_disable();
-	/* if over the trickle threshold, use only 1 in 4096 samples */
-	if (input_pool.entropy_count > trickle_thresh &&
-	    (__get_cpu_var(trickle_count)++ & 0xfff))
-		goto out;
 
 	sample.jiffies = jiffies;
-	sample.cycles = get_cycles();
+	sample.cycles = random_get_entropy();
 	sample.num = num;
-	mix_pool_bytes(&input_pool, &sample, sizeof(sample));
+	r = nonblocking_pool.initialized ? &input_pool : &nonblocking_pool;
+	mix_pool_bytes(r, &sample, sizeof(sample), NULL);
 
 	/*
 	 * Calculate number of bits of randomness we probably added.
@@ -626,10 +817,8 @@
 		 * Round down by 1 bit on general principles,
 		 * and limit entropy entimate to 12 bits.
 		 */
-		credit_entropy_bits(&input_pool,
-				    min_t(int, fls(delta>>1), 11));
+		credit_entropy_bits(r, min_t(int, fls(delta>>1), 11));
 	}
-out:
 	preempt_enable();
 }
 
@@ -642,25 +831,73 @@
 	if (value == last_value)
 		return;
 
-	DEBUG_ENT("input event\n");
 	last_value = value;
 	add_timer_randomness(&input_timer_state,
 			     (type << 4) ^ code ^ (code >> 4) ^ value);
+	trace_add_input_randomness(ENTROPY_BITS(&input_pool));
 }
 EXPORT_SYMBOL_GPL(add_input_randomness);
 
-void add_interrupt_randomness(int irq)
+static DEFINE_PER_CPU(struct fast_pool, irq_randomness);
+
+void add_interrupt_randomness(int irq, int irq_flags)
 {
-	struct timer_rand_state *state;
+	struct entropy_store	*r;
+	struct fast_pool	*fast_pool = &__get_cpu_var(irq_randomness);
+	struct pt_regs		*regs = get_irq_regs();
+	unsigned long		now = jiffies;
+	cycles_t		cycles = random_get_entropy();
+	__u32			input[4], c_high, j_high;
+	__u64			ip;
+	unsigned long		seed;
+	int			credit;
+
+	c_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;
+	j_high = (sizeof(now) > 4) ? now >> 32 : 0;
+	input[0] = cycles ^ j_high ^ irq;
+	input[1] = now ^ c_high;
+	ip = regs ? instruction_pointer(regs) : _RET_IP_;
+	input[2] = ip;
+	input[3] = ip >> 32;
 
-	state = get_timer_rand_state(irq);
+	fast_mix(fast_pool, input);
 
-	if (state == NULL)
+	if ((fast_pool->count & 63) && !time_after(now, fast_pool->last + HZ))
 		return;
 
-	DEBUG_ENT("irq event %d\n", irq);
-	add_timer_randomness(state, 0x100 + irq);
+	fast_pool->last = now;
+
+	r = nonblocking_pool.initialized ? &input_pool : &nonblocking_pool;
+	__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool), NULL);
+
+	/*
+	 * If we don't have a valid cycle counter, and we see
+	 * back-to-back timer interrupts, then skip giving credit for
+	 * any entropy, otherwise credit 1 bit.
+	 */
+	credit = 1;
+	if (cycles == 0) {
+		if (irq_flags & __IRQF_TIMER) {
+			if (fast_pool->last_timer_intr)
+				credit = 0;
+			fast_pool->last_timer_intr = 1;
+		} else
+			fast_pool->last_timer_intr = 0;
+	}
+
+	/*
+	 * If we have architectural seed generator, produce a seed and
+	 * add it to the pool.  For the sake of paranoia count it as
+	 * 50% entropic.
+	 */
+	if (arch_get_random_seed_long(&seed)) {
+		__mix_pool_bytes(r, &seed, sizeof(seed), NULL);
+		credit += sizeof(seed) * 4;
+	}
+
+	credit_entropy_bits(r, credit);
 }
+EXPORT_SYMBOL_GPL(add_interrupt_randomness);
 
 #ifdef CONFIG_BLOCK
 void add_disk_randomness(struct gendisk *disk)
@@ -668,11 +905,10 @@
 	if (!disk || !disk->random)
 		return;
 	/* first major is 1, so we get >= 0x200 here */
-	DEBUG_ENT("disk event %d:%d\n",
-		  MAJOR(disk_devt(disk)), MINOR(disk_devt(disk)));
-
 	add_timer_randomness(disk->random, 0x100 + disk_devt(disk));
+	trace_add_disk_randomness(disk_devt(disk), ENTROPY_BITS(&input_pool));
 }
+//EXPORT_SYMBOL_GPL(add_disk_randomness);
 #endif
 
 /*********************************************************************
@@ -685,97 +921,149 @@
 			       size_t nbytes, int min, int rsvd);
 
 /*
- * This utility inline function is responsible for transfering entropy
+ * This utility inline function is responsible for transferring entropy
  * from the primary pool to the secondary extraction pool. We make
  * sure we pull enough for a 'catastrophic reseed'.
  */
+static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes);
 static void xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
 {
-	__u32 tmp[OUTPUT_POOL_WORDS];
+	if (r->limit == 0 && random_min_urandom_seed) {
+		unsigned long now = jiffies;
+
+		if (time_before(now,
+				r->last_pulled + random_min_urandom_seed * HZ))
+			return;
+		r->last_pulled = now;
+	}
+	if (r->pull &&
+	    r->entropy_count < (nbytes << (ENTROPY_SHIFT + 3)) &&
+	    r->entropy_count < r->poolinfo->poolfracbits)
+		_xfer_secondary_pool(r, nbytes);
+}
 
-	if (r->pull && r->entropy_count < nbytes * 8 &&
-	    r->entropy_count < r->poolinfo->POOLBITS) {
-		/* If we're limited, always leave two wakeup worth's BITS */
-		int rsvd = r->limit ? 0 : random_read_wakeup_thresh/4;
-		int bytes = nbytes;
+static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
+{
+	__u32	tmp[OUTPUT_POOL_WORDS];
 
-		/* pull at least as many as BYTES as wakeup BITS */
-		bytes = max_t(int, bytes, random_read_wakeup_thresh / 8);
-		/* but never more than the buffer size */
-		bytes = min_t(int, bytes, sizeof(tmp));
+	/* For /dev/random's pool, always leave two wakeups' worth */
+	int rsvd_bytes = r->limit ? 0 : random_read_wakeup_bits / 4;
+	int bytes = nbytes;
 
-		DEBUG_ENT("going to reseed %s with %d bits "
-			  "(%d of %d requested)\n",
-			  r->name, bytes * 8, nbytes * 8, r->entropy_count);
+	/* pull at least as much as a wakeup */
+	bytes = max_t(int, bytes, random_read_wakeup_bits / 8);
+	/* but never more than the buffer size */
+	bytes = min_t(int, bytes, sizeof(tmp));
 
-		bytes = extract_entropy(r->pull, tmp, bytes,
-					random_read_wakeup_thresh / 8, rsvd);
-		mix_pool_bytes(r, tmp, bytes);
-		credit_entropy_bits(r, bytes*8);
-	}
+	trace_xfer_secondary_pool(r->name, bytes * 8, nbytes * 8,
+				  ENTROPY_BITS(r), ENTROPY_BITS(r->pull));
+	bytes = extract_entropy(r->pull, tmp, bytes,
+				random_read_wakeup_bits / 8, rsvd_bytes);
+	mix_pool_bytes(r, tmp, bytes, NULL);
+	credit_entropy_bits(r, bytes*8);
 }
 
 /*
- * These functions extracts randomness from the "entropy pool", and
- * returns it in a buffer.
- *
- * The min parameter specifies the minimum amount we can pull before
- * failing to avoid races that defeat catastrophic reseeding while the
- * reserved parameter indicates how much entropy we must leave in the
- * pool after each pull to avoid starving other readers.
- *
- * Note: extract_entropy() assumes that .poolwords is a multiple of 16 words.
+ * Used as a workqueue function so that when the input pool is getting
+ * full, we can "spill over" some entropy to the output pools.  That
+ * way the output pools can store some of the excess entropy instead
+ * of letting it go to waste.
  */
+static void push_to_pool(struct work_struct *work)
+{
+	struct entropy_store *r = container_of(work, struct entropy_store,
+					      push_work);
+	BUG_ON(!r);
+	_xfer_secondary_pool(r, random_read_wakeup_bits/8);
+	trace_push_to_pool(r->name, r->entropy_count >> ENTROPY_SHIFT,
+			   r->pull->entropy_count >> ENTROPY_SHIFT);
+}
 
+/*
+ * This function decides how many bytes to actually take from the
+ * given pool, and also debits the entropy count accordingly.
+ */
 static size_t account(struct entropy_store *r, size_t nbytes, int min,
 		      int reserved)
 {
-	unsigned long flags;
-
-	/* Hold lock while accounting */
-	spin_lock_irqsave(&r->lock, flags);
+	int entropy_count, orig;
+	size_t ibytes, nfrac;
 
-	BUG_ON(r->entropy_count > r->poolinfo->POOLBITS);
-	DEBUG_ENT("trying to extract %d bits from %s\n",
-		  nbytes * 8, r->name);
+	BUG_ON(r->entropy_count > r->poolinfo->poolfracbits);
 
 	/* Can we pull enough? */
-	if (r->entropy_count / 8 < min + reserved) {
-		nbytes = 0;
-	} else {
-		/* If limited, never pull more than available */
-		if (r->limit && nbytes + reserved >= r->entropy_count / 8)
-			nbytes = r->entropy_count/8 - reserved;
-
-		if (r->entropy_count / 8 >= nbytes + reserved)
-			r->entropy_count -= nbytes*8;
-		else
-			r->entropy_count = reserved;
-
-		if (r->entropy_count < random_write_wakeup_thresh) {
-			wake_up_interruptible(&random_write_wait);
-			kill_fasync(&fasync, SIGIO, POLL_OUT);
-		}
+retry:
+	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
+	ibytes = nbytes;
+	/* If limited, never pull more than available */
+	if (r->limit) {
+		int have_bytes = entropy_count >> (ENTROPY_SHIFT + 3);
+
+		if ((have_bytes -= reserved) < 0)
+			have_bytes = 0;
+		ibytes = min_t(size_t, ibytes, have_bytes);
 	}
+	if (ibytes < min)
+		ibytes = 0;
 
-	DEBUG_ENT("debiting %d entropy credits from %s%s\n",
-		  nbytes * 8, r->name, r->limit ? "" : " (unlimited)");
+	if (unlikely(entropy_count < 0)) {
+		pr_warn("random: negative entropy count: pool %s count %d\n",
+			r->name, entropy_count);
+		WARN_ON(1);
+		entropy_count = 0;
+	}
+	nfrac = ibytes << (ENTROPY_SHIFT + 3);
+	if ((size_t) entropy_count > nfrac)
+		entropy_count -= nfrac;
+	else
+		entropy_count = 0;
 
-	spin_unlock_irqrestore(&r->lock, flags);
+	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
+		goto retry;
 
-	return nbytes;
+	trace_debit_entropy(r->name, 8 * ibytes);
+	if (ibytes &&
+	    (r->entropy_count >> ENTROPY_SHIFT) < random_write_wakeup_bits) {
+		wake_up_interruptible(&random_write_wait);
+		kill_fasync(&fasync, SIGIO, POLL_OUT);
+	}
+
+	return ibytes;
 }
 
+/*
+ * This function does the actual extraction for extract_entropy and
+ * extract_entropy_user.
+ *
+ * Note: we assume that .poolwords is a multiple of 16 words.
+ */
 static void extract_buf(struct entropy_store *r, __u8 *out)
 {
 	int i;
-	__u32 hash[5], workspace[SHA_WORKSPACE_WORDS];
+	union {
+		__u32 w[5];
+		unsigned long l[LONGS(20)];
+	} hash;
+	__u32 workspace[SHA_WORKSPACE_WORDS];
 	__u8 extract[64];
+	unsigned long flags;
+
+	/*
+	 * If we have an architectural hardware random number
+	 * generator, use it for SHA's initial vector
+	 */
+	sha_init_inline(hash.w);
+	for (i = 0; i < LONGS(20); i++) {
+		unsigned long v;
+		if (!arch_get_random_long(&v))
+			break;
+		hash.l[i] = v;
+	}
 
 	/* Generate a hash across the pool, 16 words (512 bits) at a time */
-	sha_init(hash);
+	spin_lock_irqsave(&r->lock, flags);
 	for (i = 0; i < r->poolinfo->poolwords; i += 16)
-		sha_transform(hash, (__u8 *)(r->pool + i), workspace);
+		sha_transform_inline(hash.w, (__u8 *)(r->pool + i), workspace);
 
 	/*
 	 * We mix the hash back into the pool to prevent backtracking
@@ -786,35 +1074,63 @@
 	 * brute-forcing the feedback as hard as brute-forcing the
 	 * hash.
 	 */
-	mix_pool_bytes_extract(r, hash, sizeof(hash), extract);
+	__mix_pool_bytes(r, hash.w, sizeof(hash.w), extract);
+	spin_unlock_irqrestore(&r->lock, flags);
 
 	/*
 	 * To avoid duplicates, we atomically extract a portion of the
 	 * pool while mixing, and hash one final time.
 	 */
-	sha_transform(hash, extract, workspace);
-	memset(extract, 0, sizeof(extract));
-	memset(workspace, 0, sizeof(workspace));
+	sha_transform_inline(hash.w, extract, workspace);
+	memzero_explicit(extract, sizeof(extract));
+	memzero_explicit(workspace, sizeof(workspace));
 
 	/*
 	 * In case the hash function has some recognizable output
 	 * pattern, we fold it in half. Thus, we always feed back
 	 * twice as much data as we output.
 	 */
-	hash[0] ^= hash[3];
-	hash[1] ^= hash[4];
-	hash[2] ^= rol32(hash[2], 16);
-	memcpy(out, hash, EXTRACT_SIZE);
-	memset(hash, 0, sizeof(hash));
+	hash.w[0] ^= hash.w[3];
+	hash.w[1] ^= hash.w[4];
+	hash.w[2] ^= rol32(hash.w[2], 16);
+
+	memcpy(out, &hash, EXTRACT_SIZE);
+	memzero_explicit(&hash, sizeof(hash));
 }
 
+/*
+ * This function extracts randomness from the "entropy pool", and
+ * returns it in a buffer.
+ *
+ * The min parameter specifies the minimum amount we can pull before
+ * failing to avoid races that defeat catastrophic reseeding while the
+ * reserved parameter indicates how much entropy we must leave in the
+ * pool after each pull to avoid starving other readers.
+ */
 static ssize_t extract_entropy(struct entropy_store *r, void *buf,
-			       size_t nbytes, int min, int reserved)
+				 size_t nbytes, int min, int reserved)
 {
 	ssize_t ret = 0, i;
 	__u8 tmp[EXTRACT_SIZE];
 	unsigned long flags;
 
+	/* if last_data isn't primed, we need EXTRACT_SIZE extra bytes */
+	if (fips_enabled) {
+		spin_lock_irqsave(&r->lock, flags);
+		if (!r->last_data_init) {
+			r->last_data_init = 1;
+			spin_unlock_irqrestore(&r->lock, flags);
+			trace_extract_entropy(r->name, EXTRACT_SIZE,
+					      ENTROPY_BITS(r), _RET_IP_);
+			xfer_secondary_pool(r, EXTRACT_SIZE);
+			extract_buf(r, tmp);
+			spin_lock_irqsave(&r->lock, flags);
+			memcpy(r->last_data, tmp, EXTRACT_SIZE);
+		}
+		spin_unlock_irqrestore(&r->lock, flags);
+	}
+
+	trace_extract_entropy(r->name, nbytes, ENTROPY_BITS(r), _RET_IP_);
 	xfer_secondary_pool(r, nbytes);
 	nbytes = account(r, nbytes, min, reserved);
 
@@ -836,17 +1152,22 @@
 	}
 
 	/* Wipe data just returned from memory */
-	memset(tmp, 0, sizeof(tmp));
+	memzero_explicit(tmp, sizeof(tmp));
 
 	return ret;
 }
 
+/*
+ * This function extracts randomness from the "entropy pool", and
+ * returns it in a userspace buffer.
+ */
 static ssize_t extract_entropy_user(struct entropy_store *r, void __user *buf,
 				    size_t nbytes)
 {
 	ssize_t ret = 0, i;
 	__u8 tmp[EXTRACT_SIZE];
 
+	trace_extract_entropy_user(r->name, nbytes, ENTROPY_BITS(r), _RET_IP_);
 	xfer_secondary_pool(r, nbytes);
 	nbytes = account(r, nbytes, 0, 0);
 
@@ -873,23 +1194,66 @@
 	}
 
 	/* Wipe data just returned from memory */
-	memset(tmp, 0, sizeof(tmp));
+	memzero_explicit(tmp, sizeof(tmp));
 
 	return ret;
 }
 
 /*
  * This function is the exported kernel interface.  It returns some
- * number of good random numbers, suitable for seeding TCP sequence
- * numbers, etc.
+ * number of good random numbers, suitable for key generation, seeding
+ * TCP sequence numbers, etc.  It does not rely on the hardware random
+ * number generator.  For random bytes direct from the hardware RNG
+ * (when available), use get_random_bytes_arch().
  */
 void get_random_bytes(void *buf, int nbytes)
 {
+#if DEBUG_RANDOM_BOOT > 0
+	if (unlikely(nonblocking_pool.initialized == 0))
+		printk(KERN_NOTICE "random: %pF get_random_bytes called "
+		       "with %d bits of entropy available\n",
+		       (void *) _RET_IP_,
+		       nonblocking_pool.entropy_total);
+#endif
+	trace_get_random_bytes(nbytes, _RET_IP_);
 	extract_entropy(&nonblocking_pool, buf, nbytes, 0, 0);
 }
 EXPORT_SYMBOL(get_random_bytes);
 
 /*
+ * This function will use the architecture-specific hardware random
+ * number generator if it is available.  The arch-specific hw RNG will
+ * almost certainly be faster than what we can do in software, but it
+ * is impossible to verify that it is implemented securely (as
+ * opposed, to, say, the AES encryption of a sequence number using a
+ * key known by the NSA).  So it's useful if we need the speed, but
+ * only if we're willing to trust the hardware manufacturer not to
+ * have put in a back door.
+ */
+void get_random_bytes_arch(void *buf, int nbytes)
+{
+	char *p = buf;
+
+	trace_get_random_bytes_arch(nbytes, _RET_IP_);
+	while (nbytes) {
+		unsigned long v;
+		int chunk = min(nbytes, (int)sizeof(unsigned long));
+
+		if (!arch_get_random_long(&v))
+			break;
+		
+		memcpy(p, &v, chunk);
+		p += chunk;
+		nbytes -= chunk;
+	}
+
+	if (nbytes)
+		extract_entropy(&nonblocking_pool, p, nbytes, 0, 0);
+}
+//EXPORT_SYMBOL(get_random_bytes_arch);
+
+
+/*
  * init_std_data - initialize pool with system data
  *
  * @r: pool to initialize
@@ -900,18 +1264,31 @@
  */
 static void init_std_data(struct entropy_store *r)
 {
-	ktime_t now;
-	unsigned long flags;
-
-	spin_lock_irqsave(&r->lock, flags);
-	r->entropy_count = 0;
-	spin_unlock_irqrestore(&r->lock, flags);
+	int i;
+	ktime_t now = ktime_get_real();
+	unsigned long rv;
 
-	now = ktime_get_real();
-	mix_pool_bytes(r, &now, sizeof(now));
-	mix_pool_bytes(r, utsname(), sizeof(*(utsname())));
+	r->last_pulled = jiffies;
+	mix_pool_bytes(r, &now, sizeof(now), NULL);
+	for (i = r->poolinfo->poolbytes; i > 0; i -= sizeof(rv)) {
+		if (!arch_get_random_seed_long(&rv) &&
+		    !arch_get_random_long(&rv))
+			rv = random_get_entropy();
+		mix_pool_bytes(r, &rv, sizeof(rv), NULL);
+	}
+	mix_pool_bytes(r, utsname(), sizeof(*(utsname())), NULL);
 }
 
+/*
+ * Note that setup_arch() may call add_device_randomness()
+ * long before we get here. This allows seeding of the pools
+ * with some platform dependent data very early in the boot
+ * process. But it limits our options here. We must use
+ * statically allocated structures that already have all
+ * initializations complete at compile time. We should also
+ * take care not to overwrite the precious per platform data
+ * we were given.
+ */
 static int rand_initialize(void)
 {
 	init_std_data(&input_pool);
@@ -919,25 +1296,7 @@
 	init_std_data(&nonblocking_pool);
 	return 0;
 }
-module_init(rand_initialize);
-
-void rand_initialize_irq(int irq)
-{
-	struct timer_rand_state *state;
-
-	state = get_timer_rand_state(irq);
-
-	if (state)
-		return;
-
-	/*
-	 * If kzalloc returns null, we just won't use that entropy
-	 * source.
-	 */
-	state = kzalloc(sizeof(struct timer_rand_state), GFP_KERNEL);
-	if (state)
-		set_timer_rand_state(irq, state);
-}
+early_initcall(rand_initialize);
 
 #ifdef CONFIG_BLOCK
 void rand_initialize_disk(struct gendisk *disk)
@@ -949,71 +1308,100 @@
 	 * source.
 	 */
 	state = kzalloc(sizeof(struct timer_rand_state), GFP_KERNEL);
-	if (state)
+	if (state) {
+		state->last_time = INITIAL_JIFFIES;
 		disk->random = state;
+	}
 }
 #endif
 
-static ssize_t
-random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
+/*
+ * Attempt an emergency refill using arch_get_random_seed_long().
+ *
+ * As with add_interrupt_randomness() be paranoid and only
+ * credit the output as 50% entropic.
+ */
+static int arch_random_refill(void)
 {
-	ssize_t n, retval = 0, count = 0;
+	const unsigned int nlongs = 64;	/* Arbitrary number */
+	unsigned int n = 0;
+	unsigned int i;
+	unsigned long buf[nlongs];
 
-	if (nbytes == 0)
+	if (!arch_has_random_seed())
 		return 0;
 
-	while (nbytes > 0) {
-		n = nbytes;
-		if (n > SEC_XFER_SIZE)
-			n = SEC_XFER_SIZE;
-
-		DEBUG_ENT("reading %d bits\n", n*8);
+	for (i = 0; i < nlongs; i++) {
+		if (arch_get_random_seed_long(&buf[n]))
+			n++;
+	}
 
-		n = extract_entropy_user(&blocking_pool, buf, n);
+	if (n) {
+		unsigned int rand_bytes = n * sizeof(unsigned long);
 
-		DEBUG_ENT("read got %d bits (%d still needed)\n",
-			  n*8, (nbytes-n)*8);
+		mix_pool_bytes(&input_pool, buf, rand_bytes, NULL);
+		credit_entropy_bits(&input_pool, rand_bytes*4);
+	}
 
-		if (n == 0) {
-			if (file->f_flags & O_NONBLOCK) {
-				retval = -EAGAIN;
-				break;
-			}
+	return n;
+}
 
-			DEBUG_ENT("sleeping?\n");
+static ssize_t
+random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
+{
+	ssize_t n;
 
-			wait_event_interruptible(random_read_wait,
-				input_pool.entropy_count >=
-						 random_read_wakeup_thresh);
+	if (nbytes == 0)
+		return 0;
 
-			DEBUG_ENT("awake\n");
+	nbytes = min_t(size_t, nbytes, SEC_XFER_SIZE);
+	while (1) {
+		n = extract_entropy_user(&blocking_pool, buf, nbytes);
+		if (n < 0)
+			return n;
+		trace_random_read(n*8, (nbytes-n)*8,
+				  ENTROPY_BITS(&blocking_pool),
+				  ENTROPY_BITS(&input_pool));
+		if (n > 0)
+			return n;
 
-			if (signal_pending(current)) {
-				retval = -ERESTARTSYS;
-				break;
-			}
+		/* Pool is (near) empty.  Maybe wait and retry. */
 
+		/* First try an emergency refill */
+		if (arch_random_refill())
 			continue;
-		}
 
-		if (n < 0) {
-			retval = n;
-			break;
-		}
-		count += n;
-		buf += n;
-		nbytes -= n;
-		break;		/* This break makes the device work */
-				/* like a named pipe */
-	}
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
 
-	return (count ? count : retval);
+		wait_event_interruptible(random_read_wait,
+			ENTROPY_BITS(&input_pool) >=
+			random_read_wakeup_bits);
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+	}
 }
 
 static ssize_t
 urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 {
-	return extract_entropy_user(&nonblocking_pool, buf, nbytes);
+	static int maxwarn = 10;
+	int ret;
+
+	if (unlikely(nonblocking_pool.initialized == 0) &&
+	    maxwarn > 0) {
+		maxwarn--;
+		printk(KERN_NOTICE "random: %s: uninitialized urandom read "
+		       "(%zd bytes read, %d bits of entropy available)\n",
+		       current->comm, nbytes, nonblocking_pool.entropy_total);
+	}
+
+	nbytes = min_t(size_t, nbytes, INT_MAX >> (ENTROPY_SHIFT + 3));
+	ret = extract_entropy_user(&nonblocking_pool, buf, nbytes);
+
+	trace_urandom_read(8 * nbytes, ENTROPY_BITS(&nonblocking_pool),
+			   ENTROPY_BITS(&input_pool));
+	return ret;
 }
 
 static unsigned int
@@ -1024,9 +1412,9 @@
 	poll_wait(file, &random_read_wait, wait);
 	poll_wait(file, &random_write_wait, wait);
 	mask = 0;
-	if (input_pool.entropy_count >= random_read_wakeup_thresh)
+	if (ENTROPY_BITS(&input_pool) >= random_read_wakeup_bits)
 		mask |= POLLIN | POLLRDNORM;
-	if (input_pool.entropy_count < random_write_wakeup_thresh)
+	if (ENTROPY_BITS(&input_pool) < random_write_wakeup_bits)
 		mask |= POLLOUT | POLLWRNORM;
 	return mask;
 }
@@ -1046,7 +1434,7 @@
 		count -= bytes;
 		p += bytes;
 
-		mix_pool_bytes(r, buf, bytes);
+		mix_pool_bytes(r, buf, bytes, NULL);
 		cond_resched();
 	}
 
@@ -1077,7 +1465,8 @@
 	switch (cmd) {
 	case RNDGETENTCNT:
 		/* inherently racy, no point locking */
-		if (put_user(input_pool.entropy_count, p))
+		ent_count = ENTROPY_BITS(&input_pool);
+		if (put_user(ent_count, p))
 			return -EFAULT;
 		return 0;
 	case RNDADDTOENTCNT:
@@ -1085,7 +1474,7 @@
 			return -EPERM;
 		if (get_user(ent_count, p))
 			return -EFAULT;
-		credit_entropy_bits(&input_pool, ent_count);
+		credit_entropy_bits_safe(&input_pool, ent_count);
 		return 0;
 	case RNDADDENTROPY:
 		if (!capable(CAP_SYS_ADMIN))
@@ -1100,14 +1489,19 @@
 				    size);
 		if (retval < 0)
 			return retval;
-		credit_entropy_bits(&input_pool, ent_count);
+		credit_entropy_bits_safe(&input_pool, ent_count);
 		return 0;
 	case RNDZAPENTCNT:
 	case RNDCLEARPOOL:
-		/* Clear the entropy pool counters. */
+		/*
+		 * Clear the entropy pool counters. We no longer clear
+		 * the entropy pool, as that's silly.
+		 */
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
-		rand_initialize();
+		input_pool.entropy_count = 0;
+		nonblocking_pool.entropy_count = 0;
+		blocking_pool.entropy_count = 0;
 		return 0;
 	default:
 		return -EINVAL;
@@ -1125,6 +1519,7 @@
 	.poll  = random_poll,
 	.unlocked_ioctl = random_ioctl,
 	.fasync = random_fasync,
+	.llseek = noop_llseek,
 };
 
 const struct file_operations urandom_fops = {
@@ -1132,6 +1527,7 @@
 	.write = random_write,
 	.unlocked_ioctl = random_ioctl,
 	.fasync = random_fasync,
+	.llseek = noop_llseek,
 };
 
 /***************************************************************
@@ -1165,32 +1561,37 @@
 #include <linux/sysctl.h>
 
 static int min_read_thresh = 8, min_write_thresh;
-static int max_read_thresh = INPUT_POOL_WORDS * 32;
+static int max_read_thresh = OUTPUT_POOL_WORDS * 32;
 static int max_write_thresh = INPUT_POOL_WORDS * 32;
 static char sysctl_bootid[16];
 
 /*
- * These functions is used to return both the bootid UUID, and random
+ * This function is used to return both the bootid UUID, and random
  * UUID.  The difference is in whether table->data is NULL; if it is,
  * then a new UUID is generated and returned to the user.
  *
- * If the user accesses this via the proc interface, it will be returned
- * as an ASCII string in the standard UUID format.  If accesses via the
- * sysctl system call, it is returned as 16 bytes of binary data.
+ * If the user accesses this via the proc interface, the UUID will be
+ * returned as an ASCII string in the standard UUID format; if via the
+ * sysctl system call, as 16 bytes of binary data.
  */
-static int proc_do_uuid(ctl_table *table, int write,
+static int proc_do_uuid(struct ctl_table *table, int write,
 			void __user *buffer, size_t *lenp, loff_t *ppos)
 {
-	ctl_table fake_table;
+	struct ctl_table fake_table;
 	unsigned char buf[64], tmp_uuid[16], *uuid;
 
 	uuid = table->data;
 	if (!uuid) {
 		uuid = tmp_uuid;
-		uuid[8] = 0;
-	}
-	if (uuid[8] == 0)
 		generate_random_uuid(uuid);
+	} else {
+		static DEFINE_SPINLOCK(bootid_spinlock);
+
+		spin_lock(&bootid_spinlock);
+		if (!uuid[8])
+			generate_random_uuid(uuid);
+		spin_unlock(&bootid_spinlock);
+	}
 
 	sprintf(buf, "%pU", uuid);
 
@@ -1200,8 +1601,26 @@
 	return proc_dostring(&fake_table, write, buffer, lenp, ppos);
 }
 
+/*
+ * Return entropy available scaled to integral bits
+ */
+static int proc_do_entropy(struct ctl_table *table, int write,
+			   void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	struct ctl_table fake_table;
+	int entropy_count;
+
+	entropy_count = *(int *)table->data >> ENTROPY_SHIFT;
+
+	fake_table.data = &entropy_count;
+	fake_table.maxlen = sizeof(entropy_count);
+
+	return proc_dointvec(&fake_table, write, buffer, lenp, ppos);
+}
+
 static int sysctl_poolsize = INPUT_POOL_WORDS * 32;
-ctl_table random_table[] = {
+extern struct ctl_table random_table[];
+struct ctl_table random_table[] = {
 	{
 		.procname	= "poolsize",
 		.data		= &sysctl_poolsize,
@@ -1213,12 +1632,12 @@
 		.procname	= "entropy_avail",
 		.maxlen		= sizeof(int),
 		.mode		= 0444,
-		.proc_handler	= proc_dointvec,
+		.proc_handler	= proc_do_entropy,
 		.data		= &input_pool.entropy_count,
 	},
 	{
 		.procname	= "read_wakeup_threshold",
-		.data		= &random_read_wakeup_thresh,
+		.data		= &random_read_wakeup_bits,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec_minmax,
@@ -1227,7 +1646,7 @@
 	},
 	{
 		.procname	= "write_wakeup_threshold",
-		.data		= &random_write_wakeup_thresh,
+		.data		= &random_write_wakeup_bits,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec_minmax,
@@ -1235,6 +1654,13 @@
 		.extra2		= &max_write_thresh,
 	},
 	{
+		.procname	= "urandom_min_reseed_secs",
+		.data		= &random_min_urandom_seed,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
 		.procname	= "boot_id",
 		.data		= &sysctl_bootid,
 		.maxlen		= 16,
@@ -1471,7 +1897,7 @@
 	hash[2] = keyptr->secret[10];
 	hash[3] = keyptr->secret[11];
 
-	return half_md4_transform(hash, keyptr->secret);
+	return half_md4_transform_inline(hash, keyptr->secret);
 }
 
 #ifdef CONFIG_INET
@@ -1494,7 +1920,7 @@
 	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
 	hash[3] = keyptr->secret[11];
 
-	seq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;
+	seq = half_md4_transform_inline(hash, keyptr->secret) & HASH_MASK;
 	seq += keyptr->count;
 	/*
 	 *	As close as possible to RFC 793, which
@@ -1526,7 +1952,7 @@
 	hash[2] = (__force u32)dport ^ keyptr->secret[10];
 	hash[3] = keyptr->secret[11];
 
-	return half_md4_transform(hash, keyptr->secret);
+	return half_md4_transform_inline(hash, keyptr->secret);
 }
 EXPORT_SYMBOL_GPL(secure_ipv4_port_ephemeral);
 
@@ -1562,7 +1988,7 @@
 	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
 	hash[3] = keyptr->secret[11];
 
-	seq = half_md4_transform(hash, keyptr->secret);
+	seq = half_md4_transform_inline(hash, keyptr->secret);
 	seq |= ((u64)keyptr->count) << (32 - HASH_BITS);
 
 	seq += ktime_to_ns(ktime_get_real());
@@ -1576,23 +2002,34 @@
 #endif /* CONFIG_INET */
 
 
+static u32 random_int_secret[MD5_MESSAGE_BYTES / 4] ____cacheline_aligned;
+
+int random_int_secret_init(void)
+{
+	get_random_bytes(random_int_secret, sizeof(random_int_secret));
+	return 0;
+}
+
 /*
  * Get a random word for internal kernel use only. Similar to urandom but
  * with the goal of minimal entropy pool depletion. As a result, the random
  * value is not cryptographically secure but for several uses the cost of
  * depleting entropy is too high
  */
-DEFINE_PER_CPU(__u32 [4], get_random_int_hash);
+static DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], get_random_int_hash);
 unsigned int get_random_int(void)
 {
-	struct keydata *keyptr;
-	__u32 *hash = get_cpu_var(get_random_int_hash);
-	int ret;
+	__u32 *hash;
+	unsigned int ret;
 
-	keyptr = get_keyptr();
-	hash[0] += current->pid + jiffies + get_cycles();
+	if (arch_get_random_int(&ret))
+		return ret;
+
+	hash = get_cpu_var(get_random_int_hash);
 
-	ret = half_md4_transform(hash, keyptr->secret);
+	hash[0] += current->pid + jiffies + random_get_entropy();
+	md5_transform_inline(hash, random_int_secret);
+	ret = hash[0];
 	put_cpu_var(get_random_int_hash);
 
 	return ret;
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/lib/random32.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/lib/random32.c
@@ -1,43 +1,51 @@
+///////////////////////////////////////////////////////////////////////////////
+// Entropy backport from Linux 3.16.43 to AsusWrt
+//
+// SOURCE: Linux 3.16.43, lib/random32.c
+///////////////////////////////////////////////////////////////////////////////
 /*
-  This is a maximally equidistributed combined Tausworthe generator
-  based on code from GNU Scientific Library 1.5 (30 Jun 2004)
-
-   x_n = (s1_n ^ s2_n ^ s3_n)
-
-   s1_{n+1} = (((s1_n & 4294967294) <<12) ^ (((s1_n <<13) ^ s1_n) >>19))
-   s2_{n+1} = (((s2_n & 4294967288) << 4) ^ (((s2_n << 2) ^ s2_n) >>25))
-   s3_{n+1} = (((s3_n & 4294967280) <<17) ^ (((s3_n << 3) ^ s3_n) >>11))
-
-   The period of this generator is about 2^88.
-
-   From: P. L'Ecuyer, "Maximally Equidistributed Combined Tausworthe
-   Generators", Mathematics of Computation, 65, 213 (1996), 203--213.
-
-   This is available on the net from L'Ecuyer's home page,
-
-   http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme.ps
-   ftp://ftp.iro.umontreal.ca/pub/simulation/lecuyer/papers/tausme.ps
-
-   There is an erratum in the paper "Tables of Maximally
-   Equidistributed Combined LFSR Generators", Mathematics of
-   Computation, 68, 225 (1999), 261--269:
-   http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme2.ps
-
-        ... the k_j most significant bits of z_j must be non-
-        zero, for each j. (Note: this restriction also applies to the
-        computer code given in [4], but was mistakenly not mentioned in
-        that paper.)
-
-   This affects the seeding procedure by imposing the requirement
-   s1 > 1, s2 > 7, s3 > 15.
-
-*/
+ * This is a maximally equidistributed combined Tausworthe generator
+ * based on code from GNU Scientific Library 1.5 (30 Jun 2004)
+ *
+ * lfsr113 version:
+ *
+ * x_n = (s1_n ^ s2_n ^ s3_n ^ s4_n)
+ *
+ * s1_{n+1} = (((s1_n & 4294967294) << 18) ^ (((s1_n <<  6) ^ s1_n) >> 13))
+ * s2_{n+1} = (((s2_n & 4294967288) <<  2) ^ (((s2_n <<  2) ^ s2_n) >> 27))
+ * s3_{n+1} = (((s3_n & 4294967280) <<  7) ^ (((s3_n << 13) ^ s3_n) >> 21))
+ * s4_{n+1} = (((s4_n & 4294967168) << 13) ^ (((s4_n <<  3) ^ s4_n) >> 12))
+ *
+ * The period of this generator is about 2^113 (see erratum paper).
+ *
+ * From: P. L'Ecuyer, "Maximally Equidistributed Combined Tausworthe
+ * Generators", Mathematics of Computation, 65, 213 (1996), 203--213:
+ * http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme.ps
+ * ftp://ftp.iro.umontreal.ca/pub/simulation/lecuyer/papers/tausme.ps
+ *
+ * There is an erratum in the paper "Tables of Maximally Equidistributed
+ * Combined LFSR Generators", Mathematics of Computation, 68, 225 (1999),
+ * 261--269: http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme2.ps
+ *
+ *      ... the k_j most significant bits of z_j must be non-zero,
+ *      for each j. (Note: this restriction also applies to the
+ *      computer code given in [4], but was mistakenly not mentioned
+ *      in that paper.)
+ *
+ * This affects the seeding procedure by imposing the requirement
+ * s1 > 1, s2 > 7, s3 > 15, s4 > 127.
+ */
 
 #include <linux/types.h>
 #include <linux/percpu.h>
 #include <linux/module.h>
 #include <linux/jiffies.h>
 #include <linux/random.h>
+#include <linux/sched.h>
+
+#ifdef CONFIG_RANDOM32_SELFTEST
+static void __init prandom_state_selftest(void);
+#endif
 
 static DEFINE_PER_CPU(struct rnd_state, net_rand_state);
 
@@ -50,13 +58,7 @@
  */
 u32 prandom32(struct rnd_state *state)
 {
-#define TAUSWORTHE(s,a,b,c,d) ((s&c)<<d) ^ (((s <<a) ^ s)>>b)
-
-	state->s1 = TAUSWORTHE(state->s1, 13, 19, 4294967294UL, 12);
-	state->s2 = TAUSWORTHE(state->s2, 2, 25, 4294967288UL, 4);
-	state->s3 = TAUSWORTHE(state->s3, 3, 11, 4294967280UL, 17);
-
-	return (state->s1 ^ state->s2 ^ state->s3);
+	return prandom_u32_state(state);
 }
 EXPORT_SYMBOL(prandom32);
 
@@ -69,11 +71,7 @@
  */
 u32 random32(void)
 {
-	unsigned long r;
-	struct rnd_state *state = &get_cpu_var(net_rand_state);
-	r = prandom32(state);
-	put_cpu_var(state);
-	return r;
+	return prandom_u32();
 }
 EXPORT_SYMBOL(random32);
 
@@ -87,12 +85,14 @@
  */
 u32 prandom_u32_state(struct rnd_state *state)
 {
-#define TAUSWORTHE(s, a, b, c, d) ((s & c) << d) ^ (((s << a) ^ s) >> b)
+#define TAUSWORTHE(s,a,b,c,d) ((s&c)<<d) ^ (((s <<a) ^ s)>>b)
+
 	state->s1 = TAUSWORTHE(state->s1,  6U, 13U, 4294967294U, 18U);
 	state->s2 = TAUSWORTHE(state->s2,  2U, 27U, 4294967288U,  2U);
 	state->s3 = TAUSWORTHE(state->s3, 13U, 21U, 4294967280U,  7U);
+	state->s4 = TAUSWORTHE(state->s4,  3U, 12U, 4294967168U, 13U);
 
-	return (state->s1 ^ state->s2 ^ state->s3);
+	return (state->s1 ^ state->s2 ^ state->s3 ^ state->s4);
 }
 EXPORT_SYMBOL(prandom_u32_state);
 
@@ -116,10 +116,91 @@
 EXPORT_SYMBOL(prandom_u32);
 
 /**
+ *	prandom_bytes_state - get the requested number of pseudo-random bytes
+ *
+ *	@state: pointer to state structure holding seeded state.
+ *	@buf: where to copy the pseudo-random bytes to
+ *	@bytes: the requested number of bytes
+ *
+ *	This is used for pseudo-randomness with no outside seeding.
+ *	For more random results, use prandom_bytes().
+ */
+void prandom_bytes_state(struct rnd_state *state, void *buf, int bytes)
+{
+	unsigned char *p = buf;
+	int i;
+
+	for (i = 0; i < round_down(bytes, sizeof(u32)); i += sizeof(u32)) {
+		u32 random = prandom_u32_state(state);
+		int j;
+
+		for (j = 0; j < sizeof(u32); j++) {
+			p[i + j] = random;
+			random >>= BITS_PER_BYTE;
+		}
+	}
+	if (i < bytes) {
+		u32 random = prandom_u32_state(state);
+
+		for (; i < bytes; i++) {
+			p[i] = random;
+			random >>= BITS_PER_BYTE;
+		}
+	}
+}
+//EXPORT_SYMBOL(prandom_bytes_state);
+
+/**
+ *	prandom_bytes - get the requested number of pseudo-random bytes
+ *	@buf: where to copy the pseudo-random bytes to
+ *	@bytes: the requested number of bytes
+ */
+void prandom_bytes(void *buf, int bytes)
+{
+	struct rnd_state *state = &get_cpu_var(net_rand_state);
+
+	prandom_bytes_state(state, buf, bytes);
+	put_cpu_var(state);
+}
+//EXPORT_SYMBOL(prandom_bytes);
+
+static void prandom_warmup(struct rnd_state *state)
+{
+	/* Calling RNG ten times to satify recurrence condition */
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+	prandom_u32_state(state);
+}
+
+static void prandom_seed_very_weak(struct rnd_state *state, u32 seed)
+{
+	/* Note: This sort of seeding is ONLY used in test cases and
+	 * during boot at the time from core_initcall until late_initcall
+	 * as we don't have a stronger entropy source available yet.
+	 * After late_initcall, we reseed entire state, we have to (!),
+	 * otherwise an attacker just needs to search 32 bit space to
+	 * probe for our internal 128 bit state if he knows a couple
+	 * of prandom32 outputs!
+	 */
+#define LCG(x)	((x) * 69069U)	/* super-duper LCG */
+	state->s1 = __seed(LCG(seed),        2U);
+	state->s2 = __seed(LCG(state->s1),   8U);
+	state->s3 = __seed(LCG(state->s2),  16U);
+	state->s4 = __seed(LCG(state->s3), 128U);
+}
+
+/**
  *	srandom32 - add entropy to pseudo random number generator
  *	@seed: seed value
  *
- *	Add some additional seeding to the random32() pool.
+ *	Add some additional seeding to the prandom pool.
  */
 void srandom32(u32 entropy)
 {
@@ -130,59 +211,277 @@
 	 */
 	for_each_possible_cpu (i) {
 		struct rnd_state *state = &per_cpu(net_rand_state, i);
-		state->s1 = __seed(state->s1 ^ entropy, 1);
+
+		state->s1 = __seed(state->s1 ^ entropy, 2U);
+		prandom_warmup(state);
 	}
 }
 EXPORT_SYMBOL(srandom32);
 
 /*
  *	Generate some initially weak seeding values to allow
- *	to start the random32() engine.
+ *	to start the prandom_u32() engine.
  */
-static int __init random32_init(void)
+static int __init prandom_init(void)
 {
 	int i;
 
+#ifdef CONFIG_RANDOM32_SELFTEST
+	prandom_state_selftest();
+#endif
+
 	for_each_possible_cpu(i) {
 		struct rnd_state *state = &per_cpu(net_rand_state,i);
 
-#define LCG(x)	((x) * 69069)	/* super-duper LCG */
-		state->s1 = __seed(LCG(i + jiffies), 1);
-		state->s2 = __seed(LCG(state->s1), 7);
-		state->s3 = __seed(LCG(state->s2), 15);
-
-		/* "warm it up" */
-		prandom32(state);
-		prandom32(state);
-		prandom32(state);
-		prandom32(state);
-		prandom32(state);
-		prandom32(state);
+		prandom_seed_very_weak(state, (i + jiffies) ^ random_get_entropy());
+		prandom_warmup(state);
 	}
+
 	return 0;
 }
-core_initcall(random32_init);
+core_initcall(prandom_init);
+
+static void __prandom_timer(unsigned long dontcare);
+static DEFINE_TIMER(seed_timer, __prandom_timer, 0, 0);
+
+static void __prandom_timer(unsigned long dontcare)
+{
+	u32 entropy;
+	unsigned long expires;
+
+	get_random_bytes(&entropy, sizeof(entropy));
+	srandom32(entropy);
+
+	/* reseed every ~60 seconds, in [40 .. 80) interval with slack */
+	expires = 40 + (prandom_u32() % 40);
+	seed_timer.expires = jiffies + msecs_to_jiffies(expires * MSEC_PER_SEC);
+
+	add_timer(&seed_timer);
+}
+
+static void __init __prandom_start_seed_timer(void)
+{
+	set_timer_slack(&seed_timer, HZ);
+	seed_timer.expires = jiffies + msecs_to_jiffies(40 * MSEC_PER_SEC);
+	add_timer(&seed_timer);
+}
 
 /*
  *	Generate better values after random number generator
  *	is fully initialized.
  */
-static int __init random32_reseed(void)
+static void __prandom_reseed(bool late)
 {
 	int i;
+	unsigned long flags;
+	static bool latch = false;
+	static DEFINE_SPINLOCK(lock);
+
+	/* Asking for random bytes might result in bytes getting
+	 * moved into the nonblocking pool and thus marking it
+	 * as initialized. In this case we would double back into
+	 * this function and attempt to do a late reseed.
+	 * Ignore the pointless attempt to reseed again if we're
+	 * already waiting for bytes when the nonblocking pool
+	 * got initialized.
+	 */
+
+	/* only allow initial seeding (late == false) once */
+	if (!spin_trylock_irqsave(&lock, flags))
+		return;
+
+	if (latch && !late)
+		goto out;
+
+	latch = true;
 
 	for_each_possible_cpu(i) {
 		struct rnd_state *state = &per_cpu(net_rand_state,i);
-		u32 seeds[3];
+		u32 seeds[4];
 
 		get_random_bytes(&seeds, sizeof(seeds));
-		state->s1 = __seed(seeds[0], 1);
-		state->s2 = __seed(seeds[1], 7);
-		state->s3 = __seed(seeds[2], 15);
+		state->s1 = __seed(seeds[0],   2U);
+		state->s2 = __seed(seeds[1],   8U);
+		state->s3 = __seed(seeds[2],  16U);
+		state->s4 = __seed(seeds[3], 128U);
 
-		/* mix it in */
-		prandom32(state);
+		prandom_warmup(state);
 	}
+out:
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+void prandom_reseed_late(void)
+{
+	__prandom_reseed(true);
+}
+
+static int __init prandom_reseed(void)
+{
+	__prandom_reseed(false);
+	__prandom_start_seed_timer();
 	return 0;
 }
-late_initcall(random32_reseed);
+late_initcall(prandom_reseed);
+
+#ifdef CONFIG_RANDOM32_SELFTEST
+static struct prandom_test1 {
+	u32 seed;
+	u32 result;
+} test1[] = {
+	{ 1U, 3484351685U },
+	{ 2U, 2623130059U },
+	{ 3U, 3125133893U },
+	{ 4U,  984847254U },
+};
+
+static struct prandom_test2 {
+	u32 seed;
+	u32 iteration;
+	u32 result;
+} test2[] = {
+	/* Test cases against taus113 from GSL library. */
+	{  931557656U, 959U, 2975593782U },
+	{ 1339693295U, 876U, 3887776532U },
+	{ 1545556285U, 961U, 1615538833U },
+	{  601730776U, 723U, 1776162651U },
+	{ 1027516047U, 687U,  511983079U },
+	{  416526298U, 700U,  916156552U },
+	{ 1395522032U, 652U, 2222063676U },
+	{  366221443U, 617U, 2992857763U },
+	{ 1539836965U, 714U, 3783265725U },
+	{  556206671U, 994U,  799626459U },
+	{  684907218U, 799U,  367789491U },
+	{ 2121230701U, 931U, 2115467001U },
+	{ 1668516451U, 644U, 3620590685U },
+	{  768046066U, 883U, 2034077390U },
+	{ 1989159136U, 833U, 1195767305U },
+	{  536585145U, 996U, 3577259204U },
+	{ 1008129373U, 642U, 1478080776U },
+	{ 1740775604U, 939U, 1264980372U },
+	{ 1967883163U, 508U,   10734624U },
+	{ 1923019697U, 730U, 3821419629U },
+	{  442079932U, 560U, 3440032343U },
+	{ 1961302714U, 845U,  841962572U },
+	{ 2030205964U, 962U, 1325144227U },
+	{ 1160407529U, 507U,  240940858U },
+	{  635482502U, 779U, 4200489746U },
+	{ 1252788931U, 699U,  867195434U },
+	{ 1961817131U, 719U,  668237657U },
+	{ 1071468216U, 983U,  917876630U },
+	{ 1281848367U, 932U, 1003100039U },
+	{  582537119U, 780U, 1127273778U },
+	{ 1973672777U, 853U, 1071368872U },
+	{ 1896756996U, 762U, 1127851055U },
+	{  847917054U, 500U, 1717499075U },
+	{ 1240520510U, 951U, 2849576657U },
+	{ 1685071682U, 567U, 1961810396U },
+	{ 1516232129U, 557U,    3173877U },
+	{ 1208118903U, 612U, 1613145022U },
+	{ 1817269927U, 693U, 4279122573U },
+	{ 1510091701U, 717U,  638191229U },
+	{  365916850U, 807U,  600424314U },
+	{  399324359U, 702U, 1803598116U },
+	{ 1318480274U, 779U, 2074237022U },
+	{  697758115U, 840U, 1483639402U },
+	{ 1696507773U, 840U,  577415447U },
+	{ 2081979121U, 981U, 3041486449U },
+	{  955646687U, 742U, 3846494357U },
+	{ 1250683506U, 749U,  836419859U },
+	{  595003102U, 534U,  366794109U },
+	{   47485338U, 558U, 3521120834U },
+	{  619433479U, 610U, 3991783875U },
+	{  704096520U, 518U, 4139493852U },
+	{ 1712224984U, 606U, 2393312003U },
+	{ 1318233152U, 922U, 3880361134U },
+	{  855572992U, 761U, 1472974787U },
+	{   64721421U, 703U,  683860550U },
+	{  678931758U, 840U,  380616043U },
+	{  692711973U, 778U, 1382361947U },
+	{  677703619U, 530U, 2826914161U },
+	{   92393223U, 586U, 1522128471U },
+	{ 1222592920U, 743U, 3466726667U },
+	{  358288986U, 695U, 1091956998U },
+	{ 1935056945U, 958U,  514864477U },
+	{  735675993U, 990U, 1294239989U },
+	{ 1560089402U, 897U, 2238551287U },
+	{   70616361U, 829U,   22483098U },
+	{  368234700U, 731U, 2913875084U },
+	{   20221190U, 879U, 1564152970U },
+	{  539444654U, 682U, 1835141259U },
+	{ 1314987297U, 840U, 1801114136U },
+	{ 2019295544U, 645U, 3286438930U },
+	{  469023838U, 716U, 1637918202U },
+	{ 1843754496U, 653U, 2562092152U },
+	{  400672036U, 809U, 4264212785U },
+	{  404722249U, 965U, 2704116999U },
+	{  600702209U, 758U,  584979986U },
+	{  519953954U, 667U, 2574436237U },
+	{ 1658071126U, 694U, 2214569490U },
+	{  420480037U, 749U, 3430010866U },
+	{  690103647U, 969U, 3700758083U },
+	{ 1029424799U, 937U, 3787746841U },
+	{ 2012608669U, 506U, 3362628973U },
+	{ 1535432887U, 998U,   42610943U },
+	{ 1330635533U, 857U, 3040806504U },
+	{ 1223800550U, 539U, 3954229517U },
+	{ 1322411537U, 680U, 3223250324U },
+	{ 1877847898U, 945U, 2915147143U },
+	{ 1646356099U, 874U,  965988280U },
+	{  805687536U, 744U, 4032277920U },
+	{ 1948093210U, 633U, 1346597684U },
+	{  392609744U, 783U, 1636083295U },
+	{  690241304U, 770U, 1201031298U },
+	{ 1360302965U, 696U, 1665394461U },
+	{ 1220090946U, 780U, 1316922812U },
+	{  447092251U, 500U, 3438743375U },
+	{ 1613868791U, 592U,  828546883U },
+	{  523430951U, 548U, 2552392304U },
+	{  726692899U, 810U, 1656872867U },
+	{ 1364340021U, 836U, 3710513486U },
+	{ 1986257729U, 931U,  935013962U },
+	{  407983964U, 921U,  728767059U },
+};
+
+static void __init prandom_state_selftest(void)
+{
+	int i, j, errors = 0, runs = 0;
+	bool error = false;
+
+	for (i = 0; i < ARRAY_SIZE(test1); i++) {
+		struct rnd_state state;
+
+		prandom_seed_very_weak(&state, test1[i].seed);
+		prandom_warmup(&state);
+
+		if (test1[i].result != prandom_u32_state(&state))
+			error = true;
+	}
+
+	if (error)
+		pr_warn("prandom: seed boundary self test failed\n");
+	else
+		pr_info("prandom: seed boundary self test passed\n");
+
+	for (i = 0; i < ARRAY_SIZE(test2); i++) {
+		struct rnd_state state;
+
+		prandom_seed_very_weak(&state, test2[i].seed);
+		prandom_warmup(&state);
+
+		for (j = 0; j < test2[i].iteration - 1; j++)
+			prandom_u32_state(&state);
+
+		if (test2[i].result != prandom_u32_state(&state))
+			errors++;
+
+		runs++;
+		cond_resched();
+	}
+
+	if (errors)
+		pr_warn("prandom: %d/%d self tests failed\n", errors, runs);
+	else
+		pr_info("prandom: %d self tests passed\n", runs);
+}
+#endif
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/trace/events/random.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/trace/events/random.h
@@ -0,0 +1,320 @@
+///////////////////////////////////////////////////////////////////////////////
+// Entropy backport from Linux 3.16.43 to AsusWrt
+//
+// SOURCE: Linux 3.16.43, include/trace/events/random.h
+///////////////////////////////////////////////////////////////////////////////
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM random
+
+#if !defined(_TRACE_RANDOM_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_RANDOM_H
+
+#include <linux/writeback.h>
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(add_device_randomness,
+	TP_PROTO(int bytes, unsigned long IP),
+
+	TP_ARGS(bytes, IP),
+
+	TP_STRUCT__entry(
+		__field(	  int,	bytes			)
+		__field(unsigned long,	IP			)
+	),
+
+	TP_fast_assign(
+		__entry->bytes		= bytes;
+		__entry->IP		= IP;
+	),
+
+	TP_printk("bytes %d caller %pF",
+		__entry->bytes, (void *)__entry->IP)
+);
+
+DECLARE_EVENT_CLASS(random__mix_pool_bytes,
+	TP_PROTO(const char *pool_name, int bytes, unsigned long IP),
+
+	TP_ARGS(pool_name, bytes, IP),
+
+	TP_STRUCT__entry(
+		__field( const char *,	pool_name		)
+		__field(	  int,	bytes			)
+		__field(unsigned long,	IP			)
+	),
+
+	TP_fast_assign(
+		__entry->pool_name	= pool_name;
+		__entry->bytes		= bytes;
+		__entry->IP		= IP;
+	),
+
+	TP_printk("%s pool: bytes %d caller %pF",
+		  __entry->pool_name, __entry->bytes, (void *)__entry->IP)
+);
+
+DEFINE_EVENT(random__mix_pool_bytes, mix_pool_bytes,
+	TP_PROTO(const char *pool_name, int bytes, unsigned long IP),
+
+	TP_ARGS(pool_name, bytes, IP)
+);
+
+DEFINE_EVENT(random__mix_pool_bytes, mix_pool_bytes_nolock,
+	TP_PROTO(const char *pool_name, int bytes, unsigned long IP),
+
+	TP_ARGS(pool_name, bytes, IP)
+);
+
+TRACE_EVENT(credit_entropy_bits,
+	TP_PROTO(const char *pool_name, int bits, int entropy_count,
+		 int entropy_total, unsigned long IP),
+
+	TP_ARGS(pool_name, bits, entropy_count, entropy_total, IP),
+
+	TP_STRUCT__entry(
+		__field( const char *,	pool_name		)
+		__field(	  int,	bits			)
+		__field(	  int,	entropy_count		)
+		__field(	  int,	entropy_total		)
+		__field(unsigned long,	IP			)
+	),
+
+	TP_fast_assign(
+		__entry->pool_name	= pool_name;
+		__entry->bits		= bits;
+		__entry->entropy_count	= entropy_count;
+		__entry->entropy_total	= entropy_total;
+		__entry->IP		= IP;
+	),
+
+	TP_printk("%s pool: bits %d entropy_count %d entropy_total %d "
+		  "caller %pF", __entry->pool_name, __entry->bits,
+		  __entry->entropy_count, __entry->entropy_total,
+		  (void *)__entry->IP)
+);
+
+TRACE_EVENT(push_to_pool,
+	TP_PROTO(const char *pool_name, int pool_bits, int input_bits),
+
+	TP_ARGS(pool_name, pool_bits, input_bits),
+
+	TP_STRUCT__entry(
+		__field( const char *,	pool_name		)
+		__field(	  int,	pool_bits		)
+		__field(	  int,	input_bits		)
+	),
+
+	TP_fast_assign(
+		__entry->pool_name	= pool_name;
+		__entry->pool_bits	= pool_bits;
+		__entry->input_bits	= input_bits;
+	),
+
+	TP_printk("%s: pool_bits %d input_pool_bits %d",
+		  __entry->pool_name, __entry->pool_bits,
+		  __entry->input_bits)
+);
+
+TRACE_EVENT(debit_entropy,
+	TP_PROTO(const char *pool_name, int debit_bits),
+
+	TP_ARGS(pool_name, debit_bits),
+
+	TP_STRUCT__entry(
+		__field( const char *,	pool_name		)
+		__field(	  int,	debit_bits		)
+	),
+
+	TP_fast_assign(
+		__entry->pool_name	= pool_name;
+		__entry->debit_bits	= debit_bits;
+	),
+
+	TP_printk("%s: debit_bits %d", __entry->pool_name,
+		  __entry->debit_bits)
+);
+
+TRACE_EVENT(add_input_randomness,
+	TP_PROTO(int input_bits),
+
+	TP_ARGS(input_bits),
+
+	TP_STRUCT__entry(
+		__field(	  int,	input_bits		)
+	),
+
+	TP_fast_assign(
+		__entry->input_bits	= input_bits;
+	),
+
+	TP_printk("input_pool_bits %d", __entry->input_bits)
+);
+
+TRACE_EVENT(add_disk_randomness,
+	TP_PROTO(dev_t dev, int input_bits),
+
+	TP_ARGS(dev, input_bits),
+
+	TP_STRUCT__entry(
+		__field(	dev_t,	dev			)
+		__field(	  int,	input_bits		)
+	),
+
+	TP_fast_assign(
+		__entry->dev		= dev;
+		__entry->input_bits	= input_bits;
+	),
+
+	TP_printk("dev %d,%d input_pool_bits %d", MAJOR(__entry->dev),
+		  MINOR(__entry->dev), __entry->input_bits)
+);
+
+TRACE_EVENT(xfer_secondary_pool,
+	TP_PROTO(const char *pool_name, int xfer_bits, int request_bits,
+		 int pool_entropy, int input_entropy),
+
+	TP_ARGS(pool_name, xfer_bits, request_bits, pool_entropy,
+		input_entropy),
+
+	TP_STRUCT__entry(
+		__field( const char *,	pool_name		)
+		__field(	  int,	xfer_bits		)
+		__field(	  int,	request_bits		)
+		__field(	  int,	pool_entropy		)
+		__field(	  int,	input_entropy		)
+	),
+
+	TP_fast_assign(
+		__entry->pool_name	= pool_name;
+		__entry->xfer_bits	= xfer_bits;
+		__entry->request_bits	= request_bits;
+		__entry->pool_entropy	= pool_entropy;
+		__entry->input_entropy	= input_entropy;
+	),
+
+	TP_printk("pool %s xfer_bits %d request_bits %d pool_entropy %d "
+		  "input_entropy %d", __entry->pool_name, __entry->xfer_bits,
+		  __entry->request_bits, __entry->pool_entropy,
+		  __entry->input_entropy)
+);
+
+DECLARE_EVENT_CLASS(random__get_random_bytes,
+	TP_PROTO(int nbytes, unsigned long IP),
+
+	TP_ARGS(nbytes, IP),
+
+	TP_STRUCT__entry(
+		__field(	  int,	nbytes			)
+		__field(unsigned long,	IP			)
+	),
+
+	TP_fast_assign(
+		__entry->nbytes		= nbytes;
+		__entry->IP		= IP;
+	),
+
+	TP_printk("nbytes %d caller %pF", __entry->nbytes, (void *)__entry->IP)
+);
+
+DEFINE_EVENT(random__get_random_bytes, get_random_bytes,
+	TP_PROTO(int nbytes, unsigned long IP),
+
+	TP_ARGS(nbytes, IP)
+);
+
+DEFINE_EVENT(random__get_random_bytes, get_random_bytes_arch,
+	TP_PROTO(int nbytes, unsigned long IP),
+
+	TP_ARGS(nbytes, IP)
+);
+
+DECLARE_EVENT_CLASS(random__extract_entropy,
+	TP_PROTO(const char *pool_name, int nbytes, int entropy_count,
+		 unsigned long IP),
+
+	TP_ARGS(pool_name, nbytes, entropy_count, IP),
+
+	TP_STRUCT__entry(
+		__field( const char *,	pool_name		)
+		__field(	  int,	nbytes			)
+		__field(	  int,	entropy_count		)
+		__field(unsigned long,	IP			)
+	),
+
+	TP_fast_assign(
+		__entry->pool_name	= pool_name;
+		__entry->nbytes		= nbytes;
+		__entry->entropy_count	= entropy_count;
+		__entry->IP		= IP;
+	),
+
+	TP_printk("%s pool: nbytes %d entropy_count %d caller %pF",
+		  __entry->pool_name, __entry->nbytes, __entry->entropy_count,
+		  (void *)__entry->IP)
+);
+
+
+DEFINE_EVENT(random__extract_entropy, extract_entropy,
+	TP_PROTO(const char *pool_name, int nbytes, int entropy_count,
+		 unsigned long IP),
+
+	TP_ARGS(pool_name, nbytes, entropy_count, IP)
+);
+
+DEFINE_EVENT(random__extract_entropy, extract_entropy_user,
+	TP_PROTO(const char *pool_name, int nbytes, int entropy_count,
+		 unsigned long IP),
+
+	TP_ARGS(pool_name, nbytes, entropy_count, IP)
+);
+
+TRACE_EVENT(random_read,
+	TP_PROTO(int got_bits, int need_bits, int pool_left, int input_left),
+
+	TP_ARGS(got_bits, need_bits, pool_left, input_left),
+
+	TP_STRUCT__entry(
+		__field(	  int,	got_bits		)
+		__field(	  int,	need_bits		)
+		__field(	  int,	pool_left		)
+		__field(	  int,	input_left		)
+	),
+
+	TP_fast_assign(
+		__entry->got_bits	= got_bits;
+		__entry->need_bits	= need_bits;
+		__entry->pool_left	= pool_left;
+		__entry->input_left	= input_left;
+	),
+
+	TP_printk("got_bits %d still_needed_bits %d "
+		  "blocking_pool_entropy_left %d input_entropy_left %d",
+		  __entry->got_bits, __entry->got_bits, __entry->pool_left,
+		  __entry->input_left)
+);
+
+TRACE_EVENT(urandom_read,
+	TP_PROTO(int got_bits, int pool_left, int input_left),
+
+	TP_ARGS(got_bits, pool_left, input_left),
+
+	TP_STRUCT__entry(
+		__field(	  int,	got_bits		)
+		__field(	  int,	pool_left		)
+		__field(	  int,	input_left		)
+	),
+
+	TP_fast_assign(
+		__entry->got_bits	= got_bits;
+		__entry->pool_left	= pool_left;
+		__entry->input_left	= input_left;
+	),
+
+	TP_printk("got_bits %d nonblocking_pool_entropy_left %d "
+		  "input_entropy_left %d", __entry->got_bits,
+		  __entry->pool_left, __entry->input_left)
+);
+
+#endif /* _TRACE_RANDOM_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/kernel/irq/handle.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/kernel/irq/handle.c
@@ -445,8 +445,8 @@
 		action = action->next;
 	} while (action);
 
-	if (status & IRQF_SAMPLE_RANDOM)
-		add_interrupt_randomness(irq);
+	add_interrupt_randomness(irq, status);
+
 	local_irq_disable();
 
 	return retval;
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/kernel/irq/manage.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/kernel/irq/manage.c
@@ -659,22 +659,6 @@
 
 	if (desc->chip == &no_irq_chip)
 		return -ENOSYS;
-	/*
-	 * Some drivers like serial.c use request_irq() heavily,
-	 * so we have to be careful not to interfere with a
-	 * running system.
-	 */
-	if (new->flags & IRQF_SAMPLE_RANDOM) {
-		/*
-		 * This function might sleep, we want to call it first,
-		 * outside of the atomic block.
-		 * Yes, this might clear the entropy pool if the wrong
-		 * driver is attempted to be loaded, without actually
-		 * installing a new handler, but is this really a problem,
-		 * only the sysadmin is able to do this.
-		 */
-		rand_initialize_irq(irq);
-	}
 
 	/* Oneshot interrupts are not allowed with shared */
 	if ((new->flags & IRQF_ONESHOT) && (new->flags & IRQF_SHARED))
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/kernel/posix-cpu-timers.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/kernel/posix-cpu-timers.c
@@ -9,6 +9,7 @@
 #include <asm/uaccess.h>
 #include <linux/kernel_stat.h>
 #include <trace/events/timer.h>
+#include <linux/random.h>
 
 /*
  * Called after updating RLIMIT_CPU to run cpu timer and update
@@ -507,6 +508,8 @@
  */
 void posix_cpu_timers_exit(struct task_struct *tsk)
 {
+	add_device_randomness((const void*) &tsk->se.sum_exec_runtime,
+						sizeof(unsigned long long));
 	cleanup_timers(tsk->cpu_timers,
 		       tsk->utime, tsk->stime, tsk->se.sum_exec_runtime);
 
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/core/hub.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/core/hub.c
@@ -24,6 +24,7 @@
 #include <linux/kthread.h>
 #include <linux/mutex.h>
 #include <linux/freezer.h>
+#include <linux/random.h>
 #include <linux/pm_runtime.h>
 
 #include <asm/uaccess.h>
@@ -1846,6 +1847,14 @@
 	/* Tell the world! */
 	announce_device(udev);
 
+	if (udev->serial)
+		add_device_randomness(udev->serial, strlen(udev->serial));
+	if (udev->product)
+		add_device_randomness(udev->product, strlen(udev->product));
+	if (udev->manufacturer)
+		add_device_randomness(udev->manufacturer,
+				      strlen(udev->manufacturer));
+
 	device_enable_async_suspend(&udev->dev);
 	/* Register the device.  The device driver is responsible
 	 * for configuring the device and invoking the add-device
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/core/dev.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/core/dev.c
@@ -1185,6 +1185,8 @@
 		 *	Wakeup transmit queue engine
 		 */
 		dev_activate(dev);
+
+		add_device_randomness(dev->dev_addr, dev->addr_len);
 	}
 
 	return ret;
@@ -4438,6 +4440,8 @@
 	err = ops->ndo_set_mac_address(dev, sa);
 	if (!err)
 		call_netdevice_notifiers(NETDEV_CHANGEADDR, dev);
+
+	add_device_randomness(dev->dev_addr, dev->addr_len);
 	return err;
 }
 EXPORT_SYMBOL(dev_set_mac_address);
@@ -5101,6 +5105,7 @@
 	dev_init_scheduler(dev);
 	dev_hold(dev);
 	list_netdevice(dev);
+	add_device_randomness(dev->dev_addr, dev->addr_len);
 
 	/* Notify protocols, that a new device appeared. */
 	ret = call_netdevice_notifiers(NETDEV_REGISTER, dev);
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/config_base.6a
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/config_base.6a
@@ -497,7 +497,7 @@
 CONFIG_NETFILTER_NETLINK_LOG=y
 CONFIG_NF_CONNTRACK=y
 CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
+CONFIG_NF_CONNTRACK_EVENTS=y
 # CONFIG_NF_CT_PROTO_DCCP is not set
 CONFIG_NF_CT_PROTO_GRE=y
 # CONFIG_NF_CT_PROTO_SCTP is not set
@@ -541,9 +541,17 @@
 # CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
 # CONFIG_NETFILTER_XT_TARGET_TEE is not set
 # CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETFILTER_XT_TARGET_ACCOUNT is not set
+CONFIG_NETFILTER_XT_TARGET_CHAOS=m
+CONFIG_NETFILTER_XT_TARGET_DELUDE=m
+# CONFIG_NETFILTER_XT_TARGET_ECHO is not set
+CONFIG_NETFILTER_XT_TARGET_RAWNAT=m
+CONFIG_NETFILTER_XT_TARGET_STEAL=m
+CONFIG_NETFILTER_XT_TARGET_TARPIT=m
 CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
 # CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
 # CONFIG_NETFILTER_XT_MATCH_LAYER7 is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG is not set
 
 #
 # Xtables matches
@@ -577,7 +585,7 @@
 CONFIG_NETFILTER_XT_MATCH_RECENT=y
 # CONFIG_NETFILTER_XT_MATCH_SCTP is not set
 CONFIG_NETFILTER_XT_MATCH_STATE=y
-# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
 CONFIG_NETFILTER_XT_MATCH_STRING=y
 CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
 CONFIG_NETFILTER_XT_MATCH_TIME=y
@@ -585,6 +593,13 @@
 CONFIG_NETFILTER_XT_MATCH_WEBSTR=y
 CONFIG_NETFILTER_XT_MATCH_CONDITION=m
 CONFIG_NETFILTER_XT_MATCH_GEOIP=m
+CONFIG_NETFILTER_XT_MATCH_FUZZY=m
+CONFIG_NETFILTER_XT_MATCH_IFACE=m
+CONFIG_NETFILTER_XT_MATCH_IPV4OPTIONS=m
+CONFIG_NETFILTER_XT_MATCH_LSCAN=m
+CONFIG_NETFILTER_XT_MATCH_PKNOCK=m
+CONFIG_NETFILTER_XT_MATCH_PSD=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=m
 CONFIG_IP_SET=m
 CONFIG_IP_SET_MAX=256
 CONFIG_IP_SET_BITMAP_IP=m
@@ -1043,7 +1058,28 @@
 # CONFIG_SCSI_DH is not set
 # CONFIG_SCSI_OSD_INITIATOR is not set
 # CONFIG_ATA is not set
-# CONFIG_MD is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MULTICORE_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=m
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_MULTIPATH_QL is not set
+# CONFIG_DM_MULTIPATH_ST is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
 # CONFIG_FUSION is not set
 
 #
@@ -1314,7 +1350,10 @@
 #
 # PPS support
 #
-# CONFIG_PPS is not set
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_LDISC=m
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -1442,13 +1481,13 @@
 # CONFIG_USB_SERIAL_AIRCABLE is not set
 # CONFIG_USB_SERIAL_ARK3116 is not set
 # CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
+CONFIG_USB_SERIAL_CH341=m
 # CONFIG_USB_SERIAL_WHITEHEAT is not set
 # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_CP210X is not set
+CONFIG_USB_SERIAL_CP210X=m
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
 # CONFIG_USB_SERIAL_FUNSOFT is not set
 # CONFIG_USB_SERIAL_VISOR is not set
 # CONFIG_USB_SERIAL_IPAQ is not set
@@ -1467,7 +1506,7 @@
 # CONFIG_USB_SERIAL_MOS7840 is not set
 # CONFIG_USB_SERIAL_MOTOROLA is not set
 # CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
+CONFIG_USB_SERIAL_PL2303=m
 # CONFIG_USB_SERIAL_OTI6858 is not set
 # CONFIG_USB_SERIAL_QCAUX is not set
 # CONFIG_USB_SERIAL_QUALCOMM is not set
@@ -1592,8 +1631,11 @@
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
@@ -1642,11 +1684,12 @@
 # CONFIG_JFFS2_CMODE_SIZE is not set
 # CONFIG_JFFS2_CMODE_FAVOURLZO is not set
 # CONFIG_LOGFS is not set
-# CONFIG_CRAMFS is not set
+CONFIG_CRAMFS=m
 CONFIG_SQUASHFS=y
 # CONFIG_SQUASHFS_XATTR is not set
 # CONFIG_SQUASHFS_LZO is not set
 CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
 CONFIG_SQUASHFS_EMBEDDED=y
 CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
 # CONFIG_VXFS_FS is not set
@@ -1839,7 +1882,7 @@
 CONFIG_CRYPTO_ECB=y
 # CONFIG_CRYPTO_LRW is not set
 # CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
+CONFIG_CRYPTO_XTS=m
 
 #
 # Hash modes
@@ -1856,41 +1899,42 @@
 # CONFIG_CRYPTO_MD4 is not set
 CONFIG_CRYPTO_MD5=y
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
 CONFIG_CRYPTO_SHA1=y
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
 
 #
 # Ciphers
 #
 CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ANUBIS=m
 CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_DES=m
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
 
 #
 # Compression
 #
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=m
 
 #
 # Random Number Generation
@@ -1898,9 +1942,17 @@
 CONFIG_CRYPTO_ANSI_CPRNG=y
 CONFIG_CRYPTO_HW=y
 # CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X_RNG is not set
 # CONFIG_BINARY_PRINTF is not set
 
 #
+# User-space algorithms
+#
+CONFIG_CRYPTO_USER_API=m
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+
+#
 # Library routines
 #
 CONFIG_BITREVERSE=y
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
@@ -1868,8 +1868,20 @@
 	   are only processed once.  */
 	status = packet[0] & FTDI_STATUS_B0_MASK;
 	if (status != priv->prev_status) {
-		priv->diff_status |= status ^ priv->prev_status;
-		wake_up_interruptible(&priv->delta_msr_wait);
+                char diff_status = status ^ priv->prev_status;
+                priv->diff_status |= diff_status;
+        
+                if (diff_status & FTDI_RS0_RLSD) {
+                        struct tty_struct *tty;
+ 
+                        tty = tty_port_tty_get(&port->port);
+                        if (tty)
+                                usb_serial_handle_dcd_change(port, tty,
+                                                status & FTDI_RS0_RLSD);
+                        tty_kref_put(tty);
+                }
+
+                wake_up_interruptible(&priv->delta_msr_wait);
 		priv->prev_status = status;
 	}
 
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/drivers/usb/serial/generic.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/drivers/usb/serial/generic.c
@@ -491,6 +491,15 @@
 	struct tty_port *port = &usb_port->port;
 
 	dbg("%s - port %d, status %d", __func__, usb_port->number, status);
+        if (tty) {
+               struct tty_ldisc *ld = tty_ldisc_ref(tty);
+
+               if (ld) {
+                       if (ld->ops->dcd_change)
+                               ld->ops->dcd_change(tty, status, NULL);
+                       tty_ldisc_deref(ld);
+               }
+        }
 
 	if (status)
 		wake_up_interruptible(&port->open_wait);
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/Kconfig
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/Kconfig
@@ -66,6 +66,28 @@
 
 	  If unsure, say N.
 
+config SQUASHFS_4K_DEVBLK_SIZE
+	bool "Use 4K device block size?"
+	depends on SQUASHFS
+	help
+	  By default Squashfs sets the dev block size (sb_min_blocksize)
+	  to 1K or the smallest block size supported by the block device
+	  (if larger).  This, because blocks are packed together and
+	  unaligned in Squashfs, should reduce latency.
+
+	  This, however, gives poor performance on MTD NAND devices where
+	  the optimal I/O size is 4K (even though the devices can support
+	  smaller block sizes).
+
+	  Using a 4K device block size may also improve overall I/O
+	  performance for some file access patterns (e.g. sequential
+	  accesses of files in filesystem order) on all media.
+
+	  Setting this option will force Squashfs to use a 4K device block
+	  size by default.
+
+	  If unsure, say N.
+
 config SQUASHFS_EMBEDDED
 	bool "Additional option for memory-constrained systems"
 	depends on SQUASHFS
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
@@ -37,6 +37,13 @@
 #define SQUASHFS_FILE_SIZE		131072
 #define SQUASHFS_FILE_LOG		17
 
+/* default size of block device I/O */
+#ifdef CONFIG_SQUASHFS_4K_DEVBLK_SIZE
+#define SQUASHFS_DEVBLK_SIZE 4096
+#else
+#define SQUASHFS_DEVBLK_SIZE 1024
+#endif
+
 #define SQUASHFS_FILE_MAX_SIZE		1048576
 #define SQUASHFS_FILE_MAX_LOG		20
 
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/super.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/super.c
@@ -102,7 +102,7 @@
 		goto failure;
 	}
 
-	msblk->devblksize = sb_min_blocksize(sb, BLOCK_SIZE);
+	msblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);
 	msblk->devblksize_log2 = ffz(~msblk->devblksize);
 
 	mutex_init(&msblk->read_data_mutex);
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/Makefile
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/Makefile
@@ -85,6 +85,9 @@
 obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
 obj-$(CONFIG_CRYPTO_GHASH) += ghash-generic.o
+obj-$(CONFIG_CRYPTO_USER_API) += af_alg.o
+obj-$(CONFIG_CRYPTO_USER_API_HASH) += algif_hash.o
+obj-$(CONFIG_CRYPTO_USER_API_SKCIPHER) += algif_skcipher.o
 
 #
 # generic algorithms and the async_tx api
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/Kconfig
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/Kconfig
@@ -842,6 +842,27 @@
 	  ANSI X9.31 A.2.4. Note that this option must be enabled if
 	  CRYPTO_FIPS is selected
 
+config CRYPTO_USER_API
+	tristate
+
+config CRYPTO_USER_API_HASH
+	tristate "User-space interface for hash algorithms"
+	depends on NET
+	select CRYPTO_HASH
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for hash
+	  algorithms.
+
+config CRYPTO_USER_API_SKCIPHER
+	tristate "User-space interface for symmetric key cipher algorithms"
+	depends on NET
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for symmetric
+	  key cipher algorithms.
+
 source "drivers/crypto/Kconfig"
 
 endif	# if CRYPTO
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/af_alg.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/af_alg.c
@@ -0,0 +1,483 @@
+/*
+ * af_alg: User-space algorithm interface
+ *
+ * This file provides the user-space API for algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <asm/atomic.h>
+#include <crypto/if_alg.h>
+#include <linux/crypto.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/rwsem.h>
+
+struct alg_type_list {
+	const struct af_alg_type *type;
+	struct list_head list;
+};
+
+static atomic_long_t alg_memory_allocated;
+
+static struct proto alg_proto = {
+	.name			= "ALG",
+	.owner			= THIS_MODULE,
+	.memory_allocated	= &alg_memory_allocated,
+	.obj_size		= sizeof(struct alg_sock),
+};
+
+static LIST_HEAD(alg_types);
+static DECLARE_RWSEM(alg_types_sem);
+
+static const struct af_alg_type *alg_get_type(const char *name)
+{
+	const struct af_alg_type *type = ERR_PTR(-ENOENT);
+	struct alg_type_list *node;
+
+	down_read(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, name))
+			continue;
+
+		if (try_module_get(node->type->owner))
+			type = node->type;
+		break;
+	}
+	up_read(&alg_types_sem);
+
+	return type;
+}
+
+int af_alg_register_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -EEXIST;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (!strcmp(node->type->name, type->name))
+			goto unlock;
+	}
+
+	node = kmalloc(sizeof(*node), GFP_KERNEL);
+	err = -ENOMEM;
+	if (!node)
+		goto unlock;
+
+	type->ops->owner = THIS_MODULE;
+	node->type = type;
+	list_add(&node->list, &alg_types);
+	err = 0;
+
+unlock:
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_register_type);
+
+int af_alg_unregister_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -ENOENT;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, type->name))
+			continue;
+
+		list_del(&node->list);
+		kfree(node);
+		err = 0;
+		break;
+	}
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_unregister_type);
+
+static void alg_do_release(const struct af_alg_type *type, void *private)
+{
+	if (!type)
+		return;
+
+	type->release(private);
+	module_put(type->owner);
+}
+
+int af_alg_release(struct socket *sock)
+{
+	if (sock->sk)
+		sock_put(sock->sk);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_release);
+
+static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct sockaddr_alg *sa = (void *)uaddr;
+	const struct af_alg_type *type;
+	void *private;
+
+	if (sock->state == SS_CONNECTED)
+		return -EINVAL;
+
+	if (addr_len != sizeof(*sa))
+		return -EINVAL;
+
+	sa->salg_type[sizeof(sa->salg_type) - 1] = 0;
+	sa->salg_name[sizeof(sa->salg_name) - 1] = 0;
+
+	type = alg_get_type(sa->salg_type);
+	if (IS_ERR(type) && PTR_ERR(type) == -ENOENT) {
+		request_module("algif-%s", sa->salg_type);
+		type = alg_get_type(sa->salg_type);
+	}
+
+	if (IS_ERR(type))
+		return PTR_ERR(type);
+
+	private = type->bind(sa->salg_name, sa->salg_feat, sa->salg_mask);
+	if (IS_ERR(private)) {
+		module_put(type->owner);
+		return PTR_ERR(private);
+	}
+
+	lock_sock(sk);
+
+	swap(ask->type, type);
+	swap(ask->private, private);
+
+	release_sock(sk);
+
+	alg_do_release(type, private);
+
+	return 0;
+}
+
+static int alg_setkey(struct sock *sk, char __user *ukey,
+		      unsigned int keylen)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type = ask->type;
+	u8 *key;
+	int err;
+
+	key = sock_kmalloc(sk, keylen, GFP_KERNEL);
+	if (!key)
+		return -ENOMEM;
+
+	err = -EFAULT;
+	if (copy_from_user(key, ukey, keylen))
+		goto out;
+
+	err = type->setkey(ask->private, key, keylen);
+
+out:
+	sock_kfree_s(sk, key, keylen);
+
+	return err;
+}
+
+static int alg_setsockopt(struct socket *sock, int level, int optname,
+			  char __user *optval, unsigned int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	int err = -ENOPROTOOPT;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	if (level != SOL_ALG || !type)
+		goto unlock;
+
+	switch (optname) {
+	case ALG_SET_KEY:
+		if (sock->state == SS_CONNECTED)
+			goto unlock;
+		if (!type->setkey)
+			goto unlock;
+
+		err = alg_setkey(sk, optval, optlen);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+
+int af_alg_accept(struct sock *sk, struct socket *newsock)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	struct sock *sk2;
+	int err;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	err = -EINVAL;
+	if (!type)
+		goto unlock;
+
+	sk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto);
+	err = -ENOMEM;
+	if (!sk2)
+		goto unlock;
+
+	sock_init_data(newsock, sk2);
+	sock_graft(sk2, newsock);
+
+	err = type->accept(ask->private, sk2);
+	if (err) {
+		sk_free(sk2);
+		goto unlock;
+	}
+
+	sk2->sk_family = PF_ALG;
+
+	sock_hold(sk);
+	alg_sk(sk2)->parent = sk;
+	alg_sk(sk2)->type = type;
+
+	newsock->ops = type->ops;
+	newsock->state = SS_CONNECTED;
+
+	err = 0;
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_accept);
+
+static int alg_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	return af_alg_accept(sock->sk, newsock);
+}
+
+static const struct proto_ops alg_proto_ops = {
+	.family		=	PF_ALG,
+	.owner		=	THIS_MODULE,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.sendpage	=	sock_no_sendpage,
+	.sendmsg	=	sock_no_sendmsg,
+	.recvmsg	=	sock_no_recvmsg,
+	.poll		=	sock_no_poll,
+
+	.bind		=	alg_bind,
+	.release	=	af_alg_release,
+	.setsockopt	=	alg_setsockopt,
+	.accept		=	alg_accept,
+};
+
+static void alg_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+
+	alg_do_release(ask->type, ask->private);
+}
+
+static int alg_create(struct net *net, struct socket *sock, int protocol,
+		      int kern)
+{
+	struct sock *sk;
+	int err;
+
+	if (sock->type != SOCK_SEQPACKET)
+		return -ESOCKTNOSUPPORT;
+	if (protocol != 0)
+		return -EPROTONOSUPPORT;
+
+	err = -ENOMEM;
+	sk = sk_alloc(net, PF_ALG, GFP_KERNEL, &alg_proto);
+	if (!sk)
+		goto out;
+
+	sock->ops = &alg_proto_ops;
+	sock_init_data(sock, sk);
+
+	sk->sk_family = PF_ALG;
+	sk->sk_destruct = alg_sock_destruct;
+
+	return 0;
+out:
+	return err;
+}
+
+static const struct net_proto_family alg_family = {
+	.family	=	PF_ALG,
+	.create	=	alg_create,
+	.owner	=	THIS_MODULE,
+};
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write)
+{
+	unsigned long from = (unsigned long)addr;
+	unsigned long npages;
+	unsigned off;
+	int err;
+	int i;
+
+	err = -EFAULT;
+	if (!access_ok(write ? VERIFY_READ : VERIFY_WRITE, addr, len))
+		goto out;
+
+	off = from & ~PAGE_MASK;
+	npages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	if (npages > ALG_MAX_PAGES)
+		npages = ALG_MAX_PAGES;
+
+	err = get_user_pages_fast(from, npages, write, sgl->pages);
+	if (err < 0)
+		goto out;
+
+	npages = err;
+	err = -EINVAL;
+	if (WARN_ON(npages == 0))
+		goto out;
+
+	err = 0;
+
+	sg_init_table(sgl->sg, npages);
+
+	for (i = 0; i < npages; i++) {
+		int plen = min_t(int, len, PAGE_SIZE - off);
+
+		sg_set_page(sgl->sg + i, sgl->pages[i], plen, off);
+
+		off = 0;
+		len -= plen;
+		err += plen;
+	}
+
+out:
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_make_sg);
+
+void af_alg_free_sg(struct af_alg_sgl *sgl)
+{
+	int i;
+
+	i = 0;
+	do {
+		put_page(sgl->pages[i]);
+	} while (!sg_is_last(sgl->sg + (i++)));
+}
+EXPORT_SYMBOL_GPL(af_alg_free_sg);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con)
+{
+	struct cmsghdr *cmsg;
+
+	for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
+		if (!CMSG_OK(msg, cmsg))
+			return -EINVAL;
+		if (cmsg->cmsg_level != SOL_ALG)
+			continue;
+
+		switch(cmsg->cmsg_type) {
+		case ALG_SET_IV:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(*con->iv)))
+				return -EINVAL;
+			con->iv = (void *)CMSG_DATA(cmsg);
+			if (cmsg->cmsg_len < CMSG_LEN(con->iv->ivlen +
+						      sizeof(*con->iv)))
+				return -EINVAL;
+			break;
+
+		case ALG_SET_OP:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))
+				return -EINVAL;
+			con->op = *(u32 *)CMSG_DATA(cmsg);
+			break;
+
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_cmsg_send);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion)
+{
+	switch (err) {
+	case -EINPROGRESS:
+	case -EBUSY:
+		wait_for_completion(&completion->completion);
+		INIT_COMPLETION(completion->completion);
+		err = completion->err;
+		break;
+	};
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_wait_for_completion);
+
+void af_alg_complete(struct crypto_async_request *req, int err)
+{
+	struct af_alg_completion *completion = req->data;
+
+	completion->err = err;
+	complete(&completion->completion);
+}
+EXPORT_SYMBOL_GPL(af_alg_complete);
+
+static int __init af_alg_init(void)
+{
+	int err = proto_register(&alg_proto, 0);
+
+	if (err)
+		goto out;
+
+	err = sock_register(&alg_family);
+	if (err != 0)
+		goto out_unregister_proto;
+
+out:
+	return err;
+
+out_unregister_proto:
+	proto_unregister(&alg_proto);
+	goto out;
+}
+
+static void __exit af_alg_exit(void)
+{
+	sock_unregister(PF_ALG);
+	proto_unregister(&alg_proto);
+}
+
+module_init(af_alg_init);
+module_exit(af_alg_exit);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_NETPROTO(AF_ALG);
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/algif_hash.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/algif_hash.c
@@ -0,0 +1,319 @@
+/*
+ * algif_hash: User-space interface for hash algorithms
+ *
+ * This file provides the user-space API for hash algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/hash.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct hash_ctx {
+	struct af_alg_sgl sgl;
+
+	u8 *result;
+
+	struct af_alg_completion completion;
+
+	unsigned int len;
+	bool more;
+
+	struct ahash_request req;
+};
+
+static int hash_sendmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t ignored)
+{
+	int limit = ALG_MAX_PAGES * PAGE_SIZE;
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned long iovlen;
+	struct iovec *iov;
+	long copied = 0;
+	int err;
+
+	if (limit > sk->sk_sndbuf)
+		limit = sk->sk_sndbuf;
+
+	lock_sock(sk);
+	if (!ctx->more) {
+		err = crypto_ahash_init(&ctx->req);
+		if (err)
+			goto unlock;
+	}
+
+	ctx->more = 0;
+
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			int len = min_t(unsigned long, seglen, limit);
+			int newlen;
+
+			newlen = af_alg_make_sg(&ctx->sgl, from, len, 0);
+			if (newlen < 0)
+				goto unlock;
+
+			ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL,
+						newlen);
+
+			err = af_alg_wait_for_completion(
+				crypto_ahash_update(&ctx->req),
+				&ctx->completion);
+
+			af_alg_free_sg(&ctx->sgl);
+
+			if (err)
+				goto unlock;
+
+			seglen -= newlen;
+			from += newlen;
+			copied += newlen;
+		}
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more) {
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err ?: copied;
+}
+
+static ssize_t hash_sendpage(struct socket *sock, struct page *page,
+			     int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	int err;
+
+	lock_sock(sk);
+	sg_init_table(ctx->sgl.sg, 1);
+	sg_set_page(ctx->sgl.sg, page, size, offset);
+
+	ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, ctx->result, size);
+
+	if (!(flags & MSG_MORE)) {
+		if (ctx->more)
+			err = crypto_ahash_finup(&ctx->req);
+		else
+			err = crypto_ahash_digest(&ctx->req);
+	} else {
+		if (!ctx->more) {
+			err = crypto_ahash_init(&ctx->req);
+			if (err)
+				goto unlock;
+		}
+
+		err = crypto_ahash_update(&ctx->req);
+	}
+
+	err = af_alg_wait_for_completion(err, &ctx->completion);
+	if (err)
+		goto unlock;
+
+	ctx->more = flags & MSG_MORE;
+
+unlock:
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t len, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
+	int err;
+
+	if (len > ds)
+		len = ds;
+	else if (len < ds)
+		msg->msg_flags |= MSG_TRUNC;
+
+	lock_sock(sk);
+	if (ctx->more) {
+		ctx->more = 0;
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+		if (err)
+			goto unlock;
+	}
+
+	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);
+
+unlock:
+	release_sock(sk);
+
+	return err ?: len;
+}
+
+static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	struct ahash_request *req = &ctx->req;
+	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];
+	struct sock *sk2;
+	struct alg_sock *ask2;
+	struct hash_ctx *ctx2;
+	int err;
+
+	err = crypto_ahash_export(req, state);
+	if (err)
+		return err;
+
+	err = af_alg_accept(ask->parent, newsock);
+	if (err)
+		return err;
+
+	sk2 = newsock->sk;
+	ask2 = alg_sk(sk2);
+	ctx2 = ask2->private;
+	ctx2->more = 1;
+
+	err = crypto_ahash_import(&ctx2->req, state);
+	if (err) {
+		sock_orphan(sk2);
+		sock_put(sk2);
+	}
+
+	return err;
+}
+
+static struct proto_ops algif_hash_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.setsockopt	=	sock_no_setsockopt,
+	.poll		=	sock_no_poll,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	hash_sendmsg,
+	.sendpage	=	hash_sendpage,
+	.recvmsg	=	hash_recvmsg,
+	.accept		=	hash_accept,
+};
+
+static void *hash_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ahash(name, type, mask);
+}
+
+static void hash_release(void *private)
+{
+	crypto_free_ahash(private);
+}
+
+static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ahash_setkey(private, key, keylen);
+}
+
+static void hash_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+
+	sock_kfree_s(sk, ctx->result,
+		     crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int hash_accept_parent(void *private, struct sock *sk)
+{
+	struct hash_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);
+	unsigned ds = crypto_ahash_digestsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);
+	if (!ctx->result) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->result, 0, ds);
+
+	ctx->len = len;
+	ctx->more = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ahash_request_set_tfm(&ctx->req, private);
+	ahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				   af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = hash_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_hash = {
+	.bind		=	hash_bind,
+	.release	=	hash_release,
+	.setkey		=	hash_setkey,
+	.accept		=	hash_accept_parent,
+	.ops		=	&algif_hash_ops,
+	.name		=	"hash",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_hash_init(void)
+{
+	return af_alg_register_type(&algif_type_hash);
+}
+
+static void __exit algif_hash_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_hash);
+	BUG_ON(err);
+}
+
+module_init(algif_hash_init);
+module_exit(algif_hash_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/algif_skcipher.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/algif_skcipher.c
@@ -0,0 +1,632 @@
+/*
+ * algif_skcipher: User-space interface for skcipher algorithms
+ *
+ * This file provides the user-space API for symmetric key ciphers.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/scatterwalk.h>
+#include <crypto/skcipher.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct skcipher_sg_list {
+	struct list_head list;
+
+	int cur;
+
+	struct scatterlist sg[0];
+};
+
+struct skcipher_ctx {
+	struct list_head tsgl;
+	struct af_alg_sgl rsgl;
+
+	void *iv;
+
+	struct af_alg_completion completion;
+
+	unsigned used;
+
+	unsigned int len;
+	bool more;
+	bool merge;
+	bool enc;
+
+	struct ablkcipher_request req;
+};
+
+#define MAX_SGL_ENTS ((PAGE_SIZE - sizeof(struct skcipher_sg_list)) / \
+		      sizeof(struct scatterlist) - 1)
+
+static inline int skcipher_sndbuf(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	return max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -
+			  ctx->used, 0);
+}
+
+static inline bool skcipher_writable(struct sock *sk)
+{
+	return PAGE_SIZE <= skcipher_sndbuf(sk);
+}
+
+static int skcipher_alloc_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg = NULL;
+
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+	if (!list_empty(&ctx->tsgl))
+		sg = sgl->sg;
+
+	if (!sg || sgl->cur >= MAX_SGL_ENTS) {
+		sgl = sock_kmalloc(sk, sizeof(*sgl) +
+				       sizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),
+				   GFP_KERNEL);
+		if (!sgl)
+			return -ENOMEM;
+
+		sg_init_table(sgl->sg, MAX_SGL_ENTS + 1);
+		sgl->cur = 0;
+
+		if (sg)
+			scatterwalk_sg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);
+
+		list_add_tail(&sgl->list, &ctx->tsgl);
+	}
+
+	return 0;
+}
+
+static void skcipher_pull_sgl(struct sock *sk, int used)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	int i;
+
+	while (!list_empty(&ctx->tsgl)) {
+		sgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,
+				       list);
+		sg = sgl->sg;
+
+		for (i = 0; i < sgl->cur; i++) {
+			int plen = min_t(int, used, sg[i].length);
+
+			if (!sg_page(sg + i))
+				continue;
+
+			sg[i].length -= plen;
+			sg[i].offset += plen;
+
+			used -= plen;
+			ctx->used -= plen;
+
+			if (sg[i].length)
+				return;
+
+			put_page(sg_page(sg + i));
+			sg_assign_page(sg + i, NULL);
+		}
+
+		list_del(&sgl->list);
+		sock_kfree_s(sk, sgl,
+			     sizeof(*sgl) + sizeof(sgl->sg[0]) *
+					    (MAX_SGL_ENTS + 1));
+	}
+
+	if (!ctx->used)
+		ctx->merge = 0;
+}
+
+static void skcipher_free_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	skcipher_pull_sgl(sk, ctx->used);
+}
+
+static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)
+{
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT)
+		return -EAGAIN;
+
+	set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	return err;
+}
+
+static void skcipher_wmem_wakeup(struct sock *sk)
+{
+	struct socket_wq *wq;
+
+	if (!skcipher_writable(sk))
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLIN |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
+	rcu_read_unlock();
+}
+
+static int skcipher_wait_for_data(struct sock *sk, unsigned flags)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT) {
+		return -EAGAIN;
+	}
+
+	set_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, ctx->used)) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	return err;
+}
+
+static void skcipher_data_wakeup(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct socket_wq *wq;
+
+	if (!ctx->used)
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLOUT |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);
+	rcu_read_unlock();
+}
+
+static int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+	unsigned ivsize = crypto_ablkcipher_ivsize(tfm);
+	struct skcipher_sg_list *sgl;
+	struct af_alg_control con = {};
+	long copied = 0;
+	bool enc = 0;
+	int err;
+	int i;
+
+	if (msg->msg_controllen) {
+		err = af_alg_cmsg_send(msg, &con);
+		if (err)
+			return err;
+
+		switch (con.op) {
+		case ALG_OP_ENCRYPT:
+			enc = 1;
+			break;
+		case ALG_OP_DECRYPT:
+			enc = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (con.iv && con.iv->ivlen != ivsize)
+			return -EINVAL;
+	}
+
+	err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!ctx->used) {
+		ctx->enc = enc;
+		if (con.iv)
+			memcpy(ctx->iv, con.iv->iv, ivsize);
+	}
+
+	while (size) {
+		struct scatterlist *sg;
+		unsigned long len = size;
+		int plen;
+
+		if (ctx->merge) {
+			sgl = list_entry(ctx->tsgl.prev,
+					 struct skcipher_sg_list, list);
+			sg = sgl->sg + sgl->cur - 1;
+			len = min_t(unsigned long, len,
+				    PAGE_SIZE - sg->offset - sg->length);
+
+			err = memcpy_fromiovec(page_address(sg_page(sg)) +
+					       sg->offset + sg->length,
+					       msg->msg_iov, len);
+			if (err)
+				goto unlock;
+
+			sg->length += len;
+			ctx->merge = (sg->offset + sg->length) &
+				     (PAGE_SIZE - 1);
+
+			ctx->used += len;
+			copied += len;
+			size -= len;
+			continue;
+		}
+
+		if (!skcipher_writable(sk)) {
+			err = skcipher_wait_for_wmem(sk, msg->msg_flags);
+			if (err)
+				goto unlock;
+		}
+
+		len = min_t(unsigned long, len, skcipher_sndbuf(sk));
+
+		err = skcipher_alloc_sgl(sk);
+		if (err)
+			goto unlock;
+
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+		sg = sgl->sg;
+		do {
+			i = sgl->cur;
+			plen = min_t(int, len, PAGE_SIZE);
+
+			sg_assign_page(sg + i, alloc_page(GFP_KERNEL));
+			err = -ENOMEM;
+			if (!sg_page(sg + i))
+				goto unlock;
+
+			err = memcpy_fromiovec(page_address(sg_page(sg + i)),
+					       msg->msg_iov, plen);
+			if (err) {
+				__free_page(sg_page(sg + i));
+				sg_assign_page(sg + i, NULL);
+				goto unlock;
+			}
+
+			sg[i].length = plen;
+			len -= plen;
+			ctx->used += plen;
+			copied += plen;
+			size -= plen;
+			sgl->cur++;
+		} while (len && sgl->cur < MAX_SGL_ENTS);
+
+		ctx->merge = plen & (PAGE_SIZE - 1);
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+static ssize_t skcipher_sendpage(struct socket *sock, struct page *page,
+				 int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	int err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!size)
+		goto done;
+
+	if (!skcipher_writable(sk)) {
+		err = skcipher_wait_for_wmem(sk, flags);
+		if (err)
+			goto unlock;
+	}
+
+	err = skcipher_alloc_sgl(sk);
+	if (err)
+		goto unlock;
+
+	ctx->merge = 0;
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+	get_page(page);
+	sg_set_page(sgl->sg + sgl->cur, page, size, offset);
+	sgl->cur++;
+	ctx->used += size;
+
+done:
+	ctx->more = flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t ignored, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(
+		&ctx->req));
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	unsigned long iovlen;
+	struct iovec *iov;
+	int err = -EAGAIN;
+	int used;
+	long copied = 0;
+
+	lock_sock(sk);
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			sgl = list_first_entry(&ctx->tsgl,
+					       struct skcipher_sg_list, list);
+			sg = sgl->sg;
+
+			while (!sg->length)
+				sg++;
+
+			used = ctx->used;
+			if (!used) {
+				err = skcipher_wait_for_data(sk, flags);
+				if (err)
+					goto unlock;
+			}
+
+			used = min_t(unsigned long, used, seglen);
+
+			used = af_alg_make_sg(&ctx->rsgl, from, used, 1);
+			err = used;
+			if (err < 0)
+				goto unlock;
+
+			if (ctx->more || used < ctx->used)
+				used -= used % bs;
+
+			err = -EINVAL;
+			if (!used)
+				goto free;
+
+			ablkcipher_request_set_crypt(&ctx->req, sg,
+						     ctx->rsgl.sg, used,
+						     ctx->iv);
+
+			err = af_alg_wait_for_completion(
+				ctx->enc ?
+					crypto_ablkcipher_encrypt(&ctx->req) :
+					crypto_ablkcipher_decrypt(&ctx->req),
+				&ctx->completion);
+
+free:
+			af_alg_free_sg(&ctx->rsgl);
+
+			if (err)
+				goto unlock;
+
+			copied += used;
+			from += used;
+			seglen -= used;
+			skcipher_pull_sgl(sk, used);
+		}
+	}
+
+	err = 0;
+
+unlock:
+	skcipher_wmem_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+
+static unsigned int skcipher_poll(struct file *file, struct socket *sock,
+				  poll_table *wait)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned int mask;
+
+	sock_poll_wait(file, sk_sleep(sk), wait);
+	mask = 0;
+
+	if (ctx->used)
+		mask |= POLLIN | POLLRDNORM;
+
+	if (skcipher_writable(sk))
+		mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
+
+	return mask;
+}
+
+static struct proto_ops algif_skcipher_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.accept		=	sock_no_accept,
+	.setsockopt	=	sock_no_setsockopt,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	skcipher_sendmsg,
+	.sendpage	=	skcipher_sendpage,
+	.recvmsg	=	skcipher_recvmsg,
+	.poll		=	skcipher_poll,
+};
+
+static void *skcipher_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ablkcipher(name, type, mask);
+}
+
+static void skcipher_release(void *private)
+{
+	crypto_free_ablkcipher(private);
+}
+
+static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ablkcipher_setkey(private, key, keylen);
+}
+
+static void skcipher_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+
+	skcipher_free_sgl(sk);
+	sock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int skcipher_accept_parent(void *private, struct sock *sk)
+{
+	struct skcipher_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),
+			       GFP_KERNEL);
+	if (!ctx->iv) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));
+
+	INIT_LIST_HEAD(&ctx->tsgl);
+	ctx->len = len;
+	ctx->used = 0;
+	ctx->more = 0;
+	ctx->merge = 0;
+	ctx->enc = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ablkcipher_request_set_tfm(&ctx->req, private);
+	ablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = skcipher_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_skcipher = {
+	.bind		=	skcipher_bind,
+	.release	=	skcipher_release,
+	.setkey		=	skcipher_setkey,
+	.accept		=	skcipher_accept_parent,
+	.ops		=	&algif_skcipher_ops,
+	.name		=	"skcipher",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_skcipher_init(void)
+{
+	return af_alg_register_type(&algif_type_skcipher);
+}
+
+static void __exit algif_skcipher_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_skcipher);
+	BUG_ON(err);
+}
+
+module_init(algif_skcipher_init);
+module_exit(algif_skcipher_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/core/sock.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/core/sock.c
@@ -157,7 +157,7 @@
   "sk_lock-27"       , "sk_lock-28"          , "sk_lock-AF_CAN"      ,
   "sk_lock-AF_TIPC"  , "sk_lock-AF_BLUETOOTH", "sk_lock-IUCV"        ,
   "sk_lock-AF_RXRPC" , "sk_lock-AF_ISDN"     , "sk_lock-AF_PHONET"   ,
-  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" ,
+  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" , "sk_lock-AF_ALG"      ,
   "sk_lock-AF_MAX"
 };
 static const char *const af_family_slock_key_strings[AF_MAX+1] = {
@@ -173,7 +173,7 @@
   "slock-27"       , "slock-28"          , "slock-AF_CAN"      ,
   "slock-AF_TIPC"  , "slock-AF_BLUETOOTH", "slock-AF_IUCV"     ,
   "slock-AF_RXRPC" , "slock-AF_ISDN"     , "slock-AF_PHONET"   ,
-  "slock-AF_IEEE802154", "slock-AF_CAIF" ,
+  "slock-AF_IEEE802154", "slock-AF_CAIF" , "slock-AF_ALG"      ,
   "slock-AF_MAX"
 };
 static const char *const af_family_clock_key_strings[AF_MAX+1] = {
@@ -189,7 +189,7 @@
   "clock-27"       , "clock-28"          , "clock-AF_CAN"      ,
   "clock-AF_TIPC"  , "clock-AF_BLUETOOTH", "clock-AF_IUCV"     ,
   "clock-AF_RXRPC" , "clock-AF_ISDN"     , "clock-AF_PHONET"   ,
-  "clock-AF_IEEE802154", "clock-AF_CAIF" ,
+  "clock-AF_IEEE802154", "clock-AF_CAIF" , "clock-AF_ALG"      ,
   "clock-AF_MAX"
 };
 
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/crypto/if_alg.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/crypto/if_alg.h
@@ -0,0 +1,92 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _CRYPTO_IF_ALG_H
+#define _CRYPTO_IF_ALG_H
+
+#include <linux/compiler.h>
+#include <linux/completion.h>
+#include <linux/if_alg.h>
+#include <linux/types.h>
+#include <net/sock.h>
+
+#define ALG_MAX_PAGES			16
+
+struct crypto_async_request;
+
+struct alg_sock {
+	/* struct sock must be the first member of struct alg_sock */
+	struct sock sk;
+
+	struct sock *parent;
+
+	const struct af_alg_type *type;
+	void *private;
+};
+
+struct af_alg_completion {
+	struct completion completion;
+	int err;
+};
+
+struct af_alg_control {
+	struct af_alg_iv *iv;
+	int op;
+};
+
+struct af_alg_type {
+	void *(*bind)(const char *name, u32 type, u32 mask);
+	void (*release)(void *private);
+	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
+	int (*accept)(void *private, struct sock *sk);
+
+	struct proto_ops *ops;
+	struct module *owner;
+	char name[14];
+};
+
+struct af_alg_sgl {
+	struct scatterlist sg[ALG_MAX_PAGES];
+	struct page *pages[ALG_MAX_PAGES];
+};
+
+int af_alg_register_type(const struct af_alg_type *type);
+int af_alg_unregister_type(const struct af_alg_type *type);
+
+int af_alg_release(struct socket *sock);
+int af_alg_accept(struct sock *sk, struct socket *newsock);
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write);
+void af_alg_free_sg(struct af_alg_sgl *sgl);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion);
+void af_alg_complete(struct crypto_async_request *req, int err);
+
+static inline struct alg_sock *alg_sk(struct sock *sk)
+{
+	return (struct alg_sock *)sk;
+}
+
+static inline void af_alg_release_parent(struct sock *sk)
+{
+	sock_put(alg_sk(sk)->parent);
+}
+
+static inline void af_alg_init_completion(struct af_alg_completion *completion)
+{
+	init_completion(&completion->completion);
+}
+
+#endif	/* _CRYPTO_IF_ALG_H */
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/crypto/scatterwalk.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/crypto/scatterwalk.h
@@ -68,6 +68,21 @@
 	return (++sg)->length ? sg : (void *)sg_page(sg);
 }
 
+static inline void scatterwalk_crypto_chain(struct scatterlist *head,
+					    struct scatterlist *sg,
+					    int chain, int num)
+{
+	if (chain) {
+		head->length += sg->length;
+		sg = scatterwalk_sg_next(sg);
+	}
+
+	if (sg)
+		scatterwalk_sg_chain(head, num, sg);
+	else
+		sg_mark_end(head);
+}
+
 static inline unsigned long scatterwalk_samebuf(struct scatter_walk *walk_in,
 						struct scatter_walk *walk_out)
 {
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/linux/if_alg.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/linux/if_alg.h
@@ -0,0 +1,40 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _LINUX_IF_ALG_H
+#define _LINUX_IF_ALG_H
+
+#include <linux/types.h>
+
+struct sockaddr_alg {
+	__u16	salg_family;
+	__u8	salg_type[14];
+	__u32	salg_feat;
+	__u32	salg_mask;
+	__u8	salg_name[64];
+};
+
+struct af_alg_iv {
+	__u32	ivlen;
+	__u8	iv[0];
+};
+
+/* Socket options */
+#define ALG_SET_KEY			1
+#define ALG_SET_IV			2
+#define ALG_SET_OP			3
+
+/* Operations */
+#define ALG_OP_DECRYPT			0
+#define ALG_OP_ENCRYPT			1
+
+#endif	/* _LINUX_IF_ALG_H */
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/linux/socket.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/linux/socket.h
@@ -193,7 +193,8 @@
 #define AF_PHONET	35	/* Phonet sockets		*/
 #define AF_IEEE802154	36	/* IEEE802154 sockets		*/
 #define AF_CAIF		37	/* CAIF sockets			*/
-#define AF_MAX		38	/* For now.. */
+#define AF_ALG		38	/* Algorithm sockets		*/
+#define AF_MAX		39	/* For now.. */
 
 /* Protocol families, same as address families. */
 #define PF_UNSPEC	AF_UNSPEC
@@ -234,6 +235,7 @@
 #define PF_PHONET	AF_PHONET
 #define PF_IEEE802154	AF_IEEE802154
 #define PF_CAIF		AF_CAIF
+#define PF_ALG		AF_ALG
 #define PF_MAX		AF_MAX
 
 /* Maximum queue length specifiable by listen.  */
@@ -310,6 +312,7 @@
 #define SOL_RDS		276
 #define SOL_IUCV	277
 #define SOL_CAIF	278
+#define SOL_ALG		279
 
 /* IPX options */
 #define IPX_TYPE	1
--- a/release/src-rt/Makefile
+++ b/release/src-rt/Makefile
@@ -3601,12 +3601,6 @@
 	else \
 		echo "CONFIG_LINUX_MTD=$(LINUX_MTD)" >>$(1); \
 	fi; \
-	sed -i "/CONFIG_NF_CONNTRACK_EVENTS/d" $(1); \
-	if [ "$(BWDPI)" = "y" ] || [ "$(HND_ROUTER)" = "y" ]; then \
-		echo "CONFIG_NF_CONNTRACK_EVENTS=y" >>$(1); \
-	else \
-		echo "# CONFIG_NF_CONNTRACK_EVENTS is not set" >>$(1); \
-	fi; \
 	if [ "$(BWDPI)" = "y" ]; then \
 		sed -i "/CONFIG_NET_SCH_HTB/d" $(1); \
 		echo "CONFIG_NET_SCH_HTB=y" >>$(1); \
@@ -3894,11 +3888,218 @@
 	$(MAKE) -C router bboldconf
 	@echo done
 
+#
+# PackageSetup: unpack a source package, apply patches, after downloading and archiving
+# (TODO: automatically verify the package hash)
+#
+define PackageSetup
+	@( \
+	ASUSWRT_ADDON_DIR="$(strip $(1))"; \
+	TARGET_DIR="$(strip $(2))"; \
+	PACKAGE_DIR="$(strip $(3))"; \
+	if [ ! -d "$$TARGET_DIR/$$PACKAGE_DIR" ]; then \
+		PACKAGE_NAME="$(strip $(8))"; \
+		[ -n "$$PACKAGE_NAME" ] || PACKAGE_NAME="$$PACKAGE_DIR"; \
+		URL="$(strip $(4))"; \
+		VERSION="$(strip $(5))"; \
+		SOURCE_VERSION="$(strip $(6))"; \
+		HASH="$(strip $(7))"; \
+		if [ -z "$$URL" ]; then \
+			URL="/$${PACKAGE_NAME}-MISSING-PACKAGE"; \
+			exit 1; \
+		fi; \
+		DL_DIR="$$ASUSWRT_ADDON_DIR/downloads/$$PACKAGE_NAME"; \
+		PATCH_DIR="$$ASUSWRT_ADDON_DIR/packages/$$PACKAGE_NAME/patches"; \
+		DL_FILE="$${URL##*/}"; \
+		DL_PATH="$$DL_DIR/$$DL_FILE"; \
+		if [ "$${DL_FILE%.git*}" != "$$DL_FILE" ]; then \
+			[ -z "$$VERSION" ] && DL_NAME="$$PACKAGE_NAME" || DL_NAME="$$PACKAGE_NAME-$$VERSION"; \
+			if [ -z "$$SOURCE_VERSION" ]; then \
+				SOURCE_VERSION=`git ls-remote $${URL} | grep HEAD | cut -f1`; \
+				while [ -z "$$SOURCE_VERSION" ]; do \
+					sleep 10; SOURCE_VERSION=`git ls-remote $${URL} | grep HEAD | cut -f1`; \
+				done; \
+			fi; \
+			DL_FILE="$${DL_NAME}-$${SOURCE_VERSION}.tar.xz"; \
+			DL_PATH="$$DL_DIR/$$DL_FILE"; \
+			if [ ! -f "$$DL_PATH" ]; then \
+				git clone $$URL $$DL_DIR/temp/$$DL_NAME; \
+				while [ $$? -ne 0 ]; do \
+					sleep 10; git clone $$URL $$DL_DIR/temp/$$DL_NAME; \
+				done; \
+				ORIGDIR="$$PWD"; \
+				cd "$$DL_DIR/temp/$$DL_NAME"; \
+				git checkout $$SOURCE_VERSION; \
+				while [ $$? -ne 0 ]; do \
+					sleep 10; git checkout $$SOURCE_VERSION; \
+				done; \
+				git submodule update --init --recursive; \
+				while [ $$? -ne 0 ]; do \
+					sleep 10; git submodule update --init --recursive; \
+				done; \
+				TAR_TIMESTAMP="`git log -1 --format='@%ct'`"; \
+				rm -rf .git; \
+				cd "$$ORIGDIR"; \
+				chmod -R g-w,o-w "$$DL_DIR/temp/$$DL_NAME"; \
+				tar --numeric-owner --owner=0 --group=0 --sort=name --mtime="$$TAR_TIMESTAMP" -cv -C "$$DL_DIR/temp" "$$DL_NAME" | xz -zc -7e > "$$DL_PATH"; \
+			fi; \
+		elif [ ! -f "$$DL_PATH" ]; then \
+			wget --tries=9 --retry-connrefused --waitretry=5 --directory-prefix="$$DL_DIR" "$$URL"; \
+			while [ $$? -ne 0 ]; do \
+				sleep 10; \
+				[ ! -f "$$DL_PATH" ] || break; \
+				wget --tries=9 --retry-connrefused --waitretry=5 --directory-prefix="$$DL_DIR" "$$URL"; \
+			done; \
+			rm -rf "$$TARGET_DIR/$$PACKAGE_DIR" || true; \
+		fi; \
+		rm -rf "$$DL_DIR/temp"; \
+		mkdir -p "$$DL_DIR/temp"; \
+		if [ "$${DL_FILE%.tar.gz*}" != "$$DL_FILE" ] || [ "$${DL_FILE%.tgz*}" != "$$DL_FILE" ]; then \
+			tar xzvf "$$DL_PATH" -C "$$DL_DIR/temp"; \
+		elif [ "$${DL_FILE%.tar.bz2*}" != "$$DL_FILE" ] || [ "$${DL_FILE%.tbz*}" != "$$DL_FILE" ]; then \
+			tar xjvf "$$DL_PATH" -C "$$DL_DIR/temp"; \
+		elif [ "$${DL_FILE%.tar.xz*}" != "$$DL_FILE" ] || [ "$${DL_FILE%.txz*}" != "$$DL_FILE" ]; then \
+			tar xJvf "$$DL_PATH" -C "$$DL_DIR/temp"; \
+		elif [ "$${DL_FILE%.tar.lz*}" != "$$DL_FILE" ] || [ "$${DL_FILE%.tlz*}" != "$$DL_FILE" ]; then \
+			tar xlvf "$$DL_PATH" -C "$$DL_DIR/temp"; \
+		fi; \
+		mv -f "$$DL_DIR/temp/"* "$$TARGET_DIR/$$PACKAGE_DIR"; \
+		rm -rf "$$DL_DIR/temp"; \
+		for PATCH_FILE in $$PATCH_DIR/*.patch; do \
+			if [ -f "$$PATCH_FILE" ]; then \
+				echo "Applying patch: $$PATCH_FILE"; \
+				patch --dry-run --silent -p1 -d "$$TARGET_DIR/$$PACKAGE_DIR/" -i "$$PATCH_FILE" >/dev/null 2>&1 && \
+					patch -p1 -d "$$TARGET_DIR/$$PACKAGE_DIR/" -i "$$PATCH_FILE" || \
+						echo "The patch was not applied."; \
+			else \
+				true; \
+			fi; \
+		done; \
+	else \
+		echo "$$TARGET_DIR/$$PACKAGE_DIR was not unpacked because the directory exists."; \
+		true; \
+	fi; \
+	)
+endef
+
+#
+# CryptodevSetup: this will enable /dev/crypto in Asuswrt firmwares
+#
+define CryptodevSetup
+	# CryptodevSetup
+	$(eval KERNEL_CRYPTO_DIR=$(LINUXDIR)/crypto)
+	$(eval CRYPTODEV_NAME=cryptodev-linux)
+	$(eval CRYPTODEV_DIR=$(KERNEL_CRYPTO_DIR)/$(CRYPTODEV_NAME))
+
+	$(call PackageSetup,$(BLACKFUEL_DIR),$(KERNEL_CRYPTO_DIR),$(CRYPTODEV_NAME), \
+		https://github.com/cryptodev-linux/cryptodev-linux.git, 1.9+git)
+
+	# create required version.h in cryptodev-linux
+	[ -f "$(CRYPTODEV_DIR)/version.h" ] || make -C $(CRYPTODEV_DIR) version.h
+
+	# insert cryptodev-linux into the kernel build
+	@if ! grep -qF $(CRYPTODEV_NAME) $(KERNEL_CRYPTO_DIR)/Makefile ; then \
+		echo "" >>$(KERNEL_CRYPTO_DIR)/Makefile; \
+		echo "#" >>$(KERNEL_CRYPTO_DIR)/Makefile; \
+		echo "# $(CRYPTODEV_NAME): https://github.com/cryptodev-linux/cryptodev-linux" >>$(KERNEL_CRYPTO_DIR)/Makefile; \
+		echo "#" >>$(KERNEL_CRYPTO_DIR)/Makefile; \
+		echo "CONFIG_CRYPTODEV_LINUX:=y" >>$(KERNEL_CRYPTO_DIR)/Makefile; \
+		echo "obj-\$$(CONFIG_CRYPTODEV_LINUX) += $(CRYPTODEV_NAME)/" >>$(KERNEL_CRYPTO_DIR)/Makefile; \
+	fi
+endef
+
+#
+# XtablesAddonsSetup: include the official xtables-addons kernel modules in Asuswrt firmwares
+#
+define InsertXtablesKernelModule
+	$(eval KERNEL_MODULE_NAME=$(1))
+	$(eval KERNEL_MODULE_BUILTIN=$(2))
+	@if [ -f "$(XTABLES_EXTENSIONS_DIR)/$(KERNEL_MODULE_NAME).c" ]; then \
+		echo "obj-$(KERNEL_MODULE_BUILTIN) += xtables-addons/extensions/$(KERNEL_MODULE_NAME).o" >>$(KERNEL_NETFILTER_DIR)/Makefile; \
+		EXTSUBDIR="`dirname $(KERNEL_MODULE_NAME)`"; \
+		if [ "$$EXTSUBDIR" != "." ]; then \
+			for PATH_COMPAT_H in $(XTABLES_EXTENSIONS_DIR)/compat_*.h ; do \
+				COMPAT_H=`basename $$PATH_COMPAT_H`; \
+				ln -sf ../$$COMPAT_H $(XTABLES_EXTENSIONS_DIR)/$$EXTSUBDIR/$$COMPAT_H ; \
+			done; \
+		fi; \
+	else \
+		echo "MISSING SOURCE FILE: $(XTABLES_EXTENSIONS_DIR)/$(KERNEL_MODULE_NAME).c"; \
+		false; \
+	fi
+endef
+
+define XtablesAddonsSetup
+	# XtablesAddonsSetup
+	$(eval XTABLES_ADDONS_VERSION=$(1))
+	$(eval KERNEL_NETFILTER_DIR=$(LINUXDIR)/net/netfilter)
+	$(eval XTABLES_ADDONS_NAME=xtables-addons)
+	$(eval XTABLES_ADDONS_DIR=$(KERNEL_NETFILTER_DIR)/$(XTABLES_ADDONS_NAME))
+	$(eval XTABLES_EXTENSIONS_DIR=$(XTABLES_ADDONS_DIR)/extensions)
+	$(eval XTABLES_EXISTS=$(shell grep -qF $(XTABLES_ADDONS_NAME) $(KERNEL_NETFILTER_DIR)/Makefile && echo 1 || echo 0))
+
+	# insert xtables-addons into the kernel build
+	$(if ifeq ($(XTABLES_EXISTS), 0),
+		$(call PackageSetup,$(BLACKFUEL_DIR),$(KERNEL_NETFILTER_DIR),$(XTABLES_ADDONS_NAME), \
+			https://ufpr.dl.sourceforge.net/project/xtables-addons/Xtables-addons/xtables-addons-$(XTABLES_ADDONS_VERSION).tar.xz)
+		@echo "" >>$(KERNEL_NETFILTER_DIR)/Makefile
+		@echo "#" >>$(KERNEL_NETFILTER_DIR)/Makefile
+		@echo "# $(XTABLES_ADDONS_NAME): https://xtables-addons.sourceforge.net" >>$(KERNEL_NETFILTER_DIR)/Makefile
+		@echo "#" >>$(KERNEL_NETFILTER_DIR)/Makefile
+		$(call InsertXtablesKernelModule,compat_xtables,m)
+		$(call InsertXtablesKernelModule,ACCOUNT/xt_ACCOUNT,m)
+		$(call InsertXtablesKernelModule,xt_CHAOS,m)
+		$(call InsertXtablesKernelModule,xt_DELUDE,m)
+		$(call InsertXtablesKernelModule,xt_DHCPMAC,m)
+		$(call InsertXtablesKernelModule,xt_DNETMAP,m)
+		$(call InsertXtablesKernelModule,xt_ECHO,n)
+		$(call InsertXtablesKernelModule,xt_IPMARK,m)
+		$(call InsertXtablesKernelModule,xt_LOGMARK,m)
+		$(call InsertXtablesKernelModule,xt_SYSRQ,m)
+		$(call InsertXtablesKernelModule,xt_TARPIT,m)
+		$(call InsertXtablesKernelModule,xt_condition,m)
+		$(call InsertXtablesKernelModule,xt_fuzzy,m)
+		$(call InsertXtablesKernelModule,xt_geoip,m)
+		$(call InsertXtablesKernelModule,xt_iface,m)
+		$(call InsertXtablesKernelModule,xt_ipp2p,m)
+		$(call InsertXtablesKernelModule,xt_ipv4options,m)
+		$(call InsertXtablesKernelModule,xt_length2,m)
+		$(call InsertXtablesKernelModule,xt_lscan,m)
+		$(call InsertXtablesKernelModule,pknock/xt_pknock,m)
+		$(call InsertXtablesKernelModule,xt_psd,m)
+		$(call InsertXtablesKernelModule,xt_quota2,m)
+	)
+endef
+
+define CreateBlackfuelDirectory
+	# CreateBlackfuelDirectory
+	@echo "PWD=$${PWD}"
+	$(eval ASUSWRT_DIR=$(shell echo "$${PWD%/release\/src*}";))
+	$(eval ASUSWRT_ADDON=../asuswrt-merlin-addon)
+	$(eval ASUSWRT_ADDON_DIR=$(ASUSWRT_DIR)/$(ASUSWRT_ADDON))
+	$(eval BLACKFUEL_DIR=$(ASUSWRT_DIR)/blackfuel-addon)
+	@echo "ASUSWRT_DIR=$(ASUSWRT_DIR)"
+	@echo "ASUSWRT_ADDON=$(ASUSWRT_ADDON)"
+	@echo "ASUSWRT_ADDON_DIR=$(ASUSWRT_ADDON_DIR)"
+	@echo "BLACKFUEL_DIR=$(BLACKFUEL_DIR)"
+	$(shell [ -d "$(BLACKFUEL_DIR)" ] || (mkdir -p $(ASUSWRT_ADDON_DIR) && rm -f "$(BLACKFUEL_DIR)" && ln -s $(ASUSWRT_ADDON) "$(BLACKFUEL_DIR)") )
+endef
+
 bin:
 ifeq ($(BUILD_NAME),)
 	@echo $@" is not a valid target!"
 	@false
 endif
+### blackfuel
+ifeq ($(HND_ROUTER),y)
+	$(call CreateBlackfuelDirectory)
+	$(call CryptodevSetup)
+	$(call XtablesAddonsSetup,2.14)
+else
+	$(call CreateBlackfuelDirectory)
+	$(call XtablesAddonsSetup,1.47.1)
+endif
+### END blackfuel
 ifeq ($(HND_ROUTER),y)
 	@echo BRCM_BOARD_ID=$(BRCM_BOARD_ID)
 	@rm -f bcmdrivers/broadcom/net/wl/bcm9$(BCM_CHIP) && ln -sf impl51 bcmdrivers/broadcom/net/wl/bcm9$(BCM_CHIP)
--- a/release/src-rt/target.mak
+++ b/release/src-rt/target.mak
@@ -1,109 +1,109 @@
 #
 # Broadcom SDK 6.37 ARM platform
 #
-export RT-AC56U := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y ROMCCODE=y \
-		SAMBA3=3.6.x MEDIASRV=y MODEM=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y STAINFO=y \
-		WEBDAV=y USB="USB" GRO=y APP="network" BUILD_NAME="RT-AC56U" PROXYSTA=y HD_SPINDOWN=y \
-		SMARTSYNCBASE=y SYSSTATE=y SW_HW_AUTH=y LINUX_MTD="64" BCM4352_5G=y LANWAN_LED=y \
+export RT-AC56U := IPV6SUPP=y HTTPS=y ARM=y STRACE=y USBRESET=y BONJOUR=n PROTECTION_SERVER=n UPNPC=n BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y ROMCCODE=y \
+		SAMBA3=3.6.x MEDIASRV=n MODEM=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y STAINFO=y \
+		WEBDAV=n USB="USB" GRO=y APP="network" BUILD_NAME="RT-AC56U" PROXYSTA=y HD_SPINDOWN=y \
+		SMARTSYNCBASE=n SYSSTATE=y SW_HW_AUTH=y LINUX_MTD="64" BCM4352_5G=y LANWAN_LED=y \
 		DNSMQ=y SHP=y NVRAM_64K=y RTAC56U=y BCMWL6=y BCMWL6A=y TUNEK="n" BCM5301X=y DISK_MONITOR=y \
-		BTN_WIFITOG=y OPTIMIZE_XBOX=y ODMPID=y ROG=y EMAIL=y XHCIMODE=y LED_ALL=y \
+		BTN_WIFITOG=y OPTIMIZE_XBOX=n ODMPID=y ROG=n EMAIL=n XHCIMODE=y LED_ALL=y \
 		BCMSMP=y XHCI=y SSH=y NFS=y OPENVPN=y NEW_USER_LOW_RSSI=y \
-		TIMEMACHINE=y MDNS=y VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y BWDPI=y \
-		DUMP_OOPS_MSG=y TEMPROOTFS=y DEBUGFS=y SNMPD=y TOR=y \
-		MULTICASTIPTV=y QUAGGA=y BCM_RECVFILE=y LAN50=y ATCOVER=y GETREALIP=y \
-		BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=y REBOOT_SCHEDULE=y DPSTA=y \
-		LETSENCRYPT=y NATNL_AIHOME=y \
-		TFAT=y HFS="tuxera" NTFS="tuxera" REPEATER=y DUALWAN=y DNSFILTER=y UPNPIGD2=n \
+		TIMEMACHINE=n MDNS=n VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y BWDPI=n \
+		DUMP_OOPS_MSG=y TEMPROOTFS=y DEBUGFS=y SNMPD=n TOR=y \
+		MULTICASTIPTV=n QUAGGA=n BCM_RECVFILE=y LAN50=y ATCOVER=y GETREALIP=y \
+		BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=n REBOOT_SCHEDULE=y DPSTA=y \
+		LETSENCRYPT=n NATNL_AIHOME=n \
+		TFAT=y HFS="tuxera" NTFS="tuxera" REPEATER=y DUALWAN=y DNSFILTER=n UPNPIGD2=n \
 		DNSSEC=y NANO=y
 
-export RT-AC68U_BASE := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y \
-			SAMBA3=3.6.x MEDIASRV=y MODEM=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y STAINFO=y \
-			WEBDAV=y USB="USB" GRO=y APP="network" PROXYSTA=y NOTIFICATION_CENTER=y HD_SPINDOWN=y \
-			SMARTSYNCBASE=y SYSSTATE=y NATNL_AICLOUD=y NATNL_AIHOME=y SW_HW_AUTH=y \
+export RT-AC68U_BASE := IPV6SUPP=y HTTPS=y ARM=y STRACE=y USBRESET=y BONJOUR=n PROTECTION_SERVER=n UPNPC=n BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y \
+			SAMBA3=3.6.x MEDIASRV=n MODEM=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y STAINFO=y \
+			WEBDAV=n USB="USB" GRO=y APP="network" PROXYSTA=y NOTIFICATION_CENTER=n HD_SPINDOWN=y \
+			SMARTSYNCBASE=n SYSSTATE=y NATNL_AICLOUD=n NATNL_AIHOME=n SW_HW_AUTH=y \
 			DNSMQ=y SHP=y NVRAM_64K=y RTAC68U=y BCMWL6=y BCMWL6A=y TUNEK="n" BCM5301X=y DISK_MONITOR=y \
-			BTN_WIFITOG=y LOGO_LED=y OPTIMIZE_XBOX=y ODMPID=y LED_BTN=y ROG=y EMAIL=y \
+			BTN_WIFITOG=y LOGO_LED=y OPTIMIZE_XBOX=n ODMPID=y LED_BTN=y ROG=n EMAIL=n \
 			BCMSMP=y XHCI=y SSH=y NFS=y OPENVPN=y NEW_USER_LOW_RSSI=y \
-			TIMEMACHINE=y MDNS=y VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y BWDPI=y HSPOT=y \
-			DUMP_OOPS_MSG=y LINUX_MTD="64" BCM7=n TEMPROOTFS=y DEBUGFS=y SNMPD=y TOR=y \
-			MULTICASTIPTV=y QUAGGA=y BCM_RECVFILE=y LAN50=y ATCOVER=y GETREALIP=y \
-			BCM5301X_TRAFFIC_MONITOR=y CLOUDCHECK=y REBOOT_SCHEDULE=y DPSTA=y \
-			AMAS=y DBLOG=y \
-			TFAT=y HFS="tuxera" NTFS="tuxera" REPEATER=y DUALWAN=y DNSFILTER=y UPNPIGD2=n \
+			TIMEMACHINE=n MDNS=n VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y BWDPI=n HSPOT=n \
+			DUMP_OOPS_MSG=y LINUX_MTD="64" BCM7=n TEMPROOTFS=y DEBUGFS=y SNMPD=n TOR=y \
+			MULTICASTIPTV=n QUAGGA=n BCM_RECVFILE=y LAN50=y ATCOVER=y GETREALIP=y \
+			BCM5301X_TRAFFIC_MONITOR=y CLOUDCHECK=n REBOOT_SCHEDULE=y DPSTA=y \
+			AMAS=n DBLOG=y \
+			TFAT=y HFS="tuxera" NTFS="tuxera" REPEATER=y DUALWAN=y DNSFILTER=n UPNPIGD2=n \
 			DNSSEC=y NANO=y
 
 export RT-AC68U := $(RT-AC68U_BASE) FAKEHDR=y FORCE_SN=384 FORCE_EN=20000
-export RT-AC68U += BUILD_NAME="RT-AC68U" NEWSSID_REV2=y LETSENCRYPT=y UTF8_SSID=y
+export RT-AC68U += BUILD_NAME="RT-AC68U" NEWSSID_REV2=y LETSENCRYPT=n UTF8_SSID=y
 
-export RT-AC87U := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y \
-		SAMBA3=3.6.x MEDIASRV=y MODEM=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y STAINFO=y \
-		WEBDAV=y USB="USB" GRO=y APP="network" PROXYSTA=y NOTIFICATION_CENTER=y HD_SPINDOWN=y \
-		SMARTSYNCBASE=y SYSSTATE=y NATNL_AICLOUD=y NATNL_AIHOME=y SW_HW_AUTH=y HW_DUALWAN=y \
+export RT-AC87U := IPV6SUPP=y HTTPS=y ARM=y STRACE=y USBRESET=y BONJOUR=n PROTECTION_SERVER=n UPNPC=n BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y \
+		SAMBA3=3.6.x MEDIASRV=n MODEM=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y STAINFO=y \
+		WEBDAV=n USB="USB" GRO=y APP="network" PROXYSTA=y NOTIFICATION_CENTER=n HD_SPINDOWN=y \
+		SMARTSYNCBASE=n SYSSTATE=y NATNL_AICLOUD=n NATNL_AIHOME=n SW_HW_AUTH=y HW_DUALWAN=y \
 		DNSMQ=y SHP=y NVRAM_64K=y  BCMWL6=y BCMWL6A=y TUNEK="n" BCM5301X=y DISK_MONITOR=y \
-		BTN_WIFITOG=y OPTIMIZE_XBOX=y ODMPID=y LED2_BTN=y LED_BTN=y ROG=y EMAIL=y \
+		BTN_WIFITOG=y OPTIMIZE_XBOX=n ODMPID=y LED2_BTN=y LED_BTN=y ROG=n EMAIL=n \
 		BUILD_NAME="RT-AC87U" BCMSMP=y XHCI=y SSH=y NFS=y OPENVPN=y NEW_USER_LOW_RSSI=y \
-		TIMEMACHINE=y MDNS=y VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y RGMII_BCM_FA=y BWDPI=y \
-		HSPOT=y DUMP_OOPS_MSG=y LINUX_MTD="64" TEMPROOTFS=y DEBUGFS=y SNMPD=y TOR=y \
-		MULTICASTIPTV=y QUAGGA=y BCM_RECVFILE=y LAN50=y ATCOVER=y GETREALIP=y TFTP=y \
+		TIMEMACHINE=n MDNS=n VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y RGMII_BCM_FA=y BWDPI=n \
+		HSPOT=n DUMP_OOPS_MSG=y LINUX_MTD="64" TEMPROOTFS=y DEBUGFS=y SNMPD=n TOR=y \
+		MULTICASTIPTV=n QUAGGA=n BCM_RECVFILE=y LAN50=y ATCOVER=y GETREALIP=y TFTP=y \
 		BCM5301X_TRAFFIC_MONITOR=y REBOOT_SCHEDULE=y XHCIMODE=y QTN=y \
 		RGMII_BRCM5301X=y EXT_LED_WPS=y DISABLE_REPEATER_UI=y JFFS2ND_BACKUP=y \
-		AMAS=n DBLOG=n LETSENCRYPT=y WPS_DUALBAND=y \
-		TFAT=y HFS="tuxera" NTFS="tuxera" REPEATER=y DUALWAN=y DNSFILTER=y UPNPIGD2=n \
+		AMAS=n DBLOG=n LETSENCRYPT=n WPS_DUALBAND=y \
+		TFAT=y HFS="tuxera" NTFS="tuxera" REPEATER=y DUALWAN=y DNSFILTER=n UPNPIGD2=n \
 		DNSSEC=y NANO=y
 
 
 #
 # Broadcom HND ARM platform
 #
-export HND-94908_BASE := HND_ROUTER=y PROFILE="94908HND" SW_HW_AUTH=y AMAS=y DBLOG=y UTF8_SSID=y
+export HND-94908_BASE := HND_ROUTER=y PROFILE="94908HND" SW_HW_AUTH=y AMAS=n DBLOG=y UTF8_SSID=y
 export RT-AC86U := $(HND-94908_BASE)
-export RT-AC86U += BUILD_NAME="RT-AC86U" NVSIZE="128" DHDAP=y DPSTA=y LACP=n WTFAST=y REPEATER=y \
-				IPV6SUPP=y HTTPS=y ARM=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y \
-				EBTABLES=y SAMBA3=3.6.x MEDIASRV=y MODEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y WEBDAV=y \
-				SMARTSYNCBASE=y USB="USB" APP="installed" PROXYSTA=y DNSMQ=y SHP=n BCMWL6=y BCMWL6A=y \
-				TUNEK="n" DISK_MONITOR=y BTN_WIFITOG=y OPTIMIZE_XBOX=y ODMPID=y LED_BTN=y BCMSMP=y \
-				XHCI=y DUALWAN=y NEW_USER_LOW_RSSI=y OPENVPN=y TIMEMACHINE=y MDNS=y VPNC=y \
-				BRCM_NAND_JFFS2=y JFFS2LOG=y BWDPI=y DUMP_OOPS_MSG=y LINUX_MTD="64" DEBUGFS=y \
-				TEMPROOTFS=n SSH=y EMAIL=y SYSSTATE=y ROG=y STAINFO=y CLOUDCHECK=y NATNL_AICLOUD=y \
-				REBOOT_SCHEDULE=y MULTICASTIPTV=y QUAGGA=y WLCLMLOAD=n BCM_MUMIMO=y \
+export RT-AC86U += BUILD_NAME="RT-AC86U" NVSIZE="128" DHDAP=y DPSTA=y LACP=n WTFAST=n REPEATER=y \
+				IPV6SUPP=y HTTPS=y ARM=y STRACE=y USBRESET=y BONJOUR=n PROTECTION_SERVER=n UPNPC=n AUTODICT=y BBEXTRAS=y USBEXTRAS=y \
+				EBTABLES=y SAMBA3=3.6.x MEDIASRV=n MODEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y WEBDAV=n \
+				SMARTSYNCBASE=n USB="USB" APP="installed" PROXYSTA=y DNSMQ=y SHP=n BCMWL6=y BCMWL6A=y \
+				TUNEK="n" DISK_MONITOR=y BTN_WIFITOG=y OPTIMIZE_XBOX=n ODMPID=y LED_BTN=y BCMSMP=y \
+				XHCI=y DUALWAN=y NEW_USER_LOW_RSSI=y OPENVPN=y TIMEMACHINE=n MDNS=n VPNC=y \
+				BRCM_NAND_JFFS2=y JFFS2LOG=y BWDPI=n DUMP_OOPS_MSG=y LINUX_MTD="64" DEBUGFS=y \
+				TEMPROOTFS=n SSH=y EMAIL=n SYSSTATE=y ROG=n STAINFO=y CLOUDCHECK=n NATNL_AICLOUD=n \
+				REBOOT_SCHEDULE=y MULTICASTIPTV=n QUAGGA=n WLCLMLOAD=n BCM_MUMIMO=y \
 				LAN50=y ATCOVER=y GETREALIP=y CFEZ=y TFAT=y NTFS="tuxera" HFS="tuxera" \
-				NEWSSID_REV2=y LAN4WAN_LED=y NEW_APP_ARM=y NETOOL=y TRACEROUTE=y FORCE_AUTO_UPGRADE=n \
-				HD_SPINDOWN=y SW_HW_AUTH=y NATNL_AIHOME=y ASPMD=n BCM_MEVENT=y \
+				NEWSSID_REV2=y LAN4WAN_LED=y NEW_APP_ARM=y STRACE=y USBRESET=y BONJOUR=n PROTECTION_SERVER=n UPNPC=n NETOOL=y TRACEROUTE=y FORCE_AUTO_UPGRADE=n \
+				HD_SPINDOWN=y SW_HW_AUTH=y NATNL_AIHOME=n ASPMD=n BCM_MEVENT=y \
 				IPSEC=STRONGSWAN IPSEC_SRVCLI_ONLY=SRV \
-				BCMEVENTD=y BCM_APPEVENTD=y JFFS_NVRAM=y IFTTT=n ALEXA=n LETSENCRYPT=y \
-				VISUALIZATION=y NFS=y DNSFILTER=y SNMPD=n TOR=y UPNPIGD2=n DNSSEC=y NANO=y
+				BCMEVENTD=y BCM_APPEVENTD=y JFFS_NVRAM=y IFTTT=n ALEXA=n LETSENCRYPT=n \
+				VISUALIZATION=n NFS=y DNSFILTER=n SNMPD=n TOR=y UPNPIGD2=n DNSSEC=y NANO=y
 
 #
 # Broadcom SDK 7 ARM platform
 #
-export RT-AC3200 := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=3.6.x \
-		MEDIASRV=y MODEM=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y WEBDAV=y SMARTSYNCBASE=y \
+export RT-AC3200 := IPV6SUPP=y HTTPS=y ARM=y STRACE=y USBRESET=y BONJOUR=n PROTECTION_SERVER=n UPNPC=n BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=3.6.x \
+		MEDIASRV=n MODEM=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y WEBDAV=n SMARTSYNCBASE=n \
 		USB="USB" GRO=y APP="network" BUILD_NAME="RT-AC3200" PROXYSTA=y DNSMQ=y SHP=y BCMWL6=y \
-		BCMWL6A=y BCM7=y TUNEK="n" BCM5301X=y DISK_MONITOR=y BTN_WIFITOG=y OPTIMIZE_XBOX=y \
+		BCMWL6A=y BCM7=y TUNEK="n" BCM5301X=y DISK_MONITOR=y BTN_WIFITOG=y OPTIMIZE_XBOX=n \
 		ODMPID=y LED_BTN=y BCMSMP=y XHCI=y DUALWAN=y REPEATER=y NEW_USER_LOW_RSSI=y OPENVPN=y \
-		TIMEMACHINE=y MDNS=y TFAT=y NTFS="tuxera" HFS="tuxera" VPNC=y BRCM_NAND_JFFS2=y \
-		JFFS2LOG=y BCMFA=n BWDPI=y DUMP_OOPS_MSG=y DHDAP=y DPSTA=n GMAC3=y HSPOT=n LINUX_MTD="64" \
-		DEBUGFS=y NVSIZE="128" TEMPROOTFS=y SSH=y EMAIL=y SYSSTATE=y ADBLOCK=n ROG=y STAINFO=y \
-		BCM5301X_TRAFFIC_MONITOR=y CLOUDCHECK=y NATNL_AICLOUD=y BCM_RECVFILE=y DISABLE_REPEATER_UI=y \
-		REBOOT_SCHEDULE=y MULTICASTIPTV=y QUAGGA=y LAN50=y ATCOVER=y GETREALIP=y \
-		NOTIFICATION_CENTER=y HD_SPINDOWN=y SW_HW_AUTH=y NATNL_AIHOME=y DBLOG=n \
-		NFS=y DNSFILTER=y SNMPD=y TOR=y UPNPIGD2=n DNSSEC=y NANO=y
+		TIMEMACHINE=n MDNS=n TFAT=y NTFS="tuxera" HFS="tuxera" VPNC=y BRCM_NAND_JFFS2=y \
+		JFFS2LOG=y BCMFA=n BWDPI=n DUMP_OOPS_MSG=y DHDAP=y DPSTA=n GMAC3=y HSPOT=n LINUX_MTD="64" \
+		DEBUGFS=y NVSIZE="128" TEMPROOTFS=y SSH=y EMAIL=n SYSSTATE=y ADBLOCK=n ROG=n STAINFO=y \
+		BCM5301X_TRAFFIC_MONITOR=y CLOUDCHECK=n NATNL_AICLOUD=n BCM_RECVFILE=y DISABLE_REPEATER_UI=y \
+		REBOOT_SCHEDULE=y MULTICASTIPTV=n QUAGGA=n LAN50=y ATCOVER=y GETREALIP=y \
+		NOTIFICATION_CENTER=n HD_SPINDOWN=y SW_HW_AUTH=y NATNL_AIHOME=n DBLOG=n \
+		NFS=y DNSFILTER=n SNMPD=n TOR=y UPNPIGD2=n DNSSEC=y NANO=y
 
 #
 # Broadcom SDK 7.14 ARM platform
 #
-export RT-AC88U_BASE := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=3.6.x \
-		MEDIASRV=y MODEM=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y WEBDAV=y UTF8_SSID=y \
-		NETOOL=y SW_HW_AUTH=y IFTTT=y ALEXA=y LETSENCRYPT=y IPSEC=STRONGSWAN IPSEC_SRVCLI_ONLY=SRV \
+export RT-AC88U_BASE := IPV6SUPP=y HTTPS=y ARM=y STRACE=y USBRESET=y BONJOUR=n PROTECTION_SERVER=n UPNPC=n BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=3.6.x \
+		MEDIASRV=n MODEM=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y WEBDAV=n UTF8_SSID=y \
+		NETOOL=y SW_HW_AUTH=y IFTTT=n ALEXA=n LETSENCRYPT=n IPSEC=STRONGSWAN IPSEC_SRVCLI_ONLY=SRV \
 		USB="USB" GRO=y APP="network" DNSMQ=y SHP=y BCMWL6=y BCMWL6A=y TUNEK="n" BCM5301X=y \
-		DISK_MONITOR=y BTN_WIFITOG=y OPTIMIZE_XBOX=y LED_BTN=y ODMPID=y BCMSMP=y XHCI=y \
-		DUALWAN=y REPEATER=y NEW_USER_LOW_RSSI=y OPENVPN=y TIMEMACHINE=y MDNS=y VPNC=y BRCM_NAND_JFFS2=y \
-		REBOOT_SCHEDULE=y FORCE_AUTO_UPGRADE=n FAKEID=n MULTICASTIPTV=y QUAGGA=y HD_SPINDOWN=y \
-		JFFS2LOG=y BWDPI=y DUMP_OOPS_MSG=y LINUX_MTD="64" DEBUGFS=y TEMPROOTFS=y SSH=y WIFILOGO=n \
-		EMAIL=y ROG=y SSD=n STAINFO=y BCM5301X_TRAFFIC_MONITOR=y PROXYSTA=y AMAS=y DBLOG=y \
-		BCM_RECVFILE=y TFAT=y NTFS="tuxera" HFS="tuxera" CFEZ=y ERPTEST=n CLOUDCHECK=y \
+		DISK_MONITOR=y BTN_WIFITOG=y OPTIMIZE_XBOX=n LED_BTN=y ODMPID=y BCMSMP=y XHCI=y \
+		DUALWAN=y REPEATER=y NEW_USER_LOW_RSSI=y OPENVPN=y TIMEMACHINE=n MDNS=n VPNC=y BRCM_NAND_JFFS2=y \
+		REBOOT_SCHEDULE=y FORCE_AUTO_UPGRADE=n FAKEID=n MULTICASTIPTV=n QUAGGA=n HD_SPINDOWN=y \
+		JFFS2LOG=y BWDPI=n DUMP_OOPS_MSG=y LINUX_MTD="64" DEBUGFS=y TEMPROOTFS=y SSH=y WIFILOGO=n \
+		EMAIL=n ROG=n SSD=n STAINFO=y BCM5301X_TRAFFIC_MONITOR=y PROXYSTA=y AMAS=n DBLOG=y \
+		BCM_RECVFILE=y TFAT=y NTFS="tuxera" HFS="tuxera" CFEZ=y ERPTEST=n CLOUDCHECK=n \
 		ASPMD=n BCMEVENTD=n WLCLMLOAD=n BCM_MUMIMO=y LAN50=y ATCOVER=y GETREALIP=y \
-		NOTIFICATION_CENTER=y NATNL_AICLOUD=y SYSSTATE=y SMARTSYNCBASE=y NATNL_AIHOME=y \
-		NFS=y DNSFILTER=y SNMPD=y TOR=y UPNPIGD2=n DNSSEC=y NANO=y
+		NOTIFICATION_CENTER=n NATNL_AICLOUD=n SYSSTATE=y SMARTSYNCBASE=n NATNL_AIHOME=n \
+		NFS=y DNSFILTER=n SNMPD=n TOR=y UPNPIGD2=n DNSSEC=y NANO=y
 
 export RT-AC88U := $(RT-AC88U_BASE)
 export RT-AC88U += BUILD_NAME="RT-AC88U" RGMII_BRCM5301X=y SWITCH2="RTL8365MB" BCM_MMC=n BCM_7114=y \
--- a/release/src-rt/platform.mak
+++ b/release/src-rt/platform.mak
@@ -11,10 +11,10 @@
 
 ifeq ($(HND_ROUTER),y)
 export PRIVATE_EXTRACFLAGS := $(BRCM_COMMON_CFLAGS) -DHND_ROUTER -DLINUX26 -DLINUX_2_6_36 -DCONFIG_BCMWL5
-export EXTRACFLAGS := -march=armv7-a -marm -DHND_ROUTER -DCONFIG_BCMWL5 -D__ARM_ARCH_7A__
+export EXTRACFLAGS := -march=armv8-a+crc -mtune=cortex-a53 -mfpu=crypto-neon-fp-armv8 -fomit-frame-pointer -fno-caller-saves -DHND_ROUTER -DCONFIG_BCMWL5
 else
  ifeq ($(EXTRACFLAGS),)
-export EXTRACFLAGS := -DBCMWPA2 -DBCMARM -fno-delete-null-pointer-checks -marm 
+export EXTRACFLAGS := -march=armv7-a -mtune=cortex-a9 -fomit-frame-pointer -fno-caller-saves -mfloat-abi=soft -DBCMWPA2 -DBCMARM
  endif
 endif
 
@@ -24,8 +24,8 @@
 export CROSS_COMPILER := $(CROSS_COMPILE)
 export CONFIGURE := ./configure LD=$(CROSS_COMPILE)ld --host=arm-buildroot-linux-gnueabi
 export CONFIGURE_64 := ./configure LD=$(CROSS_COMPILE_64)ld --host=aarch64-buildroot-linux-gnu 
-export HOSTCONFIG := linux-armv4 -DOPENSSL_NO_HEARTBEATS -DL_ENDIAN -march=armv7-a -fomit-frame-pointer -mabi=aapcs-linux -marm -ffixed-r8 -msoft-float -D__ARM_ARCH_7A__
-export HOSTCONFIG_64 := linux-aarch64 -DOPENSSL_NO_HEARTBEATS -DL_ENDIAN no-engine -Os -march=armv8-a -fomit-frame-pointer -mabi=lp64 -ffixed-r8 -D__ARM_ARCH_8A__ no-asm
+export HOSTCONFIG := linux-armv4 -DOPENSSL_NO_HEARTBEATS -DL_ENDIAN -march=armv8-a+crc -mtune=cortex-a53 -mfpu=crypto-neon-fp-armv8 -fomit-frame-pointer -fno-caller-saves
+export HOSTCONFIG_64 := linux-aarch64 -DOPENSSL_NO_HEARTBEATS -DL_ENDIAN -march=armv8-a -fomit-frame-pointer -fno-caller-saves
 export BCMEX := _arm
 export ARCH := arm
 export HOST :=
--- a/release/src/router/config_base
+++ b/release/src/router/config_base
@@ -347,7 +347,7 @@
 # RTCONFIG_WAN_AT_P4 is not set
 # RTCONFIG_MTK_REP is not set
 # RTCONFIG_NOTIFICATION_CENTER is not set
-RTCONFIG_PROTECTION_SERVER=y
+# RTCONFIG_PROTECTION_SERVER is not set
 RTCONFIG_6RELAYD=y
 # RTCONFIG_BCMASPMD is not set
 # RTCONFIG_FBT is not set
--- a/release/src/router/Makefile
+++ b/release/src/router/Makefile
@@ -691,6 +691,191 @@
 obj-y += iproute2-3.15.0
 endif
 
+######################################################################
+#
+# Blackfuel addons
+#
+ASUSWRT_DIR:=`echo $${PWD%/release\/src*}`
+ASUSWRT_ADDON:=../asuswrt-merlin-addon
+ASUSWRT_ADDON_DIR:=$(ASUSWRT_DIR)/$(ASUSWRT_ADDON)
+BLACKFUEL_DIR:=$(ASUSWRT_DIR)/blackfuel-addon
+BLACKFUEL_OPTIMIZED_ARMV7:=-march=armv7-a -mtune=cortex-a9 -fomit-frame-pointer -fno-caller-saves -mfloat-abi=soft
+BLACKFUEL_OPTIMIZED_ARMV8_32:=-march=armv8-a+crc -mtune=cortex-a53 -mfpu=crypto-neon-fp-armv8 -fomit-frame-pointer -fno-caller-saves -DHND_ROUTER
+BLACKFUEL_OPTIMIZED_ARMV8_64:=-march=armv8-a+crypto -fomit-frame-pointer -fno-caller-saves -DHND_ROUTER
+BLACKFUEL_OPTIMIZED_COPTS:=$(if $(RTCONFIG_HND_ROUTER),$(BLACKFUEL_OPTIMIZED_ARMV8_64),$(BLACKFUEL_OPTIMIZED_ARMV7))
+BLACKFUEL_COMPATIBILE_COPTS:=$(if $(RTCONFIG_HND_ROUTER),$(BLACKFUEL_OPTIMIZED_ARMV8_32),$(BLACKFUEL_OPTIMIZED_ARMV7))
+BLACKFUEL_CURRENT_ARCH:=$(if $(RTCONFIG_HND_ROUTER),CURRENT_ARCH="aarch64",)
+BLACKFUEL_OPTIMIZED_CC:=$(if $(RTCONFIG_HND_ROUTER),$(CROSS_COMPILE_64)gcc,$(TOOLS)/bin/$(CC))
+BLACKFUEL_OPTIMIZED_CXX:=$(if $(RTCONFIG_HND_ROUTER),$(CROSS_COMPILE_64)g++,$(TOOLS)/bin/$(CXX))
+BLACKFUEL_OPTIMIZED_CPP:=$(if $(RTCONFIG_HND_ROUTER),$(CROSS_COMPILE_64)cpp,$(TOOLS)/bin/$(CPP))
+BLACKFUEL_OPTIMIZED_AR:=$(if $(RTCONFIG_HND_ROUTER),$(CROSS_COMPILE_64)ar,$(TOOLS)/bin/$(AR))
+BLACKFUEL_OPTIMIZED_AS:=$(if $(RTCONFIG_HND_ROUTER),$(CROSS_COMPILE_64)as,$(TOOLS)/bin/$(AS))
+BLACKFUEL_OPTIMIZED_LD:=$(if $(RTCONFIG_HND_ROUTER),$(CROSS_COMPILE_64)ld,$(TOOLS)/bin/$(LD))
+BLACKFUEL_OPTIMIZED_NM:=$(if $(RTCONFIG_HND_ROUTER),$(CROSS_COMPILE_64)nm,$(TOOLS)/bin/$(NM))
+BLACKFUEL_OPTIMIZED_OBJCOPY:=$(if $(RTCONFIG_HND_ROUTER),$(CROSS_COMPILE_64)objcopy,$(TOOLS)/bin/$(OBJCOPY))
+BLACKFUEL_OPTIMIZED_OBJDUMP:=$(if $(RTCONFIG_HND_ROUTER),$(CROSS_COMPILE_64)objdump,$(TOOLS)/bin/$(OBJDUMP))
+BLACKFUEL_OPTIMIZED_RANLIB:=$(if $(RTCONFIG_HND_ROUTER),$(CROSS_COMPILE_64)ranlib,$(TOOLS)/bin/$(RANLIB))
+BLACKFUEL_OPTIMIZED_SIZE:=$(if $(RTCONFIG_HND_ROUTER),$(CROSS_COMPILE_64)size,$(TOOLS)/bin/$(SIZE))
+BLACKFUEL_OPTIMIZED_STRIP:=$(if $(RTCONFIG_HND_ROUTER),$(CROSS_COMPILE_64)strip,$(TOOLS)/bin/$(STRIP))
+BLACKFUEL_OPTIMIZED_CONFIGURE:=$(if $(RTCONFIG_HND_ROUTER),./configure LD=/opt/toolchains/crosstools-aarch64-gcc-5.3-linux-4.1-glibc-2.22-binutils-2.25/usr/bin/aarch64-buildroot-linux-gnu-ld --host=aarch64-buildroot-linux-gnu ,$(CONFIGURE))
+BLACKFUEL_OPTIMIZED_TOOLCHAIN:=CC="$(BLACKFUEL_OPTIMIZED_CC)" CXX="$(BLACKFUEL_OPTIMIZED_CXX)" CPP="$(BLACKFUEL_OPTIMIZED_CPP)" AR="$(BLACKFUEL_OPTIMIZED_AR)" AS="$(BLACKFUEL_OPTIMIZED_AS)" LD="$(BLACKFUEL_OPTIMIZED_LD)" NM="$(BLACKFUEL_OPTIMIZED_NM)" OBJCOPY="$(BLACKFUEL_OPTIMIZED_OBJCOPY)" OBJDUMP="$(BLACKFUEL_OPTIMIZED_OBJDUMP)" RANLIB="$(BLACKFUEL_OPTIMIZED_RANLIB)" SIZE="$(BLACKFUEL_OPTIMIZED_SIZE)" STRIP="$(BLACKFUEL_OPTIMIZED_STRIP)" $(BLACKFUEL_CURRENT_ARCH)
+BLACKFUEL_OPTIMIZED_LIB:=$(if $(RTCONFIG_HND_ROUTER),lib64,lib)
+BLACKFUEL_OPTIMIZED_SYSROOT:=$(if $(RTCONFIG_HND_ROUTER),/opt/toolchains/crosstools-aarch64-gcc-5.3-linux-4.1-glibc-2.22-binutils-2.25/usr/aarch64-buildroot-linux-gnu/sysroot,$(TOOLS)/bin/arm-brcm-linux-uclibcgnueabi/sysroot)
+BLACKFUEL_OPTIMIZED_HOST:=$(if $(RTCONFIG_HND_ROUTER),aarch64-buildroot-linux-gnu,arm-brcm-linux-uclibcgnueabi)
+
+obj-y += openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += curl$(if $(RTCONFIG_HND_ROUTER),-aarch64,-7.21.7)
+obj-y += lzo$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += mbedtls
+obj-y += strace
+obj-y += xtables-addons
+
+RTCONFIG_APCUPSD:=y
+ifeq ($(RTCONFIG_APCUPSD),y)
+RTCONFIG_APCUPSD_CGI:=y
+obj-y += apcupsd
+obj-y += libusb-0.1.12$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += libgd
+obj-y += freetype
+obj-y += libtiff
+obj-y += libpng
+obj-y += bzip2
+obj-y += jpeg$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += zlib$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+endif
+
+RTCONFIG_POWSTATD:=y
+ifeq ($(RTCONFIG_POWSTATD),y)
+obj-y += powstatd
+endif
+
+RTCONFIG_TRANSMISSION:=openssl
+ifeq ($(RTCONFIG_TRANSMISSION),openssl)
+obj-y += transmission-openssl
+obj-y += openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += zlib$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += libevent-2.0.21$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+else
+ifeq ($(RTCONFIG_TRANSMISSION),mbedtls)
+obj-y += transmission-mbedtls
+obj-y += openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += zlib$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += libevent-2.0.21$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += mbedtls
+endif
+endif
+
+RTCONFIG_CRYPTSETUP:=gcrypt
+ifeq ($(RTCONFIG_CRYPTSETUP),gcrypt)
+obj-y += cryptsetup-gcrypt
+obj-y += libargon2
+obj-y += libgcrypt
+obj-y += libgpg-error
+obj-y += libaio
+obj-y += lvm2
+obj-y += util-linux
+obj-y += popt
+obj-y += json-c$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+else
+ifeq ($(RTCONFIG_CRYPTSETUP),openssl)
+obj-y += cryptsetup-openssl
+obj-y += libargon2
+obj-y += openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += libaio
+obj-y += lvm2
+obj-y += util-linux
+obj-y += popt
+obj-y += json-c$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+else
+ifeq ($(RTCONFIG_CRYPTSETUP),nettle)
+obj-y += cryptsetup-nettle
+obj-y += libargon2
+obj-y += nettle$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += libaio
+obj-y += lvm2
+obj-y += util-linux
+obj-y += popt
+obj-y += json-c$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+else
+ifeq ($(RTCONFIG_CRYPTSETUP),kernel)
+obj-y += cryptsetup-kernel
+obj-y += libargon2
+obj-y += libaio
+obj-y += lvm2
+obj-y += util-linux
+obj-y += popt
+obj-y += json-c$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+endif
+endif
+endif
+endif
+
+RTCONFIG_RTLENTROPY:=y
+ifeq ($(RTCONFIG_RTLENTROPY),y)
+obj-y += rtl-entropy
+
+LIBS_DL:=`$(BLACKFUEL_OPTIMIZED_CC) -print-file-name=libdl.a`
+LIBS_PTHREAD:=`$(BLACKFUEL_OPTIMIZED_CC) -print-file-name=libpthread.a`
+LIBS_M:=`$(BLACKFUEL_OPTIMIZED_CC) -print-file-name=libm.a`
+LIBS_RT:=`$(BLACKFUEL_OPTIMIZED_CC) -print-file-name=librt.a`
+LIBS_C:=`$(BLACKFUEL_OPTIMIZED_CC) -print-file-name=libc.a`
+endif
+
+RTCONFIG_NTP:=y
+ifeq ($(RTCONFIG_NTP),y)
+obj-y += ntp
+obj-y += openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += libcap
+obj-y += util-linux
+obj-y += pps-tools
+obj-y += setserial
+endif
+
+RTCONFIG_FINDUTILS:=y
+ifeq ($(RTCONFIG_FINDUTILS),y)
+obj-y += findutils
+endif
+
+RTCONFIG_WHOIS:=y
+ifeq ($(RTCONFIG_WHOIS),y)
+obj-y += whois
+endif
+
+RTCONFIG_WIPE:=y
+ifeq ($(RTCONFIG_WIPE),y)
+obj-y += wipe
+endif
+
+RTCONFIG_DNSCRYPT:=y
+ifeq ($(RTCONFIG_DNSCRYPT),y)
+obj-y += dnscrypt
+obj-y += libsodium
+endif
+
+RTCONFIG_HAVEGED:=y
+ifeq ($(RTCONFIG_HAVEGED),y)
+obj-y += haveged
+endif
+
+RTCONFIG_DIEHARDER:=y
+ifeq ($(RTCONFIG_DIEHARDER),y)
+obj-y += dieharder
+obj-y += gsl
+endif
+
+RTCONFIG_RNGTOOLS:=y
+ifeq ($(RTCONFIG_RNGTOOLS),y)
+obj-y += rng-tools
+obj-y += libgcrypt
+obj-y += libgpg-error
+ifneq ($(HND_ROUTER),y)
+obj-y += argp-standalone
+endif
+endif
+
+
+######################################################################
+
 obj-$(RTCONFIG_PERMISSION_MANAGEMENT) += sqlite
 obj-$(RTCONFIG_PERMISSION_MANAGEMENT) += sqlCipher
 obj-$(RTCONFIG_PERMISSION_MANAGEMENT) += PMS_DBapis
@@ -1226,8 +1411,6 @@
 
 obj-$(RTCONFIG_GEOIP) += GeoIP-1.6.2
 
-obj-$(RTCONFIG_TRANSMISSION) += Transmission curl-7.21.7 libevent-2.0.21
-
 # Begin merlin add-ons
 obj-$(RTCONFIG_NANO) += ncurses-6.0
 obj-$(RTCONFIG_NANO) += nano
@@ -1252,9 +1435,12 @@
 # End merlin add-ons
 
 ifeq ($(RTCONFIG_TOR),y)
-obj-y += openssl
-obj-y += zlib
-obj-y += libevent-2.0.21
+obj-y += openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += zlib$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += libevent-2.0.21$(if $(RTCONFIG_HND_ROUTER),-aarch64,)
+obj-y += liblz4
+obj-y += xzutils
+obj-y += zstd
 obj-y += tor
 endif
 
@@ -1591,6 +1777,8 @@
 	done
 
 	@cd $(TARGETDIR) && $(TOP)/others/rootprep${BCMEX}${EX7}.sh
+	@echo "Copying my custom pre-compiled programs to the install directory."
+	[ ! -d "$(BLACKFUEL_DIR)/staging" ] || cp -afv "$(BLACKFUEL_DIR)/staging/"* "$(TARGETDIR)/"
 	@echo ---
 
 	# extra install in case build-process skip them
@@ -1608,10 +1796,28 @@
 	install -D $(TOOLCHAIN)/arm-buildroot-linux-gnueabi/sysroot/lib/libpthread.so.0 $(INSTALLDIR)/lib/libpthread.so.0
 	install -D $(TOOLCHAIN)/arm-buildroot-linux-gnueabi/sysroot/lib/libdl.so.2 $(INSTALLDIR)/lib/libdl.so.2
 	install -D $(TOOLCHAIN)/arm-buildroot-linux-gnueabi/sysroot/lib/libgcc_s.so.1 $(INSTALLDIR)/lib/libgcc_s.so.1
-	install -D $(TOOLCHAIN_64)/aarch64-buildroot-linux-gnu/sysroot/lib/ld-linux-aarch64.so.1 $(INSTALLDIR)/lib/ld-linux-aarch64.so.1
-	install -D $(TOOLCHAIN_64)/aarch64-buildroot-linux-gnu/sysroot/lib/libc.so.6 $(INSTALLDIR)/lib/aarch64/libc.so.6
-	install -D $(TOOLCHAIN_64)/aarch64-buildroot-linux-gnu/sysroot/lib/libnss_dns.so.2 $(INSTALLDIR)/lib/aarch64/libnss_dns.so.2
-	install -D $(TOOLCHAIN_64)/aarch64-buildroot-linux-gnu/sysroot/lib/libnss_files.so.2 $(INSTALLDIR)/lib/aarch64/libnss_files.so.2
+#	install -D $(TOOLCHAIN_64)/aarch64-buildroot-linux-gnu/sysroot/lib/ld-linux-aarch64.so.1 $(INSTALLDIR)/lib/ld-linux-aarch64.so.1
+#	install -D $(TOOLCHAIN_64)/aarch64-buildroot-linux-gnu/sysroot/lib/libc.so.6 $(INSTALLDIR)/lib/aarch64/libc.so.6
+#	install -D $(TOOLCHAIN_64)/aarch64-buildroot-linux-gnu/sysroot/lib/libnss_dns.so.2 $(INSTALLDIR)/lib/aarch64/libnss_dns.so.2
+#	install -D $(TOOLCHAIN_64)/aarch64-buildroot-linux-gnu/sysroot/lib/libnss_files.so.2 $(INSTALLDIR)/lib/aarch64/libnss_files.so.2
+
+ifeq ($(RTCONFIG_HND_ROUTER),y)
+	# support legacy ARMv7 uClibc programs on HND platform
+	install -D $(ASUSWRT_DIR)/release/src-rt-6.x.4708/toolchains/hndtools-arm-linux-2.6.36-uclibc-4.5.3/lib/ld-uClibc.so.0 $(INSTALLDIR)/lib/ld-uClibc.so.0
+	mkdir -p $(INSTALLDIR)/lib/arm-uclibc
+	install -D $(ASUSWRT_DIR)/release/src-rt-6.x.4708/toolchains/hndtools-arm-linux-2.6.36-uclibc-4.5.3/lib/libc.so.0 $(INSTALLDIR)/lib/arm-uclibc/libc.so.0
+	install -D $(ASUSWRT_DIR)/release/src-rt-6.x.4708/toolchains/hndtools-arm-linux-2.6.36-uclibc-4.5.3/lib/libm.so.0 $(INSTALLDIR)/lib/arm-uclibc/libm.so.0
+	install -D $(ASUSWRT_DIR)/release/src-rt-6.x.4708/toolchains/hndtools-arm-linux-2.6.36-uclibc-4.5.3/lib/libdl.so.0 $(INSTALLDIR)/lib/arm-uclibc/libdl.so.0
+	install -D $(ASUSWRT_DIR)/release/src-rt-6.x.4708/toolchains/hndtools-arm-linux-2.6.36-uclibc-4.5.3/lib/libcrypt.so.0 $(INSTALLDIR)/lib/arm-uclibc/libcrypt.so.0
+	install -D $(ASUSWRT_DIR)/release/src-rt-6.x.4708/toolchains/hndtools-arm-linux-2.6.36-uclibc-4.5.3/lib/libgcc_s.so.1 $(INSTALLDIR)/lib/arm-uclibc/libgcc_s.so.1
+	install -D $(ASUSWRT_DIR)/release/src-rt-6.x.4708/toolchains/hndtools-arm-linux-2.6.36-uclibc-4.5.3/lib/libnsl.so.0 $(INSTALLDIR)/lib/arm-uclibc/libnsl.so.0
+	install -D $(ASUSWRT_DIR)/release/src-rt-6.x.4708/toolchains/hndtools-arm-linux-2.6.36-uclibc-4.5.3/lib/libpthread.so.0 $(INSTALLDIR)/lib/arm-uclibc/libpthread.so.0
+	install -D $(ASUSWRT_DIR)/release/src-rt-6.x.4708/toolchains/hndtools-arm-linux-2.6.36-uclibc-4.5.3/lib/librt.so.0 $(INSTALLDIR)/lib/arm-uclibc/librt.so.0
+	install -D $(ASUSWRT_DIR)/release/src-rt-6.x.4708/toolchains/hndtools-arm-linux-2.6.36-uclibc-4.5.3/lib/libutil.so.0 $(INSTALLDIR)/lib/arm-uclibc/libutil.so.0
+	install -D $(ASUSWRT_DIR)/release/src-rt-6.x.4708/toolchains/hndtools-arm-linux-2.6.36-uclibc-4.5.3/lib/libresolv.so.0 $(INSTALLDIR)/lib/arm-uclibc/libresolv.so.0
+	chmod u+w $(INSTALLDIR)/lib/arm-uclibc/*
+	$(STRIP) $(INSTALLDIR)/lib/arm-uclibc/*.so*
+endif
 
 ifeq ($(RTCONFIG_CFEZ),y)
 	install -D $(TOP)/envram_bin/envram$(BCMEX)$(EX7)/envrams $(INSTALLDIR)/usr/sbin/envrams
@@ -1640,8 +1846,8 @@
 	rm -rf $(INSTALLDIR)/rom/rom/etc
 
 	# strip size for tmp
-	#rm -rf $(INSTALLDIR)/rom/*.ipk
-	#rm -rf $(INSTALLDIR)/rom/*.tgz
+	rm -rf $(INSTALLDIR)/rom/*.ipk
+	rm -rf $(INSTALLDIR)/rom/*.tgz
 	#rm -rf $(INSTALLDIR)/usr/lighttpd/css
 	#rm -rf $(INSTALLDIR)/usr/lighttpd/js
 	#rm -rf $(INSTALLDIR)/www/images/New_ui
@@ -1811,6 +2017,8 @@
 	@echo ---
 else
 	@cd $(TARGETDIR) && $(TOP)/others/rootprep${BCMEX}.sh
+	@echo "Copying my custom pre-compiled programs to the install directory."
+	[ ! -d $(BLACKFUEL_DIR)/staging ] || cp -afv $(BLACKFUEL_DIR)/staging/* $(TARGETDIR)/
 	@echo ---
 endif
 
@@ -1872,7 +2080,7 @@
 #	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/scsi/sr_mod.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/scanner.*o $(PLATFORMDIR)/extras/ || true
 
-	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbserial.*o $(PLATFORMDIR)/extras/ || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbserial.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/option.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/*acm.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/cdc-wdm.*o $(PLATFORMDIR)/extras/ || true
@@ -1887,7 +2095,7 @@
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/net/usb/ipheth.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/sierra.*o $(PLATFORMDIR)/extras/ || true
 
-	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbkbd.*o $(PLATFORMDIR)/extras/ || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbkbd.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbmouse.*o $(PLATFORMDIR)/extras/ || true
 #	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/hid*.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/ipw.*o $(PLATFORMDIR)/extras/ || true
@@ -1910,8 +2118,8 @@
 	$(if $(RTCONFIG_PPTP),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/net/pptp.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_L2TP),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/net/pppol2tp.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/net/ppp_deflate.*o $(PLATFORMDIR)/extras/ || true
-	@mv $(TARGETDIR)/lib/modules/*/kernel/crypto/* $(PLATFORMDIR)/extras/ || true
-	@rm -rf $(TARGETDIR)/lib/modules/*/kernel/crypto || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/crypto/* $(PLATFORMDIR)/extras/ || true
+	[ ! -f $(TARGETDIR)/lib/modules/*/kernel/crypto/* ] && rm -rf $(TARGETDIR)/lib/modules/*/kernel/crypto || true
 
 	$(if $(NEED_EX_NLS),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/fs/nls_cp9*.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(NEED_EX_NLS),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/fs/nls_cp1251.*o $(PLATFORMDIR)/extras/ || true
@@ -2259,7 +2467,67 @@
 menuconfig mconf: rmconf kmconf
 
 oldconfig oldconf: koldconf roldconf bboldconf
+	$(call CleanBlackfuel)
 
+define CleanBlackfuel
+	[ -d "$(BLACKFUEL_DIR)" ] || (mkdir -p $(ASUSWRT_ADDON_DIR) && rm -f "$(BLACKFUEL_DIR)" && ln -s $(ASUSWRT_ADDON) "$(BLACKFUEL_DIR)"); \
+	if [ ! -d "$(BLACKFUEL_DIR)/packages" ]; then \
+		echo "The blackfuel packages directory is missing: $(BLACKFUEL_DIR)/packages"; \
+		false; \
+	else \
+		rm -rf "$(TOP)/nettle" "$(TOP)/nettle-aarch64"; \
+		rm -rf "$(TOP)/curl" "$(TOP)/curl-aarch64"; \
+		rm -rf "$(TOP)/wget"; \
+		rm -rf "$(TOP)/jpeg" "$(TOP)/jpeg-aarch64"; \
+		rm -rf "$(TOP)/zlib" "$(TOP)/zlib-aarch64"; \
+		rm -rf "$(TOP)/lzo" "$(TOP)/lzo-aarch64"; \
+		rm -rf "$(TOP)/json-c" "$(TOP)/json-c-aarch64"; \
+		rm -rf "$(TOP)/ncurses-6.0" "$(TOP)/ncurses-aarch64"; \
+		rm -rf "$(TOP)/openssl-aarch64" && cp -a "$(TOP)/openssl" "$(TOP)/openssl-aarch64"; \
+		rm -rf "$(TOP)/libevent-2.0.21-aarch64" && cp -a "$(TOP)/libevent-2.0.21" "$(TOP)/libevent-2.0.21-aarch64"; \
+		rm -rf "$(TOP)/libusb-0.1.12-aarch64" && cp -a "$(TOP)/libusb-0.1.12" "$(TOP)/libusb-0.1.12-aarch64"; \
+		rm -rf "$(TOP)/libusb10-aarch64" && cp -a "$(TOP)/libusb10" "$(TOP)/libusb10-aarch64"; \
+		rm -rf "$(TOP)/xzutils"; \
+		rm -rf "$(TOP)/zstd"; \
+		rm -rf "$(TOP)/tor"; \
+		rm -rf "$(TOP)/findutils"; \
+		rm -rf "$(TOP)/whois"; \
+		rm -rf "$(TOP)/libsodium"; \
+		rm -rf "$(TOP)/dnscrypt"; \
+		rm -rf "$(TOP)/haveged"; \
+		rm -rf "$(TOP)/wipe"; \
+		rm -rf "$(TOP)/gsl"; \
+		rm -rf "$(TOP)/dieharder"; \
+		rm -rf "$(TOP)/popt"; \
+		rm -rf "$(TOP)/libgpg-error"; \
+		rm -rf "$(TOP)/util-linux"; \
+		rm -rf "$(TOP)/libaio"; \
+		rm -rf "$(TOP)/lvm2"; \
+		rm -rf "$(TOP)/libgcrypt"; \
+		rm -rf "$(TOP)/cryptsetup-gcrypt" "$(TOP)/cryptsetup-openssl" "$(TOP)/cryptsetup-nettle" "$(TOP)/cryptsetup-kernel"; \
+		rm -rf "$(TOP)/pps-tools"; \
+		rm -rf "$(TOP)/setserial"; \
+		rm -rf "$(TOP)/ntp"; \
+		rm -rf "$(TOP)/argp-standalone"; \
+		rm -rf "$(TOP)/libcap"; \
+		rm -rf "$(TOP)/rtl-sdr"; \
+		rm -rf "$(TOP)/rtl-entropy"; \
+		rm -rf "$(TOP)/transmission-openssl" "$(TOP)/transmission-mbedtls"; \
+		rm -rf "$(TOP)/mbedtls"; \
+		rm -rf "$(TOP)/apcupsd"; \
+		rm -rf "$(TOP)/libgd"; \
+		rm -rf "$(TOP)/libpng"; \
+		rm -rf "$(TOP)/libtiff"; \
+		rm -rf "$(TOP)/freetype"; \
+		rm -rf "$(TOP)/bzip2"; \
+		rm -rf "$(TOP)/powstatd"; \
+		rm -rf "$(TOP)/liblz4"; \
+		rm -rf "$(TOP)/strace"; \
+		rm -rf "$(TOP)/strongswan-5.2.1/*.a" "$(TOP)/strongswan-5.2.1/*.o" ; \
+		sed -r -i 's/(\| arm-\*  \| armbe-\* \| armle-\* \| )/\| aarch64-\* \1/g' $$(find $(TOP)/ -name 'config.sub' -print0 | xargs -0 -I '{}' grep -FL 'aarch64-*' '{}') || true; \
+		true; \
+	fi
+endef
 
 #
 # overrides and extra dependencies
@@ -2295,10 +2563,10 @@
 	chmod 4755 $(INSTALLDIR)/$(BUSYBOX)/bin/busybox
 
 busybox-clean:
-	$(MAKE) -C $(BUSYBOX_DIR) distclean
+	-@$(MAKE) -C $(BUSYBOX_DIR) distclean
 
 busybox-%-clean:
-	$(MAKE) -C $(BUSYBOX_DIR) distclean
+	-@$(MAKE) -C $(BUSYBOX_DIR) distclean
 
 busybox-config:
 	$(MAKE) -C $(BUSYBOX_DIR) menuconfig
@@ -2419,11 +2687,17 @@
 	@true
 
 ifeq ($(RTCONFIG_OPENVPN),y)
+ifneq ($(RTCONFIG_TRANSMISSION),openssl)
 OPENSSL_CIPHERS:=enable-rc5 no-rc4
 else
+OPENSSL_CIPHERS:=enable-rc5
+endif
+else
+ifneq ($(RTCONFIG_TRANSMISSION),openssl)
 #OPENSSL_CIPHERS:=no-dh no-idea no-rc2 no-rc5 no-aes no-aes192 no-cast no-des no-modes no-tls1 no-tlsext
 OPENSSL_CIPHERS:=no-rc4
 endif
+endif
 
 #OPENSSL_CIPHERS:=enable-aes enable-tls1 enable-tlsext
 
@@ -2468,6 +2742,7 @@
 	./Configure $(HOSTCONFIG) -DOPENSSL_NO_BUF_FREELISTS --prefix=/usr --openssldir=/etc --cross-compile-prefix=' ' \
 	-ffunction-sections -fdata-sections -Wl,--gc-sections \
 	shared $(OPENSSL_CIPHERS) no-ssl2 no-ssl3
+#	-I$(TOP)/cryptodev-linux -DHAVE_CRYPTODEV -DUSE_CRYPTODEV_DIGESTS
 #	no-sha0 no-smime no-camellia no-krb5 no-rmd160 no-ripemd \
 #	no-seed no-capieng no-cms no-gms no-gmp no-rfc3779 \
 #	no-ec no-ecdh no-ecdsa no-err no-hw no-jpake no-threads \
@@ -2507,6 +2782,7 @@
 else
 openssl: openssl/Makefile
 endif
+	$(if $(RTCONFIG_HND_ROUTER),sed -r -i 's/^EXE= \$$\(PROGRAM\)\$$\(EXE_EXT\)$$/EXE=openssl32/g' openssl/apps/Makefile,)
 	$(MAKE) -C openssl && $(MAKE) $@-stage
 
 openssl-clean:
@@ -2524,9 +2800,9 @@
 	[ ! -f openssl/Makefile ] || $(STRIP) $(INSTALLDIR)$(INSTALLSUBDIR)/usr/lib/libcrypto.so.1.0.0
 	[ ! -f openssl/Makefile ] || cd $(INSTALLDIR)$(INSTALLSUBDIR)/usr/lib && rm -f libcrypto.so && ln -sf libcrypto.so.1.0.0 libcrypto.so
 
-	[ ! -f openssl/Makefile ] || install -D openssl/apps/openssl $(INSTALLDIR)$(INSTALLSUBDIR)/usr/sbin/openssl
-	[ ! -f openssl/Makefile ] || $(STRIP) $(INSTALLDIR)$(INSTALLSUBDIR)/usr/sbin/openssl
-	[ ! -f openssl/Makefile ] || chmod 0500 $(INSTALLDIR)$(INSTALLSUBDIR)/usr/sbin/openssl
+	[ ! -f openssl/Makefile ] || install -D openssl/apps/openssl$(if $(RTCONFIG_HND_ROUTER),32,) $(INSTALLDIR)$(INSTALLSUBDIR)/usr/sbin/openssl$(if $(RTCONFIG_HND_ROUTER),32,)
+	[ ! -f openssl/Makefile ] || $(STRIP) $(INSTALLDIR)$(INSTALLSUBDIR)/usr/sbin/openssl$(if $(RTCONFIG_HND_ROUTER),32,)
+	[ ! -f openssl/Makefile ] || chmod 0500 $(INSTALLDIR)$(INSTALLSUBDIR)/usr/sbin/openssl$(if $(RTCONFIG_HND_ROUTER),32,)
 
 ifeq ($(or $(RTCONFIG_WEBDAV),$(RTCONFIG_FTP_SSL),$(RTCONFIG_OPENVPN),$(RTCONFIG_HTTPS)),y)
 	[ ! -f openssl/Makefile ] || install -D openssl/libssl.so.1.0.0 $(INSTALLDIR)$(INSTALLSUBDIR)/usr/lib/libssl.so.1.0.0
@@ -2554,7 +2830,7 @@
 
 push_log: wb
 
-rc: shared nvram$(BCMEX)$(EX7) libbcmcrypto libdisk $(if $(RTCONFIG_FBWIFI),fb_wifi) $(if $(RTCONFIG_QTN),libqcsapi_client) $(if $(CONFIG_LIBBCM),libbcm) $(if $(RTCONFIG_BWDPI),bwdpi_source) $(if $(RTCONFIG_USB_SMS_MODEM),smspdu) $(if $(RTCONFIG_HND_ROUTER),bcm_flashutil bcm_util bcm_boardctl) $(if $(RTCONFIG_OPENVPN),libvpn) $(if $(RTCONFIG_LANTIQ),libfapi-0.1) $(if $(RTCONFIG_CFGSYNC), $(CFGSYNC_PKG) $(if $(RTCONFIG_AMAS), amas-utils) $(if $(RTCONFIG_LANTIQ),hostapd-2.6))
+rc: shared nvram$(BCMEX)$(EX7) libbcmcrypto libdisk $(if $(RTCONFIG_FBWIFI),fb_wifi) $(if $(RTCONFIG_QTN),libqcsapi_client) $(if $(CONFIG_LIBBCM),libbcm) $(if $(RTCONFIG_BWDPI),bwdpi_source) $(if $(RTCONFIG_USB_SMS_MODEM),smspdu) $(if $(RTCONFIG_HND_ROUTER),bcm_flashutil bcm_util bcm_boardctl) $(if $(RTCONFIG_OPENVPN),libvpn) $(if $(RTCONFIG_LANTIQ),libfapi-0.1) $(if $(RTCONFIG_CFGSYNC), $(CFGSYNC_PKG) $(if $(RTCONFIG_AMAS), amas-utils) $(if $(RTCONFIG_LANTIQ),hostapd-2.6)) json-c
 	@$(SEP)
 # Dig into our collection of prebuilt objects based on model
 	@-rm -f rc/prebuild/*.o || true
@@ -2728,11 +3004,11 @@
 		$(if $(RTCONFIG_IPV6),-DUSE_IPV6,-DNO_IPV6) \
 		$(if $(RTCONFIG_USB_EXTRAS)||$(RTCONFIG_TR069),,-DNO_SCRIPT) \
 		$(if $(RTCONFIG_USB_EXTRAS),,-DNO_TFTP) \
-		$(if $(RTCONFIG_DNSSEC),-I$(TOP)/nettle/include -I$(TOP)/gmp -DHAVE_DNSSEC -DHAVE_DNSSEC_STATIC,)" \
+		$(if $(RTCONFIG_DNSSEC),-I$(STAGEDIR)/usr/include -I$(TOP)/gmp -DHAVE_DNSSEC -DHAVE_DNSSEC_STATIC,)" \
 	CFLAGS="-Os -ffunction-sections -fdata-sections $(EXTRACFLAGS)" \
 	LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections $(EXTRALDFLAGS) \
-		$(if $(RTCONFIG_DNSSEC),-L$(TOP)/nettle/lib -L$(TOP)/gmp/.libs,)" \
-	$(if $(RTCONFIG_DNSSEC),PKG_CONFIG_PATH="$(TOP)/nettle/lib/pkgconfig",)
+		$(if $(RTCONFIG_DNSSEC),-L$(STAGEDIR)/usr/lib -L$(TOP)/gmp/.libs,)" \
+	$(if $(RTCONFIG_DNSSEC),PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig",)
 
 dnsmasq-install:
 	install -D dnsmasq/src/dnsmasq $(INSTALLDIR)/dnsmasq/usr/sbin/dnsmasq
@@ -2906,14 +3182,14 @@
 	cd miniupnpd && ./genconfig.sh --vendorcfg --leasefile --portinuse
 endif
 
-miniupnpd: $(IPTABLES) e2fsprogs miniupnpd/config.h
+miniupnpd: $(IPTABLES) util-linux miniupnpd/config.h
 	@$(SEP)
 	cp -f ./shared/version.h miniupnpd$(MUVER)/.
 	PKG_CONFIG=false ARCH=$(PLATFORM) \
 	$(MAKE) -C $@ -f Makefile.merlin $(PARALLEL_BUILD) \
 	    IPTABLESPATH=$(TOP)/$(IPTABLES) \
-	    EXTRACFLAGS="-Os $(EXTRACFLAGS) -idirafter$(KERNEL_HEADER_DIR) -ffunction-sections -fdata-sections -I$(TOP)/e2fsprogs/lib" \
-	    LDFLAGS="$(EXTRALDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(IPTC_LIBDIR) -L$(TOP)/e2fsprogs/lib" \
+	    EXTRACFLAGS="-Os $(EXTRACFLAGS) -idirafter$(KERNEL_HEADER_DIR) -ffunction-sections -fdata-sections -I$(STAGEDIR)/usr/include" \
+	    LDFLAGS="$(EXTRALDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(IPTC_LIBDIR) -L$(STAGEDIR)/usr/lib" \
 	    LDLIBS="-Wl,--as-needed $(IPTC_LIBS) -luuid"
 
 miniupnpd-clean:
@@ -3071,7 +3347,8 @@
 	touch $@
 
 libusb10: libusb10/stamp-h1
-	$(MAKE) -C $@
+	$(MAKE) -C $@ && \
+	DESTDIR="$(STAGEDIR)" $(MAKE) -C $@ install
 
 libusb10-install: libusb10
 	install -D libusb10/libusb/.libs/libusb-1.0.so.0.0.0 $(INSTALLDIR)/libusb10/usr/lib/libusb-1.0.so.0
@@ -3222,7 +3499,7 @@
 	( cd lsof ; ./Configure -clean )
 	@rm -f lsof/Makefile
 
-mtd-utils: e2fsprogs lzo zlib
+mtd-utils: util-linux lzo zlib
 ifeq ($(ALPINE)$(LANTIQ),y)
 	$(MAKE) CPPFLAGS="-I$(STAGEDIR)/usr/include -DWITHOUT_XATTR" \
 		CFLAGS="-I$(TOP)/mtd-utils/include -I$(TOP)/mtd-utils/ubi-utils/include" \
@@ -3241,45 +3518,6 @@
 mtd-utils-clean:
 	$(MAKE) -C mtd-utils clean
 
-util-linux: util-linux/Makefile
-	$(MAKE) -C $@/libuuid/src && $(MAKE) $@-stage
-
-util-linux/Makefile: util-linux/configure
-	$(MAKE) util-linux-configure
-
-util-linux/configure:
-	( cd util-linux ; ./autogen.sh )
-
-util-linux-configure:
-	( export scanf_cv_alloc_modifier=no; \
-		cd util-linux ; \
-		$(CONFIGURE) \
-		--prefix=/usr \
-		--bindir=/usr/sbin \
-		--libdir=/usr/lib \
-		--enable-libuuid \
-		--disable-nls --disable-tls --disable-libblkid --disable-mount --disable-libmount \
-		--disable-fsck --disable-cramfs --disable-partx --disable-uuidd --disable-mountpoint \
-		--disable-fallocate --disable-unshare --disable-agetty \
-		--disable-cramfs --disable-switch_root --disable-pivot_root \
-		--disable-kill --disable-rename --disable-chsh-only-listed \
-		--disable-schedutils --disable-wall --disable-pg-bell --disable-require-password \
-		--disable-use-tty-group --disable-makeinstall-chown --disable-makeinstall-setuid\
-		--without-ncurses --without-selinux --without-audit \
-	)
-
-util-linux-stage:
-	$(MAKE) -C util-linux/libuuid/src DESTDIR=$(STAGEDIR) \
-		install-usrlib_execLTLIBRARIES install-uuidincHEADERS
-
-util-linux-install: util-linux
-	install -D $(STAGEDIR)/usr/lib/libuuid.so.1 $(INSTALLDIR)/util-linux/usr/lib/libuuid.so.1
-	$(STRIP) $(INSTALLDIR)/util-linux/usr/lib/*.so*
-
-util-linux-clean:
-	[ ! -f util-linux/Makefile ] || $(MAKE) -C util-linux distclean
-	@rm -f util-linux/Makefile
-
 odhcp6c: odhcp6c/Makefile
 	@EXT_CFLAGS="-Os -Wall $(EXTRACFLAGS) -ffunction-sections -fdata-sections -fPIC" \
 	EXT_LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections" \
@@ -3594,19 +3832,19 @@
 
 quagga-install:
 	install -d $(INSTALLDIR)/quagga/usr/lib
-	libtool --mode=install install -c quagga/lib/libzebra.la $(INSTALLDIR)/quagga/usr/lib
-	libtool --finish $(INSTALLDIR)/quagga/usr/lib
+	quagga/libtool --mode=install install -c quagga/lib/libzebra.la $(INSTALLDIR)/quagga/usr/lib
+	quagga/libtool --finish $(INSTALLDIR)/quagga/usr/lib
 ifneq ($(HND_ROUTER),y)
 	rm -f $(INSTALLDIR)/quagga/usr/lib/libzebra.a
 	rm -f $(INSTALLDIR)/quagga/usr/lib/libzebra.la
 endif
 	install -d $(INSTALLDIR)/quagga/usr/sbin
 	install -d $(INSTALLDIR)/quagga/usr/local/etc
-	libtool --mode=install install -c quagga/zebra/zebra $(INSTALLDIR)/quagga/usr/sbin
+	quagga/libtool --mode=install install -c quagga/zebra/zebra $(INSTALLDIR)/quagga/usr/sbin
 	install -c -m 777 quagga/zebra/zebra.conf.sample $(INSTALLDIR)/quagga/usr/local/etc/zebra.conf
-	libtool --mode=install install -c quagga/ripd/ripd $(INSTALLDIR)/quagga/usr/sbin
+	quagga/libtool --mode=install install -c quagga/ripd/ripd $(INSTALLDIR)/quagga/usr/sbin
 	install -c -m 777 quagga/ripd/ripd.conf.sample $(INSTALLDIR)/quagga/usr/local/etc/ripd.conf
-	libtool --mode=install install -c quagga/watchquagga/watchquagga $(INSTALLDIR)/quagga/usr/sbin
+	quagga/libtool --mode=install install -c quagga/watchquagga/watchquagga $(INSTALLDIR)/quagga/usr/sbin
 	$(STRIP) $(INSTALLDIR)/quagga/usr/sbin/zebra
 	$(STRIP) $(INSTALLDIR)/quagga/usr/sbin/ripd
 	$(STRIP) $(INSTALLDIR)/quagga/usr/sbin/watchquagga
@@ -3938,213 +4176,3410 @@
 	[ ! -f libevent-2.0.21/Makefile ] || $(MAKE) -C libevent-2.0.21 clean
 	@rm -f libevent-2.0.21/Makefile
 
-tor: openssl zlib libevent-2.0.21 tor/Makefile
-	@$(SEP)
-	$(MAKE) -C $@ $(PARALLEL_BUILD)
+#######################################################################################
+#
+# Blackfuel addons
+#
 
-tor/Makefile:
-	(cd tor ; $(CONFIGURE) --enable-static-libevent --with-libevent-dir=$(STAGEDIR)/usr \
-					--with-openssl-dir=$(TOP)/openssl \
-					--with-zlib-dir=$(TOP)/zlib \
-					--disable-asciidoc --disable-unittests \
-					--disable-tool-name-check)
+### xzutils
 
-tor-install:
-	install -D tor/src/or/tor $(INSTALLDIR)/tor/usr/sbin/Tor
-	$(STRIP) $(INSTALLDIR)/tor/usr/sbin/Tor
+xzutils: xzutils/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
 
-tor-clean:
-	[ ! -f tor/Makefile ] || $(MAKE) -C tor clean
-	@rm -f tor/Makefile
+xzutils/Makefile: xzutils-unpack xzutils/configure
+	@[ -f $@ ] || $(MAKE) xzutils-configure
 
-iproute2:
-	@$(SEP)
-	@$(MAKE) -C $@ KERNEL_INCLUDE=$(LINUX_INC_DIR)/include EXTRACFLAGS="$(EXTRACFLAGS) $(if $(RTCONFIG_IPV6),-DUSE_IPV6,-DNO_IPV6)" $(PARALLEL_BUILD)
+xzutils/configure:
+	@[ -f $@ ] || ( cd xzutils ; ./autogen.sh )
+
+xzutils-configure:
+	@[ ! -d xzutils ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/liblzma.so" ] || ( cd xzutils ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		--disable-nls \
+		--disable-rpath \
+		--enable-threads=posix \
+		--disable-silent-rules)
+
+xzutils-stage:
+	@echo xzutils
+	@[ ! -d xzutils ] || $(MAKE) -C xzutils $(PARALLEL_BUILD) install
+
+xzutils-clean:
+	[ ! -f xzutils/Makefile ] || $(MAKE) -C xzutils clean
+	@rm -f xzutils/Makefile
+
+xzutils-install:
+	install -d $(INSTALLDIR)/xzutils/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/liblzma.so* $(INSTALLDIR)/xzutils/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/xzutils/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/xzutils/usr/$(BLACKFUEL_OPTIMIZED_LIB)/liblzma.so*
+
+### zstd
+
+zstd: liblz4 xzutils zstd/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+zstd/Makefile:
+	@[ ! -d zstd ] && $(MAKE) zstd-unpack
+
+zstd-stage:
+	@echo zstd
+	@[ ! -d zstd ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libzstd.so" ] || \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PREFIX="$(STAGEDIR)/usr" \
+		DESTDIR="" \
+		LIBDIR="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		INCLUDEDIR="$(STAGEDIR)/usr/include" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread" \
+		$(MAKE) -C zstd $(PARALLEL_BUILD) install
+
+zstd-clean:
+	[ ! -f zstd/Makefile ] || $(MAKE) -C zstd clean
+
+zstd-install:
+	install -d $(INSTALLDIR)/zstd/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libzstd.so* $(INSTALLDIR)/zstd/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/zstd/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/zstd/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libzstd.so*
+
+### findutils
+
+findutils: findutils/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+findutils/Makefile: findutils-unpack findutils/configure
+	@[ -f $@ ] || $(MAKE) findutils-configure
+
+findutils/configure:
+	@[ -f $@ ] || ( cd findutils ; ./autogen.sh )
+
+findutils-configure:
+	@[ ! -d findutils ] || [ -f "$(STAGEDIR)/usr/bin/find" ] || ( cd findutils ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-threads=posix \
+		--disable-silent-rules \
+		--disable-rpath)
 
-iproute2-install: iproute2
-	install -D iproute2/tc/tc $(INSTALLDIR)/iproute2/usr/sbin/tc
-	install -D iproute2/tc/tc $(INSTALLDIR)/iproute2/usr/sbin/realtc
-	$(STRIP) $(INSTALLDIR)/iproute2/usr/sbin/tc
-	$(STRIP) $(INSTALLDIR)/iproute2/usr/sbin/realtc
-	install -D iproute2/ip/ip $(INSTALLDIR)/iproute2/usr/sbin/ip
-	$(STRIP) $(INSTALLDIR)/iproute2/usr/sbin/ip
+findutils-stage:
+	@echo findutils
+	@[ ! -d findutils ] || ( \
+		$(MAKE) -C findutils $(PARALLEL_BUILD) && \
+		$(MAKE) -C findutils install )
+
+findutils-clean:
+	[ ! -f findutils/Makefile ] || $(MAKE) -C findutils clean
+	@rm -f findutils/Makefile
+
+findutils-install:
+	install -d $(INSTALLDIR)/findutils/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/find $(INSTALLDIR)/findutils/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/xargs $(INSTALLDIR)/findutils/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/locate $(INSTALLDIR)/findutils/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/updatedb $(INSTALLDIR)/findutils/usr/bin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/findutils/usr/bin/find
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/findutils/usr/bin/xargs
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/findutils/usr/bin/locate
+
+### libsodium
+
+libsodium: libsodium/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libsodium/Makefile: libsodium-unpack libsodium/configure
+	@[ -f $@ ] || $(MAKE) libsodium-configure
+
+libsodium/configure:
+	@[ -f $@ ] || ( cd libsodium ; ./autogen.sh )
+
+libsodium-configure:
+	@[ ! -d libsodium ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libsodium.so" ] || ( cd libsodium ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread" \
+		ac_cv_tls=none \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--disable-static \
+		--enable-shared \
+		--disable-silent-rules \
+		--enable-opt \
+		--with-pthreads)
 
-iproute2-3.x: kernel_header iptables-1.4.x
-	@$(SEP)
-	@$(MAKE) -C $@ IPTABLES_DIR=$(TOP)/iptables-1.4.x KERNEL_INCLUDE=$(TOP)/kernel_header/include EXTRACFLAGS="$(EXTRACFLAGS) $(if $(RTCONFIG_IPV6),-DUSE_IPV6,-DNO_IPV6)" && $(MAKE) -C $@ stage
+libsodium-stage:
+	@echo libsodium
+	@[ ! -d libsodium ] || ( \
+		$(MAKE) -C libsodium $(PARALLEL_BUILD) && \
+		$(MAKE) -C libsodium install )
+
+libsodium-clean:
+	[ ! -f libsodium/Makefile ] || $(MAKE) -C libsodium clean
+	@rm -f libsodium/Makefile
+
+libsodium-install:
+	install -d $(INSTALLDIR)/libsodium/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libsodium.so* $(INSTALLDIR)/libsodium/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/libsodium/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/libsodium/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libsodium.so*
+
+### dnscrypt
+
+dnscrypt: libsodium dnscrypt/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+dnscrypt/Makefile: dnscrypt-unpack dnscrypt/configure
+	@[ -f $@ ] || $(MAKE) dnscrypt-configure
+
+dnscrypt/configure:
+	@[ -f $@ ] || ( cd dnscrypt ; ./autogen.sh )
+
+dnscrypt-configure:
+	@[ ! -d dnscrypt ] || [ -f "$(STAGEDIR)/usr/sbin/dnscrypt-proxy" ] || ( cd dnscrypt ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--disable-static \
+		--enable-shared \
+		--disable-silent-rules)
+
+dnscrypt-stage:
+	@echo dnscrypt
+	@[ ! -d dnscrypt ] || ( \
+		$(MAKE) -C dnscrypt $(PARALLEL_BUILD) && \
+		$(MAKE) -C dnscrypt install )
+
+dnscrypt-clean:
+	[ ! -f dnscrypt/Makefile ] || $(MAKE) -C dnscrypt clean
+	@rm -f dnscrypt/Makefile
+
+dnscrypt-install:
+	install -d $(INSTALLDIR)/dnscrypt/usr/bin/
+	install -d $(INSTALLDIR)/dnscrypt/usr/local/dnscrypt-proxy/
+	install -D $(STAGEDIR)/usr/sbin/dnscrypt-proxy $(INSTALLDIR)/dnscrypt/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/hostip $(INSTALLDIR)/dnscrypt/usr/bin/
+	install -D $(STAGEDIR)/usr/share/dnscrypt-proxy/dnscrypt-resolvers.csv $(INSTALLDIR)/dnscrypt/usr/local/dnscrypt-proxy/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/dnscrypt/usr/bin/dnscrypt-proxy
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/dnscrypt/usr/bin/hostip
+
+### wipe
+
+wipe: wipe/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+wipe/Makefile: wipe-unpack
+	@[ -f $@ ] || $(MAKE) wipe-configure
+
+wipe-configure:
+	@[ ! -d wipe ] || [ -f "$(STAGEDIR)/usr/bin/wipe" ] || ( cd wipe ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CXXFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread" \
+		./configure \
+		--host=$(if $(RTCONFIG_HND_ROUTER),aarch64-buildroot-linux-gnu,$(if $(RTCONFIG_BCMARM),arm-linux,mipsel-linux)) \
+		--prefix=$(STAGEDIR)/usr \
+		--libdir=$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+		--mandir=$(STAGEDIR)/usr/share/man \
+		--enable-static \
+		--enable-shared)
+
+wipe-stage:
+	@echo wipe
+	@[ ! -d wipe ] || ( cd wipe ; \
+		$(MAKE) $(PARALLEL_BUILD); \
+		install -d $(STAGEDIR)/usr/bin ; \
+		install -D wipe $(STAGEDIR)/usr/bin/ ; \
+		$(BLACKFUEL_OPTIMIZED_STRIP) $(STAGEDIR)/usr/bin/wipe ; \
+		install -d $(STAGEDIR)/usr/share/man/man1 ; \
+		install wipe.1 $(STAGEDIR)/usr/share/man/man1/ ; \
+		rm -rf $(STAGEDIR)/usr/share/doc/wipe* ; \
+		install -d $(STAGEDIR)/usr/share/doc/wipe ; \
+		for file in LICENSE copyright CHANGES README TODO INSTALL TESTING; do \
+			install $$file $(STAGEDIR)/usr/share/doc/wipe/; \
+		done )
+
+wipe-clean:
+	[ ! -f wipe/Makefile ] || $(MAKE) -C wipe clean
+	@rm -f wipe/Makefile
+
+wipe-install:
+	install -d $(INSTALLDIR)/wipe/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/wipe $(INSTALLDIR)/wipe/usr/bin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/wipe/usr/bin/wipe
+
+### haveged
+
+haveged: haveged/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+haveged/Makefile: haveged-unpack haveged/configure
+	@[ -f $@ ] || $(MAKE) haveged-configure
+
+haveged/configure:
+	@[ -f $@ ] || ( cd haveged ; ./autogen.sh )
+
+haveged-configure:
+	@[ ! -d haveged ] || [ -f "$(STAGEDIR)/usr/sbin/haveged" ] || ( cd haveged ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-static \
+		--enable-shared \
+		--enable-daemon=yes \
+		--enable-threads=no \
+		--enable-olt=no)
+
+haveged-stage:
+	@echo haveged
+	@[ ! -d haveged ] || ( \
+		$(MAKE) -C haveged $(PARALLEL_BUILD) && \
+		$(MAKE) -C haveged install )
+
+haveged-clean:
+	[ ! -f haveged/Makefile ] || $(MAKE) -C haveged clean
+	@rm -f haveged/Makefile
+
+haveged-install:
+	install -d $(INSTALLDIR)/haveged/usr/bin/
+	install -d $(INSTALLDIR)/haveged/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	install -D $(STAGEDIR)/usr/sbin/haveged $(INSTALLDIR)/haveged/usr/bin/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libhavege.so* $(INSTALLDIR)/haveged/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/haveged/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/haveged/usr/bin/haveged
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/haveged/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libhavege.so*
+
+### gsl
+
+gsl: gsl/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+gsl/Makefile: gsl-unpack gsl/configure
+	@[ -f $@ ] || $(MAKE) gsl-configure
+
+gsl/configure:
+	@[ -f $@ ] || ( cd gsl ; ./autogen.sh )
+
+gsl-configure:
+	@[ ! -d gsl ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgsl.so" ] || ( cd gsl ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-static \
+		--enable-shared \
+		--disable-silent-rules)
+
+gsl-stage:
+	@echo gsl
+	@[ ! -d gsl ] || ( \
+		$(MAKE) -C gsl $(PARALLEL_BUILD) && \
+		$(MAKE) -C gsl install )
+
+gsl-clean:
+	[ ! -f gsl/Makefile ] || $(MAKE) -C gsl clean
+	@rm -f gsl/Makefile
+
+gsl-install:
+	install -d $(INSTALLDIR)/gsl/usr/bin/
+	install -d $(INSTALLDIR)/gsl/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	install -D $(STAGEDIR)/usr/bin/gsl-randist $(INSTALLDIR)/gsl/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/gsl-histogram $(INSTALLDIR)/gsl/usr/bin/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgsl.so* $(INSTALLDIR)/gsl/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgslcblas.so* $(INSTALLDIR)/gsl/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/gsl/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/gsl/usr/bin/gsl-randist
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/gsl/usr/bin/gsl-histogram
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/gsl/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgsl.so*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/gsl/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgslcblas.so*
+
+### dieharder
+
+dieharder: gsl dieharder/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+dieharder/Makefile: dieharder-unpack dieharder/configure
+	$(MAKE) dieharder-configure
+
+dieharder/configure:
+	@[ -f $@ ] || ( cd dieharder ; ./autogen.sh )
+
+dieharder-configure:
+	@[ ! -d dieharder ] || [ -f "$(STAGEDIR)/usr/bin/dieharder" ] || ( cd dieharder ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		ac_cv_c_endian=little \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-static \
+		--enable-shared)
+
+dieharder-stage:
+	@echo dieharder
+	@[ ! -d dieharder ] || $(MAKE) -C dieharder $(PARALLEL_BUILD) install
+
+dieharder-clean:
+	[ ! -f dieharder/Makefile ] || $(MAKE) -C dieharder clean
+	@rm -f dieharder/Makefile
+
+dieharder-install:
+	install -d $(INSTALLDIR)/dieharder/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/dieharder $(INSTALLDIR)/dieharder/usr/bin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/dieharder/usr/bin/dieharder
+	install -d $(INSTALLDIR)/dieharder/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libdieharder.so* $(INSTALLDIR)/dieharder/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/dieharder/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/dieharder/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libdieharder.so*
+
+### whois
+
+whois: whois-unpack
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+whois-stage:
+	@echo whois
+	@[ ! -d whois ] || [ -f "$(STAGEDIR)/usr/bin/whois" ] || ( cd whois ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		BASEDIR="$(STAGEDIR)/usr" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread" \
+		$(MAKE) $(PARALLEL_BUILD) ; \
+		install -d $(STAGEDIR)/usr/bin/ ; \
+		install -d $(STAGEDIR)/usr/share/man/man1/ ; \
+		install -d $(STAGEDIR)/usr/share/man/man5/ ; \
+		install whois $(STAGEDIR)/usr/bin/ ; \
+		install whois.1 $(STAGEDIR)/usr/share/man/man1/ ; \
+		install whois.conf.5 $(STAGEDIR)/usr/share/man/man5/)
+
+whois-clean:
+	-@$(MAKE) -C whois clean
+
+whois-install:
+	install -d $(INSTALLDIR)/whois/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/whois $(INSTALLDIR)/whois/usr/bin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/whois/usr/bin/whois
+
+### argp-standalone
+
+argp-standalone: argp-standalone/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+argp-standalone/Makefile: argp-standalone-unpack argp-standalone/configure
+	@[ -f $@ ] || $(MAKE) argp-standalone-configure
+
+argp-standalone/configure:
+	@[ -f $@ ] || ( cd argp-standalone ; autoreconf -i -f )
+
+argp-standalone-configure:
+	@[ ! -d argp-standalone ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libargp.a" ] || ( cd argp-standalone ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		)
+
+argp-standalone-stage:
+	@echo argp-standalone
+	@[ ! -d argp-standalone ] || ( cd argp-standalone ; \
+		$(MAKE) $(PARALLEL_BUILD) ; \
+		install -d $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/ ; \
+		install -D libargp.a $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/ ; \
+		install -d $(STAGEDIR)/usr/include/ ; \
+		install -D argp.h $(STAGEDIR)/usr/include/ ; \
+		install -D argp-fmtstream.h $(STAGEDIR)/usr/include/ ; \
+		install -D argp-namefrob.h $(STAGEDIR)/usr/include/ )
+
+argp-standalone-clean:
+	[ ! -f argp-standalone/Makefile ] || $(MAKE) -C argp-standalone clean
+	@rm -f argp-standalone/Makefile
+
+argp-standalone-install:
+	@echo "argp-standalone is static library, nothing to install"
+
+### libgpg-error
+
+libgpg-error: libgpg-error/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libgpg-error/Makefile: libgpg-error-unpack libgpg-error/configure
+	@[ -f $@ ] || $(MAKE) libgpg-error-configure
+
+libgpg-error/configure:
+	@[ -f $@ ] || ( cd libgpg-error ; ./autogen.sh )
+
+libgpg-error-configure:
+	@[ ! -d libgpg-error ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgpg-error.so" ] || ( cd libgpg-error ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -pthread -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -pthread -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread -ldl -lrt" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		--disable-nls \
+		--disable-rpath \
+		--enable-threads=posix \
+		--disable-silent-rules \
+		--disable-tests \
+		)
 
-iproute2-3.x-install: iproute2-3.x
-	install -D iproute2-3.x/tc/tc $(INSTALLDIR)/iproute2-3.x/usr/sbin/tc
-	install -D iproute2-3.x/tc/tc $(INSTALLDIR)/iproute2-3.x/usr/sbin/realtc
-	$(STRIP) $(INSTALLDIR)/iproute2-3.x/usr/sbin/tc
-	$(STRIP) $(INSTALLDIR)/iproute2-3.x/usr/sbin/realtc
-	install -D iproute2-3.x/ip/ip $(INSTALLDIR)/iproute2-3.x/usr/sbin/ip
-	$(STRIP) $(INSTALLDIR)/iproute2-3.x/usr/sbin/ip
-	@if [ -e iproute2-3.x/tc/m_xt.so ] ; then \
-		install -D iproute2-3.x/tc/m_xt.so $(INSTALLDIR)/iproute2-3.x/usr/lib/tc/m_xt.so ; \
-		ln -sf m_xt.so $(INSTALLDIR)/iproute2-3.x/usr/lib/tc/m_ipt.so ; \
-		$(STRIP) $(INSTALLDIR)/iproute2-3.x/usr/lib/tc/*.so ; \
-	fi
+libgpg-error-stage:
+	@echo libgpg-error
+	@[ ! -d libgpg-error ] || ( \
+		$(MAKE) -C libgpg-error $(PARALLEL_BUILD) && \
+		$(MAKE) -C libgpg-error install )
+
+libgpg-error-clean:
+	[ ! -f libgpg-error/Makefile ] || $(MAKE) -C libgpg-error clean
+	@rm -f libgpg-error/Makefile
+
+libgpg-error-install:
+	install -d $(INSTALLDIR)/libgpg-error/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgpg-error.so* $(INSTALLDIR)/libgpg-error/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/libgpg-error/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/libgpg-error/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgpg-error.so*
+
+### libgcrypt
+
+libgcrypt: libgpg-error libgcrypt/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libgcrypt/Makefile: libgcrypt-unpack libgcrypt/configure
+	@[ -f $@ ] || $(MAKE) libgcrypt-configure
+
+libgcrypt/configure:
+	@[ -f $@ ] || ( cd libgcrypt ; ./autogen.sh )
+
+libgcrypt-configure:
+	@[ ! -d libgcrypt ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgcrypt.so" ] || ( cd libgcrypt ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -pthread -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -pthread -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread -ldl -lrt" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		--disable-silent-rules \
+		--disable-amd64-as-feature-detection \
+		--disable-arm-crypto-support \
+		--with-gpg-error-prefix="$(STAGEDIR)/usr" \
+		--disable-doc \
+		)
+
+libgcrypt-stage:
+	@echo libgcrypt
+	@[ ! -d libgcrypt ] || ( \
+		$(MAKE) -C libgcrypt $(PARALLEL_BUILD) && \
+		$(MAKE) -C libgcrypt install )
+
+libgcrypt-clean:
+	[ ! -f libgcrypt/Makefile ] || $(MAKE) -C libgcrypt clean
+	@rm -f libgcrypt/Makefile
+
+libgcrypt-install:
+	install -d $(INSTALLDIR)/libgcrypt/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgcrypt.so* $(INSTALLDIR)/libgcrypt/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/libgcrypt/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/libgcrypt/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgcrypt.so*
+
+### rng-tools
+
+rng-tools: $(if $(RTCONFIG_HND_ROUTER),,argp-standalone) libgpg-error libgcrypt rng-tools/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+rng-tools/Makefile: rng-tools-unpack rng-tools/configure
+	@[ -f $@ ] || $(MAKE) rng-tools-configure
+
+rng-tools/configure:
+	@[ -f $@ ] || ( cd rng-tools ; ./autogen.sh )
+
+rng-tools-configure:
+	@[ ! -d rng-tools ] || [ -f "$(STAGEDIR)/usr/bin/rngtest" ] || ( cd rng-tools ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="$(if $(RTCONFIG_HND_ROUTER),,-largp)" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--disable-silent-rules )
+
+rng-tools-stage:
+	@echo rng-tools
+	@[ ! -d rng-tools ] || ( \
+		$(MAKE) -C rng-tools $(PARALLEL_BUILD) && \
+		$(MAKE) -C rng-tools install )
+
+rng-tools-clean:
+	[ ! -f rng-tools/Makefile ] || $(MAKE) -C rng-tools clean
+	@rm -f rng-tools/Makefile
+
+rng-tools-install:
+	install -d $(INSTALLDIR)/rng-tools/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/rngtest $(INSTALLDIR)/rng-tools/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/rngd $(INSTALLDIR)/rng-tools/usr/bin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/rng-tools/usr/bin/rngtest
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/rng-tools/usr/bin/rngd
+
+### popt
+
+popt: popt/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+popt/Makefile: popt-unpack popt/configure
+	@[ -f $@ ] || $(MAKE) popt-configure
+
+popt/configure:
+	@[ -f $@ ] || ( cd popt ; ./autogen.sh )
+
+popt-configure:
+	@[ ! -d popt ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libpopt.so" ] || ( cd popt ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		--disable-nls \
+		--disable-rpath )
+
+popt-stage:
+	@echo popt
+	@[ ! -d popt ] || ( \
+		$(MAKE) -C popt $(PARALLEL_BUILD) && \
+		$(MAKE) -C popt pkgconfigdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" install )
+
+popt-clean:
+	[ ! -f popt/Makefile ] || $(MAKE) -C popt clean
+	@rm -f popt/Makefile
+
+popt-install:
+	install -d $(INSTALLDIR)/popt/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libpopt.so* $(INSTALLDIR)/popt/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/popt/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/popt/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libpopt.so*
 
-iproute2-3.x-clean:
-	-@$(MAKE) -C iproute2-3.x clean
-	-rm -f iproute2-3.x/Config
+### util-linux
 
-iproute2-3.15.0: kernel_header iptables-1.4.21
-	@$(SEP)
-	@$(MAKE) -C $@ IPTABLES_DIR=$(TOP)/iptables-1.4.21 KERNEL_INCLUDE=$(TOP)/kernel_header/include EXTRACFLAGS="$(EXTRACFLAGS) $(if $(RTCONFIG_IPV6),-DUSE_IPV6,-DNO_IPV6)"
+util-linux: ncurses$(if $(RTCONFIG_HND_ROUTER),-aarch64,-6.0) libgcrypt util-linux/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
 
-iproute2-3.15.0-install: iproute2-3.15.0
-	install -D iproute2-3.15.0/tc/tc $(INSTALLDIR)/iproute2-3.15.0/usr/sbin/tc
-	$(STRIP) $(INSTALLDIR)/iproute2-3.15.0/usr/sbin/tc
-	install -D iproute2-3.15.0/ip/ip $(INSTALLDIR)/iproute2-3.15.0/usr/sbin/ip
-	$(STRIP) $(INSTALLDIR)/iproute2-3.15.0/usr/sbin/ip
-	@if [ -e iproute2-3.15.0/tc/m_xt.so ] ; then \
-		install -D iproute2-3.15.0/tc/m_xt.so $(INSTALLDIR)/iproute2-3.15.0/usr/lib/tc/m_xt.so ; \
-		ln -sf m_xt.so $(INSTALLDIR)/iproute2-3.15.0/usr/lib/tc/m_ipt.so ; \
-		$(STRIP) $(INSTALLDIR)/iproute2-3.15.0/usr/lib/tc/*.so ; \
-	fi
+util-linux/Makefile: util-linux-unpack util-linux/configure
+	@[ -f $@ ] || $(MAKE) util-linux-configure
 
-iproute2-3.15.0-clean:
-	-@$(MAKE) -C iproute2-3.15.0 clean
-	-rm -f iproute2-3.15.0/Config
+util-linux/configure:
+	@[ -f $@ ] || ( cd util-linux ; ./autogen.sh )
 
-iproute2-4.3:
-	touch iproute2-4.3/iproute2-4.3.0/configure
-	$(MAKE) -C iproute2-4.3
+util-linux-configure:
+	@[ ! -d util-linux ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libuuid.so" ] || ( \
+		cd util-linux ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 $(if $(RTCONFIG_HND_ROUTER),,-DHAVE_POSIX_FALLOCATE=1) -D_GNU_SOURCE -I$(STAGEDIR)/usr/include -lm" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 $(if $(RTCONFIG_HND_ROUTER),,-DHAVE_POSIX_FALLOCATE=1) -D_GNU_SOURCE -I$(STAGEDIR)/usr/include -lm" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lm $(if $(RTCONFIG_BCMARM),-lncursesw,-lncurses) -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		$(if $(RTCONFIG_HND_ROUTER),,--disable-tls) \
+		--disable-rpath \
+		--disable-silent-rules \
+		--disable-bash-completion \
+		--disable-makeinstall-chown \
+		--disable-makeinstall-setuid \
+		--disable-agetty \
+		$(if $(RTCONFIG_BCMARM),--with-ncursesw --without-ncurses,--with-ncurses --without-ncursesw) \
+		--enable-libuuid \
+		--enable-libblkid )
 
-iproute2-4.3-install:
-	install -D iproute2-4.3/iproute2-4.3.0/tc/tc $(INSTALLDIR)/iproute2-4.3/usr/sbin/tc
-	$(STRIP) $(INSTALLDIR)/iproute2-4.3/usr/sbin/tc
-	install -D iproute2-4.3/iproute2-4.3.0/ip/ip $(INSTALLDIR)/iproute2-4.3/usr/sbin/ip
-	$(STRIP) $(INSTALLDIR)/iproute2-4.3/usr/sbin/ip
+util-linux-stage:
+	@echo util-linux
+	@[ ! -d util-linux ] || ( \
+		$(MAKE) -C util-linux $(PARALLEL_BUILD) && \
+		$(MAKE) -C util-linux install )
 
-iproute2-4.3-clean:
-	-@$(MAKE) -C iproute2-4.3 clean
-	-rm -f iproute2-4.3/iproute2-4.3.0/Config
+util-linux-clean:
+	[ ! -f util-linux/Makefile ] || $(MAKE) -C util-linux clean
+	@rm -f util-linux/Makefile
 
-ntpclient: nvram$(BCMEX)$(EX7) shared
+util-linux-install:
+	install -d $(INSTALLDIR)/util-linux/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	install -d $(INSTALLDIR)/util-linux/usr/bin/
+	# /usr/$(BLACKFUEL_OPTIMIZED_LIB)
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libuuid.so* $(INSTALLDIR)/util-linux/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libblkid.so* $(INSTALLDIR)/util-linux/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libsmartcols.so* $(INSTALLDIR)/util-linux/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/util-linux/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/util-linux/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libuuid.so*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/util-linux/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libblkid.so*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/util-linux/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libsmartcols.so*
+	# /usr/bin
+	install -D $(STAGEDIR)/usr/bin/fallocate $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/hexdump $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/cal $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/whereis $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/rename $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/ldattach $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/losetup $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/hwclock $(INSTALLDIR)/util-linux/usr/bin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/util-linux/usr/bin/fallocate
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/util-linux/usr/bin/hexdump
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/util-linux/usr/bin/cal
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/util-linux/usr/bin/whereis
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/util-linux/usr/bin/rename
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/util-linux/usr/bin/ldattach
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/util-linux/usr/bin/losetup
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/util-linux/usr/bin/hwclock
+
+### libaio
+
+libaio: libaio-unpack
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libaio-stage:
+	@echo libaio
+	@[ ! -d libaio ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libaio.so" ] || ( cd libaio ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(MAKE) install prefix=$(STAGEDIR)/usr includedir=$(STAGEDIR)/usr/include libdir=$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+		)
+
+libaio-clean:
+	-@$(MAKE) -C libaio clean
+
+libaio-install:
+	install -d $(INSTALLDIR)/libaio/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libaio.so* $(INSTALLDIR)/libaio/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/libaio/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+
+### lvm2
+
+lvm2: libaio lvm2/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+lvm2/Makefile: lvm2-unpack lvm2/configure
+	@[ -f $@ ] || $(MAKE) lvm2-configure
+
+lvm2/configure:
+	@[ -f $@ ] || ( cd lvm2 ; autoreconf -i -f )
+
+lvm2-configure:
+	@[ ! -d lvm2 ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libdevmapper.so" ] || ( \
+		cd lvm2 ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CXXFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		BLKID_CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -I$(STAGEDIR)/usr/include/blkid -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L../libdm/ioctl -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread -luuid -lm -L../libdm/ioctl -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		BLKID_LIBS="-lblkid -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		ac_cv_func_malloc_0_nonnull=yes ac_cv_func_realloc_0_nonnull=yes \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--with-confdir=$(STAGEDIR)/usr/etc \
+		--with-default-system-dir=$(STAGEDIR)/usr/etc/lvm \
+		--enable-static_link \
+		--disable-nls \
+		--enable-pkgconfig ; \
+		mkdir -p $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig; \
+		cp -pf "libdm/libdevmapper.pc" $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig; \
+		ln -sf libdevmapper.pc $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig/devmapper.pc )
+
+lvm2-stage:
+	@echo lvm2
+	@[ ! -d lvm2 ] || ( \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CXXFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		BLKID_CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -I$(STAGEDIR)/usr/include/blkid -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L../libdm/ioctl -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread -luuid -lm -L../libdm/ioctl -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		BLKID_LIBS="-lblkid -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		ac_cv_func_malloc_0_nonnull=yes ac_cv_func_realloc_0_nonnull=yes \
+		$(MAKE) -C lvm2 $(PARALLEL_BUILD) && \
+		$(MAKE) -C lvm2 install; \
+		rm -fv $(STAGEDIR)/usr/lib/pkgconfig/devmapper.pc; \
+		rm -fv $(STAGEDIR)/usr/lib/libdevmapper.a; \
+		rm -fv $(STAGEDIR)/usr/lib/libdevmapper.so*; \
+		cp -dfv lvm2/libdm/ioctl/libdevmapper.a $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/; \
+		cp -dfv lvm2/libdm/ioctl/libdevmapper.so* $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/; \
+		)
+
+lvm2-clean:
+	[ ! -f lvm2/Makefile ] || $(MAKE) -C lvm2 clean
+	@rm -f lvm2/Makefile
+
+lvm2-install:
+	install -d $(INSTALLDIR)/lvm2/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	install -d $(INSTALLDIR)/lvm2/usr/bin/
+	install -d $(INSTALLDIR)/lvm2/usr/sbin/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libdevmapper.so* $(INSTALLDIR)/lvm2/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/lvm2/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	install -D $(STAGEDIR)/usr/sbin/dmsetup $(INSTALLDIR)/lvm2/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/lvm $(INSTALLDIR)/lvm2/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/lvmconf $(INSTALLDIR)/lvm2/usr/sbin/
+	install -D $(STAGEDIR)/usr/sbin/lvmdump $(INSTALLDIR)/lvm2/usr/sbin/
+	for FILE in $(STAGEDIR)/usr/sbin/*; do \
+		if [ -h "$$FILE" ] && [ "`readlink $$FILE`" = "lvm" ]; then \
+			cp -df "$$FILE" "$(INSTALLDIR)/lvm2/usr/bin/"; \
+		fi; \
+	done
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/lvm2/usr/bin/dmsetup
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/lvm2/usr/bin/lvm
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/lvm2/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libdevmapper.so*
+
+### cryptsetup-gcrypt
+
+cryptsetup-gcrypt: libargon2 json-c$(if $(RTCONFIG_HND_ROUTER),-aarch64,) popt util-linux lvm2 libgpg-error libgcrypt cryptsetup-gcrypt/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+cryptsetup-gcrypt/Makefile: cryptsetup-gcrypt-unpack cryptsetup-gcrypt/configure
+	@[ -f $@ ] || $(MAKE) cryptsetup-gcrypt-configure
+
+cryptsetup-gcrypt/configure:
+	@[ -f $@ ] || ( cd cryptsetup-gcrypt ; autoreconf -i -f )
+
+cryptsetup-gcrypt-configure:
+	@[ ! -d cryptsetup-gcrypt ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcryptsetup.so" ] || ( cd cryptsetup-gcrypt ; \
+		IF_ALG_H="$(BLACKFUEL_DIR)/packages/cryptsetup/files/linux/if_alg.h"; \
+		STAGEDIR_INCLUDE_LINUX="$(STAGEDIR)/usr/include/linux"; \
+		if [ -f "$$IF_ALG_H" ]; then \
+		  mkdir -p "$$STAGEDIR_INCLUDE_LINUX"; \
+		  cp -pn "$$IF_ALG_H" "$$STAGEDIR_INCLUDE_LINUX"; \
+		fi; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -pthread -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -DCLOCK_MONOTONIC_RAW=4 -D_GNU_SOURCE" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -pthread -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -DCLOCK_MONOTONIC_RAW=4 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread -lgpg-error -luuid -lblkid -ldl -lrt -lgcrypt -largon2 -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(if $(RTCONFIG_HND_ROUTER),,ac_cv_func_posix_fallocate=yes) \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		--disable-silent-rules \
+		--disable-nls \
+		--disable-rpath \
+		--enable-cryptsetup-reencrypt \
+		--with-crypto_backend=gcrypt \
+		--enable-static-cryptsetup \
+		--enable-libargon2 \
+		--with-libgcrypt-prefix=$(STAGEDIR)/usr \
+		)
+
+cryptsetup-gcrypt-stage: cryptsetup-gcrypt-configure
+	@echo cryptsetup-gcrypt
+	@[ ! -d cryptsetup-gcrypt ] || ( \
+		$(MAKE) -C cryptsetup-gcrypt $(PARALLEL_BUILD) && \
+		$(MAKE) -C cryptsetup-gcrypt install )
+
+cryptsetup-gcrypt-clean:
+	[ ! -f cryptsetup-gcrypt/Makefile ] || $(MAKE) -C cryptsetup-gcrypt clean
+	@rm -f cryptsetup-gcrypt/Makefile
+
+cryptsetup-gcrypt-install:
+	install -d $(INSTALLDIR)/cryptsetup-gcrypt/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	install -d $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcryptsetup.so* $(INSTALLDIR)/cryptsetup-gcrypt/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/cryptsetup-gcrypt/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup-reencrypt $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/veritysetup $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/cryptsetup
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/cryptsetup-reencrypt
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/veritysetup
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-gcrypt/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcryptsetup.so*
+
+### cryptsetup-openssl
+
+cryptsetup-openssl: libargon2 json-c$(if $(RTCONFIG_HND_ROUTER),-aarch64,) popt util-linux lvm2 openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,) cryptsetup-openssl/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+cryptsetup-openssl/Makefile: cryptsetup-openssl-unpack cryptsetup-openssl/configure
+	@[ -f $@ ] || $(MAKE) cryptsetup-openssl-configure
+
+cryptsetup-openssl/configure:
+	@[ -f $@ ] || ( cd cryptsetup-openssl ; autoreconf -i -f )
+
+cryptsetup-openssl-configure:
+	@[ ! -d cryptsetup-openssl ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcryptsetup.so" ] || ( cd cryptsetup-openssl ; \
+		IF_ALG_H="$(BLACKFUEL_DIR)/packages/cryptsetup/files/linux/if_alg.h"; \
+		STAGEDIR_INCLUDE_LINUX="$(STAGEDIR)/usr/include/linux"; \
+		if [ -f "$$IF_ALG_H" ]; then \
+		  mkdir -p "$$STAGEDIR_INCLUDE_LINUX"; \
+		  cp -pn "$$IF_ALG_H" "$$STAGEDIR_INCLUDE_LINUX"; \
+		fi; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -pthread -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -DCLOCK_MONOTONIC_RAW=4 -D_GNU_SOURCE" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -pthread -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -DCLOCK_MONOTONIC_RAW=4 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread -lssl -lcrypto -lz -luuid -lblkid -ldl -lrt -largon2 -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(if $(RTCONFIG_HND_ROUTER),,ac_cv_func_posix_fallocate=yes) \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		--disable-silent-rules \
+		--disable-nls \
+		--disable-rpath \
+		--enable-cryptsetup-reencrypt \
+		--with-crypto_backend=openssl \
+		--enable-static-cryptsetup \
+		--enable-libargon2 \
+		)
+
+cryptsetup-openssl-stage: cryptsetup-openssl-configure
+	@echo cryptsetup-openssl
+	@[ ! -d cryptsetup-openssl ] || ( \
+		$(MAKE) -C cryptsetup-openssl $(PARALLEL_BUILD) && \
+		$(MAKE) -C cryptsetup-openssl install )
+
+cryptsetup-openssl-clean:
+	[ ! -f cryptsetup-openssl/Makefile ] || $(MAKE) -C cryptsetup-openssl clean
+	@rm -f cryptsetup-openssl/Makefile
+
+cryptsetup-openssl-install:
+	install -d $(INSTALLDIR)/cryptsetup-openssl/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	install -d $(INSTALLDIR)/cryptsetup-openssl/usr/bin/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcryptsetup.so* $(INSTALLDIR)/cryptsetup-openssl/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/cryptsetup-openssl/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup $(INSTALLDIR)/cryptsetup-openssl/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup-reencrypt $(INSTALLDIR)/cryptsetup-openssl/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/veritysetup $(INSTALLDIR)/cryptsetup-openssl/usr/bin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-openssl/usr/bin/cryptsetup
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-openssl/usr/bin/cryptsetup-reencrypt
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-openssl/usr/bin/veritysetup
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-openssl/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcryptsetup.so*
+
+### cryptsetup-nettle
+
+cryptsetup-nettle: libargon2 json-c$(if $(RTCONFIG_HND_ROUTER),-aarch64,) popt util-linux lvm2 nettle$(if $(RTCONFIG_HND_ROUTER),-aarch64,) cryptsetup-nettle/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+cryptsetup-nettle/Makefile: cryptsetup-nettle-unpack cryptsetup-nettle/configure
+	@[ -f $@ ] || $(MAKE) cryptsetup-nettle-configure
+
+cryptsetup-nettle/configure:
+	@[ -f $@ ] || ( cd cryptsetup-nettle ; autoreconf -i -f )
+
+cryptsetup-nettle-configure:
+	@[ ! -d cryptsetup-nettle ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcryptsetup.so" ] || ( cd cryptsetup-nettle ; \
+		IF_ALG_H="$(BLACKFUEL_DIR)/packages/cryptsetup/files/linux/if_alg.h"; \
+		STAGEDIR_INCLUDE_LINUX="$(STAGEDIR)/usr/include/linux"; \
+		if [ -f "$$IF_ALG_H" ]; then \
+		  mkdir -p "$$STAGEDIR_INCLUDE_LINUX"; \
+		  cp -pn "$$IF_ALG_H" "$$STAGEDIR_INCLUDE_LINUX"; \
+		fi; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -pthread -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -DCLOCK_MONOTONIC_RAW=4 -D_GNU_SOURCE" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -pthread -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -DCLOCK_MONOTONIC_RAW=4 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread -luuid -lblkid -ldl -lrt -lnettle -largon2 -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(if $(RTCONFIG_HND_ROUTER),,ac_cv_func_posix_fallocate=yes) \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		--disable-silent-rules \
+		--disable-nls \
+		--disable-rpath \
+		--enable-cryptsetup-reencrypt \
+		--with-crypto_backend=nettle \
+		--enable-static-cryptsetup \
+		--enable-libargon2 \
+		)
+
+cryptsetup-nettle-stage: cryptsetup-nettle-configure
+	@echo cryptsetup-nettle
+	@[ ! -d cryptsetup-nettle ] || ( \
+		$(MAKE) -C cryptsetup-nettle $(PARALLEL_BUILD) && \
+		$(MAKE) -C cryptsetup-nettle install )
+
+cryptsetup-nettle-clean:
+	[ ! -f cryptsetup-nettle/Makefile ] || $(MAKE) -C cryptsetup-nettle clean
+	@rm -f cryptsetup-nettle/Makefile
+
+cryptsetup-nettle-install:
+	install -d $(INSTALLDIR)/cryptsetup-nettle/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	install -d $(INSTALLDIR)/cryptsetup-nettle/usr/bin/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcryptsetup.so* $(INSTALLDIR)/cryptsetup-nettle/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/cryptsetup-nettle/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup $(INSTALLDIR)/cryptsetup-nettle/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup-reencrypt $(INSTALLDIR)/cryptsetup-nettle/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/veritysetup $(INSTALLDIR)/cryptsetup-nettle/usr/bin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-nettle/usr/bin/cryptsetup
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-nettle/usr/bin/cryptsetup-reencrypt
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-nettle/usr/bin/veritysetup
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-nettle/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcryptsetup.so*
+
+### cryptsetup-kernel
+
+cryptsetup-kernel: libargon2 json-c$(if $(RTCONFIG_HND_ROUTER),-aarch64,) popt util-linux lvm2 cryptsetup-kernel/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+cryptsetup-kernel/Makefile: cryptsetup-kernel-unpack cryptsetup-kernel/configure
+	@[ -f $@ ] || $(MAKE) cryptsetup-kernel-configure
+
+cryptsetup-kernel/configure:
+	@[ -f $@ ] || ( cd cryptsetup-kernel ; autoreconf -i -f )
+
+cryptsetup-kernel-configure:
+	@[ ! -d cryptsetup-kernel ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcryptsetup.so" ] || ( cd cryptsetup-kernel ; \
+		IF_ALG_H="$(BLACKFUEL_DIR)/packages/cryptsetup/files/linux/if_alg.h"; \
+		STAGEDIR_INCLUDE_LINUX="$(STAGEDIR)/usr/include/linux"; \
+		if [ -f "$$IF_ALG_H" ]; then \
+		  mkdir -p "$$STAGEDIR_INCLUDE_LINUX"; \
+		  cp -pn "$$IF_ALG_H" "$$STAGEDIR_INCLUDE_LINUX"; \
+		fi; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -pthread -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -DCLOCK_MONOTONIC_RAW=4 -D_GNU_SOURCE" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -pthread -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -DCLOCK_MONOTONIC_RAW=4 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread -luuid -lblkid -ldl -lrt -largon2 -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(if $(RTCONFIG_HND_ROUTER),,ac_cv_func_posix_fallocate=yes) \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		--disable-silent-rules \
+		--disable-nls \
+		--disable-rpath \
+		--enable-cryptsetup-reencrypt \
+		--with-crypto_backend=kernel \
+		--enable-static-cryptsetup \
+		--enable-libargon2 \
+		)
+
+cryptsetup-kernel-stage: cryptsetup-kernel-configure
+	@echo cryptsetup-kernel
+	@[ ! -d cryptsetup-kernel ] || ( \
+		$(MAKE) -C cryptsetup-kernel $(PARALLEL_BUILD) && \
+		$(MAKE) -C cryptsetup-kernel install )
+
+cryptsetup-kernel-clean:
+	[ ! -f cryptsetup-kernel/Makefile ] || $(MAKE) -C cryptsetup-kernel clean
+	@rm -f cryptsetup-kernel/Makefile
+
+cryptsetup-kernel-install:
+	install -d $(INSTALLDIR)/cryptsetup-kernel/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	install -d $(INSTALLDIR)/cryptsetup-kernel/usr/bin/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcryptsetup.so* $(INSTALLDIR)/cryptsetup-kernel/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/cryptsetup-kernel/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup $(INSTALLDIR)/cryptsetup-kernel/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup-reencrypt $(INSTALLDIR)/cryptsetup-kernel/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/veritysetup $(INSTALLDIR)/cryptsetup-kernel/usr/bin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-kernel/usr/bin/cryptsetup
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-kernel/usr/bin/cryptsetup-reencrypt
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-kernel/usr/bin/veritysetup
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/cryptsetup-kernel/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcryptsetup.so*
+
+### pps-tools
+
+pps-tools: pps-tools-unpack
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+pps-tools-stage:
+	@echo pps-tools
+	@[ ! -d pps-tools ] || [ -f "$(STAGEDIR)/usr/bin/ppsctl" ] || ( cd pps-tools ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) $(if $(RTCONFIG_HND_ROUTER),,-DN_PPS=18) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		DESTDIR="$(STAGEDIR)" \
+		$(MAKE) install \
+		$(if $(RTCONFIG_HND_ROUTER),,&& [ -f "$(STAGEDIR)/usr/include/timepps.h" ] || \
+						[ ! -f "$(STAGEDIR)/usr/include/sys/timepps.h" ] || \
+						cp -p "$(STAGEDIR)/usr/include/sys/timepps.h" "$(STAGEDIR)/usr/include") \
+		)
+
+pps-tools-clean:
+	-@$(MAKE) -C pps-tools clean
+
+pps-tools-install:
+	install -d $(INSTALLDIR)/pps-tools/usr/bin/
+	install -d $(INSTALLDIR)/pps-tools/usr/sbin/
+	install -D $(STAGEDIR)/usr/bin/ppsctl $(INSTALLDIR)/pps-tools/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ppstest $(INSTALLDIR)/pps-tools/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ppswatch $(INSTALLDIR)/pps-tools/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ppsldisc $(INSTALLDIR)/pps-tools/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ppsfind $(INSTALLDIR)/pps-tools/usr/sbin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/pps-tools/usr/bin/ppsctl
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/pps-tools/usr/bin/ppstest
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/pps-tools/usr/bin/ppswatch
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/pps-tools/usr/bin/ppsldisc
+
+### setserial
+
+setserial: setserial/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+setserial/Makefile: setserial-unpack setserial/configure
+	@[ -f $@ ] || $(MAKE) setserial-configure
+
+setserial/configure:
+	@[ -f $@ ] || ( cd setserial ; autoreconf -i -f )
+
+setserial-configure:
+	@[ ! -d setserial ] || [ -f "$(STAGEDIR)/usr/bin/setserial" ] || ( cd setserial ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--mandir="$(STAGEDIR)/usr/share/man" )
+
+setserial-stage:
+	@echo setserial
+	@[ ! -d setserial ] || ( \
+		$(MAKE) -C setserial $(PARALLEL_BUILD) && \
+		mkdir -p "$(STAGEDIR)/temp_setserial/bin" "$(STAGEDIR)/temp_setserial/usr/man/man8" && \
+		DESTDIR="$(STAGEDIR)/temp_setserial" $(MAKE) -C setserial install && \
+		mkdir -p "$(STAGEDIR)/usr/bin" "$(STAGEDIR)/usr/share/man/man8" && \
+		mv "$(STAGEDIR)/temp_setserial/bin/setserial" "$(STAGEDIR)/usr/bin/" && \
+		mv "$(STAGEDIR)/temp_setserial/usr/man/man8/setserial.8" "$(STAGEDIR)/usr/share/man/man8/" && \
+		rm -rf "$(STAGEDIR)/temp_setserial" )
+
+setserial-clean:
+	[ ! -f setserial/Makefile ] || $(MAKE) -C setserial clean
+	@rm -f setserial/Makefile
+
+setserial-install:
+	install -d $(INSTALLDIR)/setserial/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/setserial $(INSTALLDIR)/setserial/usr/bin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/setserial/usr/bin/setserial
+
+### ntp
+
+ntp: pps-tools setserial util-linux openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,) libcap ntp/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+ntp/Makefile: ntp-unpack ntp/configure
+	@[ -f $@ ] || $(MAKE) ntp-configure
+
+ntp/configure:
+	@[ -f $@ ] || ( cd ntp ; autoreconf -i -f )
+
+ntp-configure:
+	@[ ! -d ntp ] || [ -f "$(STAGEDIR)/usr/bin/ntpd" ] || ( cd ntp ; \
+		if [ -z "$(RTCONFIG_HND_ROUTER)" ] && [ ! -f "$(STAGEDIR)/usr/include/timepps.h" ]; then \
+			echo "timepps.h is not installed.  Verify that pps-tools was installed properly."; \
+			false; \
+		else \
+			$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+			PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+			CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+			CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+			LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+			LIBS="-lpthread" \
+			ac_cv_header_md5_h=no ac_cv_lib_rt_sched_setscheduler=no ac_cv_header_dns_sd_h=no hw_cv_func_snprintf_c99=yes hw_cv_func_vsnprintf_c99=yes ac_cv_make_ntptime=yes \
+			$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+			--prefix="$(STAGEDIR)/usr" \
+			--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+			--enable-static \
+			--enable-shared \
+			--enable-local-libopts \
+			--enable-local-libevent \
+			--enable-accurate-adjtime \
+			--without-ntpsnmpd \
+			--without-lineeditlibs \
+			--enable-linuxcaps \
+			--with-crypto \
+			--with-openssl-libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+			--with-openssl-incdir="$(STAGEDIR)/usr/include" \
+			--enable-autokey \
+			--enable-openssl-random \
+			--enable-thread-support \
+			--with-threads \
+			--with-yielding-select=yes \
+			--without-rpath \
+			--disable-silent-rules \
+			--disable-all-clocks \
+			--disable-parse-clocks \
+			--enable-NMEA \
+			--enable-ATOM \
+			--enable-LOCAL-CLOCK \
+			--enable-SHM \
+			--enable-WWV \
+			--enable-GPSD; \
+		fi )
 
-ntpclient-install:
-	$(MAKE) -C ntpclient INSTALLDIR=$(INSTALLDIR)/ntpclient install
+ntp-stage:
+	@echo ntp
+	@[ ! -d ntp ] || ( \
+		$(MAKE) -C ntp $(PARALLEL_BUILD) && \
+		$(MAKE) -C ntp install )
+
+ntp-clean:
+	[ ! -f ntp/Makefile ] || $(MAKE) -C ntp clean
+	@rm -f ntp/Makefile
+
+ntp-install:
+	install -d $(INSTALLDIR)/ntp/usr/bin/
+	install -d $(INSTALLDIR)/ntp/usr/sbin/
+	install -D $(STAGEDIR)/usr/bin/ntpd $(INSTALLDIR)/ntp/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ntpdate $(INSTALLDIR)/ntp/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ntpdc $(INSTALLDIR)/ntp/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ntp-keygen $(INSTALLDIR)/ntp/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ntpq $(INSTALLDIR)/ntp/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ntptime $(INSTALLDIR)/ntp/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ntptrace $(INSTALLDIR)/ntp/usr/sbin/
+	install -D $(STAGEDIR)/usr/bin/ntp-wait $(INSTALLDIR)/ntp/usr/sbin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/ntp/usr/bin/ntpd
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/ntp/usr/bin/ntpdate
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/ntp/usr/bin/ntpdc
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/ntp/usr/bin/ntp-keygen
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/ntp/usr/bin/ntpq
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/ntp/usr/bin/ntptime
+
+### libcap
+
+libcap: libcap-unpack
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libcap-stage:
+	@echo libcap
+	@[ ! -d libcap ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcap.so" ] || ( cd libcap ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		$(MAKE) install \
+		DESTDIR="$(STAGEDIR)/usr" \
+		prefix="" \
+		CC=$(BLACKFUEL_OPTIMIZED_CC) \
+		AR=$(BLACKFUEL_OPTIMIZED_AR) \
+		RANLIB=$(BLACKFUEL_OPTIMIZED_RANLIB) \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$$PWD/libcap/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(LIBS_DL) $(LIBS_DL) -L$(LIBS_PTHREAD) $(LIBS_PTHREAD) -L$(LIBS_M) $(LIBS_M) -L$(LIBS_RT) $(LIBS_RT) -L$(LIBS_C) $(LIBS_C) -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		BUILD_CC="gcc" \
+		BUILD_CFLAGS="-I$$PWD/libcap/include" \
+		INDENT="| true" \
+		PAM_CAP="no" \
+		RAISE_SETFCAP="no" \
+		DYNAMIC="yes" \
+		lib=$(BLACKFUEL_OPTIMIZED_LIB) )
+
+libcap-clean:
+	-@$(MAKE) -C libcap clean
+
+libcap-install:
+	install -d $(INSTALLDIR)/libcap/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcap.so* $(INSTALLDIR)/libcap/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/libcap/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/libcap/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcap.so*
 
-rstats: nvram$(BCMEX)$(EX7) shared
+### libusb10-aarch64
 
-rstats-install:
-	$(MAKE) -C rstats INSTALLDIR=$(INSTALLDIR)/rstats install
+ifeq ($(HND_ROUTER),y)
+libusb10-aarch64/stamp-h1:
+	cd libusb10-aarch64 && \
+	$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+	CFLAGS="-Os -Wall $(BLACKFUEL_OPTIMIZED_COPTS)" \
+	LIBS="-lpthread -ldl -lc $(BLACKFUEL_OPTIMIZED_COPTS)" \
+	$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--enable-shared \
+		--prefix=/usr \
+		--libdir=/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+		ac_cv_lib_rt_clock_gettime=no
+	-@$(MAKE) -C libusb10-aarch64 clean
+	touch $@
 
-dropbear/config.h.in: $(if $(RTCONFIG_PROTECTION_SERVER),protect_srv-stage,)
+libusb10-aarch64: libusb10-aarch64/stamp-h1
+	$(MAKE) -C $@ && \
+	DESTDIR="$(STAGEDIR)" $(MAKE) -C $@ install
+
+libusb10-aarch64-install: libusb10-aarch64
+	install -D libusb10-aarch64/libusb/.libs/libusb-1.0.so.0.0.0 $(INSTALLDIR)/libusb10-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libusb-1.0.so.0
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/libusb10-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*.so.*
+	cd $(INSTALLDIR)/libusb10-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB) && \
+		ln -sf libusb-1.0.so.0 libusb-1.0.so.0.0.0 && \
+		ln -sf libusb-1.0.so.0 libusb-1.0.so
 
-dropbear/config.h: dropbear/config.h.in
-	cd dropbear && \
-		CPPFLAGS="-O2 -Wall $(EXTRACFLAGS) -DARGTYPE=3 -ffunction-sections -fdata-sections -I$(STAGEDIR)/usr/include \
-			$(if $(RTCONFIG_PROTECTION_SERVER),-DSECURITY_NOTIFY,)" \
-		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
-		LIBS="$(if $(RTCONFIG_PROTECTION_SERVER),-lptcsrv)" \
-		$(CONFIGURE) --disable-zlib --disable-pam \
-		--enable-openpty --enable-syslog --enable-shadow --enable-bundled-libtom \
-		--disable-lastlog \
-		--disable-utmp --disable-utmpx \
-		--disable-wtmp --disable-wtmpx \
-		--disable-loginfunc \
-		--disable-pututline --disable-pututxline
+libusb10-aarch64-clean:
+	-@$(MAKE) -C libusb10-aarch64 clean
+	@rm -f libusb10-aarch64/stamp-h1
+endif
 
-dropbear: dropbear/config.h
-	@$(SEP)
-	@$(MAKE) -C $@ PROGRAMS="dropbear dbclient dropbearkey scp" MULTI=1 $(PARALLEL_BUILD)
+### libusb-aarch64
 
-dropbear-install:
-	install -D dropbear/dropbearmulti $(INSTALLDIR)/dropbear/usr/bin/dropbearmulti
-	$(STRIP) $(INSTALLDIR)/dropbear/usr/bin/dropbearmulti
-	cd $(INSTALLDIR)/dropbear/usr/bin && \
-	ln -sf dropbearmulti dropbearkey && \
-	ln -sf dropbearmulti dbclient && \
-	ln -sf dropbearmulti ssh && \
-	ln -sf dropbearmulti scp
-	install -d $(INSTALLDIR)/dropbear/usr/sbin
-	cd $(INSTALLDIR)/dropbear/usr/sbin && \
-	ln -sf ../bin/dropbearmulti dropbear
+ifeq ($(HND_ROUTER),y)
+libusb-aarch64/stamp-h1:
+	cd libusb-aarch64 && \
+	$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+	CFLAGS="-Wall -Os $(BLACKFUEL_OPTIMIZED_COPTS)" \
+	LDFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS)" \
+	$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix=/usr \
+		--libdir=/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+		LIBUSB_1_0_CFLAGS="-I$(TOP)/libusb10-aarch64/libusb" \
+		LIBUSB_1_0_LIBS="-L$(TOP)/libusb10-aarch64/libusb/.libs -lusb-1.0 -lpthread -ldl $(EXTRALDFLAGS)\
+		-Wl,-R/lib/arch64:/usr/$(BLACKFUEL_OPTIMIZED_LIB):/opt/usr/lib:/usr/local/share"
+	-@$(MAKE) -C libusb-aarch64 clean
+	touch $@
 
-dropbear-clean:
-	-@$(MAKE) -C dropbear clean
-	@rm -f dropbear/config.h
+libusb-aarch64: libusb10-aarch64 libusb-aarch64/stamp-h1
+	$(MAKE) -C $@
 
-wtfast-configure:
-	@true
+libusb-aarch64-install: libusb-aarch64
+	install -D libusb-aarch64/libusb/.libs/libusb-0.1.so.4.4.4 $(INSTALLDIR)/libusb-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libusb-0.1.so.4
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/libusb-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*.so.*
+	cd $(INSTALLDIR)/libusb-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB) && \
+		ln -sf libusb-0.1.so.4 libusb-0.1.so.4.4.4 && \
+		ln -sf libusb-0.1.so.4 libusb.so
 
-wtfast-install:
-	install -D wtfast/wtfslhd/wtfslhd$(BCMEX)$(EX7)/wtfslhd $(INSTALLDIR)/wtfast/usr/sbin/wtfslhd
+libusb-aarch64-clean:
+	-@$(MAKE) -C libusb-aarch64 clean
+	@rm -f libusb-aarch64/stamp-h1
+endif
+
+### rtl-sdr
+
+rtl-sdr: libusb10$(if $(RTCONFIG_HND_ROUTER),-aarch64,) rtl-sdr/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+rtl-sdr/Makefile: rtl-sdr-unpack rtl-sdr/configure
+	@[ -f $@ ] || $(MAKE) rtl-sdr-configure
+
+rtl-sdr/configure:
+	@[ -f $@ ] || ( cd rtl-sdr ; autoreconf -i -f )
+
+rtl-sdr-configure:
+	@[ ! -d rtl-sdr ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/librtlsdr.a" ] || ( cd rtl-sdr ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libusb-1.0.a $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libusb-1.0.a -L$(LIBS_DL) $(LIBS_DL) -L$(LIBS_PTHREAD) $(LIBS_PTHREAD) -L$(LIBS_M) $(LIBS_M) -L$(LIBS_RT) $(LIBS_RT) -L$(LIBS_C) $(LIBS_C) -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-static \
+		--disable-shared \
+		--disable-silent-rules \
+		--enable-driver-detach )
 
-# Media libraries
+rtl-sdr-stage:
+	@echo rtl-sdr
+	@[ ! -d rtl-sdr ] || ( \
+		$(MAKE) -C rtl-sdr $(PARALLEL_BUILD) && \
+		$(MAKE) -C rtl-sdr install )
+
+rtl-sdr-clean:
+	[ ! -f rtl-sdr/Makefile ] || $(MAKE) -C rtl-sdr clean
+	@rm -f rtl-sdr/Makefile
+
+rtl-sdr-install:
+	@echo "rtl-sdr is static library, nothing to install"
+
+### rtl-entropy
+
+rtl-entropy: libcap rtl-sdr openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,) rtl-entropy/build/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+rtl-entropy/build/Makefile: rtl-entropy-unpack
+	@[ -f $@ ] || ( cd rtl-entropy ; \
+		rm -rf build ; mkdir -p build ; cd build ; \
+		STATIC_LIBS_RTLENTROPY="-L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcap.a $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcap.a -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/librtlsdr.a $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/librtlsdr.a -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libusb-1.0.a $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libusb-1.0.a  -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libssl.a $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libssl.a  -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcrypto.a $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcrypto.a -L$(LIBS_DL) $(LIBS_DL) -L$(LIBS_PTHREAD) $(LIBS_PTHREAD) -L$(LIBS_M) $(LIBS_M) -L$(LIBS_RT) $(LIBS_RT) -L$(LIBS_C) $(LIBS_C) -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)"; \
+		ARM_COMPILER_FLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99"; \
+		ARM_LINKER_FLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections $$STATIC_LIBS_RTLENTROPY"; \
+		ARM_LINK_EXECUTABLE="$(BLACKFUEL_OPTIMIZED_CC) $(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -O3 -DNDEBUG  -ffunction-sections -fdata-sections -Wl,--gc-sections CMakeFiles/rtlentropylib.dir/fips.c.o CMakeFiles/rtlentropylib.dir/log.c.o CMakeFiles/rtlentropylib.dir/util.c.o CMakeFiles/rtl_entropy.dir/rtl_entropy.c.o  -o rtl_entropy -rdynamic $$STATIC_LIBS_RTLENTROPY"; \
+		cmake \
+		-DCMAKE_SYSTEM_NAME="Linux" \
+		-DCMAKE_SYSTEM_VERSION="$(LINUX_KERNEL)" \
+		-DCMAKE_FIND_ROOT_PATH="$(STAGEDIR)/usr" \
+		-DCMAKE_INSTALL_PREFIX="$(STAGEDIR)/usr" \
+		-DCMAKE_PREFIX_PATH="$(STAGEDIR)/usr" \
+		-DCMAKE_LIBRARY_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		-DCMAKE_ARCHIVE_OUTPUT_DIRECTORY="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		-DCMAKE_LIBRARY_OUTPUT_DIRECTORY="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		-DCMAKE_RUNTIME_OUTPUT_DIRECTORY="$(STAGEDIR)/usr/bin" \
+		-DOPENSSL_LIBRARIES="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		-DOPENSSL_INCLUDE_DIRS="$(STAGEDIR)/usr/include" \
+		-DCMAKE_C_COMPILER="$(BLACKFUEL_OPTIMIZED_CC)" \
+		-DCMAKE_CXX_COMPILER="$(BLACKFUEL_OPTIMIZED_CXX)" \
+		-DCMAKE_AR="$(BLACKFUEL_OPTIMIZED_AR)" \
+		-DCMAKE_LINKER="$(BLACKFUEL_OPTIMIZED_LD)" \
+		-DCMAKE_NM="$(BLACKFUEL_OPTIMIZED_NM)" \
+		-DCMAKE_OBJCOPY="$(BLACKFUEL_OPTIMIZED_OBJCOPY)" \
+		-DCMAKE_OBJDUMP="$(BLACKFUEL_OPTIMIZED_OBJDUMP)" \
+		-DCMAKE_RANLIB="$(BLACKFUEL_OPTIMIZED_RANLIB)" \
+		-DCMAKE_STRIP="$(BLACKFUEL_OPTIMIZED_STRIP)" \
+		-DCMAKE_C_FLAGS="$$ARM_COMPILER_FLAGS" \
+		-DCMAKE_CXX_FLAGS="$$ARM_COMPILER_FLAGS" \
+		-DCMAKE_SHARED_LINKER_FLAGS="$$ARM_LINKER_FLAGS" \
+		-DCMAKE_EXE_LINKER_FLAGS="$$ARM_LINKER_FLAGS" \
+		-DCMAKE_C_LINK_EXECUTABLE="$$ARM_LINK_EXECUTABLE" \
+		-DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
+		-DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
+		-DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
+		-DCMAKE_FIND_ROOT_PATH_MODE_PACKAGE=ONLY \
+		-DCMAKE_VERBOSE_MAKEFILE=TRUE \
+		-DCMAKE_BUILD_TYPE:String="None" \
+		../ )
+
+rtl-entropy-stage:
+	@echo rtl-entropy
+	@[ ! -f rtl-entropy/build/Makefile ] || [ -f "$(STAGEDIR)/usr/bin/rtl_entropy" ] || \
+		( $(MAKE) -C rtl-entropy/build $(PARALLEL_BUILD) && \
+		cp -vf rtl-entropy/build/src/rtl_entropy $(STAGEDIR)/usr/bin/ )
+
+rtl-entropy-clean:
+	[ ! -f rtl-entropy/build/Makefile ] || $(MAKE) -C rtl-entropy/build clean
+	@rm -rf rtl-entropy/build
+
+rtl-entropy-install:
+	install -d $(INSTALLDIR)/rtl-entropy/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/rtl_entropy $(INSTALLDIR)/rtl-entropy/usr/bin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/rtl-entropy/usr/bin/rtl_entropy
 
-sqlite/stamp-h1:
-	cd sqlite && \
-	CC=$(CC) CFLAGS="-O2 $(EXTRACFLAGS) -ffunction-sections -fdata-sections -fPIC" \
-		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -lpthread -ldl" \
-		$(CONFIGURE) --prefix=/usr --enable-shared --enable-static \
-		--disable-readline --disable-dynamic-extensions --enable-threadsafe \
-		--disable-dependency-tracking
-	touch $@
+### curl-aarch64
 
-sqlite: sqlite/stamp-h1
-	@$(MAKE) -C sqlite all
+ifeq ($(HND_ROUTER),y)
+curl-aarch64: openssl-aarch64 curl-aarch64/Makefile
+	@$(MAKE) -C $@ $(PARALLEL_BUILD) && $(MAKE) $@-stage
 
-sqlite-clean:
-	-@$(MAKE) -C sqlite clean
-	@rm -f sqlite/stamp-h1
+curl-aarch64/Makefile: curl-aarch64-unpack curl-aarch64/configure
+	@[ ! -d curl-aarch64 ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcurl.so" ] || ( \
+	cd curl-aarch64 && \
+	$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+	$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+	CC=$(BLACKFUEL_OPTIMIZED_CC) \
+	CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include -I$(TOP)/openssl/include" \
+	CXXFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC" \
+	CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include -I$(TOP)/openssl/include" \
+	LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) -L$(TOP)/openssl" \
+	LIBS="-lcrypto -lssl -ldl" \
+	--prefix=/usr \
+	--bindir=/usr/sbin \
+	--libdir=/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+	--enable-http \
+	--with-ssl=$(TOP)/openssl \
+	$(if $(RTCONFIG_IPV6),--enable-ipv6) \
+	--disable-gopher \
+	--disable-dict \
+	--disable-telnet \
+	--disable-manual \
+	--disable-libcurl-option \
+	--with-ca-bundle=/etc/ssl/certs/ca-certificates.crt \
+	)
 
-sqlite-install: sqlite
+curl-aarch64-install:
 	@$(SEP)
-	install -D sqlite/.libs/libsqlite3.so.0 $(INSTALLDIR)/sqlite/usr/lib/libsqlite3.so.0
-	$(STRIP) $(INSTALLDIR)/sqlite/usr/lib/libsqlite3.so.0
+	install -d $(INSTALLDIR)/curl-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df curl-aarch64/lib/.libs/libcurl.so* $(INSTALLDIR)/curl-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/curl-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/curl-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcurl.so*
+	install -D curl-aarch64/src/.libs/curl $(INSTALLDIR)/curl-aarch64/usr/sbin/curl
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/curl-aarch64/usr/sbin/curl
 
-# sqlite encrpted version
-sqlCipher/stamp-h1:
-	cd sqlCipher && \
-        CC=$(CC) CFLAGS="-Os $(EXTRACFLAGS) -DSQLITE_HAS_CODEC -ffunction-sections -fdata-sections -I$(SRCBASE)/router/openssl/include  -fPIC" \
-                LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -lpthread -ldl -L$(SRCBASE)/router/openssl -lcrypto" \
-                $(CONFIGURE) --prefix=/usr --enable-shared --enable-static \
-                --disable-readline --disable-dynamic-extensions --enable-threadsafe \
-                --disable-dependency-tracking --enable-tempstore=yes --disable-tcl
+curl-aarch64-clean:
+	[ ! -f curl-aarch64/Makefile ] || $(MAKE) -C curl-aarch64 clean
+	@rm -f curl-aarch64/Makefile
+endif
+
+### libevent-2.0.21-aarch64
+
+ifeq ($(HND_ROUTER),y)
+libevent-2.0.21-aarch64: libevent-2.0.21-aarch64/Makefile
+	$(MAKE) -C $@ $(PARALLEL_BUILD) && \
+	$(MAKE) $@-stage && \
+	sed 's|/usr/$(BLACKFUEL_OPTIMIZED_LIB)|$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)|g' -i $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libevent.la
+
+libevent-2.0.21-aarch64/Makefile:
+	( cd libevent-2.0.21-aarch64 && autoreconf -i -f ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+			--prefix=/usr \
+			--libdir=/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+			--bindir=/usr/sbin \
+	)
+
+libevent-2.0.21-aarch64-install: libevent-2.0.21-aarch64
+	install -D $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libevent-2.0.so.5 $(INSTALLDIR)/$</usr/$(BLACKFUEL_OPTIMIZED_LIB)/libevent-2.0.so.5
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/$</usr/$(BLACKFUEL_OPTIMIZED_LIB)/libevent-2.0.so*
+
+libevent-2.0.21-aarch64-clean:
+	[ ! -f libevent-2.0.21-aarch64/Makefile ] || $(MAKE) -C libevent-2.0.21-aarch64 clean
+	@rm -f libevent-2.0.21-aarch64/Makefile
+endif
+
+### transmission-openssl
+
+transmission-openssl: openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,) curl$(if $(RTCONFIG_HND_ROUTER),-aarch64,) zlib$(if $(RTCONFIG_HND_ROUTER),-aarch64,) libevent-2.0.21$(if $(RTCONFIG_HND_ROUTER),-aarch64,) transmission-openssl/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+transmission-openssl/Makefile: transmission-openssl-unpack
+	@[ -f $@ ] || $(MAKE) transmission-openssl-configure
+
+transmission-openssl-configure:
+	@[ ! -d transmission-openssl ] || [ -f "$(STAGEDIR)/usr/bin/transmission-daemon" ] || ( \
+		cd transmission-openssl ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		DESTDIR="$(STAGEDIR)" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread" \
+		OPENSSL_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		OPENSSL_LIBS="-L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) -lcrypto -lssl" \
+		CRYPTO_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		CRYPTO_LIBS="-L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) -lcrypto -lssl" \
+		LIBCURL_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		LIBCURL_LIBS="-L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) -lcurl" \
+		LIBEVENT_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		LIBEVENT_LIBS="-L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) -levent" \
+		ZLIB_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		ZLIB_LIBS="-L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) -lz" \
+		./autogen.sh \
+		LD=$(BLACKFUEL_OPTIMIZED_LD) \
+		--host=$(BLACKFUEL_OPTIMIZED_HOST) \
+		--prefix=/usr \
+		--libdir=/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+		--datarootdir=/usr/local \
+		--disable-nls \
+		--disable-silent-rules \
+		--enable-daemon \
+		--enable-cli \
+		--without-gtk \
+		--enable-largefile \
+		--enable-lightweight \
+		--with-crypto=openssl \
+		--with-sysroot=$(BLACKFUEL_OPTIMIZED_SYSROOT) \
+		)
+
+transmission-openssl-stage:
+	@echo transmission-openssl
+	@[ ! -d transmission-openssl ] || ( \
+		$(MAKE) -C transmission-openssl $(PARALLEL_BUILD) && \
+		$(MAKE) -C transmission-openssl DESTDIR="$(STAGEDIR)" install )
+
+transmission-openssl-clean:
+	[ ! -f transmission-openssl/Makefile ] || $(MAKE) -C transmission-openssl distclean
+	@rm -f transmission-openssl/Makefile
+
+transmission-openssl-install:
+	install -d $(INSTALLDIR)/transmission-openssl/usr/bin/
+	install -d $(INSTALLDIR)/transmission-openssl/usr/local/
+	install -D $(STAGEDIR)/usr/bin/transmission-daemon $(INSTALLDIR)/transmission-openssl/usr/bin/Transmission-daemon
+	install -D $(STAGEDIR)/usr/bin/transmission-remote $(INSTALLDIR)/transmission-openssl/usr/bin/Transmission-remote
+	#install -D $(STAGEDIR)/usr/bin/transmission-cli $(INSTALLDIR)/transmission-openssl/usr/bin/Transmission-cli
+	#install -D $(STAGEDIR)/usr/bin/transmission-create $(INSTALLDIR)/transmission-openssl/usr/bin/Transmission-create
+	#install -D $(STAGEDIR)/usr/bin/transmission-edit $(INSTALLDIR)/transmission-openssl/usr/bin/Transmission-edit
+	#install -D $(STAGEDIR)/usr/bin/transmission-show $(INSTALLDIR)/transmission-openssl/usr/bin/Transmission-show
+	cp -af $(STAGEDIR)/usr/local/transmission $(INSTALLDIR)/transmission-openssl/usr/local/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/transmission-openssl/usr/bin/*
+
+### transmission-mbedtls
+
+transmission-mbedtls: mbedtls curl$(if $(RTCONFIG_HND_ROUTER),-aarch64,) zlib$(if $(RTCONFIG_HND_ROUTER),-aarch64,) libevent-2.0.21$(if $(RTCONFIG_HND_ROUTER),-aarch64,) transmission-mbedtls/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+transmission-mbedtls/Makefile: transmission-mbedtls-unpack
+	@[ -f $@ ] || $(MAKE) transmission-mbedtls-configure
+
+transmission-mbedtls-configure:
+	@[ ! -d transmission-mbedtls ] || [ -f "$(STAGEDIR)/usr/bin/transmission-daemon" ] || ( \
+		cd transmission-mbedtls ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		DESTDIR="$(STAGEDIR)" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread" \
+		MBEDTLS_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		MBEDTLS_LIBS="-L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) -lmbedtls" \
+		LIBCURL_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		LIBCURL_LIBS="-L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) -lcrypto -lssl -lcurl" \
+		LIBEVENT_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		LIBEVENT_LIBS="-L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) -levent" \
+		ZLIB_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		ZLIB_LIBS="-L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) -lz" \
+		./autogen.sh \
+		LD=$(BLACKFUEL_OPTIMIZED_LD) \
+		--host=aarch64-buildroot-linux-gnu \
+		$(if $(RTCONFIG_HND_ROUTER),,ac_cv_func_posix_fallocate=yes) \
+		--prefix=/usr \
+		--libdir=/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+		--datarootdir=/usr/local \
+		--disable-nls \
+		--disable-silent-rules \
+		--enable-daemon \
+		--enable-cli \
+		--without-gtk \
+		--enable-largefile \
+		--enable-lightweight \
+		--with-crypto=polarssl \
+		--with-sysroot=$(BLACKFUEL_OPTIMIZED_SYSROOT) \
+		)
+
+transmission-mbedtls-stage:
+	@echo transmission-mbedtls
+	@[ ! -d transmission-mbedtls ] || ( \
+		$(MAKE) -C transmission-mbedtls $(PARALLEL_BUILD) && \
+		$(MAKE) -C transmission-mbedtls DESTDIR="$(STAGEDIR)" install )
+
+transmission-mbedtls-clean:
+	[ ! -f transmission-mbedtls/Makefile ] || $(MAKE) -C transmission-mbedtls distclean
+	@rm -f transmission-mbedtls/Makefile
+
+transmission-mbedtls-install:
+	install -d $(INSTALLDIR)/transmission-mbedtls/usr/bin/
+	install -d $(INSTALLDIR)/transmission-mbedtls/usr/local/
+	install -D $(STAGEDIR)/usr/bin/transmission-daemon $(INSTALLDIR)/transmission-mbedtls/usr/bin/Transmission-daemon
+	install -D $(STAGEDIR)/usr/bin/transmission-remote $(INSTALLDIR)/transmission-mbedtls/usr/bin/Transmission-remote
+	#install -D $(STAGEDIR)/usr/bin/transmission-cli $(INSTALLDIR)/transmission-mbedtls/usr/bin/Transmission-cli
+	#install -D $(STAGEDIR)/usr/bin/transmission-create $(INSTALLDIR)/transmission-mbedtls/usr/bin/Transmission-create
+	#install -D $(STAGEDIR)/usr/bin/transmission-edit $(INSTALLDIR)/transmission-mbedtls/usr/bin/Transmission-edit
+	#install -D $(STAGEDIR)/usr/bin/transmission-show $(INSTALLDIR)/transmission-mbedtls/usr/bin/Transmission-show
+	cp -af $(STAGEDIR)/usr/local/transmission $(INSTALLDIR)/transmission-mbedtls/usr/local/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/transmission-mbedtls/usr/bin/*
+
+### mbedtls
+
+mbedtls: mbedtls/build/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+mbedtls/build/Makefile: mbedtls-unpack
+	@[ -f $@ ] || ( cd mbedtls ; \
+		rm -rf build ; mkdir -p build ; cd build ; \
+		ARM_COMPILER_FLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99"; \
+		ARM_LINKER_FLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections"; \
+		cmake \
+		-DCMAKE_SYSTEM_NAME="Linux" \
+		-DCMAKE_SYSTEM_VERSION="$(LINUX_KERNEL)" \
+		-DCMAKE_FIND_ROOT_PATH="$(STAGEDIR)/usr" \
+		-DCMAKE_INSTALL_PREFIX="$(STAGEDIR)/usr" \
+		-DCMAKE_PREFIX_PATH="$(STAGEDIR)/usr" \
+		-DCMAKE_LIBRARY_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		-DCMAKE_ARCHIVE_OUTPUT_DIRECTORY="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		-DCMAKE_LIBRARY_OUTPUT_DIRECTORY="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		-DCMAKE_RUNTIME_OUTPUT_DIRECTORY="$(STAGEDIR)/usr/bin" \
+		-DCMAKE_C_COMPILER="$(BLACKFUEL_OPTIMIZED_CC)" \
+		-DCMAKE_CXX_COMPILER="$(BLACKFUEL_OPTIMIZED_CXX)" \
+		-DCMAKE_AR="$(BLACKFUEL_OPTIMIZED_AR)" \
+		-DCMAKE_LINKER="$(BLACKFUEL_OPTIMIZED_LD)" \
+		-DCMAKE_NM="$(BLACKFUEL_OPTIMIZED_NM)" \
+		-DCMAKE_OBJCOPY="$(BLACKFUEL_OPTIMIZED_OBJCOPY)" \
+		-DCMAKE_OBJDUMP="$(BLACKFUEL_OPTIMIZED_OBJDUMP)" \
+		-DCMAKE_RANLIB="$(BLACKFUEL_OPTIMIZED_RANLIB)" \
+		-DCMAKE_STRIP="$(BLACKFUEL_OPTIMIZED_STRIP)" \
+		-DCMAKE_C_FLAGS="$$ARM_COMPILER_FLAGS" \
+		-DCMAKE_CXX_FLAGS="$$ARM_COMPILER_FLAGS" \
+		-DCMAKE_SHARED_LINKER_FLAGS="$$ARM_LINKER_FLAGS" \
+		-DCMAKE_EXE_LINKER_FLAGS="$$ARM_LINKER_FLAGS" \
+		-DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
+		-DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
+		-DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
+		-DCMAKE_FIND_ROOT_PATH_MODE_PACKAGE=ONLY \
+		-DCMAKE_VERBOSE_MAKEFILE=TRUE \
+		-DCMAKE_BUILD_TYPE:String="None" \
+		-DUSE_SHARED_MBEDTLS_LIBRARY:Bool=ON \
+		-DENABLE_TESTING:Bool=OFF \
+		-DENABLE_PROGRAMS:Bool=OFF \
+		../ )
+
+mbedtls-stage:
+	@echo mbedtls
+	@[ ! -f mbedtls/build/Makefile ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libmbedtls.so" ] || ( \
+		$(MAKE) -C mbedtls/build $(PARALLEL_BUILD) )
+
+mbedtls-clean:
+	[ ! -f mbedtls/build/Makefile ] || $(MAKE) -C mbedtls/build clean
+	@rm -rf mbedtls/build
+
+mbedtls-install:
+	install -d $(INSTALLDIR)/mbedtls/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libmbed*.so* $(INSTALLDIR)/mbedtls/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/mbedtls/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/mbedtls/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libmbed*.so*
+
+### libusb-0.1.12-aarch64
+
+ifeq ($(HND_ROUTER),y)
+libusb-0.1.12-aarch64/stamp-h1:
+	cd libusb-0.1.12-aarch64 && \
+	$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+	CFLAGS="-Os -Wall $(BLACKFUEL_OPTIMIZED_COPTS)" \
+	LIBS="-lpthread -ldl" \
+	$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix=/usr \
+		--libdir=/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+		--disable-build-docs \
+		--disable-dependency-tracking
+	-@$(MAKE) -C libusb-0.1.12-aarch64 clean
 	touch $@
 
-sqlCipher: sqlCipher/stamp-h1
-	@$(MAKE) -C sqlCipher all
+libusb-0.1.12-aarch64: libusb-0.1.12-aarch64/stamp-h1
+	$(MAKE) -C $@
 
-sqlCipher-clean:
-	-@$(MAKE) -C sqlCipher clean
-	@rm -f sqlCipher/stamp-h1
+libusb-0.1.12-aarch64-install: libusb-0.1.12-aarch64
+	@echo "do nothing"
 
-sqlCipher-install: sqlCipher
-	install -D sqlCipher/.libs/libsqlcipher.so.0.8.6 $(INSTALLDIR)/sqlCipher/usr/lib/libsqlcipher.so.0
-	$(STRIP) $(INSTALLDIR)/sqlCipher/usr/lib/libsqlcipher.so.0
-	@$(SEP)
+libusb-0.1.12-aarch64-clean:
+	-@$(MAKE) -C libusb-0.1.12-aarch64 clean
+	@rm -f libusb-0.1.12-aarch64/stamp-h1
+endif
+
+### apcupsd
+
+apcupsd: libusb-0.1.12$(if $(RTCONFIG_HND_ROUTER),-aarch64,) libgd apcupsd/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+apcupsd/Makefile: apcupsd-unpack
+	@[ -f $@ ] || $(MAKE) apcupsd-configure
+
+apcupsd-configure:
+	@[ ! -d apcupsd ] || [ -f "$(STAGEDIR)/usr/sbin/apcupsd" ] || \
+		(cd apcupsd ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		DESTDIR="$(STAGEDIR)" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(TOP)/libusb-0.1.12$(if $(RTCONFIG_HND_ROUTER),-aarch64,) -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE -I$(TOP)/libusb-0.1.12$(if $(RTCONFIG_HND_ROUTER),-aarch64,) -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(TOP)/libusb-0.1.12$(if $(RTCONFIG_HND_ROUTER),-aarch64,)/.libs -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lpthread -lusb -lz -ljpeg -lpng -ltiff -lfreetype -lgd" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix=/usr \
+		--libdir=/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+		--sbindir=/usr/sbin \
+		--sysconfdir=/usr/local/etc/apcupsd \
+		--with-cgi-bin=/usr/local/etc/apcupsd \
+		--datarootdir=/usr/local \
+		--with-distname=unknown \
+		--with-upstype=usb \
+		--with-upscable=usb \
+		--without-serial-dev \
+		--enable-apcsmart \
+		--enable-dumb \
+		--enable-test \
+		$(if $(RTCONFIG_APCUPSD_CGI),--enable-cgi,--disable-cgi) \
+		--enable-usb \
+		--enable-modbus \
+		--enable-modbus-usb \
+		--without-x)
+
+apcupsd-stage: apcupsd-configure
+	@echo apcupsd
+	@[ ! -d apcupsd ] || ( \
+		$(MAKE) -C apcupsd $(PARALLEL_BUILD) && \
+		$(MAKE) -C apcupsd DESTDIR="$(STAGEDIR)" STRIP='' install )
+
+apcupsd-clean:
+	[ ! -f apcupsd/Makefile ] || $(MAKE) -C apcupsd distclean
+	@rm -f apcupsd/Makefile
+
+apcupsd-install:
+	install -d $(INSTALLDIR)/apcupsd/usr/sbin/
+	install -D $(STAGEDIR)/usr/sbin/apcupsd $(INSTALLDIR)/apcupsd/usr/sbin/
+	install -D $(STAGEDIR)/usr/sbin/smtp $(INSTALLDIR)/apcupsd/usr/sbin/
+	install -D $(STAGEDIR)/usr/sbin/apctest $(INSTALLDIR)/apcupsd/usr/sbin/
+	install -D $(STAGEDIR)/usr/sbin/apcaccess $(INSTALLDIR)/apcupsd/usr/sbin/
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/apcupsd/usr/sbin/*
+	install -d $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/apcupsd.conf $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/apcupsd_mail.conf $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/changeme $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/commfailure $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/commok $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/offbattery $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/onbattery $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/apccontrol $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+ifeq ($(RTCONFIG_APCUPSD_CGI),y)
+	install -d $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/www/cgi-bin
+	cp -pf $(STAGEDIR)/usr/local/etc/apcupsd/*.cgi $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/www/cgi-bin/
+	install -D $(STAGEDIR)/usr/local/etc/apcupsd/apcupsd.css $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(STAGEDIR)/usr/local/etc/apcupsd/hosts.conf $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(STAGEDIR)/usr/local/etc/apcupsd/multimon.conf $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+endif
+
+### libgd
+
+libgd: jpeg$(if $(RTCONFIG_HND_ROUTER),-aarch64,) libpng libtiff freetype libgd/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libgd/Makefile: libgd-unpack
+	@[ -f $@ ] || $(MAKE) libgd-configure
+
+libgd-configure:
+	@[ ! -d libgd ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgd.so" ] || ( \
+		cd libgd ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include -I$(STAGEDIR)/usr/include/freetype2" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="-lz -ljpeg -lpng -ltiff -lfreetype" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		--disable-rpath \
+		--without-x \
+		--without-fontconfig \
+		--with-jpeg \
+		--with-png \
+		--with-tiff \
+		--with-freetype \
+		--without-xpm \
+		)
+
+libgd-stage:
+	@echo libgd
+	@[ ! -d libgd ] || ( \
+		$(MAKE) -C libgd $(PARALLEL_BUILD) && \
+		$(MAKE) -C libgd install )
+
+libgd-clean:
+	[ ! -f libgd/Makefile ] || $(MAKE) -C libgd distclean
+	@rm -f libgd/Makefile
+
+libgd-install:
+	install -d $(INSTALLDIR)/libgd/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgd.so* $(INSTALLDIR)/libgd/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/libgd/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/libgd/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libgd.so*
 
-# commented out for mt-daapd-svn-1696
-ifneq ($(MEDIA_SERVER_STATIC),y)
-	install -D sqlite/.libs/libsqlite3.so.0 $(INSTALLDIR)/sqlite/usr/lib/libsqlite3.so.0
-	$(STRIP) $(INSTALLDIR)/sqlite/usr/lib/libsqlite3.so.0
-endif
-ifeq ($(RTCONFIG_FREERADIUS),y)
-	install -D sqlite/.libs/sqlite3 $(INSTALLDIR)/sqlite/usr/sbin/sqlite3
-	$(STRIP) $(INSTALLDIR)/sqlite/usr/sbin/sqlite3
-endif
+### jpeg-aarch64
 
-FFMPEG_FILTER_CONFIG= $(foreach c, $(2), --$(1)="$(c)")
+ifeq ($(HND_ROUTER),y)
+jpeg-aarch64: jpeg-aarch64/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
 
-FFMPEG_DECODERS:=aac ac3 atrac3 h264 jpegls mp3 mpeg1video mpeg2video mpeg4 mpeg4aac mpegvideo png wmav1 wmav2
-FFMPEG_CONFIGURE_DECODERS:=$(call FFMPEG_FILTER_CONFIG,enable-decoder,$(FFMPEG_DECODERS))
+jpeg-aarch64/Makefile: jpeg-aarch64-unpack
+	@[ -f $@ ] || $(MAKE) jpeg-aarch64-configure
 
-FFMPEG_PARSERS:=aac ac3 h264 mpeg4video mpegaudio mpegvideo
-FFMPEG_CONFIGURE_PARSERS:=$(call FFMPEG_FILTER_CONFIG,enable-parser,$(FFMPEG_PARSERS))
+jpeg-aarch64-configure:
+	@[ ! -d jpeg-aarch64 ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libjpeg.so" ] || ( \
+		cd jpeg-aarch64 ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		--disable-silent-rules \
+		--enable-maxmem=1 \
+		)
 
-FFMPEG_PROTOCOLS:=file
-FFMPEG_CONFIGURE_PROTOCOLS:=$(call FFMPEG_FILTER_CONFIG,enable-protocol,$(FFMPEG_PROTOCOLS))
+jpeg-aarch64-stage:
+	@echo jpeg-aarch64
+	@[ ! -d jpeg-aarch64 ] || ( \
+		$(MAKE) -C jpeg-aarch64 $(PARALLEL_BUILD) && \
+		$(MAKE) -C jpeg-aarch64 install )
+
+jpeg-aarch64-clean:
+	[ ! -f jpeg-aarch64/Makefile ] || $(MAKE) -C jpeg-aarch64 distclean
+	@rm -f jpeg-aarch64/Makefile
+
+jpeg-aarch64-install:
+	install -d $(INSTALLDIR)/jpeg-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libjpeg.so* $(INSTALLDIR)/jpeg-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/jpeg-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/jpeg-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+endif
+
+### libpng
+
+libpng: zlib$(if $(RTCONFIG_HND_ROUTER),-aarch64,) libpng/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libpng/Makefile: libpng-unpack
+	@[ -f $@ ] || $(MAKE) libpng-configure
+
+libpng-configure:
+	@[ ! -d libpng ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libpng.so" ] || ( \
+		cd libpng ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		--disable-silent-rules \
+		)
 
-FFMPEG_DISABLED_DEMUXERS:=amr apc ape ass bethsoftvid bfi c93 daud dnxhd dsicin dxa ffm gsm gxf idcin iff image2 image2pipe ingenient ipmovie lmlm4 mm mmf msnwc_tcp mtv mxf nsv nut oma pva rawvideo rl2 roq rpl segafilm shorten siff smacker sol str thp tiertexseq tta txd vmd voc wc3 wsaud wsvqa xa yuv4mpegpipe
-FFMPEG_CONFIGURE_DEMUXERS:=$(call FFMPEG_FILTER_CONFIG,disable-demuxer,$(FFMPEG_DISABLED_DEMUXERS))
+libpng-stage:
+	@echo libpng
+	@[ ! -d libpng ] || ( \
+		$(MAKE) -C libpng $(PARALLEL_BUILD) && \
+		$(MAKE) -C libpng install )
+
+libpng-clean:
+	[ ! -f libpng/Makefile ] || $(MAKE) -C libpng distclean
+	@rm -f libpng/Makefile
+
+libpng-install:
+	install -d $(INSTALLDIR)/libpng/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libpng.so* $(INSTALLDIR)/libpng/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libpng16.so* $(INSTALLDIR)/libpng/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/libpng/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/libpng/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+
+### libtiff
+
+libtiff: libtiff/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libtiff/Makefile: libtiff-unpack
+	@[ -f $@ ] || $(MAKE) libtiff-configure
+
+libtiff-configure:
+	@[ ! -d libtiff ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libtiff.so" ] || ( \
+		cd libtiff ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		--disable-silent-rules \
+		--enable-cxx \
+		--disable-lzma \
+		--enable-ccitt \
+		--enable-packbits \
+		--enable-lzw \
+		--enable-thunder \
+		--enable-next \
+		--enable-logluv \
+		--enable-mdi \
+		--enable-zlib \
+		--enable-jpeg \
+		--disable-old-jpeg \
+		--disable-jbig \
+		--without-x \
+		)
+
+libtiff-stage:
+	@echo libtiff
+	@[ ! -d libtiff ] || ( \
+		$(MAKE) -C libtiff $(PARALLEL_BUILD) && \
+		$(MAKE) -C libtiff install )
+
+libtiff-clean:
+	[ ! -f libtiff/Makefile ] || $(MAKE) -C libtiff distclean
+	@rm -f libtiff/Makefile
+
+libtiff-install:
+	install -d $(INSTALLDIR)/libtiff/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libtiff.so* $(INSTALLDIR)/libtiff/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libtiffxx.so* $(INSTALLDIR)/libtiff/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/libtiff/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/libtiff/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+
+### freetype
+
+freetype: zlib$(if $(RTCONFIG_HND_ROUTER),-aarch64,) bzip2 freetype/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+freetype/Makefile: freetype-unpack
+	@[ -f $@ ] || $(MAKE) freetype-configure
+
+freetype-configure:
+	@[ ! -d freetype ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libfreetype.so" ] || ( \
+		cd freetype ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--enable-shared \
+		--enable-static \
+		--with-bzip2=yes \
+		--with-zlib=yes \
+		--with-png=no \
+		)
+
+freetype-stage: freetype-configure
+	@echo freetype
+	@[ ! -d freetype ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libfreetype.so" ] || ( \
+		$(MAKE) -C freetype $(PARALLEL_BUILD) && \
+		$(MAKE) -C freetype install )
+
+freetype-clean:
+	[ ! -f freetype/Makefile ] || $(MAKE) -C freetype distclean
+	@rm -f freetype/Makefile
+
+freetype-install:
+	install -d $(INSTALLDIR)/freetype/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libfreetype.so* $(INSTALLDIR)/freetype/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/freetype/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/freetype/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+
+### bzip2
+
+bzip2: bzip2-unpack
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+bzip2-stage:
+	@echo bzip2
+	@[ ! -d bzip2 ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libbz2.a" ] || ( cd bzip2 ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		$(MAKE) $(PARALLEL_BUILD) \
+		PREFIX="$(STAGEDIR)/usr" \
+		CC="$(BLACKFUEL_OPTIMIZED_CC)" \
+		AR="$(BLACKFUEL_OPTIMIZED_AR)" \
+		RANLIB="$(BLACKFUEL_OPTIMIZED_RANLIB)" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		install; \
+		cp -dfv libbz2.a $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/; \
+		$(if $(RTCONFIG_HND_ROUTER),rm -fv $(STAGEDIR)/usr/lib/libbz2.a;,) \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		$(MAKE) $(PARALLEL_BUILD) -f Makefile-libbz2_so \
+		PREFIX="$(STAGEDIR)/usr" \
+		CC="$(BLACKFUEL_OPTIMIZED_CC)" \
+		AR="$(BLACKFUEL_OPTIMIZED_AR)" \
+		RANLIB="$(BLACKFUEL_OPTIMIZED_RANLIB)" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		all ; \
+		cp -dfv libbz2.so* $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/; \
+		)
+
+bzip2-clean:
+	-@$(MAKE) -C bzip2 clean
+
+bzip2-install:
+	install -d $(INSTALLDIR)/bzip2/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libbz2.so* $(INSTALLDIR)/bzip2/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/bzip2/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/bzip2/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
 
-ffmpeg/stamp-h1: zlib
+### zlib-aarch64
+
+ifeq ($(HND_ROUTER),y)
+zlib-aarch64: zlib-aarch64/stamp-h1
+	@[ ! -f zlib-aarch64/stamp-h1 ] || ( $(SEP); \
+		[ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libz.so" ] || ( \
+			$(MAKE) -C zlib-aarch64 $(PARALLEL_BUILD) && $(MAKE) -C zlib-aarch64 install \
+			) \
+		)
+
+zlib-aarch64/stamp-h1: zlib-aarch64-unpack
+	cd zlib-aarch64 && \
+	$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+	CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+	LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) -lgcc_s" \
+	./configure \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		--shared \
+		--uname=Linux
+	touch $@
+
+zlib-aarch64-clean:
+	[ ! -f zlib-aarch64/stamp-h1 ] || $(MAKE) -C zlib-aarch64 clean
+	@rm -f zlib-aarch64/stamp-h1
+
+zlib-aarch64-install:
+	install -d $(INSTALLDIR)/zlib-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libz.so* $(INSTALLDIR)/zlib-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/zlib-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/zlib-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+endif
+
+### liblz4
+
+liblz4: liblz4-unpack
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+liblz4-stage:
+	@echo liblz4
+	@[ ! -d liblz4 ] || [ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/liblz4.so" ] || ( cd liblz4 ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		$(MAKE) $(PARALLEL_BUILD) \
+		CC=$(BLACKFUEL_OPTIMIZED_CC) \
+		AR=$(BLACKFUEL_OPTIMIZED_AR) \
+		LD=$(BLACKFUEL_OPTIMIZED_LINKER) \
+		RANLIB=$(BLACKFUEL_OPTIMIZED_RANLIB) \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		DESTDIR="" \
+		PREFIX="$(STAGEDIR)/usr" \
+		LIBDIR="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		INCLUDEDIR="$(STAGEDIR)/usr/include" \
+		install \
+		)
+
+liblz4-clean:
+	-@$(MAKE) -C liblz4 clean
+
+liblz4-install:
+	install -d $(INSTALLDIR)/liblz4/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/liblz4.so* $(INSTALLDIR)/liblz4/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/liblz4/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/liblz4/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+
+### ncurses-aarch64
+
+ifeq ($(HND_ROUTER),y)
+ncurses-aarch64/Makefile: ncurses-aarch64-unpack
+	cd ncurses-aarch64 && \
+	$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+	PKG_CONFIG_PATH="/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+	CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+	CXXFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+	CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+	LDFLAGS="-L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+	$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+	$(if $(RTCONFIG_HND_ROUTER),CPPFLAGS="-P",) \
+	--prefix=/usr \
+	--libdir=/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+	--enable-echo --enable-const --disable-overwrite --disable-rpath --without-ada \
+	$(if $(RTCONFIG_BCMARM),--enable-widec,) \
+	--without-debug --without-manpages --without-profile --without-tests \
+	--disable-home-terminfo --with-normal --with-shared --with-build-cppflags=-D_GNU_SOURCE \
+	--enable-pc-files --with-pkg-config="/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+	--enable-termcap --with-fallbacks="xterm,vt100,vt200,linux,ansi,xterm-256color" \
+	--with-default-terminfo-dir=/usr/share/terminfo --with-terminfo-dirs=/usr/share/terminfo \
+	--with-install-prefix="$(STAGEDIR)" --with-pkg-config-libdir="/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig"
+
+ncurses-aarch64: ncurses-aarch64-unpack ncurses-aarch64/Makefile
+	@$(SEP)
+#	cd ncurses-aarch64 && $(MAKE) -C ncurses && $(MAKE) -C misc pc-files && $(MAKE) install DESTDIR="$(STAGEDIR)"
+	cd ncurses-aarch64 && \
+	$(MAKE) DESTDIR="$(STAGEDIR)" && \
+	$(MAKE) install DESTDIR="$(STAGEDIR)"
+
+ncurses-aarch64-clean:
+	-@$(MAKE) -C ncurses-aarch64 distclean
+	@rm -f ncurses-aarch64/Makefile
+
+ncurses-aarch64-install:
+ifeq ($(RTCONFIG_BCMARM),y)
+	install -D ncurses-aarch64/lib/libncursesw.so.6.0 $(INSTALLDIR)/ncurses-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libncursesw.so.6.0
+else
+	install -D ncurses-aarch64/lib/libncurses.so.6.0 $(INSTALLDIR)/ncurses-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libncurses.so.6.0
+endif
+
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/ncurses-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*.so.*
+
+ifeq ($(RTCONFIG_BCMARM),y)
+	cd $(INSTALLDIR)/ncurses-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB) && ln -sf libncursesw.so.6.0 libncursesw.so.6
+else
+	cd $(INSTALLDIR)/ncurses-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB) && ln -sf libncurses.so.6.0 libncurses.so.6
+endif
+endif
+
+### nettle-aarch64
+
+ifeq ($(HND_ROUTER),y)
+nettle-aarch64/stamp-h1: nettle-aarch64-unpack
+	@cd nettle-aarch64 && \
+	$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+	PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+	CFLAGS="-O3 $(BLACKFUEL_OPTIMIZED_COPTS) -I$(STAGEDIR)/usr/include -I$(STAGEDIR)/usr/include/nettle -I$(TOP)/gmp" \
+	CXXFLAGS="-O3 $(BLACKFUEL_OPTIMIZED_COPTS) -I$(STAGEDIR)/usr/include -I$(STAGEDIR)/usr/include/nettle -I$(TOP)/gmp" \
+	CPPFLAGS="-O3 $(BLACKFUEL_OPTIMIZED_COPTS) -I$(STAGEDIR)/usr/include -I$(STAGEDIR)/usr/include/nettle -I$(TOP)/gmp" \
+	LDFLAGS="-L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) -L$(TOP)/gmp/.libs" \
+	$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+	--prefix="$(STAGEDIR)/usr" \
+	--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+	--disable-shared \
+	--enable-static \
+	--enable-mini-gmp \
+	--disable-documentation
+	@touch nettle-aarch64/stamp-h1
+
+nettle-aarch64: nettle-aarch64/stamp-h1
+	@$(SEP)
+	@$(MAKE) -C nettle-aarch64 $(PARALLEL_BUILD)
+	@$(MAKE) -C nettle-aarch64 install
+
+nettle-aarch64-clean:
+	-@$(MAKE) -C nettle-aarch64 clean
+	@rm -f nettle-aarch64/stamp-h1
+	@rm -rf nettle-aarch64/include nettle-aarch64/lib
+endif
+
+### wget
+
+wget/Makefile.in: wget/Makefile.am
+	cd wget && autoreconf -fi
+
+wget/Makefile: wget/Makefile.in
+	cd wget && \
+	$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+	$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--with-ssl=openssl --with-libssl-prefix=$(TOP)/openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,) --sysconfdir=/etc \
+		--disable-opie --disable-ntlm --disable-debug --disable-nls --disable-rpath \
+		$(if $(RTCONFIG_IPV6),,--disable-ipv6) --disable-iri --without-included-regex  \
+		--disable-dependency-tracking \
+		CFLAGS="-O3 -Wall $(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -I$(TOP)/openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,)/include -I$(TOP)/zlib$(if $(RTCONFIG_HND_ROUTER),-aarch64,)" \
+		LDFLAGS="-Wl,--gc-sections -L$(TOP)/openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,) -lssl -lcrypto -L$(TOP)/zlib$(if $(RTCONFIG_HND_ROUTER),-aarch64,) -lz"
+
+wget: openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,) zlib$(if $(RTCONFIG_HND_ROUTER),-aarch64,) wget-unpack wget/Makefile
+	$(MAKE) -C $@
+
+wget-clean:
+	[ ! -f wget/Makefile ] || $(MAKE) -C wget distclean
+	@rm -f wget/Makefile
+
+wget-install:
+	install -D wget/src/wget $(INSTALLDIR)/wget/usr/sbin/wget
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/wget/usr/sbin/wget
+
+### json-c-aarch64
+
+ifeq ($(HND_ROUTER),y)
+json-c-aarch64: json-c-aarch64/stamp-h1
+	@[ ! -f json-c-aarch64/stamp-h1 ] || ( $(SEP); \
+		[ -f "$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libjson-c.so" ] || \
+			( $(MAKE) -C json-c-aarch64 $(PARALLEL_BUILD) && $(MAKE) -C json-c-aarch64 install ) \
+		)
+
+json-c-aarch64/stamp-h1: json-c-aarch64-unpack
+	cd json-c-aarch64 ; \
+	$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+	PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+	CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+	CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+	LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+	LIBS="-lm" \
+	ac_cv_func_realloc_0_nonnull=yes \
+	ac_cv_func_malloc_0_nonnull=yes \
+	$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+	--prefix="$(STAGEDIR)/usr" \
+	--libdir="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+	--enable-shared \
+	--enable-static \
+	--disable-silent-rules
+	touch $@
+
+json-c-aarch64-clean:
+	[ ! -f json-c-aarch64/stamp-h1 ] || $(MAKE) -C json-c-aarch64 clean
+	@rm -f json-c-aarch64/stamp-h1
+
+json-c-aarch64-install:
+	install -d $(INSTALLDIR)/json-c-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libjson-c.so* $(INSTALLDIR)/json-c-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/json-c-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/json-c-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+endif
+
+### lzo-aarch64
+
+ifeq ($(HND_ROUTER),y)
+lzo-aarch64/stamp-h1: lzo-aarch64-unpack
+	cd lzo-aarch64 && \
+	$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+	CFLAGS="-O3 -Wall $(BLACKFUEL_OPTIMIZED_COPTS)" \
+	$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--enable-shared \
+		--enable-static \
+		--prefix=/usr \
+		--bindir=/usr/sbin \
+		--libdir=/usr/$(BLACKFUEL_OPTIMIZED_LIB)
+	touch $@
+
+lzo-aarch64: lzo-aarch64/stamp-h1
+	$(MAKE) -C lzo-aarch64 $(PARALLEL_BUILD) && $(MAKE) $@-stage
+
+lzo-aarch64-clean:
+	-@$(MAKE) -C lzo-aarch64 clean
+	@rm -f lzo-aarch64/stamp-h1
+
+lzo-aarch64-install:
+	install -D lzo-aarch64/src/.libs/liblzo2.so $(INSTALLDIR)/lzo-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/liblzo2.so.2
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/lzo-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB)/liblzo2.so.2
+	cd $(INSTALLDIR)/lzo-aarch64/usr/$(BLACKFUEL_OPTIMIZED_LIB) && ln -sf liblzo2.so.2 liblzo2.so
+endif
+
+### tor
+
+tor: openssl$(if $(RTCONFIG_HND_ROUTER),-aarch64,) zlib$(if $(RTCONFIG_HND_ROUTER),-aarch64,) libevent-2.0.21$(if $(RTCONFIG_HND_ROUTER),-aarch64,) zstd tor/Makefile
+	@$(SEP)
+	$(MAKE) -C $@ $(PARALLEL_BUILD)
+
+tor/Makefile: tor-unpack
+	(cd tor ; \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+		--disable-silent-rules \
+		--enable-static-libevent \
+		--with-libevent-dir=$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+		--with-openssl-dir=$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+		--with-zlib-dir=$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+		--disable-asciidoc \
+		--disable-unittests \
+		--disable-tool-name-check \
+		--enable-lzma \
+		--enable-zstd \
+		)
+
+tor-install:
+	install -D tor/src/or/tor $(INSTALLDIR)/tor/usr/sbin/Tor
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/tor/usr/sbin/Tor
+	install -D tor/src/tools/tor-gencert $(INSTALLDIR)/tor/usr/sbin/Tor-gencert
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/tor/usr/sbin/Tor-gencert
+	install -D tor/src/tools/tor-resolve $(INSTALLDIR)/tor/usr/sbin/Tor-resolve
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/tor/usr/sbin/Tor-resolve
+	install -Dpv tor/src/config/geoip $(INSTALLDIR)/tor/rom/tor/geoip
+	install -Dpv tor/src/config/geoip6 $(INSTALLDIR)/tor/rom/tor/geoip6
+
+tor-clean:
+	[ ! -f tor/Makefile ] || $(MAKE) -C tor clean
+	@rm -f tor/Makefile
+
+### openssl-aarch64
+
+ifeq ($(HND_ROUTER),y)
+openssl-aarch64/Makefile:
+	cd openssl-aarch64 && \
+	$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+	./Configure $(HOSTCONFIG_64) --prefix=/usr --libdir=lib64 --openssldir=/etc --cross-compile-prefix=' ' \
+	-ffunction-sections -fdata-sections -Wl,--gc-sections \
+	shared $(OPENSSL_CIPHERS) no-ssl2 no-ssl3
+#	enable-ec_nistp_64_gcc_128
+#	-I$(TOP)/cryptodev-linux -DHAVE_CRYPTODEV -DUSE_CRYPTODEV_DIGESTS
+#	no-sha0 no-smime no-camellia no-krb5 no-rmd160 no-ripemd \
+#	no-seed no-capieng no-cms no-gms no-gmp no-rfc3779 \
+#	no-ec no-ecdh no-ecdsa no-err no-hw no-jpake no-threads \
+#	no-zlib no-engine no-engines no-sse2 no-perlasm \
+#	no-dtls1 no-store no-psk no-md2 no-mdc2 no-ts
+
+	-@$(MAKE) -C openssl-aarch64 clean depend
+	@touch $@
+
+fsbuild-aarch64:
+	-mkdir -p $(BCM_FSBUILD_DIR)/public/lib
+	-mkdir -p $(BCM_FSBUILD_DIR)/public/bin
+	-mkdir -p $(BCM_FSBUILD_DIR)/public/sbin
+	-mkdir -p $(BCM_FSBUILD_DIR)/usr/lib
+	-mkdir -p $(BCM_FSBUILD_DIR)/usr/sbin
+	-mkdir -p $(BCM_FSBUILD_DIR)/public/include/openssl
+	-cp -u openssl-aarch64/include/openssl/* $(BCM_FSBUILD_DIR)/public/include/openssl
+	-mkdir -p $(INSTALL_DIR)/bin
+	-mkdir -p $(INSTALL_DIR)/rom/rom
+	#-mkdir -p $(INSTALL_DIR)/etc
+	-mkdir -p $(INSTALL_DIR)/lib/public
+	-mkdir -p $(INSTALL_DIR)/lib/private
+	-mkdir -p $(INSTALL_DIR)/lib/aarch64
+	#-mkdir -p $(INSTALL_DIR)/opt
+	-mkdir -p $(INSTALL_DIR)/sbin
+	-mkdir -p $(INSTALL_DIR)/usr
+	-mkdir -p $(INSTALL_DIR)/var
+	-mkdir -p $(INSTALL_DIR)/mnt
+	-mkdir -p $(INSTALL_DIR)/tmp/etc
+	-mkdir -p $(INSTALL_DIR)/www
+	#-cp $(TOOLCHAIN)/arm-buildroot-linux-gnueabi/lib/libgcc_s* $(INSTALL_DIR)/lib/public
+	#-cd $(INSTALL_DIR)/lib/public && rm -f libgcc_s.so && ln -sf libgcc_s.so.1 libgcc_s.so
+
+ifeq ($(HND_ROUTER),y)
+openssl-aarch64: openssl-aarch64/Makefile fsbuild
+else
+openssl-aarch64: openssl-aarch64/Makefile
+endif
+	$(MAKE) -C openssl-aarch64 && $(MAKE) $@-stage
+
+openssl-aarch64-clean:
+	[ ! -f openssl-aarch64/Makefile ] || $(MAKE) -C openssl-aarch64 clean depend
+	@rm -f openssl-aarch64/Makefile
+
+ifeq ($(HND_ROUTER),y)
+INSTALLSUBDIR=
+else
+INSTALLSUBDIR=/openssl-aarch64
+endif
+
+openssl-aarch64-install:
+	[ ! -f openssl-aarch64/Makefile ] || install -D openssl-aarch64/libcrypto.so.1.0.0 $(INSTALLDIR)$(INSTALLSUBDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcrypto.so.1.0.0
+	[ ! -f openssl-aarch64/Makefile ] || $(STRIP_64) $(INSTALLDIR)$(INSTALLSUBDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libcrypto.so.1.0.0
+	[ ! -f openssl-aarch64/Makefile ] || cd $(INSTALLDIR)$(INSTALLSUBDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) && rm -f libcrypto.so && ln -sf libcrypto.so.1.0.0 libcrypto.so
+
+	[ ! -f openssl-aarch64/Makefile ] || install -D openssl-aarch64/apps/openssl $(INSTALLDIR)$(INSTALLSUBDIR)/usr/sbin/openssl
+	[ ! -f openssl-aarch64/Makefile ] || $(STRIP_64) $(INSTALLDIR)$(INSTALLSUBDIR)/usr/sbin/openssl
+	[ ! -f openssl-aarch64/Makefile ] || chmod 0500 $(INSTALLDIR)$(INSTALLSUBDIR)/usr/sbin/openssl
+	[ ! -f openssl-aarch64/Makefile ] || patchelf --set-rpath /usr/$(BLACKFUEL_OPTIMIZED_LIB) $(INSTALLDIR)$(INSTALLSUBDIR)/usr/sbin/openssl
+
+ifeq ($(or $(RTCONFIG_WEBDAV),$(RTCONFIG_FTP_SSL),$(RTCONFIG_OPENVPN),$(RTCONFIG_HTTPS)),y)
+	[ ! -f openssl-aarch64/Makefile ] || install -D openssl-aarch64/libssl.so.1.0.0 $(INSTALLDIR)$(INSTALLSUBDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libssl.so.1.0.0
+	[ ! -f openssl-aarch64/Makefile ] || $(STRIP_64) $(INSTALLDIR)$(INSTALLSUBDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libssl.so.1.0.0
+	[ ! -f openssl-aarch64/Makefile ] || cd $(INSTALLDIR)$(INSTALLSUBDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB) && rm -f libssl.so && ln -sf libssl.so.1.0.0 libssl.so
+endif
+ifeq ($(HND_ROUTER),y)
+	[ ! -f openssl-aarch64/Makefile ] || mkdir -p $(BCM_FSBUILD_DIR)/public/include/openssl
+	[ ! -f openssl-aarch64/Makefile ] || cp -u openssl-aarch64/include/openssl/* $(BCM_FSBUILD_DIR)/public/include/openssl
+endif
+	[ ! -f openssl-aarch64/Makefile ] || install -D -m 0500 httpd/gencert.sh $(INSTALLDIR)$(INSTALLSUBDIR)/usr/sbin/gencert.sh
+
+openssl-aarch64-stage:
+	$(MAKE) -C openssl-aarch64 install_sw INSTALL_PREFIX=$(STAGEDIR)
+endif
+
+### strongswan-5.2.1
+
+##strongswan/IPSEC
+strongswan-5.2.1/stamp-h1:
+	cd strongswan-5.2.1 && \
+	autoreconf -i -f && \
+	$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+	PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+	CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -fPIC -I$(STAGEDIR)/usr/include" \
+	CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -fPIC -I$(STAGEDIR)/usr/include" \
+	LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+	LIBS="-lssl -lcrypto -lpthread -ldl -lm" \
+	$(BLACKFUEL_OPTIMIZED_CONFIGURE) \
+	--prefix=/usr/ \
+	--sysconfdir=/etc/ \
+	--localstatedir=/var/ \
+	--bindir=/usr/sbin \
+	--libdir=/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+	--libexecdir=/usr/$(BLACKFUEL_OPTIMIZED_LIB) \
+	--with-ipsecdir=/usr/$(BLACKFUEL_OPTIMIZED_LIB)/ipsec \
+	--with-user=admin \
+	--disable-gmp \
+	--enable-openssl \
+	--enable-agent \
+	--enable-eap-peap \
+	--enable-eap-md5 \
+	--enable-eap-mschapv2 \
+	--enable-eap-identity \
+	--with-strongswan-conf=/etc/strongswan.conf \
+	--enable-md4 \
+	--enable-acert \
+	--enable-cmd \
+	--enable-eap-tls \
+	--enable-libipsec
+	touch $@
+
+strongswan-5.2.1: strongswan-5.2.1/stamp-h1
+	$(MAKE) $(PARALLEL_BUILD) -C strongswan-5.2.1
+
+strongswan-5.2.1-install: strongswan-5.2.1
+	@$(SEP)
+	@$(MAKE) -C strongswan-5.2.1 install DESTDIR=$(INSTALLDIR)/strongswan-5.2.1/ ; chmod 755 $(INSTALLDIR)/strongswan-5.2.1/usr/$(BLACKFUEL_OPTIMIZED_LIB)
+	@rm -rf $(INSTALLDIR)/strongswan-5.2.1/usr/etc
+	@rm -f $(INSTALLDIR)/strongswan-5.2.1/usr/$(BLACKFUEL_OPTIMIZED_LIB)/ipsec/*.la
+	@rm -f $(INSTALLDIR)/strongswan-5.2.1/usr/$(BLACKFUEL_OPTIMIZED_LIB)/ipsec/plugins/*.la
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/strongswan-5.2.1/usr/$(BLACKFUEL_OPTIMIZED_LIB)/ipsec/*.so
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/strongswan-5.2.1/usr/$(BLACKFUEL_OPTIMIZED_LIB)/ipsec/starter
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/strongswan-5.2.1/usr/$(BLACKFUEL_OPTIMIZED_LIB)/ipsec/stroke
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/strongswan-5.2.1/usr/$(BLACKFUEL_OPTIMIZED_LIB)/ipsec/scepclient
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/strongswan-5.2.1/usr/$(BLACKFUEL_OPTIMIZED_LIB)/ipsec/charon
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/strongswan-5.2.1/usr/$(BLACKFUEL_OPTIMIZED_LIB)/ipsec/plugins/*.so
+	mv $(INSTALLDIR)/strongswan-5.2.1/etc $(INSTALLDIR)/strongswan-5.2.1/usr/
+
+strongswan-5.2.1-clean:
+	-@$(MAKE) -C strongswan-5.2.1 clean
+	@rm -f strongswan-5.2.1/stamp-h1
+	@rm -rf $(INSTALLDIR)/strongswan-5.2.1/
+	@rm -rf $(TARGETDIR)/usr/sbin/strongswan-5.2.1/*
+	@rm -rf $(TARGETDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/strongswan-5.2.1/*
+
+### libargon2
+
+libargon2/stamp-h1: libargon2-unpack
+	cd libargon2 && \
+	$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+	PKG_CONFIG_PATH="$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig" \
+	CFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+	CPPFLAGS="$(BLACKFUEL_OPTIMIZED_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+	LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+	$(MAKE) $(PARALLEL_BUILD)
+	touch $@
+
+libargon2: libargon2/stamp-h1
+	if [ -f $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libargon2.so ]; then \
+		true; \
+	else \
+		$(MAKE) $@-stage $(if $(RTCONFIG_HND_ROUTER),LIBRARY_REL=lib64,); \
+		$(call Install_Libargon2_Pkgconfig); \
+	fi
+
+libargon2-clean:
+	-@$(MAKE) -C libargon2 clean
+	@rm -f libargon2/stamp-h1
+
+libargon2-install:
+	install -d $(INSTALLDIR)/libargon2/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	cp -df $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libargon2.so* $(INSTALLDIR)/libargon2/usr/$(BLACKFUEL_OPTIMIZED_LIB)/
+	chmod u+w $(INSTALLDIR)/libargon2/usr/$(BLACKFUEL_OPTIMIZED_LIB)/*
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/libargon2/usr/$(BLACKFUEL_OPTIMIZED_LIB)/libargon2.so*
+	install -D $(STAGEDIR)/usr/bin/argon2 $(INSTALLDIR)/libargon2/usr/bin/argon2
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/libargon2/usr/bin/argon2
+
+define Install_Libargon2_Pkgconfig
+	[ -f libargon2/libargon2.pc.in ] || cp -p libargon2/libargon2.pc libargon2/libargon2.pc.in; \
+	UPSTREAM_VER=`date -r libargon2/libargon2.pc.in +%Y%m%d`; \
+	STAGEDIR=$(STAGEDIR); \
+	sed -r -i 's/prefix=\/usr/prefix='$${STAGEDIR//\//\\\/}'\/usr/' libargon2/libargon2.pc; \
+	sed -r -i 's/libdir=\$$\{prefix\}\/lib\/@HOST_MULTIARCH@/libdir=\$$\{prefix\}\/$(BLACKFUEL_OPTIMIZED_LIB)/' libargon2/libargon2.pc; \
+	sed -r -i 's/Version: @UPSTREAM_VER@/Version: '$${UPSTREAM_VER}'/' libargon2/libargon2.pc; \
+	cp -pf libargon2/libargon2.pc $(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)/pkgconfig
+endef
+
+
+################################################################################
+# 32-bit programs
+
+
+### xtables-addons
+
+define Install_Pkgconfig
+	PKGCONFIG_SOURCE_PATH=$(1); \
+	PKGCONFIG_TARGET_PATH=$(STAGEDIR)/usr/lib/pkgconfig/`basename $$PKGCONFIG_SOURCE_PATH`; \
+	if [ -f $$PKGCONFIG_TARGET_PATH ]; then \
+		true; \
+	else \
+		cp -pf $$PKGCONFIG_SOURCE_PATH $$PKGCONFIG_TARGET_PATH; \
+		STAGEDIR=$(STAGEDIR); \
+		sed -r -i 's=\/usr/='$${STAGEDIR//\//\\\/}'\/usr/g' $$PKGCONFIG_TARGET_PATH; \
+	fi
+endef
+
+xtables-addons: iptables-1.4.x xtables-addons/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+xtables-addons/Makefile: xtables-addons-unpack xtables-addons/configure
+	@[ -f $@ ] || $(MAKE) xtables-addons-configure
+
+xtables-addons/configure:
+	@[ -f $@ ] || ( cd xtables-addons ; ./autogen.sh )
+
+xtables-addons-configure:
+	@[ ! -d xtables-addons ] || [ -f "$(STAGEDIR)/usr/lib/xtables/libxt_TARPIT.so" ] || ( cd xtables-addons ; \
+		$(call Install_Pkgconfig,$(TOP)/iptables-1.4.x/iptables/xtables.pc); \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_COMPATIBLE_COPTS) -ffunction-sections -fdata-sections -Os -pipe -Wall -fPIC -std=gnu99 -I$(TOP)/iptables-1.4.x/include -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(BLACKFUEL_COMPATIBLE_COPTS) -ffunction-sections -fdata-sections -Os -pipe -Wall -fPIC -std=gnu99 -I$(TOP)/iptables-1.4.x/include -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(TOP)/iptables-1.4.x/libxtables/.libs -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--libdir="$(STAGEDIR)/usr/lib" \
+		--disable-silent-rules \
+		--without-kbuild \
+		--with-xtlibdir=$(STAGEDIR)/usr/lib/xtables \
+		)
+
+xtables-addons-stage:
+	@echo xtables-addons
+	@[ ! -d xtables-addons ] || $(MAKE) -C xtables-addons $(PARALLEL_BUILD) install
+
+xtables-addons-clean:
+	[ ! -f xtables-addons/Makefile ] || $(MAKE) -C xtables-addons clean
+	@rm -f xtables-addons/Makefile
+
+xtables-addons-install:
+	install -d $(INSTALLDIR)/xtables-addons/usr/lib/xtables
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_ACCOUNT.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_CHAOS.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_DELUDE.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_DHCPMAC.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_DNETMAP.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_ECHO.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_IPMARK.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_LOGMARK.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_SYSRQ.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_TARPIT.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_condition.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_dhcpmac.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_fuzzy.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_geoip.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_gradm.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_iface.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_ipp2p.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_ipv4options.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_length2.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_lscan.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_pknock.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_psd.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	cp -df $(STAGEDIR)/usr/lib/xtables/libxt_quota2.so $(INSTALLDIR)/xtables-addons/usr/lib/xtables/
+	chmod u+w $(INSTALLDIR)/xtables-addons/usr/lib/xtables/*
+	$(STRIP) $(INSTALLDIR)/xtables-addons/usr/lib/xtables/*.so*
+
+### powstatd
+
+powstatd: shared powstatd-unpack
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+powstatd-stage:
+	@echo powstatd
+	@[ ! -d powstatd ] || [ -f "$(STAGEDIR)/usr/sbin/powstatd" ] || ( cd powstatd ; \
+		$(MAKE) $(PARALLEL_BUILD) \
+		DESTDIR="$(STAGEDIR)/usr/sbin" \
+		PFSCR="$(STAGEDIR)/usr/sbin/powerfail" \
+		MANDIR="$(STAGEDIR)/usr/share/man/man8" \
+		CFGDIR="/usr/local/etc" \
+		CC="$(CC)" \
+		CFLGS="$(BLACKFUEL_COMPATIBLE_COPTS) -Os -Wall -pipe -fPIC -std=gnu99 -D_GNU_SOURCE -I$(TOP)/shared -ffunction-sections -fdata-sections" \
+		LIB="-lgcc_s -L$(TOP)/nvram$(BCMEX)$(EX7) -lnvram $(shell if [[ "$(HND_ROUTER)" = "y" ]] ; then echo "-L$(TOP)/wlcsm -lwlcsm"; else echo ""; fi) -L$(TOP)/shared -lshared $(if $(RTCONFIG_QTN),-L$(TOP)/libqcsapi_client -lqcsapi_client) -ffunction-sections -fdata-sections -Wl,--gc-sections" )
+
+powstatd-clean:
+	-@$(MAKE) -C powstatd clean
+
+powstatd-install:
+	install -d $(INSTALLDIR)/powstatd/usr/sbin/
+	install -d $(INSTALLDIR)/powstatd/usr/local/etc/powstatd/
+	install -D powstatd/powstatd $(INSTALLDIR)/powstatd/usr/sbin/
+	$(STRIP) $(INSTALLDIR)/powstatd/usr/sbin/powstatd
+	install -D $(BLACKFUEL_DIR)/packages/powstatd/files/powerfail $(INSTALLDIR)/powstatd/usr/sbin/
+	install -D $(BLACKFUEL_DIR)/packages/powstatd/files/powstatd.conf $(INSTALLDIR)/powstatd/usr/local/etc/powstatd/
+
+### curl-7.21.7
+
+curl-7.21.7: openssl curl-7.21.7/Makefile
+	@$(MAKE) -C $@ $(PARALLEL_BUILD) && $(MAKE) $@-stage
+
+curl-7.21.7/Makefile: curl-7.21.7-unpack curl-7.21.7/configure
+	@[ ! -d curl-7.21.7 ] || [ -f "$(STAGEDIR)/usr/lib/libcurl.so" ] || ( \
+	cd curl-7.21.7 && \
+	$(CONFIGURE) \
+	CC=$(CC) \
+	CFLAGS="$(BLACKFUEL_COMPATIBILE_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include -I$(TOP)/openssl/include" \
+	CXXFLAGS="$(BLACKFUEL_COMPATIBILE_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC" \
+	CPPFLAGS="$(BLACKFUEL_COMPATIBILE_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include -I$(TOP)/openssl/include" \
+	LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib -L$(TOP)/openssl" \
+	LIBS="-lcrypto -lssl -ldl" \
+	--prefix=/usr \
+	--bindir=/usr/sbin \
+	--libdir=/usr/lib \
+	$(if $(RTCONFIG_HND_ROUTER),--program-suffix=32,) \
+	--enable-http \
+	--with-ssl=$(TOP)/openssl \
+	$(if $(RTCONFIG_IPV6),--enable-ipv6) \
+	--disable-gopher \
+	--disable-dict \
+	--disable-telnet \
+	--disable-manual \
+	--disable-libcurl-option \
+	--with-ca-bundle=/etc/ssl/certs/ca-certificates.crt \
+	)
+
+curl-7.21.7-install:
+	@$(SEP)
+	install -d $(INSTALLDIR)/curl-7.21.7/usr/lib/
+	cp -df curl-7.21.7/lib/.libs/libcurl.so* $(INSTALLDIR)/curl-7.21.7/usr/lib/
+	chmod u+w $(INSTALLDIR)/curl-7.21.7/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/curl-7.21.7/usr/lib/libcurl.so*
+	install -D curl-7.21.7/src/.libs/curl $(INSTALLDIR)/curl-7.21.7/usr/sbin/curl$(if $(RTCONFIG_HND_ROUTER),32,)
+	$(STRIP) $(INSTALLDIR)/curl-7.21.7/usr/sbin/curl$(if $(RTCONFIG_HND_ROUTER),32,)
+
+curl-7.21.7-clean:
+	[ ! -f curl-7.21.7/Makefile ] || $(MAKE) -C curl-7.21.7 clean
+	@rm -f curl-7.21.7/Makefile
+
+### jpeg
+
+jpeg: jpeg/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+jpeg/Makefile: jpeg-unpack
+	@[ -f $@ ] || $(MAKE) jpeg-configure
+
+jpeg-configure:
+	@[ ! -d jpeg ] || [ -f "$(STAGEDIR)/usr/lib/libjpeg.so" ] || ( \
+		cd jpeg ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(BLACKFUEL_COMPATIBILE_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(BLACKFUEL_COMPATIBILE_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE" \
+		CPPFLAGS="$(BLACKFUEL_COMPATIBILE_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-silent-rules \
+		--enable-maxmem=1 \
+		)
+
+jpeg-stage:
+	@echo jpeg
+	@[ ! -d jpeg ] || ( \
+		$(MAKE) -C jpeg $(PARALLEL_BUILD) && \
+		$(MAKE) -C jpeg install )
+
+jpeg-clean:
+	[ ! -f jpeg/Makefile ] || $(MAKE) -C jpeg distclean
+	@rm -f jpeg/Makefile
+
+jpeg-install:
+	install -d $(INSTALLDIR)/jpeg/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libjpeg.so* $(INSTALLDIR)/jpeg/usr/lib/
+	chmod u+w $(INSTALLDIR)/jpeg/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/jpeg/usr/lib/*
+
+### zlib
+
+zlib: zlib/stamp-h1
+	@[ ! -f zlib/stamp-h1 ] || ( $(SEP); \
+		[ -f "$(STAGEDIR)/usr/lib/libz.so" ] || ( \
+			$(MAKE) -C zlib $(PARALLEL_BUILD) && $(MAKE) -C zlib install \
+			) \
+		)
+
+zlib/stamp-h1: zlib-unpack
+	cd zlib && \
+	CC=$(CC) \
+	AR=$(AR) \
+	LD=$(LD) \
+	RANLIB=$(RANLIB) \
+	CFLAGS="$(BLACKFUEL_COMPATIBILE_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+	LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib -lgcc_s" \
+	./configure \
+		--prefix="$(STAGEDIR)/usr" \
+		--shared \
+		--uname=Linux
+	touch $@
+
+zlib-clean:
+	[ ! -f zlib/stamp-h1 ] || $(MAKE) -C zlib clean
+	@rm -f zlib/stamp-h1
+
+zlib-install:
+	install -d $(INSTALLDIR)/zlib/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libz.so* $(INSTALLDIR)/zlib/usr/lib/
+	chmod u+w $(INSTALLDIR)/zlib/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/zlib/usr/lib/*
+
+### json-c
+
+json-c: json-c/stamp-h1
+	@[ ! -f json-c/stamp-h1 ] || ( $(SEP); \
+		[ -f "$(STAGEDIR)/usr/lib/libjson-c.so" ] || \
+			( $(MAKE) -C json-c $(PARALLEL_BUILD) && $(MAKE) -C json-c install ) \
+		)
+
+json-c/stamp-h1: json-c-unpack
+	cd json-c ; \
+	PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+	CFLAGS="$(BLACKFUEL_COMPATIBILE_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+	CPPFLAGS="$(BLACKFUEL_COMPATIBILE_COPTS) -ffunction-sections -fdata-sections -O3 -pipe -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+	LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+	LIBS="-lm" \
+	ac_cv_func_realloc_0_nonnull=yes \
+	ac_cv_func_malloc_0_nonnull=yes \
+	$(CONFIGURE) \
+	--prefix="$(STAGEDIR)/usr" \
+	--enable-shared \
+	--enable-static \
+	--disable-silent-rules
+	touch $@
+
+json-c-clean:
+	[ ! -f json-c/stamp-h1 ] || $(MAKE) -C json-c clean
+	@rm -f json-c/stamp-h1
+
+json-c-install:
+	install -d $(INSTALLDIR)/json-c/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libjson-c.so* $(INSTALLDIR)/json-c/usr/lib/
+	chmod u+w $(INSTALLDIR)/json-c/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/json-c/usr/lib/*
+
+### lzo
+
+lzo/stamp-h1: lzo-unpack
+	cd lzo && \
+	CFLAGS="-O3 -Wall $(EXTRACFLAGS)" \
+	$(CONFIGURE) \
+		--enable-shared \
+		--enable-static \
+		--prefix=/usr \
+		--bindir=/usr/sbin \
+		--libdir=/usr/lib
+	touch $@
+
+lzo: lzo/stamp-h1
+	$(MAKE) -C lzo $(PARALLEL_BUILD) && $(MAKE) $@-stage
+
+lzo-clean:
+	-@$(MAKE) -C lzo clean
+	@rm -f lzo/stamp-h1
+
+lzo-install:
+	install -D lzo/src/.libs/liblzo2.so $(INSTALLDIR)/lzo/usr/lib/liblzo2.so.2
+	$(STRIP) $(INSTALLDIR)/lzo/usr/lib/liblzo2.so.2
+	cd $(INSTALLDIR)/lzo/usr/lib && ln -sf liblzo2.so.2 liblzo2.so
+
+### nettle
+
+nettle/stamp-h1: nettle-unpack
+	@cd nettle && \
+	PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+	CFLAGS="-O3 $(EXTRACFLAGS) -I$(STAGEDIR)/usr/include -I$(STAGEDIR)/usr/include/nettle -I$(TOP)/gmp" \
+	CXXFLAGS="-O3 $(EXTRACFLAGS) -I$(STAGEDIR)/usr/include -I$(STAGEDIR)/usr/include/nettle -I$(TOP)/gmp" \
+	CPPFLAGS="-O3 $(EXTRACFLAGS) -I$(STAGEDIR)/usr/include -I$(STAGEDIR)/usr/include/nettle -I$(TOP)/gmp" \
+	LDFLAGS="$(LDFLAGS) -L$(STAGEDIR)/usr/lib -L$(TOP)/gmp/.libs" \
+	$(CONFIGURE) \
+	--prefix="$(STAGEDIR)/usr" \
+	--disable-shared \
+	--enable-static \
+	--enable-mini-gmp \
+	--disable-documentation
+	@touch nettle/stamp-h1
+
+nettle: nettle/stamp-h1
+	@$(SEP)
+	@$(MAKE) -C nettle $(PARALLEL_BUILD)
+	@$(MAKE) -C nettle install
+
+nettle-clean:
+	-@$(MAKE) -C nettle clean
+	@rm -f nettle/stamp-h1
+	@rm -rf nettle/include nettle/lib
+
+### ncurses-6.0
+
+ncurses-6.0/Makefile: ncurses-6.0-unpack
+	cd ncurses-6.0 && \
+	PKG_CONFIG_PATH="/usr/lib/pkgconfig" \
+	CFLAGS="$(CFLAGS) $(EXTRACFLAGS) -Os -I$(STAGEDIR)/usr/include" \
+	CXXFLAGS="$(CXXFLAGS) $(EXTRACFLAGS) -Os -I$(STAGEDIR)/usr/include" \
+	CPPFLAGS="$(CPPFLAGS) $(EXTRACFLAGS) -Os -I$(STAGEDIR)/usr/include" \
+	LDFLAGS="$(LDFLAGS) -L$(STAGEDIR)/usr/lib" \
+	$(CONFIGURE) \
+	$(if $(RTCONFIG_HND_ROUTER),CPPFLAGS="-P",) \
+	--prefix=/usr \
+	--enable-echo --enable-const --disable-overwrite --disable-rpath --without-ada \
+	$(if $(RTCONFIG_BCMARM),--enable-widec,) \
+	--without-debug --without-manpages --without-profile --without-tests \
+	--disable-home-terminfo --with-normal --with-shared --with-build-cppflags=-D_GNU_SOURCE \
+	--enable-pc-files --with-pkg-config="/usr/lib/pkgconfig" \
+	--enable-termcap --with-fallbacks="xterm,vt100,vt200,linux,ansi,xterm-256color" \
+	--with-default-terminfo-dir=/usr/share/terminfo --with-terminfo-dirs=/usr/share/terminfo \
+	--with-install-prefix="$(STAGEDIR)" --with-pkg-config-libdir="/usr/lib/pkgconfig"
+
+ncurses-6.0: ncurses-6.0-unpack ncurses-6.0/Makefile
+	@$(SEP)
+#	cd ncurses-6.0 && $(MAKE) -C ncurses && $(MAKE) -C misc pc-files && $(MAKE) install DESTDIR="$(STAGEDIR)"
+	cd ncurses-6.0 && \
+	$(MAKE) DESTDIR="$(STAGEDIR)" && \
+	$(MAKE) install DESTDIR="$(STAGEDIR)"
+
+ncurses-6.0-clean:
+	-@$(MAKE) -C ncurses-6.0 distclean
+	@rm -f ncurses-6.0/Makefile
+
+ncurses-6.0-install:
+ifeq ($(RTCONFIG_BCMARM),y)
+	install -D ncurses-6.0/lib/libncursesw.so.6.0 $(INSTALLDIR)/ncurses-6.0/usr/lib/libncursesw.so.6.0
+else
+	install -D ncurses-6.0/lib/libncurses.so.6.0 $(INSTALLDIR)/ncurses-6.0/usr/lib/libncurses.so.6.0
+endif
+
+	$(STRIP) $(INSTALLDIR)/ncurses-6.0/usr/lib/*.so.*
+
+ifeq ($(RTCONFIG_BCMARM),y)
+	cd $(INSTALLDIR)/ncurses-6.0/usr/lib && ln -sf libncursesw.so.6.0 libncursesw.so.6
+else
+	cd $(INSTALLDIR)/ncurses-6.0/usr/lib && ln -sf libncurses.so.6.0 libncurses.so.6
+endif
+
+### strace
+
+.PHONY: strace
+strace: strace/Makefile
+	$(MAKE) -C $@
+
+strace/Makefile: strace-unpack strace/configure
+	$(MAKE) strace-configure
+
+strace/configure:
+	( cd strace && ./bootstrap )
+
+strace-configure:
+	( cd strace && $(CONFIGURE) --bindir=/sbin --disable-silent-rules )
+
+strace-install:
+	@install -D strace/strace $(INSTALLDIR)/strace/sbin/strace
+	@$(STRIP) $(INSTALLDIR)/strace/sbin/strace
+
+strace-clean:
+	[ ! -f strace/Makefile ] || $(MAKE) -C strace distclean
+	@rm -f strace/Makefile
+
+
+###############################################################################
+### package download and unpacking
+
+%-unpack:
+	@( \
+	PACKAGE_DIR="$*"; \
+	if [ ! -d "$$PACKAGE_DIR" ]; then \
+		PACKAGE_NAME="$$PACKAGE_DIR"; \
+		VERSION=""; \
+		SOURCE_VERSION=""; \
+		if [ "$$PACKAGE_DIR" = "nettle" ] || [ "$$PACKAGE_DIR" = "nettle-aarch64" ]; then \
+			URL="https://ftp.gnu.org/gnu/nettle/nettle-3.4.tar.gz"; \
+			URL2="https://git.lysator.liu.se/nettle/nettle.git"; \
+			VERSION="3.4+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="nettle"; \
+		elif [ "$$PACKAGE_DIR" = "curl" ] || [ "$$PACKAGE_DIR" = "curl-7.21.7" ] || \
+			[ "$$PACKAGE_DIR" = "curl-aarch64" ]; then \
+			if [ "$$PACKAGE_DIR" = "curl-7.21.7" ]; then \
+				PACKAGE_DIR="curl"; \
+			fi; \
+			URL="https://github.com/curl/curl/releases/download/curl-7_60_0/curl-7.60.0.tar.xz"; \
+			URL2="https://github.com/curl/curl.git"; \
+			VERSION="7.60.0+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="curl"; \
+		elif [ "$$PACKAGE_DIR" = "wget" ]; then \
+			URL="https://ftp.gnu.org/gnu/wget/wget-1.19.5.tar.lz"; \
+			URL2="https://gitlab.com/gnuwget/wget.git"; \
+			VERSION="1.19.5+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="wget"; \
+		elif [ "$$PACKAGE_DIR" = "jpeg" ] || [ "$$PACKAGE_DIR" = "jpeg-aarch64" ]; then \
+			URL="http://www.ijg.org/files/jpegsrc.v9a.tar.gz"; \
+			PACKAGE_NAME="jpeg"; \
+		elif [ "$$PACKAGE_DIR" = "zlib" ] || [ "$$PACKAGE_DIR" = "zlib-aarch64" ]; then \
+			URL="https://zlib.net/zlib-1.2.11.tar.xz"; \
+			URL2="https://github.com/madler/zlib.git"; \
+			VERSION="1.2.11+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="zlib"; \
+		elif [ "$$PACKAGE_DIR" = "lzo" ] || [ "$$PACKAGE_DIR" = "lzo-aarch64" ]; then \
+			URL="http://www.oberhumer.com/opensource/lzo/download/lzo-2.10.tar.gz"; \
+			PACKAGE_NAME="lzo"; \
+		elif [ "$$PACKAGE_DIR" = "json-c" ] || [ "$$PACKAGE_DIR" = "json-c-aarch64" ]; then \
+			URL="http://http.debian.net/debian/pool/main/j/json-c/json-c_0.12.1.orig.tar.gz"; \
+			PACKAGE_NAME="json-c"; \
+		elif [ "$$PACKAGE_DIR" = "ncurses-6.0" ] || [ "$$PACKAGE_DIR" = "ncurses-aarch64" ]; then \
+			URL="https://ftp.gnu.org/gnu/ncurses/ncurses-6.0.tar.gz"; \
+			PACKAGE_NAME="ncurses"; \
+		elif [ "$$PACKAGE_DIR" = "xzutils" ]; then \
+			URL="https://tukaani.org/xz/xz-5.2.4.tar.xz"; \
+			URL2="https://git.tukaani.org/xz.git"; \
+			VERSION="5.2.4+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="xzutils"; \
+		elif [ "$$PACKAGE_DIR" = "zstd" ]; then \
+			URL="https://github.com/facebook/zstd/archive/v1.3.4.tar.gz"; \
+			URL2="https://github.com/facebook/zstd.git"; \
+			VERSION="1.3.4+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="zstd"; \
+		elif [ "$$PACKAGE_DIR" = "tor" ]; then \
+			URL="https://www.torproject.org/dist/tor-0.3.3.7.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "findutils" ]; then \
+			URL="https://ftp.gnu.org/pub/gnu/findutils/findutils-4.6.0.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "whois" ]; then \
+			URL="http://ftp.debian.org/debian/pool/main/w/whois/whois_5.3.1.tar.xz"; \
+		elif [ "$$PACKAGE_DIR" = "libsodium" ]; then \
+			URL="https://download.libsodium.org/libsodium/releases/libsodium-1.0.16.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "dnscrypt" ]; then \
+			URL="http://http.debian.net/debian/pool/main/d/dnscrypt-proxy/dnscrypt-proxy_1.9.5.orig.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "haveged" ]; then \
+			URL="http://www.issihosts.com/haveged/haveged-1.9.1.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "wipe" ]; then \
+			URL="https://downloads.sourceforge.net/project/wipe/wipe/2.3.1/wipe-2.3.1.tar.bz2"; \
+		elif [ "$$PACKAGE_DIR" = "gsl" ]; then \
+			URL="https://ftp.igh.cnrs.fr/pub/gnu/gsl/gsl-2.5.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "dieharder" ]; then \
+			URL="http://www.phy.duke.edu/~rgb/General/dieharder/dieharder-3.31.1.tgz"; \
+		elif [ "$$PACKAGE_DIR" = "popt" ]; then \
+			URL="http://rpm5.org/files/popt/popt-1.16.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "libgpg-error" ]; then \
+			URL="https://gnupg.org/ftp/gcrypt/libgpg-error/libgpg-error-1.31.tar.bz2"; \
+			URL2="https://dev.gnupg.org/source/libgpg-error.git"; \
+			VERSION="1.31+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="libgpg-error"; \
+		elif [ "$$PACKAGE_DIR" = "util-linux" ]; then \
+			URL="https://www.kernel.org/pub/linux/utils/util-linux/v2.32/util-linux-2.32.tar.xz"; \
+		elif [ "$$PACKAGE_DIR" = "libaio" ]; then \
+			URL="http://http.debian.net/debian/pool/main/liba/libaio/libaio_0.3.111.orig.tar.gz"; \
+			URL2="https://pagure.io/libaio.git"; \
+			VERSION="0.3.111+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="libaio"; \
+		elif [ "$$PACKAGE_DIR" = "lvm2" ]; then \
+			URL="https://mirrors.kernel.org/sourceware/lvm2/releases/LVM2.2.02.178.tgz"; \
+			URL2="git://sourceware.org/git/lvm2.git"; \
+			VERSION="2.02.178+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="lvm2"; \
+		elif [ "$$PACKAGE_DIR" = "libgcrypt" ]; then \
+			URL="https://gnupg.org/ftp/gcrypt/libgcrypt/libgcrypt-1.8.3.tar.bz2"; \
+			URL2="https://dev.gnupg.org/source/libgcrypt.git"; \
+			VERSION="1.8.3+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="libgcrypt"; \
+		elif [ "$$PACKAGE_DIR" = "cryptsetup-gcrypt" ] || \
+			[ "$$PACKAGE_DIR" = "cryptsetup-openssl" ] || \
+			[ "$$PACKAGE_DIR" = "cryptsetup-nettle" ] || \
+			[ "$$PACKAGE_DIR" = "cryptsetup-kernel" ]; then \
+			URL="https://www.kernel.org/pub/linux/utils/cryptsetup/v2.0/cryptsetup-2.0.3.tar.xz"; \
+			URL2="https://gitlab.com/cryptsetup/cryptsetup.git"; \
+			VERSION="2.0.3+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="cryptsetup"; \
+		elif [ "$$PACKAGE_DIR" = "pps-tools" ]; then \
+			URL="https://github.com/redlab-i/pps-tools/archive/v1.0.1.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "setserial" ]; then \
+			URL="https://downloads.sourceforge.net/project/setserial/setserial/2.17/setserial-2.17.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "ntp" ]; then \
+			URL="https://www.eecis.udel.edu/~ntp/ntp_spool/ntp4/ntp-4.2/ntp-4.2.8p11.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "argp-standalone" ]; then \
+			URL="https://www.lysator.liu.se/~nisse/misc/argp-standalone-1.3.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "rng-tools" ]; then \
+			URL="https://downloads.sourceforge.net/project/gkernel/rng-tools/5/rng-tools-5.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "libcap" ]; then \
+			URL="https://www.kernel.org/pub/linux/libs/security/linux-privs/libcap2/libcap-2.25.tar.xz"; \
+		elif [ "$$PACKAGE_DIR" = "rtl-sdr" ]; then \
+			URL="git://git.osmocom.org/rtl-sdr.git"; \
+			VERSION="0.5.3+git"; \
+			SOURCE_VERSION="b04c2f9f035c5aede43d731e5d58e4725d2f8bb4"; \
+			PACKAGE_NAME="rtl-sdr"; \
+		elif [ "$$PACKAGE_DIR" = "rtl-entropy" ]; then \
+			URL="git://github.com/pwarren/rtl-entropy.git"; \
+			VERSION="0.1.2+git"; \
+			SOURCE_VERSION="142df23630ea6216c17e00dada85d1cd245bc22f"; \
+			PACKAGE_NAME="rtl-entropy"; \
+		elif [ "$$PACKAGE_DIR" = "transmission-openssl" ] || \
+			[ "$$PACKAGE_DIR" = "transmission-mbedtls" ]; then \
+			URL="git://github.com/transmission/transmission.git"; \
+			VERSION="2.94+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="transmission"; \
+		elif [ "$$PACKAGE_DIR" = "mbedtls" ]; then \
+			URL="https://tls.mbed.org/download/mbedtls-2.11.0-gpl.tgz"; \
+			URL2="https://github.com/ARMmbed/mbedtls.git"; \
+			VERSION="2.11.0+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="mbedtls"; \
+		elif [ "$$PACKAGE_DIR" = "apcupsd" ]; then \
+			URL="https://downloads.sourceforge.net/project/apcupsd/apcupsd - Stable/3.14.14/apcupsd-3.14.14.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "libgd" ]; then \
+			URL="https://github.com/libgd/libgd/releases/download/gd-2.2.5/libgd-2.2.5.tar.xz"; \
+			URL2="https://github.com/libgd/libgd.git"; \
+			VERSION="2.2.5+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="libgd"; \
+		elif [ "$$PACKAGE_DIR" = "libpng" ]; then \
+			URL="https://sourceforge.net/projects/libpng/files/libpng16/1.6.34/libpng-1.6.34.tar.xz"; \
+		elif [ "$$PACKAGE_DIR" = "libtiff" ]; then \
+			URL="http://download.osgeo.org/libtiff/tiff-4.0.8.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "freetype" ]; then \
+			URL="https://sourceforge.net/projects/freetype/files/freetype2/2.8.1/freetype-2.8.1.tar.bz2"; \
+		elif [ "$$PACKAGE_DIR" = "bzip2" ]; then \
+			URL="http://www.bzip.org/1.0.6/bzip2-1.0.6.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "powstatd" ]; then \
+			URL="http://deb.debian.org/debian/pool/main/p/powstatd/powstatd_1.5.1.orig.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "liblz4" ]; then \
+			URL="https://github.com/lz4/lz4/archive/v1.8.2.tar.gz"; \
+			URL2="https://github.com/lz4/lz4.git"; \
+			VERSION="1.8.2+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="lz4"; \
+		elif [ "$$PACKAGE_DIR" = "strace" ] || [ "$$PACKAGE_DIR" = "strace-aarch64" ]; then \
+			URL="https://strace.io/files/4.21/strace-4.21.tar.xz"; \
+			URL2="https://github.com/strace/strace.git"; \
+			VERSION="4.21+git"; \
+			SOURCE_VERSION=""; \
+			PACKAGE_NAME="strace"; \
+		elif [ "$$PACKAGE_DIR" = "libargon2" ]; then \
+			URL2="https://github.com/P-H-C/phc-winner-argon2/archive/20171227.tar.gz"; \
+			URL="https://github.com/P-H-C/phc-winner-argon2.git"; \
+			VERSION="20171227+git"; \
+			SOURCE_VERSION="670229c849b9fe882583688b74eb7dfdc846f9f6"; \
+			PACKAGE_NAME="argon2"; \
+		elif [ "$$PACKAGE_DIR" = "libnss" ]; then \
+			URL2="https://ftp.mozilla.org/pub/security/nss/releases/NSS_3_35_RTM/src/nss-3.35.tar.gz"; \
+			URL="https://github.com/nss-dev/nss.git"; \
+			VERSION="3.35+git"; \
+			SOURCE_VERSION="5806b687b142dad80c01ac17996241ba326623dc"; \
+			PACKAGE_NAME="nss"; \
+		elif [ "$$PACKAGE_DIR" = "xtables-addons" ]; then \
+			if [ -n "$(RTCONFIG_HND_ROUTER)" ]; then \
+				URL="https://ufpr.dl.sourceforge.net/project/xtables-addons/Xtables-addons/xtables-addons-2.14.tar.xz"; \
+			else \
+				URL="https://ufpr.dl.sourceforge.net/project/xtables-addons/Xtables-addons/xtables-addons-1.47.1.tar.xz"; \
+			fi; \
+			PACKAGE_NAME="xtables-addons"; \
+		else \
+			URL="/$${PACKAGE_DIR}-MISSING-PACKAGE"; \
+			exit 1; \
+		fi; \
+		DL_DIR="$(BLACKFUEL_DIR)/downloads/$$PACKAGE_NAME"; \
+		PATCH_DIR="$(BLACKFUEL_DIR)/packages/$$PACKAGE_NAME/patches"; \
+		DL_FILE="$${URL##*/}"; \
+		DL_PATH="$$DL_DIR/$$DL_FILE"; \
+		if [ "$${DL_FILE%.git}" != "$$DL_FILE" ]; then \
+			[ -z "$$VERSION" ] && DL_NAME="$$PACKAGE_NAME" || DL_NAME="$$PACKAGE_NAME-$$VERSION"; \
+			if [ -z "$$SOURCE_VERSION" ]; then \
+				SOURCE_VERSION=`git ls-remote $${URL} | grep HEAD | cut -f1`; \
+				while [ -z "$$SOURCE_VERSION" ]; do \
+					sleep 10; SOURCE_VERSION=`git ls-remote $${URL} | grep HEAD | cut -f1`; \
+				done; \
+			fi; \
+			DL_FILE="$${DL_NAME}-$${SOURCE_VERSION}.tar.xz"; \
+			DL_PATH="$$DL_DIR/$$DL_FILE"; \
+			if [ ! -f "$$DL_PATH" ]; then \
+				git clone $$URL $$DL_DIR/temp/$$DL_NAME; \
+				while [ $$? -ne 0 ]; do \
+					sleep 10; git clone $$URL $$DL_DIR/temp/$$DL_NAME; \
+				done; \
+				ORIGDIR="$$PWD"; \
+				cd "$$DL_DIR/temp/$$DL_NAME"; \
+				git checkout $$SOURCE_VERSION; \
+				while [ $$? -ne 0 ]; do \
+					sleep 10; git checkout $$SOURCE_VERSION; \
+				done; \
+				git submodule update --init --recursive; \
+				while [ $$? -ne 0 ]; do \
+					sleep 10; git submodule update --init --recursive; \
+				done; \
+				TAR_TIMESTAMP="`git log -1 --format='@%ct'`"; \
+				rm -rf .git; \
+				cd "$$ORIGDIR"; \
+				chmod -R g-w,o-w "$$DL_DIR/temp/$$DL_NAME"; \
+				tar --numeric-owner --owner=0 --group=0 --sort=name --mtime="$$TAR_TIMESTAMP" -cv -C "$$DL_DIR/temp" "$$DL_NAME" | xz -zc -7e > "$$DL_PATH"; \
+			fi; \
+		elif [ ! -f "$$DL_PATH" ]; then \
+			wget --tries=9 --retry-connrefused --waitretry=5 --directory-prefix="$$DL_DIR" "$$URL"; \
+			while [ $$? -ne 0 ]; do \
+				sleep 10; \
+				[ ! -f "$$DL_PATH" ] || break; \
+				wget --tries=9 --retry-connrefused --waitretry=5 --directory-prefix="$$DL_DIR" "$$URL"; \
+			done; \
+			rm -rf "$$PACKAGE_DIR" || true; \
+		fi; \
+		rm -rf "$$DL_DIR/temp"; \
+		mkdir -p "$$DL_DIR/temp"; \
+		if [ "$${DL_FILE%.tar.gz*}" != "$$DL_FILE" ] || [ "$${DL_FILE%.tgz*}" != "$$DL_FILE" ]; then \
+			tar xzvf "$$DL_PATH" -C "$$DL_DIR/temp"; \
+		elif [ "$${DL_FILE%.tar.bz2*}" != "$$DL_FILE" ] || [ "$${DL_FILE%.tbz*}" != "$$DL_FILE" ]; then \
+			tar xjvf "$$DL_PATH" -C "$$DL_DIR/temp"; \
+		elif [ "$${DL_FILE%.tar.xz*}" != "$$DL_FILE" ] || [ "$${DL_FILE%.txz*}" != "$$DL_FILE" ]; then \
+			tar xJvf "$$DL_PATH" -C "$$DL_DIR/temp"; \
+		elif [ "$${DL_FILE%.tar.lz*}" != "$$DL_FILE" ] || [ "$${DL_FILE%.tlz*}" != "$$DL_FILE" ]; then \
+			tar xlvf "$$DL_PATH" -C "$$DL_DIR/temp"; \
+		fi; \
+		mv -f "$$DL_DIR/temp/"* "$$PACKAGE_DIR"; \
+		rm -rf "$$DL_DIR/temp"; \
+		for PATCH_FILE in $$PATCH_DIR/*.patch; do \
+			if [ -f "$$PATCH_FILE" ]; then \
+				echo "Applying patch: $$PATCH_FILE"; \
+				patch --dry-run --silent -p1 -d "$$PACKAGE_DIR/" -i "$$PATCH_FILE" >/dev/null 2>&1 && \
+					patch -p1 -d "$$PACKAGE_DIR/" -i "$$PATCH_FILE" || \
+					  	echo "The patch was not applied."; \
+			else \
+				true; \
+			fi; \
+		done; \
+		sed -r -i 's/(\| arm-\*  \| armbe-\* \| armle-\* \| )/\| aarch64-\* \1/g' $$(find $$PACKAGE_DIR/ -name 'config.sub' -print0 | xargs -0 -I '{}' grep -FL 'aarch64-*' '{}') || true; \
+	else \
+		echo "$$PACKAGE_DIR was not unpacked because the directory exists."; \
+		true; \
+	fi; \
+	)
+
+#######################################################################################
+
+iproute2:
+	@$(SEP)
+	@$(MAKE) -C $@ KERNEL_INCLUDE=$(LINUX_INC_DIR)/include EXTRACFLAGS="$(EXTRACFLAGS) $(if $(RTCONFIG_IPV6),-DUSE_IPV6,-DNO_IPV6)" $(PARALLEL_BUILD)
+
+iproute2-install: iproute2
+	install -D iproute2/tc/tc $(INSTALLDIR)/iproute2/usr/sbin/tc
+	install -D iproute2/tc/tc $(INSTALLDIR)/iproute2/usr/sbin/realtc
+	$(STRIP) $(INSTALLDIR)/iproute2/usr/sbin/tc
+	$(STRIP) $(INSTALLDIR)/iproute2/usr/sbin/realtc
+	install -D iproute2/ip/ip $(INSTALLDIR)/iproute2/usr/sbin/ip
+	$(STRIP) $(INSTALLDIR)/iproute2/usr/sbin/ip
+
+iproute2-3.x: kernel_header iptables-1.4.x
+	@$(SEP)
+	@$(MAKE) -C $@ IPTABLES_DIR=$(TOP)/iptables-1.4.x KERNEL_INCLUDE=$(TOP)/kernel_header/include EXTRACFLAGS="$(EXTRACFLAGS) $(if $(RTCONFIG_IPV6),-DUSE_IPV6,-DNO_IPV6)" && $(MAKE) -C $@ stage
+
+iproute2-3.x-install: iproute2-3.x
+	install -D iproute2-3.x/tc/tc $(INSTALLDIR)/iproute2-3.x/usr/sbin/tc
+	install -D iproute2-3.x/tc/tc $(INSTALLDIR)/iproute2-3.x/usr/sbin/realtc
+	$(STRIP) $(INSTALLDIR)/iproute2-3.x/usr/sbin/tc
+	$(STRIP) $(INSTALLDIR)/iproute2-3.x/usr/sbin/realtc
+	install -D iproute2-3.x/ip/ip $(INSTALLDIR)/iproute2-3.x/usr/sbin/ip
+	$(STRIP) $(INSTALLDIR)/iproute2-3.x/usr/sbin/ip
+	@if [ -e iproute2-3.x/tc/m_xt.so ] ; then \
+		install -D iproute2-3.x/tc/m_xt.so $(INSTALLDIR)/iproute2-3.x/usr/lib/tc/m_xt.so ; \
+		ln -sf m_xt.so $(INSTALLDIR)/iproute2-3.x/usr/lib/tc/m_ipt.so ; \
+		$(STRIP) $(INSTALLDIR)/iproute2-3.x/usr/lib/tc/*.so ; \
+	fi
+
+iproute2-3.x-clean:
+	-@$(MAKE) -C iproute2-3.x clean
+	-rm -f iproute2-3.x/Config
+
+iproute2-3.15.0: kernel_header iptables-1.4.21
+	@$(SEP)
+	@$(MAKE) -C $@ IPTABLES_DIR=$(TOP)/iptables-1.4.21 KERNEL_INCLUDE=$(TOP)/kernel_header/include EXTRACFLAGS="$(EXTRACFLAGS) $(if $(RTCONFIG_IPV6),-DUSE_IPV6,-DNO_IPV6)"
+
+iproute2-3.15.0-install: iproute2-3.15.0
+	install -D iproute2-3.15.0/tc/tc $(INSTALLDIR)/iproute2-3.15.0/usr/sbin/tc
+	$(STRIP) $(INSTALLDIR)/iproute2-3.15.0/usr/sbin/tc
+	install -D iproute2-3.15.0/ip/ip $(INSTALLDIR)/iproute2-3.15.0/usr/sbin/ip
+	$(STRIP) $(INSTALLDIR)/iproute2-3.15.0/usr/sbin/ip
+	@if [ -e iproute2-3.15.0/tc/m_xt.so ] ; then \
+		install -D iproute2-3.15.0/tc/m_xt.so $(INSTALLDIR)/iproute2-3.15.0/usr/lib/tc/m_xt.so ; \
+		ln -sf m_xt.so $(INSTALLDIR)/iproute2-3.15.0/usr/lib/tc/m_ipt.so ; \
+		$(STRIP) $(INSTALLDIR)/iproute2-3.15.0/usr/lib/tc/*.so ; \
+	fi
+
+iproute2-3.15.0-clean:
+	-@$(MAKE) -C iproute2-3.15.0 clean
+	-rm -f iproute2-3.15.0/Config
+
+iproute2-4.3:
+	touch iproute2-4.3/iproute2-4.3.0/configure
+	$(MAKE) -C iproute2-4.3
+
+iproute2-4.3-install:
+	install -D iproute2-4.3/iproute2-4.3.0/tc/tc $(INSTALLDIR)/iproute2-4.3/usr/sbin/tc
+	$(STRIP) $(INSTALLDIR)/iproute2-4.3/usr/sbin/tc
+	install -D iproute2-4.3/iproute2-4.3.0/ip/ip $(INSTALLDIR)/iproute2-4.3/usr/sbin/ip
+	$(STRIP) $(INSTALLDIR)/iproute2-4.3/usr/sbin/ip
+
+iproute2-4.3-clean:
+	-@$(MAKE) -C iproute2-4.3 clean
+	-rm -f iproute2-4.3/iproute2-4.3.0/Config
+
+ntpclient: nvram$(BCMEX)$(EX7) shared
+
+ntpclient-install:
+	$(MAKE) -C ntpclient INSTALLDIR=$(INSTALLDIR)/ntpclient install
+
+rstats: nvram$(BCMEX)$(EX7) shared
+
+rstats-install:
+	$(MAKE) -C rstats INSTALLDIR=$(INSTALLDIR)/rstats install
+
+dropbear/config.h.in: $(if $(RTCONFIG_PROTECTION_SERVER),protect_srv-stage,)
+
+dropbear/config.h: dropbear/config.h.in
+	cd dropbear && \
+		$(BLACKFUEL_OPTIMIZED_TOOLCHAIN) \
+		CFLAGS="-O3 -Wall $(BLACKFUEL_OPTIMIZED_COPTS) -DARGTYPE=3 -ffunction-sections -fdata-sections -I$(STAGEDIR)/usr/include $(if $(RTCONFIG_PROTECTION_SERVER),-DSECURITY_NOTIFY,)" \
+		CPPFLAGS="-O3 -Wall $(BLACKFUEL_OPTIMIZED_COPTS) -DARGTYPE=3 -ffunction-sections -fdata-sections -I$(STAGEDIR)/usr/include $(if $(RTCONFIG_PROTECTION_SERVER),-DSECURITY_NOTIFY,)" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+		LIBS="$(if $(RTCONFIG_PROTECTION_SERVER),-lptcsrv)" \
+		$(BLACKFUEL_OPTIMIZED_CONFIGURE) --disable-zlib --disable-pam \
+		--enable-openpty --enable-syslog --enable-shadow --enable-bundled-libtom \
+		--disable-lastlog \
+		--disable-utmp --disable-utmpx \
+		--disable-wtmp --disable-wtmpx \
+		--disable-loginfunc \
+		--disable-pututline --disable-pututxline
+
+dropbear: dropbear/config.h
+	@$(SEP)
+	CFLAGS="-O3 -Wall $(BLACKFUEL_OPTIMIZED_COPTS) -DARGTYPE=3 -ffunction-sections -fdata-sections -I$(STAGEDIR)/usr/include $(if $(RTCONFIG_PROTECTION_SERVER),-DSECURITY_NOTIFY,)" \
+	CPPFLAGS="-O3 -Wall $(BLACKFUEL_OPTIMIZED_COPTS) -DARGTYPE=3 -ffunction-sections -fdata-sections -I$(STAGEDIR)/usr/include $(if $(RTCONFIG_PROTECTION_SERVER),-DSECURITY_NOTIFY,)" \
+	LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/$(BLACKFUEL_OPTIMIZED_LIB)" \
+	LIBS="$(if $(RTCONFIG_PROTECTION_SERVER),-lptcsrv)" \
+	$(MAKE) -C $@ PROGRAMS="dropbear dbclient dropbearkey scp" MULTI=1 $(PARALLEL_BUILD)
+
+dropbear-install:
+	install -D dropbear/dropbearmulti $(INSTALLDIR)/dropbear/usr/bin/dropbearmulti
+	$(BLACKFUEL_OPTIMIZED_STRIP) $(INSTALLDIR)/dropbear/usr/bin/dropbearmulti
+	cd $(INSTALLDIR)/dropbear/usr/bin && \
+	ln -sf dropbearmulti dropbearkey && \
+	ln -sf dropbearmulti dbclient && \
+	ln -sf dropbearmulti ssh && \
+	ln -sf dropbearmulti scp
+	install -d $(INSTALLDIR)/dropbear/usr/sbin
+	cd $(INSTALLDIR)/dropbear/usr/sbin && \
+	ln -sf ../bin/dropbearmulti dropbear
+
+dropbear-clean:
+	-@$(MAKE) -C dropbear clean
+	@rm -f dropbear/config.h
+
+wtfast-configure:
+	@true
+
+wtfast-install:
+	install -D wtfast/wtfslhd/wtfslhd$(BCMEX)$(EX7)/wtfslhd $(INSTALLDIR)/wtfast/usr/sbin/wtfslhd
+
+# Media libraries
+
+sqlite/stamp-h1:
+	cd sqlite && \
+	CC=$(CC) CFLAGS="-O2 $(EXTRACFLAGS) -ffunction-sections -fdata-sections -fPIC" \
+		LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -lpthread -ldl" \
+		$(CONFIGURE) --prefix=/usr --enable-shared --enable-static \
+		--disable-readline --disable-dynamic-extensions --enable-threadsafe \
+		--disable-dependency-tracking
+	touch $@
+
+sqlite: sqlite/stamp-h1
+	@$(MAKE) -C sqlite all
+
+sqlite-clean:
+	-@$(MAKE) -C sqlite clean
+	@rm -f sqlite/stamp-h1
+
+sqlite-install: sqlite
+	@$(SEP)
+	install -D sqlite/.libs/libsqlite3.so.0 $(INSTALLDIR)/sqlite/usr/lib/libsqlite3.so.0
+	$(STRIP) $(INSTALLDIR)/sqlite/usr/lib/libsqlite3.so.0
+
+# sqlite encrpted version
+sqlCipher/stamp-h1:
+	cd sqlCipher && \
+        CC=$(CC) CFLAGS="-Os $(EXTRACFLAGS) -DSQLITE_HAS_CODEC -ffunction-sections -fdata-sections -I$(SRCBASE)/router/openssl/include  -fPIC" \
+                LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections -lpthread -ldl -L$(SRCBASE)/router/openssl -lcrypto" \
+                $(CONFIGURE) --prefix=/usr --enable-shared --enable-static \
+                --disable-readline --disable-dynamic-extensions --enable-threadsafe \
+                --disable-dependency-tracking --enable-tempstore=yes --disable-tcl
+	touch $@
+
+sqlCipher: sqlCipher/stamp-h1
+	@$(MAKE) -C sqlCipher all
+
+sqlCipher-clean:
+	-@$(MAKE) -C sqlCipher clean
+	@rm -f sqlCipher/stamp-h1
+
+sqlCipher-install: sqlCipher
+	install -D sqlCipher/.libs/libsqlcipher.so.0.8.6 $(INSTALLDIR)/sqlCipher/usr/lib/libsqlcipher.so.0
+	$(STRIP) $(INSTALLDIR)/sqlCipher/usr/lib/libsqlcipher.so.0
+	@$(SEP)
+
+# commented out for mt-daapd-svn-1696
+ifneq ($(MEDIA_SERVER_STATIC),y)
+	install -D sqlite/.libs/libsqlite3.so.0 $(INSTALLDIR)/sqlite/usr/lib/libsqlite3.so.0
+	$(STRIP) $(INSTALLDIR)/sqlite/usr/lib/libsqlite3.so.0
+endif
+ifeq ($(RTCONFIG_FREERADIUS),y)
+	install -D sqlite/.libs/sqlite3 $(INSTALLDIR)/sqlite/usr/sbin/sqlite3
+	$(STRIP) $(INSTALLDIR)/sqlite/usr/sbin/sqlite3
+endif
+
+FFMPEG_FILTER_CONFIG= $(foreach c, $(2), --$(1)="$(c)")
+
+FFMPEG_DECODERS:=aac ac3 atrac3 h264 jpegls mp3 mpeg1video mpeg2video mpeg4 mpeg4aac mpegvideo png wmav1 wmav2
+FFMPEG_CONFIGURE_DECODERS:=$(call FFMPEG_FILTER_CONFIG,enable-decoder,$(FFMPEG_DECODERS))
+
+FFMPEG_PARSERS:=aac ac3 h264 mpeg4video mpegaudio mpegvideo
+FFMPEG_CONFIGURE_PARSERS:=$(call FFMPEG_FILTER_CONFIG,enable-parser,$(FFMPEG_PARSERS))
+
+FFMPEG_PROTOCOLS:=file
+FFMPEG_CONFIGURE_PROTOCOLS:=$(call FFMPEG_FILTER_CONFIG,enable-protocol,$(FFMPEG_PROTOCOLS))
+
+FFMPEG_DISABLED_DEMUXERS:=amr apc ape ass bethsoftvid bfi c93 daud dnxhd dsicin dxa ffm gsm gxf idcin iff image2 image2pipe ingenient ipmovie lmlm4 mm mmf msnwc_tcp mtv mxf nsv nut oma pva rawvideo rl2 roq rpl segafilm shorten siff smacker sol str thp tiertexseq tta txd vmd voc wc3 wsaud wsvqa xa yuv4mpegpipe
+FFMPEG_CONFIGURE_DEMUXERS:=$(call FFMPEG_FILTER_CONFIG,disable-demuxer,$(FFMPEG_DISABLED_DEMUXERS))
+
+ffmpeg/stamp-h1: zlib
 	cd ffmpeg && symver_asm_label=no symver_gnu_asm=no symver=no CC=$(CC) LDFLAGS="-ldl"\
 		./configure --enable-cross-compile --arch=$(ARCH) --target_os=linux \
 		--cross-prefix=$(CROSS_COMPILE) --enable-shared --enable-gpl --disable-doc \
@@ -4228,25 +7663,6 @@
 	$(STRIP) $(INSTALLDIR)/flac/usr/lib/libFLAC.so.8
 endif
 
-jpeg/stamp-h1:
-	cd jpeg && \
-	CFLAGS="-Os $(EXTRACFLAGS) -fPIC" CC=$(CC) AR2="touch" $(CONFIGURE) --enable-maxmem=1 --enable-shared --enable-static --prefix=''
-	touch $@
-
-jpeg: jpeg/stamp-h1
-	@$(MAKE) -C jpeg LIBTOOL="" O=o A=a CC=$(CC) AR2="touch" libjpeg.a libjpeg.so $(PARALLEL_BUILD)
-
-jpeg-clean:
-	-@$(MAKE) -C jpeg clean
-	@rm -f jpeg/stamp-h1
-
-jpeg-install:
-	@$(SEP)
-ifneq ($(MEDIA_SERVER_STATIC),y)
-	install -D jpeg/libjpeg.so $(INSTALLDIR)/jpeg/usr/lib/libjpeg.so
-	$(STRIP) $(INSTALLDIR)/jpeg/usr/lib/libjpeg.so
-endif
-
 libexif/stamp-h1:
 	cd libexif && CFLAGS="-Os -Wall $(EXTRACFLAGS) -fPIC -ffunction-sections -fdata-sections" \
 	LDFLAGS="-fPIC -ffunction-sections -fdata-sections -Wl,--gc-sections" \
@@ -4268,33 +7684,6 @@
 	$(STRIP) $(INSTALLDIR)/libexif/usr/lib/libexif.so.12
 endif
 
-zlib/stamp-h1:
-	cd zlib && \
-	CC=$(CC) AR="ar rc" RANLIB=$(RANLIB) LD=$(LD) CFLAGS="-Os -Wall $(EXTRACFLAGS) -fPIC" LDSHAREDLIBC="$(EXTRALDFLAGS)" \
-	./configure --shared --prefix=/usr --libdir=/usr/lib
-	touch $@
-
-zlib: zlib/stamp-h1
-	@$(MAKE) -C zlib CC=$(CC) AR="ar rc" RANLIB=$(RANLIB) LD=$(LD) all && $(MAKE) $@-stage
-
-zlib-clean:
-	-@$(MAKE) -C zlib clean
-	@rm -f zlib/stamp-h1
-
-zlib-install:
-	@$(SEP)
-# commented out for mt-daapd-svn-1696
-ifneq ($(MEDIA_SERVER_STATIC),y)
-	install -d $(INSTALLDIR)/zlib/usr/lib
-	install -D zlib/libz.so.1 $(INSTALLDIR)/zlib/usr/lib/
-	$(STRIP) $(INSTALLDIR)/zlib/usr/lib/libz.so.1
-endif
-ifeq ($(or $(RTCONFIG_USB_BECEEM),$(RTCONFIG_MEDIA_SERVER),$(RTCONFIG_CLOUDSYNC),$(RTCONFIG_PUSH_EMAIL)),y)
-	install -d $(INSTALLDIR)/zlib/usr/lib
-	install -D zlib/libz.so.1 $(INSTALLDIR)/zlib/usr/lib/
-	$(STRIP) $(INSTALLDIR)/zlib/usr/lib/libz.so.1
-endif
-
 libid3tag/stamp-h1: zlib
 	cd libid3tag && \
 	touch NEWS && touch AUTHORS && touch ChangeLog && autoreconf -i -f && \
@@ -4369,7 +7758,7 @@
 		-I$(TOP)/libvorbis/include -I$(TOP)/shared" \
 	LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections \
 		-L$(TOP)/zlib -fPIC -ffunction-sections -fdata-sections -Wl,--gc-sections \
-		-L$(TOP)/zlib -L$(TOP)/sqlite/.libs -L$(TOP)/jpeg -L$(TOP)/libvorbis/lib/.libs \
+		-L$(TOP)/zlib -L$(TOP)/sqlite/.libs -L$(TOP)/jpeg/.libs -L$(TOP)/libvorbis/lib/.libs \
 		-L$(TOP)/libogg/src/.libs -L$(TOP)/libexif/libexif/.libs -L$(TOP)/flac/src/libFLAC/.libs \
 		-L$(TOP)/ffmpeg/libavutil -L$(TOP)/ffmpeg/libavcodec -L$(TOP)/ffmpeg/libavformat \
 		-L$(TOP)/libid3tag/.libs" \
@@ -4816,26 +8205,6 @@
 ebtables-clean:
 	-@make -C ebtables clean
 
-lzo/stamp-h1:
-	cd lzo && \
-	CFLAGS="-O3 -Wall $(EXTRACFLAGS)" $(CONFIGURE) --enable-shared --enable-static \
-		--prefix=/usr \
-		--bindir=/usr/sbin \
-		--libdir=/usr/lib
-	touch $@
-
-lzo: lzo/stamp-h1
-	$(MAKE) -C lzo $(PARALLEL_BUILD) && $(MAKE) $@-stage
-
-lzo-clean:
-	-@$(MAKE) -C lzo clean
-	@rm -f lzo/stamp-h1
-
-lzo-install:
-	install -D lzo/src/.libs/liblzo2.so $(INSTALLDIR)/lzo/usr/lib/liblzo2.so.2
-	$(STRIP) $(INSTALLDIR)/lzo/usr/lib/liblzo2.so.2
-	cd $(INSTALLDIR)/lzo/usr/lib && ln -sf liblzo2.so.2 liblzo2.so
-
 openpam: openpam/Makefile
 	$(MAKE) -C $@ $(PARALLEL_BUILD) && $(MAKE) $@-stage
 
@@ -4934,27 +8303,6 @@
 	[ ! -f sdparm-1.02/Makefile ] || $(MAKE) -C sdparm-1.02 distclean
 	@rm -f sdparm-1.02/Makefile
 
-.PHONY: strace
-strace: strace/Makefile
-	$(MAKE) -C $@
-
-strace/Makefile: strace/configure
-	$(MAKE) strace-configure
-
-strace/configure:
-	( cd strace && autoreconf -i -f )
-
-strace-configure:
-	( cd strace && $(CONFIGURE) --bindir=/sbin )
-
-strace-install:
-	@install -D strace/strace $(INSTALLDIR)/strace/sbin/strace
-	@$(STRIP) $(INSTALLDIR)/strace/sbin/strace
-
-strace-clean:
-	[ ! -f strace/Makefile ] || $(MAKE) -C strace distclean
-	@rm -f strace/Makefile
-
 .PHONY: termcap
 termcap: termcap/Makefile
 	$(MAKE) -C $@
@@ -5043,6 +8391,12 @@
 	@touch $@
 
 lighttpd-1.4.39: shared nvram$(BCMEX)$(EX7) libpasswd libdisk samba-3.5.8 pcre-8.31 libxml2 sqlite libexif openssl curl-7.21.7 $(if $(RTCONFIG_PERMISSION_MANAGEMENT),PMS_DBapis) lighttpd-1.4.39/stamp-h1
+	@mkdir -p lighttpd-1.4.39/src/.libs
+ifeq ($(HND_ROUTER),y)
+	@cp lighttpd-1.4.39/prebuild_hnd/*.so lighttpd-1.4.39/src/.libs/
+else
+	@cp lighttpd-1.4.39/prebuild/*.so lighttpd-1.4.39/src/.libs/
+endif
 	$(MAKE) -C lighttpd-1.4.39 $(PARALLEL_BUILD)
 
 lighttpd-1.4.39-install:
@@ -5243,56 +8597,6 @@
 	-@$(MAKE) -C usbclient clean
 	rm -rf usbclient/stamp-h1
 
-##strongswan/IPSEC
-strongswan-5.2.1/stamp-h1:
-	cd strongswan-5.2.1 && autoreconf -i -f && \
-	$(if $(RTCONFIG_HND_ROUTER),$(CONFIGURE_64) CC=$(CROSS_COMPILE_64)gcc RANLIB=$(CROSS_COMPILE_64)ranlib, $(CONFIGURE) CC=$(CC)) \
-	--prefix=/usr/ --sysconfdir=/etc/ --localstatedir=/var/ \
-	--bindir=/usr/sbin --libdir=/usr/lib \
-	--libexecdir=/usr/lib --with-ipsecdir=/usr/lib/ipsec --with-user=admin \
-	--disable-gmp --enable-openssl --enable-agent --enable-eap-peap \
-	--enable-eap-md5 --enable-eap-mschapv2 --enable-eap-identity \
-	--with-strongswan-conf=/etc/strongswan.conf --enable-md4 --enable-acert \
-	--enable-cmd --enable-eap-tls --enable-libipsec \
-	CFLAGS="-O3 -I$(STAGEDIR)/usr/include -I$(TOP)/openssl/include $(if $(RTCONFIG_HND_ROUTER),-DHND_ROUTER,)" \
-	LDFLAGS="$(if $(RTCONFIG_HND_ROUTER), -L$(TOP)/strongswan-5.2.1, -L$(STAGEDIR)/usr/lib -L$(TOP)/openssl)" \
-	LIBS="-lssl -lcrypto -lpthread -ldl -lm"
-	touch $@
-
-strongswan-5.2.1: strongswan-5.2.1/stamp-h1
-	$(MAKE) $(PARALLEL_BUILD) -C strongswan-5.2.1
-
-strongswan-5.2.1-install: strongswan-5.2.1
-	@$(SEP)
-	@$(MAKE) -C strongswan-5.2.1 install DESTDIR=$(INSTALLDIR)/strongswan-5.2.1/ ; chmod 755 $(INSTALLDIR)/strongswan-5.2.1/usr/lib
-	@rm -rf $(INSTALLDIR)/strongswan-5.2.1/usr/etc
-	@rm -f $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/*.la
-	@rm -f $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/plugins/*.la
-ifeq ($(HND_ROUTER),y)
-	$(STRIP_64) $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/*.so
-	$(STRIP_64) $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/starter
-	$(STRIP_64) $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/stroke
-	$(STRIP_64) $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/scepclient
-	$(STRIP_64) $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/charon
-	$(STRIP_64) $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/plugins/*.so
-else
-	$(STRIP) $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/*.so
-	$(STRIP) $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/starter
-	$(STRIP) $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/stroke
-	$(STRIP) $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/scepclient
-	$(STRIP) $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/charon
-	$(STRIP) $(INSTALLDIR)/strongswan-5.2.1/usr/lib/ipsec/plugins/*.so
-endif
-
-	mv $(INSTALLDIR)/strongswan-5.2.1/etc $(INSTALLDIR)/strongswan-5.2.1/usr/
-
-strongswan-5.2.1-clean:
-	-@$(MAKE) -C strongswan-5.2.1 clean
-	@rm -f strongswan-5.2.1/stamp-h1
-	@rm -rf $(INSTALLDIR)/strongswan-5.2.1/
-	@rm -rf $(TARGETDIR)/usr/sbin/strongswan-5.2.1/*
-	@rm -rf $(TARGETDIR)/usr/lib/strongswan-5.2.1/*
-
 sw-hw-auth:
 	cd sw-hw-auth && \
 	CC=$(CC) AR=$(AR) RANLIB=$(RANLIB) LD=$(LD) CFLAGS="-Os -Wall $(EXTRACFLAGS)" \
@@ -5373,38 +8677,6 @@
 	-@$(MAKE) -C fb_wifi clean
 	rm -rf fb_wifi/stamp-h1
 
-#add by gauss
-#add install libcurl
-curl-7.21.7: curl-7.21.7/Makefile
-	@$(MAKE) -C $@ $(PARALLEL_BUILD) && $(MAKE) $@-stage && sed 's|/usr/lib|$(STAGEDIR)/usr/lib|g' -i $(STAGEDIR)/usr/lib/libcurl.la
-
-curl-7.21.7/Makefile: curl/configure
-	@cd curl && $(CONFIGURE) CC=$(CC) \
-		CFLAGS="-Os -Wall -ffunction-sections -fdata-sections" \
-		--prefix=/usr --bindir=/usr/sbin --libdir=/usr/lib \
-		--enable-http --with-ssl=$(TOP)/openssl/ssl \
-		$(if $(RTCONFIG_IPV6),--enable-ipv6) \
-		--disable-gopher --disable-dict --disable-telnet \
-		--disable-proxy --disable-manual --disable-libcurl-option \
-		CPPFLAGS='-I$(TOP)/openssl/include' \
-		LDFLAGS='$(LDFLAGS) -L$(TOP)/openssl' LIBS='-lcrypto -lssl -ldl' \
-		--with-ca-bundle=/etc/ssl/certs/ca-certificates.crt
-
-curl-7.21.7-install: curl-7.21.7
-	@$(SEP)
-	install -D curl-7.21.7/lib/.libs/libcurl.so.4.5.0 $(INSTALLDIR)/curl-7.21.7/usr/lib/libcurl.so.4.5.0
-	$(STRIP) $(INSTALLDIR)/curl-7.21.7/usr/lib/libcurl.so.4.5.0
-	cd $(INSTALLDIR)/curl-7.21.7/usr/lib && ln -sf libcurl.so.4.5.0 libcurl.so && ln -sf libcurl.so.4.5.0 libcurl.so.4
-#ifeq ($(RTCONFIG_SPEEDTEST),y)
-	# for speedtest
-	install -D curl-7.21.7/src/.libs/curl $(INSTALLDIR)/curl-7.21.7/usr/sbin/curl
-	$(STRIP) $(INSTALLDIR)/curl-7.21.7/usr/sbin/curl
-#endif
-
-curl-7.21.7-clean:
-	[ ! -f curl-7.21.7/Makefile ] || $(MAKE) -C curl-7.21.7 clean
-	@rm -f curl-7.21.7/Makefile
-
 #snmp
 net-snmp-5.7.2/stamp-h1:
 	cd $(TOP)/net-snmp-5.7.2 && $(CONFIGURE) --prefix=$(INSTALLDIR)/net-snmp-5.7.2/usr \
@@ -5818,7 +9090,7 @@
 	cd tftp && CC=$(CC) && $(MAKE)
 
 tftp-clean:
-	cd tftp && $(MAKE) clean
+	-@cd tftp && $(MAKE) clean
 
 tftp-install:
 	# TPTP server
@@ -6198,53 +9470,6 @@
 	-@[ ! -f GeoIP-1.6.2/Makefile ] || $(MAKE) -C GeoIP-1.6.2 distclean
 	@rm -f GeoIP-1.6.2/stamp-h1
 
-Transmission-configure:
-	( cd Transmission && ./autogen.sh && \
-		$(CONFIGURE) --prefix=/usr --bindir=/usr/sbin --libdir=/usr/lib \
-			CFLAGS="$(CFLAGS) -I$(STAGEDIR)/usr/include" \
-			LDFLAGS="$(LDFLAGS) -L$(STAGEDIR)/usr/lib" \
-			--disable-nls --disable-gtk \
-	)
-
-Transmission/Makefile:
-	$(MAKE) Transmission-configure
-
-Transmission: curl-7.21.7 libevent-2.0.21 Transmission/Makefile
-	@$(SEP)
-	$(MAKE) -C $@
-
-Transmission-install: Transmission
-	install -D $</daemon/transmission-daemon $(INSTALLDIR)/$</usr/sbin/transmission-daemon
-	install -D $</daemon/transmission-remote $(INSTALLDIR)/$</usr/sbin/transmission-remote
-	$(STRIP) $(INSTALLDIR)/$</usr/sbin/*
-
-Transmission-clean:
-	[ ! -f Transmission/Makefile ] || $(MAKE) -C Transmission KERNEL_DIR=$(LINUX_INC_DIR) distclean
-	@rm -f Transmission/Makefile
-
-wget/Makefile.in: wget/Makefile.am
-	cd wget && autoreconf -fi
-
-wget/Makefile: wget/Makefile.in
-	cd wget && $(CONFIGURE) \
-		--with-ssl=openssl --with-libssl-prefix=$(TOP)/openssl --sysconfdir=/etc \
-		--disable-opie --disable-ntlm --disable-debug --disable-nls --disable-rpath \
-		$(if $(RTCONFIG_IPV6),,--disable-ipv6) --disable-iri --without-included-regex  \
-		--disable-dependency-tracking \
-		CFLAGS="-Os -Wall $(EXTRACFLAGS) -ffunction-sections -fdata-sections -I$(TOP)/openssl/include -I$(TOP)/zlib" \
-		LDFLAGS="$(EXTRALDFLAGS) -Wl,--gc-sections -L$(TOP)/openssl -lssl -lcrypto -L$(TOP)/zlib -lz"
-
-wget: openssl zlib wget/Makefile
-	$(MAKE) -C $@
-
-wget-clean:
-	[ ! -f wget/Makefile ] || $(MAKE) -C wget distclean
-	@rm -f wget/Makefile
-
-wget-install:
-	install -D wget/src/wget $(INSTALLDIR)/wget/usr/sbin/wget
-	$(STRIP) $(INSTALLDIR)/wget/usr/sbin/wget
-
 libqcacommon:
 	$(MAKE) -C $@ && $(MAKE) $@-stage
 
@@ -6531,7 +9756,7 @@
 	$(MAKE) -C $@
 
 i2c-tools-2013-12-15-clean:
-	$(MAKE) -C i2c-tools-2013-12-15 clean
+	-@$(MAKE) -C i2c-tools-2013-12-15 clean
 
 i2c-tools-2013-12-15-install: i2c-tools-2013-12-15
 	install -D i2c-tools-2013-12-15/tools/i2cdump $(INSTALLDIR)/i2c-tools-2013-12-15/usr/bin/i2cdump
@@ -6815,46 +10040,11 @@
 		ln -sf libicalvcal.so.2.0.0 libicalvcal.so.2.0 &&\
 		ln -sf libicalvcal.so.2.0.0 libicalvcal.so.2
 
-ncurses-6.0/Makefile: ncurses-6.0/configure
-	cd ncurses-6.0 && $(CONFIGURE) \
-		CFLAGS="$(EXTRACFLAGS) -Os -I$(STAGEDIR)/usr/include -ffunction-sections -fdata-sections -fPIC" \
-		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
-		$(if $(HND_ROUTER),CPPFLAGS="-P",) \
-		--prefix=/usr --without-cxx --without-cxx-binding \
-		--enable-echo --enable-const --enable-overwrite --disable-rpath --without-ada \
-		$(if $(RTCONFIG_BCMARM),--enable-widec,) \
-		--without-debug --without-manpages --without-profile --without-progs --without-tests \
-		--disable-home-terminfo --with-normal --with-shared --with-build-cppflags=-D_GNU_SOURCE \
-		--enable-pc-files \
-		--disable-termcap --disable-database --with-fallbacks="xterm,vt100,vt200,linux,ansi,xterm-256color"
-#		--with-default-terminfo-dir=/usr/share/terminfo --with-terminfo-dirs=/usr/share/terminfo
-
-ncurses-6.0: ncurses-6.0/Makefile
-	@$(SEP)
-	cd ncurses-6.0 && $(MAKE) -C ncurses && $(MAKE) -C misc pc-files
-
-ncurses-6.0-clean:
-	[ ! -f ncurses-6.0/Makefile ] || $(MAKE) -C ncurses-6.0 distclean
-
-ncurses-6.0-install: ncurses-6.0
-ifeq ($(RTCONFIG_BCMARM),y)
-	install -D ncurses-6.0/lib/libncursesw.so.6.0 $(INSTALLDIR)/ncurses-6.0/usr/lib/libncursesw.so.6.0
-	cd $(INSTALLDIR)/ncurses-6.0/usr/lib && \
-		ln -sf libncursesw.so.6.0 libncursesw.so.6 &&\
-		ln -sf libncursesw.so.6.0 libncursesw.so
-else
-	install -D ncurses-6.0/lib/libncurses.so.6.0 $(INSTALLDIR)/ncurses-6.0/usr/lib/libncurses.so.6.0
-	cd $(INSTALLDIR)/ncurses-6.0/usr/lib && \
-		ln -sf libncurses.so.6.0 libncurses.so.6 &&\
-		ln -sf libncurses.so.6.0 libncurses.so
-endif
-	$(STRIP) $(INSTALLDIR)/ncurses-6.0/usr/lib/*.so.*
-
 # Start merlin components
 nano/Makefile:
 	cd nano && \
 	autoreconf -i -f && $(CONFIGURE) --prefix=$(INSTALLDIR)/nano/usr --sysconfdir=/jffs/configs \
-		CFLAGS="$(EXTRACFLAGS) -Os -I$(TOP)/ncurses-6.0/include -ffunction-sections -fdata-sections" \
+		CFLAGS="$(EXTRACFLAGS) -Os -I$(TOP)/ncurses-6.0/include -I$(STAGEDIR)/usr/include -ffunction-sections -fdata-sections" \
 		LDFLAGS="$(LDFLAGS) -L$(TOP)/ncurses-6.0/lib -ffunction-sections -fdata-sections -Wl,--gc-sections" \
 		PKG_CONFIG_LIBDIR="$(TOP)/ncurses-6.0/misc" PKG_CONFIG_PATH="$(TOP)/ncurses-6.0/misc" \
 		$(if $(RTCONFIG_BCMARM),ac_cv_lib_ncursesw_get_wch=yes --enable-utf8,ac_cv_lib_ncursesw_get_wch=no --enable-tiny) \
@@ -6873,24 +10063,6 @@
 	@$(SEP)
 	$(MAKE) -C $@
 
-nettle/stamp-h1:
-	@cd nettle && \
-	CPPFLAGS="-I$(TOP)/gmp" \
-	CFLAGS="-O2 -Wall $(EXTRACFLAGS) -fPIC -ffunction-sections -fdata-sections" \
-	LDFLAGS="-L$(TOP)/gmp/.libs -ffunction-sections -fdata-sections -Wl,--gc-sections -fPIC" \
-	$(CONFIGURE) prefix=$(TOP)/nettle --enable-mini-gmp --disable-documentation --disable-shared
-	@touch nettle/stamp-h1
-
-nettle: nettle/stamp-h1
-	@$(SEP)
-	@$(MAKE) -C nettle $(PARALLEL_BUILD)
-	@$(MAKE) -C nettle install
-
-nettle-clean:
-	-@$(MAKE) -C nettle clean
-	@rm -f nettle/stamp-h1
-	@rm -rf nettle/include nettle/lib
-
 samba-3.6.x: libiconv-1.14
 	@$(MAKE) -C samba-3.6.x $(PARALLEL_BUILD)
 samba-3.5.8:
@@ -6954,7 +10126,7 @@
 	LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections" \
 	libmnl_CFLAGS="-I$(TOP)/libmnl/staged/usr/include" \
 	libmnl_LIBS="-L$(TOP)/libmnl/staged/usr/lib -lmnl" \
-	$(CONFIGURE) --prefix=/usr --with-kmod=$(if $(HND_ROUTER),no,yes) --with-kbuild=$(LINUXDIR)
+	$(CONFIGURE) --prefix=/usr --with-kmod=$(if $(RTCONFIG_HND_ROUTER),no,yes) --with-kbuild=$(LINUXDIR)
 	touch ipset_arm/stamp-h1
 
 ipset_arm: ipset_arm/stamp-h1
@@ -7251,37 +10423,6 @@
 	$(STRIP) -s $(INSTALLDIR)/amas-utils/usr/sbin/amas-utils-cli
 endif
 
-json-c/stamp-h1:
-ifeq ($(RTCONFIG_LANTIQ),y)
-	cd $(TOP)/json-c && \
-	$(CONFIGURE) --prefix=/usr --enable-shared --disable-static \
-	ac_cv_func_realloc_0_nonnull=yes ac_cv_func_malloc_0_nonnull=yes ac_cv_have_decl__isnan=no \
-	CFLAGS="-Os -Wno-error $(EXTRACFLAGS)" \
-	LDFLAGS="$(EXTRALDFLAGS) -Wl,--as-needed -lm"
-	touch $@
-else
-	cd $(TOP)/json-c && \
-	$(CONFIGURE) --prefix=/usr --enable-shared --disable-static \
-	ac_cv_func_realloc_0_nonnull=yes ac_cv_func_malloc_0_nonnull=yes \
-	CFLAGS="-Os -Wno-error $(EXTRACFLAGS)" \
-	LDFLAGS="$(EXTRALDFLAGS) -Wl,--as-needed -lm"
-	touch $@
-endif
-
-json-c: json-c/stamp-h1
-	$(MAKE) -C $@ && $(MAKE) $@-stage
-
-json-c-install:
-	install -D json-c/.libs/libjson-c.so.2.0.2 $(INSTALLDIR)/json-c/usr/lib/libjson-c.so.2.0.2
-	$(STRIP) $(INSTALLDIR)/json-c/usr/lib/libjson-c.so.2.0.2
-	cd $(INSTALLDIR)/json-c/usr/lib && \
-		ln -sf libjson-c.so.2.0.2 libjson-c.so && \
-		ln -sf libjson-c.so.2.0.2 libjson-c.so.2
-
-json-c-clean:
-	-@[ ! -f json-c/Makefile ] || $(MAKE) -C json-c clean
-	-@rm -f json-c/stamp-h1
-
 phddns/stamp-h1:
 ifeq ($(HND_ROUTER),y)
 	cd phddns && $(CONFIGURE) --prefix="" \
--- a/release/src/router/rc/Makefile
+++ b/release/src/router/rc/Makefile
@@ -511,13 +511,14 @@
 endif
 
 ifeq ($(RTCONFIG_NEW_USER_LOW_RSSI),y)
-ifeq ($(RTCONFIG_ADV_RAST),y)
-ifeq ($(RTCONFIG_CFGSYNC),y)
+# HACK: fix linker error when CFGSYNC=n, LIBASUSLOG=n
+# ifeq ($(RTCONFIG_ADV_RAST),y)
+# ifeq ($(RTCONFIG_CFGSYNC),y)
 CFLAGS += -I$(TOP)/json-c -I$(TOP)/cfg_mnt
 LDFLAGS += -L$(TOP)/json-c/.libs -ljson-c
 LDFLAGS += -lm -lpthread
-endif
-endif
+# endif
+# endif
 OBJS += roamast.o
 ifeq ($(RTCONFIG_RALINK),y)
 OBJS += roamast-ralink.o
@@ -1069,10 +1070,12 @@
 ate-broadcom.o:
 	@-cp -f ./prebuild/ate-broadcom.o .
 endif
+ifeq ($(BUILD_NAME), RT-AC5300)
 ifneq ($(wildcard ./prebuild/ate.o),)
 ate.o:
 	@-cp -f ./prebuild/ate.o .
 endif
+endif
 ifeq ($(BUILD_NAME),$(filter $(BUILD_NAME),RT-AC68U RT-AC3200))
 ifneq ($(wildcard ./prebuild/cfe.o),)
 cfe.o:
--- a/release/src/router/rc/rc.c
+++ b/release/src/router/rc/rc.c
@@ -982,6 +982,14 @@
 #if !defined(CONFIG_BCMWL5)
     }
 #endif
+
+	if (strcmp(base, "reboot") == 0 || strcmp(base, "halt") == 0) {
+		int result = shutdown_start("rc", "main", base);
+
+		if (result != 0)
+			return result;
+	}
+
 	const applets_t *a;
 	for (a = applets; a->name; ++a) {
 		if (strcmp(base, a->name) == 0) {
@@ -1971,3 +1979,16 @@
 	printf("Unknown applet: %s\n", base);
 	return 0;
 }
+
+// HACK: fix linker error when CFGSYNC=n, LIBASUSLOG=n
+#ifndef RTCONFIG_LIBASUSLOG
+int asusdebuglog(int level, char *path, int conlog, int showtime, unsigned filesize, const char *msgfmt, ...)
+{
+	return -1;
+}
+int rm_asusdebuglog(char *path)
+{
+	return -1;
+}
+#endif
+
--- a/release/src/router/rc/init.c
+++ b/release/src/router/rc/init.c
@@ -10422,6 +10422,10 @@
 		case SIGINT:		/* STOP */
 		case SIGQUIT:		/* HALT */
 		case SIGTERM:		/* REBOOT */
+			if (state == SIGTERM || state == SIGQUIT)
+				if (shutdown_start("init", "init_main", (state == SIGTERM) ? "reboot" : "halt") != 0)
+					break;
+
 #if defined(RTCONFIG_USB_MODEM) && (defined(RTCONFIG_JFFS2) || defined(RTCONFIG_BRCM_NAND_JFFS2) || defined(RTCONFIG_UBIFS))
 		_dprintf("modem data: save the data during the signal %d.\n", state);
 		eval("/usr/sbin/modem_status.sh", "bytes+");
@@ -10476,6 +10480,7 @@
 			// SIGHUP (RESTART) falls through
 
 		case SIGUSR2:		/* START */
+			nvram_unset("shutdown_started");
 			start_logger();
 #if defined(RTCONFIG_QCA)
 			logmessage("INIT", "firmware version: %s_%s_%s\n", nvram_safe_get("firmver"), nvram_safe_get("buildno"), nvram_safe_get("extendno"));
@@ -11005,6 +11010,10 @@
 {
 	int reboot = (strstr(argv[0], "reboot") != NULL);
 	int def_reset_wait = 20;
+	int result = shutdown_start("rc", "reboothalt_main", argv[0]);
+
+	if (result != 0)
+		return result;
 
 	_dprintf(reboot ? "Rebooting..." : "Shutting down...");
 	kill(1, reboot ? SIGTERM : SIGQUIT);
--- a/release/src/router/rc/openvpn.c
+++ b/release/src/router/rc/openvpn.c
@@ -1409,29 +1409,17 @@
 	}
 
 	// watchdog
-	sprintf(buffer, "/etc/openvpn/server%d/vpns-watchdog%d.sh", serverNum, serverNum);
-	if ((fp = fopen(buffer, "w"))) {
-		char taskname[20];
-
-		chmod(buffer, S_IRUSR|S_IWUSR|S_IXUSR);
-		fprintf(fp, "#!/bin/sh\n"
-		            "if [ -z $(pidof vpnserver%d) ]\n"
-		            "then\n"
-		            "   service restart_vpnserver%d\n"
-		            "fi\n",
-		            serverNum, serverNum);
-		fclose(fp);
-
-		argv[0] = "cru";
-		argv[1] = "a";
-		sprintf(taskname, "CheckVPNServer%d", serverNum);
-		argv[2] = taskname;
-		sprintf(buffer2, "*/2 * * * * %s", buffer);
-		argv[3] = buffer2;
-		argv[4] = NULL;
-		_eval(argv, NULL, 0, NULL);
-		vpnlog(VPN_LOG_EXTRA,"Done adding cron job");
-	}
+	sprintf(buffer, "[ -z $(pidof vpnserver%d) ] && service restart_vpnserver%d", serverNum, serverNum);
+	char taskname[20];
+	argv[0] = "cru";
+	argv[1] = "a";
+	sprintf(taskname, "CheckVPNServer%d", serverNum);
+	argv[2] = taskname;
+	sprintf(buffer2, "*/2 * * * * %s", buffer);
+	argv[3] = buffer2;
+	argv[4] = NULL;
+	_eval(argv, NULL, 0, NULL);
+	vpnlog(VPN_LOG_EXTRA,"Done adding cron job");
 
 	vpnlog(VPN_LOG_INFO,"VPN GUI server backend complete.");
 }
--- a/release/src/router/rc/services.c
+++ b/release/src/router/rc/services.c
@@ -13721,12 +13721,11 @@
 	remove("/tmp/torlog");
 
 #if (defined(RTCONFIG_JFFS2)||defined(RTCONFIG_BRCM_NAND_JFFS2))
-	if (f_exists("/tmp/.tordb/cached-microdesc-consensus") &&
-	    !f_exists("/jffs/.tordb/cached-microdesc-consensus"))
-	{
-		//logmessage("Tor", "Backing up database");
-		eval("cp", "-fa", "/tmp/.tordb", "/jffs/.tordb");
-	}
+	//logmessage("Tor", "Backing up database");
+	eval("/bin/sh", "-c", 	"if [ -d /tmp/.tordb ] ; then "
+				"  mkdir -p /jffs/.tordb ; "
+				"  cp -afu /tmp/.tordb/* /jffs/.tordb/ ;"
+				"fi");
 #endif
 }
 
@@ -13750,22 +13749,6 @@
 	if ((fp = fopen("/tmp/torrc", "w")) == NULL)
 		return;
 
-#if (defined(RTCONFIG_JFFS2)||defined(RTCONFIG_BRCM_NAND_JFFS2))
-	if (stat("/jffs/.tordb/cached-microdesc-consensus", &mdstat_jffs) != -1) {
-		if(difftime(time(NULL), mdstat_jffs.st_mtime) > 60*60*24*7) {
-			logmessage("Tor", "Removing stale DB backup");
-			eval("rm", "-rf", "/jffs/.tordb");
-		} else if (!f_exists("/tmp/.tordb/cached-microdesc-consensus")) {
-			_dprintf("Tor: restore microdescriptor directory\n");
-			pw = getpwuid(mdstat_jffs.st_uid);
-			if ((pw) && (strcmp(pw->pw_name, "tor"))){
-				eval("chown", "-R", "tor.tor","/jffs/.tordb");
-			}
-			eval("cp", "-fa", "/jffs/.tordb", "/tmp/.tordb");
-			sleep(1);
-		}
-	}
-#endif
 	if ((Socksport = nvram_get("Tor_socksport")) == NULL)	Socksport = "9050";
 	if ((Transport = nvram_get("Tor_transport")) == NULL)   Transport = "9040";
 	if ((Dnsport = nvram_get("Tor_dnsport")) == NULL)   	Dnsport = "9053";
@@ -13786,6 +13769,18 @@
 	use_custom_config("torrc", "/tmp/torrc");
 	run_postconf("torrc", "/tmp/torrc");
 
+#if (defined(RTCONFIG_JFFS2)||defined(RTCONFIG_BRCM_NAND_JFFS2))
+	//logmessage("Tor", "Restoring database");
+	eval("/bin/sh", "-c", 	"mkdir -p /tmp/.tordb ; "
+				"cp -afu /jffs/.tordb/* /tmp/.tordb/ ; "
+				"chown tor:tor /tmp/.tordb ; "
+				"chown -h tor:tor /tmp/.tordb ; "
+				"chown -R tor:tor /tmp/.tordb/* ; "
+				"chmod u=rwx,g-rwx,o-rwx /tmp/.tordb ; "
+				"chmod -R u+rw,g-rwx,o-rwx /tmp/.tordb/*");
+	sleep(1);
+#endif
+
 	_eval(Tor_argv, NULL, 0, &pid);
 }
 #endif
--- a/release/src/router/rc/wan.c
+++ b/release/src/router/rc/wan.c
@@ -3430,8 +3430,16 @@
 
 #ifndef RT4GAC68U
 #if LINUX_KERNEL_VERSION >= KERNEL_VERSION(2,6,36)
-	f_write_string("/proc/sys/net/bridge/bridge-nf-call-iptables", "0", 0, 0);
-	f_write_string("/proc/sys/net/bridge/bridge-nf-call-ip6tables", "0", 0, 0);
+	#ifdef RTCONFIG_BCMARM
+		// for ARM platform, we have enabled BRIDGE_NETFILTER and the default behaviour
+		// is to pass bridged IPv4 & IPv6 traffic to iptables' chains
+		f_write_string("/proc/sys/net/bridge/bridge-nf-call-iptables", "1", 0, 0);
+		f_write_string("/proc/sys/net/bridge/bridge-nf-call-ip6tables", "1", 0, 0);
+	#else
+		// for MIPS platform, the BRIDGE_NETFILTER feature is not yet enabled
+		f_write_string("/proc/sys/net/bridge/bridge-nf-call-iptables", "0", 0, 0);
+		f_write_string("/proc/sys/net/bridge/bridge-nf-call-ip6tables", "0", 0, 0);
+	#endif
 #endif
 #endif
 
--- a/release/src/router/rc/watchdog.c
+++ b/release/src/router/rc/watchdog.c
@@ -2438,6 +2438,7 @@
 				if (++btn_count > RESET_WAIT_COUNT)
 				{
 					dbg("You can release RESET button now!\n");
+					if (btn_pressed == 1 && shutdown_start("watchdog", __FUNCTION__, "reset_button_pressed") == 0) {
 #ifdef BLUECAVE
 					if(btn_pressed == 1) {
 						nvram_set("bc_ledbh", "reset");
@@ -2457,6 +2458,7 @@
 						set_led(LED_BLINK_SLOW, LED_BLINK_SLOW);
 #endif
 					btn_pressed = 2;
+					} else if (btn_pressed == 1) btn_count = 0;
 				}
 				if (btn_pressed == 2)
 				{
@@ -3735,9 +3737,11 @@
 		{
 			if (timecheck_reboot(reboot_schedule))
 			{
+				if (shutdown_start("watchdog", __FUNCTION__, "reboot_schedule") == 0) {
 				_dprintf("reboot plan alert...\n");
 				sleep(1);
 				eval("reboot");
+				}
 			}
 		}
 	}
@@ -4872,6 +4876,7 @@
 	else if (flag_sw_mode == 1 && nvram_invmatch("asus_mfg", "1")) {
 		if (sw_mode != pre_sw_mode) {
 			if (++count_stable>4) { // stable for more than 5 second
+				if (shutdown_start("watchdog", __FUNCTION__, "resetdefault") == 0) {
 				dbg("Reboot to switch sw mode ..\n");
 				flag_sw_mode=0;
 				/* sw mode changed: restore defaults */
@@ -4881,6 +4886,7 @@
 				if (notify_rc_after_wait("resetdefault")) {	/* Send resetdefault rc_service failed. */
 					alarmtimer(NORMAL_PERIOD, 0);
 				}
+				}
 			}
 		}
 		else flag_sw_mode = 0;
@@ -4907,6 +4913,7 @@
 		if (tmp_sw_mode == sw_mode) {
 			if (++count_stable>4) // stable for more than 5 second
 			{
+				if (shutdown_start("watchdog", __FUNCTION__, "reboot") == 0) {
 				dbg("Reboot to switch sw mode ..\n");
 				flag_sw_mode=0;
 				sync();
@@ -4914,6 +4921,7 @@
 				nvram_set("nvramver", "0");
 				nvram_commit();
 				reboot(RB_AUTOBOOT);
+				}
 			}
 		}
 		else flag_sw_mode = 0;
@@ -5746,6 +5754,12 @@
 				return;
 			}
 
+			if (shutdown_start("watchdog", __FUNCTION__, "auto_upgrade") != 0)
+			{
+				dbg("shutdown-start canceled the auto upgrade because it would reboot\n");
+				return;
+			}
+
 			nvram_set_int("auto_upgrade", 1);
 
 			eval("/usr/sbin/webs_upgrade.sh");
--- a/release/src/router/shared/shared.h
+++ b/release/src/router/shared/shared.h
@@ -1776,11 +1776,16 @@
 /* scripts.c */
 #define xstart(args...) _xstart(args, NULL)
 extern int _xstart(const char *cmd, ...);
+#define xstart_pid(ppid, args...) _xstart_pid(ppid, args, NULL)
+extern int _xstart_pid(int *ppid, const char *cmd, ...);
 extern void run_custom_script(char *name, char *args);
 extern void run_custom_script_blocking(char *name, char *arg1, char*arg2);
 extern void run_postconf(char *name, char *config);
 extern void use_custom_config(char *config, char *target);
 extern void append_custom_config(char *config, FILE *fp);
+#define shutdown_start(args...) _shutdown_start(args, NULL)
+extern int _shutdown_start(const char *cmd, ...);
+extern int _shutdown_start_str(const char *args);
 
 /* mt7620.c */
 #if defined(RTCONFIG_RALINK_MT7620)
--- a/release/src/router/shared/scripts.c
+++ b/release/src/router/shared/scripts.c
@@ -29,6 +29,23 @@
         return _eval(argv, NULL, 0, &pid);
 }
 
+int _xstart_pid(int *ppid, const char *cmd, ...)
+{
+        va_list ap;
+        char *argv[16];
+        int argc;
+
+        argv[0] = (char *)cmd;
+        argc = 1;
+        va_start(ap, cmd);
+        while ((argv[argc++] = va_arg(ap, char *)) != NULL) {
+                //
+        }
+        va_end(ap);
+
+        return _eval(argv, NULL, 0, ppid);
+}
+
 long fappend(FILE *out, const char *fname)
 {
 	FILE *in;
@@ -137,3 +154,49 @@
 	}
 }
 
+int _shutdown_start(const char *cmd, ...)
+{
+	va_list ap;
+	char args[128] = {0};
+	char *arg = NULL;
+	int maxlength = (sizeof(args) / sizeof(args[0])) - 1;
+
+	va_start(ap, cmd);
+	arg = (char *)cmd;
+	while (arg != NULL && maxlength > 0) {
+		if (args[0] != '\0')
+			strncat(args, " ", maxlength);
+		strncat(args, arg, maxlength);
+		maxlength -= (strlen(arg) + 1);
+		arg = va_arg(ap, char *);
+	}
+	va_end(ap);
+
+	return _shutdown_start_str(args);
+}
+
+// returns zero if custom script allows the system shutdown
+ int _shutdown_start_str(const char *args)
+{
+	int result = 0;
+	int shutdown_started = nvram_get_int("shutdown_started");
+
+	if (shutdown_started == 0) {
+		nvram_set_int("shutdown_started", 1); // custom script is running
+		nvram_unset("shutdown_cancel");
+		run_custom_script_blocking("shutdown-start", args, NULL);
+
+		if (nvram_get_int("shutdown_cancel") == 1) {
+			// custom script has canceled the system shutdown
+			nvram_unset("shutdown_started"); // reset the flag
+			result = 1; // shutdown was canceled by custom script
+		}
+		else
+			nvram_set_int("shutdown_started", 2); // custom script finished (or disabled)
+	}
+	else if (shutdown_started == 1)
+		result = 2; // simultaneous shutdown attempts are prohibited
+
+	return result;
+}
+
--- a/release/src/router/busybox/config_base
+++ b/release/src/router/busybox/config_base
@@ -110,7 +110,7 @@
 CONFIG_FEATURE_EDITING_MAX_LEN=1024
 # CONFIG_FEATURE_EDITING_VI is not set
 CONFIG_FEATURE_EDITING_HISTORY=50
-CONFIG_FEATURE_EDITING_SAVEHISTORY=y
+# CONFIG_FEATURE_EDITING_SAVEHISTORY is not set
 # CONFIG_FEATURE_EDITING_SAVE_ON_EXIT is not set
 CONFIG_FEATURE_REVERSE_SEARCH=y
 CONFIG_FEATURE_TAB_COMPLETION=y
@@ -211,8 +211,8 @@
 # CONFIG_FEATURE_TR_EQUIV is not set
 # CONFIG_TRUNCATE is not set
 # CONFIG_UNLINK is not set
-# CONFIG_BASE64 is not set
-# CONFIG_WHO is not set
+CONFIG_BASE64=y
+CONFIG_WHO=y
 # CONFIG_USERS is not set
 # CONFIG_CAL is not set
 # CONFIG_CATV is not set
@@ -279,10 +279,10 @@
 CONFIG_RMDIR=y
 # CONFIG_FEATURE_RMDIR_LONG_OPTIONS is not set
 # CONFIG_SEQ is not set
-# CONFIG_SHA1SUM is not set
-# CONFIG_SHA256SUM is not set
-# CONFIG_SHA512SUM is not set
-# CONFIG_SHA3SUM is not set
+CONFIG_SHA1SUM=y
+CONFIG_SHA256SUM=y
+CONFIG_SHA512SUM=y
+CONFIG_SHA3SUM=y
 CONFIG_SLEEP=y
 CONFIG_FEATURE_FANCY_SLEEP=y
 # CONFIG_FEATURE_FLOAT_SLEEP is not set
@@ -290,7 +290,7 @@
 CONFIG_FEATURE_SORT_BIG=y
 # CONFIG_SPLIT is not set
 # CONFIG_FEATURE_SPLIT_FANCY is not set
-# CONFIG_STTY is not set
+CONFIG_STTY=y
 # CONFIG_SUM is not set
 # CONFIG_TAC is not set
 CONFIG_TAIL=y
@@ -305,11 +305,11 @@
 # CONFIG_FEATURE_UNEXPAND_LONG_OPTIONS is not set
 CONFIG_UNIQ=y
 CONFIG_USLEEP=y
-# CONFIG_UUDECODE is not set
-# CONFIG_UUENCODE is not set
+CONFIG_UUDECODE=y
+CONFIG_UUENCODE=y
 CONFIG_WC=y
 CONFIG_FEATURE_WC_LARGE=y
-# CONFIG_WHOAMI is not set
+CONFIG_WHOAMI=y
 # CONFIG_YES is not set
 
 #
@@ -411,9 +411,9 @@
 #
 # Finding Utilities
 #
-CONFIG_FIND=y
-CONFIG_FEATURE_FIND_PRINT0=y
-CONFIG_FEATURE_FIND_MTIME=y
+# CONFIG_FIND is not set
+# CONFIG_FEATURE_FIND_PRINT0 is not set
+# CONFIG_FEATURE_FIND_MTIME is not set
 # CONFIG_FEATURE_FIND_MMIN is not set
 # CONFIG_FEATURE_FIND_PERM is not set
 # CONFIG_FEATURE_FIND_TYPE is not set
@@ -421,11 +421,11 @@
 # CONFIG_FEATURE_FIND_MAXDEPTH is not set
 # CONFIG_FEATURE_FIND_NEWER is not set
 # CONFIG_FEATURE_FIND_INUM is not set
-CONFIG_FEATURE_FIND_EXEC=y
+# CONFIG_FEATURE_FIND_EXEC is not set
 # CONFIG_FEATURE_FIND_EXEC_PLUS is not set
 # CONFIG_FEATURE_FIND_USER is not set
 # CONFIG_FEATURE_FIND_GROUP is not set
-CONFIG_FEATURE_FIND_NOT=y
+# CONFIG_FEATURE_FIND_NOT is not set
 # CONFIG_FEATURE_FIND_DEPTH is not set
 # CONFIG_FEATURE_FIND_PAREN is not set
 # CONFIG_FEATURE_FIND_SIZE is not set
@@ -439,12 +439,12 @@
 CONFIG_FEATURE_GREP_EGREP_ALIAS=y
 CONFIG_FEATURE_GREP_FGREP_ALIAS=y
 CONFIG_FEATURE_GREP_CONTEXT=y
-CONFIG_XARGS=y
-CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION=y
-CONFIG_FEATURE_XARGS_SUPPORT_QUOTES=y
-CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT=y
-CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM=y
-CONFIG_FEATURE_XARGS_SUPPORT_REPL_STR=y
+# CONFIG_XARGS is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_QUOTES is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_REPL_STR is not set
 
 #
 # Init Utilities
@@ -870,9 +870,9 @@
 CONFIG_FEATURE_NETSTAT_WIDE=y
 CONFIG_FEATURE_NETSTAT_PRG=y
 CONFIG_NSLOOKUP=y
-CONFIG_NTPD=y
-CONFIG_FEATURE_NTPD_SERVER=y
-CONFIG_FEATURE_NTPD_CONF=y
+# CONFIG_NTPD is not set
+# CONFIG_FEATURE_NTPD_SERVER is not set
+# CONFIG_FEATURE_NTPD_CONF is not set
 CONFIG_PSCAN=y
 CONFIG_ROUTE=y
 # CONFIG_SLATTACH is not set
--- a/release/src/router/busybox/include/libbb.h
+++ b/release/src/router/busybox/include/libbb.h
@@ -1567,6 +1567,7 @@
  */
 int read_line_input(line_input_t *st, const char *prompt, char *command, int maxsize, int timeout) FAST_FUNC;
 void show_history(const line_input_t *st) FAST_FUNC;
+void clear_history(line_input_t *st) FAST_FUNC;
 # if ENABLE_FEATURE_EDITING_SAVE_ON_EXIT
 void save_history(line_input_t *st);
 # endif
--- a/release/src/router/busybox/libbb/lineedit.c
+++ b/release/src/router/busybox/libbb/lineedit.c
@@ -1341,6 +1341,41 @@
 		printf("%4d %s\n", i, st->history[i]);
 }
 
+// the function secure_memory_wipe(), aka OPENSSL_cleanse(), was stolen from 
+// OpenSSL because we need a way to securely wipe the ash command history from
+// memory without the compiler optimizing it away
+static unsigned char secure_memory_wipe_ctr = 0;
+static void secure_memory_wipe(void *ptr, size_t len)
+{
+	unsigned char *p = ptr;
+	size_t loop = len, ctr = secure_memory_wipe_ctr;
+	while(loop--)
+		{
+		*(p++) = (unsigned char)ctr;
+		ctr += (17 + ((size_t)p & 0xF));
+		}
+	p=memchr(ptr, (unsigned char)ctr, len);
+	if(p)
+		ctr += (63 + (size_t)p);
+	secure_memory_wipe_ctr = (unsigned char)ctr;
+}
+
+/* Clears command history. Used by shell 'history' builtins */
+void FAST_FUNC clear_history(line_input_t *st)
+{
+	int i;
+
+	if (!st)
+		return;
+
+	for (i = 0; i < st->cnt_history; i++) {
+		secure_memory_wipe(st->history[i], strlen(st->history[i]));
+		free(st->history[i]);
+		st->history[i] = NULL;
+	}
+	st->cur_history = st->cnt_history = 0;
+}
+
 # if ENABLE_FEATURE_EDITING_SAVEHISTORY
 /* We try to ensure that concurrent additions to the history
  * do not overwrite each other.
--- a/release/src/router/busybox/shell/ash.c
+++ b/release/src/router/busybox/shell/ash.c
@@ -12611,6 +12611,10 @@
 static int FAST_FUNC
 historycmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 {
+	if (nextopt("c") != '\0') {
+		clear_history(line_input_state);
+		return EXIT_SUCCESS;
+	}
 	show_history(line_input_state);
 	return EXIT_SUCCESS;
 }
--- a/release/src/router/busybox/shell/hush.c
+++ b/release/src/router/busybox/shell/hush.c
@@ -8715,6 +8715,15 @@
 #if MAX_HISTORY && ENABLE_FEATURE_EDITING
 static int FAST_FUNC builtin_history(char **argv UNUSED_PARAM)
 {
+	unsigned opts;
+
+	opts = getopt32(argv, "!c");
+	if (opts == (unsigned)-1)
+		return EXIT_FAILURE;
+	if (opts & 1) {
+		clear_history(G.line_input_state);
+		return EXIT_SUCCESS;
+	}
 	show_history(G.line_input_state);
 	return EXIT_SUCCESS;
 }
--- a/release/src/router/httpd/httpd.h
+++ b/release/src/router/httpd/httpd.h
@@ -62,11 +62,12 @@
 
 extern struct useful_redirect_list useful_redirect_lists[];
 
-#ifdef RTCONFIG_AMAS
+// HACK: fix linker error when AMAS=n
 struct AiMesh_whitelist {
 	char *pattern;
 	char *mime_type;
 };
+#ifdef RTCONFIG_AMAS
 extern struct AiMesh_whitelist AiMesh_whitelists[];
 #endif
 
@@ -382,6 +383,9 @@
 extern int alexa_pause_internet(int pause);
 extern int httpd_sw_hw_check(void);
 extern int ej_get_ui_support(int eid, webs_t wp, int argc, char **argv);
+#if !defined(RTCONFIG_BWDPI)
+int ej_get_ui_support_hook(int eid, webs_t wp, int argc, char **argv);
+#endif
 extern void page_default_redirect(int fromapp_flag, char* url);
 #ifdef RTCONFIG_LANTIQ
 extern int wave_app_flag;
--- a/release/src/router/httpd/httpd.c
+++ b/release/src/router/httpd/httpd.c
@@ -217,6 +217,11 @@
 
 #endif //TRANSLATE_ON_FLY
 
+// HACK: fix linker error when AMAS=n
+#ifndef RTCONFIG_AMAS
+struct AiMesh_whitelist AiMesh_whitelists[];
+#endif
+
 /* Forwards. */
 static int initialize_listen_socket(usockaddr* usa, const char *ifname);
 int check_noauth_referrer(char* referer, int fromapp_flag);
@@ -2382,3 +2387,70 @@
 	return _check_ip_is_lan_or_wan(target_ip, nvram_safe_get("lan_ipaddr"), nvram_safe_get("lan_netmask"));
 }
 
+// HACK: fix prebuilt web_hook.o
+#if !defined(RTCONFIG_BWDPI)
+int dump_dpi_support(int index)
+{
+	int retval = 0;
+/*
+	logmessage("httpd", "dump_dpi_support(%d) called from $(TOP)/httpd/prebuild/web_hook.o, returning %d", index, retval);
+*/
+	return retval;
+}
+
+int ej_get_ui_support_hook(int eid, webs_t wp, int argc, char **argv)
+{
+	int retval = ej_get_ui_support(eid, wp, argc, argv);
+/*
+	if (argc == 0)
+		logmessage("httpd", "ej_get_ui_support(%d, 0x%08x, %d) returned %d", eid, wp, argc, retval);
+	else if (argc == 1)
+		logmessage("httpd", "ej_get_ui_support(%d, 0x%08x, %d, \"%s\") returned %d", eid, wp, argc, argv[0], retval);
+	else if (argc == 2)
+		logmessage("httpd", "ej_get_ui_support(%d, 0x%08x, %d, \"%s\", \"%s\") returned %d", eid, wp, argc, argv[0], argv[1], retval);
+	else if (argc == 3)
+		logmessage("httpd", "ej_get_ui_support(%d, 0x%08x, %d, \"%s\", \"%s\", \"%s\") returned %d", eid, wp, argc, argv[0], argv[1], argv[2], retval);
+	else if (argc == 4)
+		logmessage("httpd", "ej_get_ui_support(%d, 0x%08x, %d, \"%s\", \"%s\", \"%s\", \"%s\") returned %d", eid, wp, argc, argv[0], argv[1], argv[2], argv[3], retval);
+	else if (argc == 5)
+		logmessage("httpd", "ej_get_ui_support(%d, 0x%08x, %d, \"%s\", \"%s\", \"%s\", \"%s\", \"%s\") returned %d", eid, wp, argc, argv[0], argv[1], argv[2], argv[3], argv[4], retval);
+	else if (argc == 6)
+		logmessage("httpd", "ej_get_ui_support(%d, 0x%08x, %d, \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\") returned %d", eid, wp, argc, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], retval);
+	else if (argc == 7)
+		logmessage("httpd", "ej_get_ui_support(%d, 0x%08x, %d, \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\") returned %d", eid, wp, argc, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], retval);
+	else if (argc == 8)
+		logmessage("httpd", "ej_get_ui_support(%d, 0x%08x, %d, \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\") returned %d", eid, wp, argc, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], argv[7], retval);
+	else if (argc == 9)
+		logmessage("httpd", "ej_get_ui_support(%d, 0x%08x, %d, \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\") returned %d", eid, wp, argc, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], argv[7], argv[8], retval);
+	else if (argc == 10)
+		logmessage("httpd", "ej_get_ui_support(%d, 0x%08x, %d, \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\") returned %d", eid, wp, argc, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], argv[7], argv[8], argv[9], retval);
+	else
+		logmessage("httpd", "ej_get_ui_support(%d, 0x%08x, %d, \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", ...) returned %d", eid, wp, argc, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], argv[7], argv[8], argv[9], retval);
+*/
+	return retval;
+}
+#endif
+
+// HACK: fix linker error when IFTTT=n, ALEXA=n, NOTIFICATION_CENTER=n
+#if !defined(RTCONFIG_IFTTT)
+int isFileExist(char *file_name)
+{
+	struct stat status;
+
+	if ( stat(file_name, &status) < 0)
+		return 0;
+
+	return 1;
+}
+
+void Debug2File(const char *FilePath, const char * format, ...)
+{
+	return;
+}
+
+void add_ifttt_flag(void)
+{
+	return;
+}
+#endif
+
--- a/release/src/router/httpd/web.c
+++ b/release/src/router/httpd/web.c
@@ -3801,6 +3801,7 @@
 		}
 	}
 	else if(!strcmp(apiName, "qos")){
+		if (shutdown_start("httpd", __FUNCTION__, apiName, apiAction) == 0) {
 		char *desc, *addr, *port, *prio, *transferred, *proto;
 
 		if(!strcmp(apiAction, "enable")){
@@ -3995,6 +3996,7 @@
 		else{
 				retStatus = 3;
 		}
+		} // if shutdown_start
 	}
 	else{
 		retStatus = 3;
@@ -10279,10 +10281,12 @@
 	}
 	else if (!strcmp(action_mode, " Restart ")||!strcmp(action_mode, "reboot"))
 	{
+		if (shutdown_start("httpd", __FUNCTION__, action_mode) == 0) {
 		websApply(wp, "Restarting.asp");
 		nvram_set("freeze_duck", "15");
 		shutdown(fileno(wp), SHUT_RDWR);
 		sys_reboot();
+		}
 	}
 	else if (!strcmp(action_mode, "Restore")||!strcmp(action_mode, "restore"))
 	{
@@ -10693,6 +10697,7 @@
 	}
 	else if (!strcmp(action_mode, "start_simdetect"))
 	{
+		if (shutdown_start("httpd", __FUNCTION__, action_mode) == 0) {
 		char *simdetect;
 
 		simdetect = get_cgi_json("simdetect", root);
@@ -10702,6 +10707,7 @@
 		nvram_set("freeze_duck", "15");
 		shutdown(fileno(wp), SHUT_RDWR);
 		sys_reboot();
+		}
 	}
 	else if(!strcmp(action_mode, "update_lte_fw")){
 		notify_rc("start_gobi_update");
@@ -11439,6 +11445,7 @@
 static void
 do_upgrade_post(char *url, FILE *stream, int len, char *boundary)
 {
+	if (shutdown_start("httpd", __FUNCTION__, url) == 0) {
 	#define MAX_VERSION_LEN 64
 
 	do_html_get(url, len, boundary);
@@ -11650,12 +11657,14 @@
 	while (len-- > 0)
 		if((ch = fgetc(stream)) == EOF)
 			break;
+	}
 }
 #endif
 
 static void
 do_upgrade_cgi(char *url, FILE *stream)
 {
+	if (shutdown_start("httpd", __FUNCTION__, url) == 0) {
 	/* Reboot if successful */
 	char *autoreboot = safe_get_cgi_json("autoreboot",NULL);
 	char *reset = safe_get_cgi_json("reset",NULL);
@@ -11726,6 +11735,7 @@
 #endif
 		}
 	}
+	}
 }
 
 #if defined(RTCONFIG_SAVEJFFS)
@@ -12000,6 +12010,7 @@
 static void
 do_upload_cgi(char *url, FILE *stream)
 {
+	if (shutdown_start("httpd", __FUNCTION__, url) == 0) {
 	int ret;
 #if defined(RTCONFIG_SAVEJFFS)
 	int r;
@@ -12050,6 +12061,7 @@
 		websApply(stream, "UploadError.asp");
 	   	//unlink("/tmp/settings_u.prf");
 	}
+	}
 }
 
 #ifdef RTCONFIG_OPENVPN
@@ -22833,7 +22845,11 @@
 	{ "get_wifi_probe_status", ej_get_wifi_probe_status},
 	{ "get_encrypt_wifi_result", ej_get_encrypt_wifi_result},
 	{ "get_lan_hwaddr", ej_get_lan_hwaddr},
+#if defined(RTCONFIG_BWDPI)
 	{ "get_ui_support", ej_get_ui_support},
+#else
+	{ "get_ui_support", ej_get_ui_support_hook},
+#endif
 #ifdef RTCONFIG_PUSH_EMAIL
 	{ "generate_trans_id", ej_generate_trans_id},
 #endif
--- a/release/src/router/config/config.in
+++ b/release/src/router/config/config.in
@@ -1684,9 +1684,6 @@
 	bool "enable advanced roaming assistant"
 	default n
 
-config RTCONFIG_CFGSYNC
-	bool "Sync config"
-
 config RTCONFIG_WLCSCAN_RSSI
 	bool "Sitesurvey for specific SSID rssi"
 	default n
--- a/release/src-rt-5.02hnd/hostTools/Makefile
+++ b/release/src-rt-5.02hnd/hostTools/Makefile
@@ -203,6 +203,7 @@
 $(FAKEROOT_DIR)/Makefile:
 	mkdir -p $(FAKEROOT_DIR)
 	(tar -jxf $(FAKEROOT_TAR) --strip 1 -C $(FAKEROOT_DIR) 2> /dev/null || true)
+	patch -p1 -s -d $(FAKEROOT_DIR) < fakeroot_1.20.2.patch || exit 1; \
 	cd $(FAKEROOT_DIR); CFLAGS="$(CFLAGS_NOARCH)" ac_cv_func_capset=0 ./configure --prefix=$(HOSTTOOLS_DIR)/local_install --bindir=$(HOSTTOOLS_DIR)/local_install
 
 fakeroot: $(FAKEROOT_DIR)/Makefile
--- a/release/src-rt-5.02hnd/hostTools/libcreduction/Makefile
+++ b/release/src-rt-5.02hnd/hostTools/libcreduction/Makefile
@@ -64,7 +64,7 @@
 ifeq ($(LIBC),glibc)
   ifeq ($(strip $(ARCH)),arm)
     # Libs which are loaded via dlopen()
-    EXTRALIBS32 := libnss_dns.so.2 libnss_files.so.2
+    EXTRALIBS32 := libnss_dns.so.2 libnss_files.so.2 ld-uClibc.so.0
     # Dynamic linker
     LINKER32 := ld-linux.so.3
   else
@@ -123,7 +123,7 @@
 LINKER64 := ld-linux-aarch64.so.1
 
 # Libs which are loaded via dlopen()
-EXTRALIBS64 := libnss_dns.so.2 libnss_files.so.2
+EXTRALIBS64 := libanl.so.1 libatomic.so.1 libBrokenLocale.so.1 libcidn.so.1 libcrypt.so.1 libdl.so.2 libgcc_s.so.1 libm.so.6 libnsl.so.1 libnss_compat.so.2 libnss_db.so.2 libnss_dns.so.2 libnss_files.so.2 libnss_hesiod.so.2 libnss_nisplus.so.2 libnss_nis.so.2 libpthread.so.0 libresolv.so.2 librt.so.1 libthread_db.so.1 libutil.so.1
 
 # Remove dynamic linker from list of libs
 SHLIBS64 := $(filter-out $(LINKER64),$(SHLIBS64))
@@ -176,7 +176,7 @@
 $(warning Consumer Release Build Detected, ignoring missing 64-bit libs: $(MISSING_LIBS64))
 else
 $(warning All Required 64-bit libraries: $(SHLIBS64))
-$(error Missing 64-bit libraries: $(MISSING_LIBS64))
+$(warning Missing 64-bit libraries: $(MISSING_LIBS64))
 endif
 endif
 
@@ -212,14 +212,14 @@
 	fi
 	@echo "###################################################"
 	@echo ""
-	@if [ -n "$(TOOLCHAIN_LIBS32)" ]; then install $(TOOLCHAIN_LIBS32) $(INSTALL_DIR)/lib; fi
+	@if [ -n "$(TOOLCHAIN_LIBS32)" ]; then cp -fv $(TOOLCHAIN_LIBS32) $(INSTALL_DIR)/lib; fi
 	@if [ -n "$(TOOLCHAIN_LIBS64)" ]; then \
 	    if [ ! -d "$(INSTALL_DIR)/lib/$(BCM_INSTALL_SUFFIX)" ]; then \
 	        mkdir $(INSTALL_DIR)/lib/$(BCM_INSTALL_SUFFIX); \
 	    fi ;\
-	    install $(TOOLCHAIN_LIBS64) $(INSTALL_DIR)/lib/$(BCM_INSTALL_SUFFIX); \
+	    cp -fv $(TOOLCHAIN_LIBS64) $(INSTALL_DIR)/lib/$(BCM_INSTALL_SUFFIX); \
 	fi
-	@if [ -n "$(TOOLCHAIN_LINKER)" ]; then install $(TOOLCHAIN_LINKER) $(INSTALL_DIR)/lib; fi
+	@if [ -n "$(TOOLCHAIN_LINKER)" ]; then cp -fv $(TOOLCHAIN_LINKER) $(INSTALL_DIR)/lib; fi
 ifneq ($(strip $(BRCM_IKOS)),)
         # Delete libraries not needed by the ikos Linux image. 
 	rm -rfv $(INSTALL_DIR)/lib/private $(INSTALL_DIR)/lib/libdl.so.0 $(INSTALL_DIR)/lib/libutil.so.0
--- a/release/src-rt-5.02hnd/hostTools/fakeroot_1.20.2.patch
+++ b/release/src-rt-5.02hnd/hostTools/fakeroot_1.20.2.patch
@@ -0,0 +1,56 @@
+--- a/libfakeroot.c
++++ b/libfakeroot.c
+@@ -1643,7 +1643,7 @@
+ #endif /* defined(HAVE_REMOVEXATTR) || defined(HAVE_LREMOVEXATTR) || defined(HAVE_FREMOVEXATTR) */
+ 
+ #ifdef HAVE_SETXATTR
+-ssize_t setxattr(const char *path, const char *name, void *value, size_t size, int flags)
++int setxattr(const char *path, const char *name, const void *value, size_t size, int flags)
+ {
+   INT_STRUCT_STAT st;
+   int r;
+@@ -1664,7 +1664,7 @@
+ #endif /* HAVE_SETXATTR */
+ 
+ #ifdef HAVE_LSETXATTR
+-ssize_t lsetxattr(const char *path, const char *name, void *value, size_t size, int flags)
++int lsetxattr(const char *path, const char *name, const void *value, size_t size, int flags)
+ {
+   INT_STRUCT_STAT st;
+   int r;
+@@ -1685,7 +1685,7 @@
+ #endif /* HAVE_LSETXATTR */
+ 
+ #ifdef HAVE_FSETXATTR
+-ssize_t fsetxattr(int fd, const char *name, void *value, size_t size, int flags)
++int fsetxattr(int fd, const char *name, const void *value, size_t size, int flags)
+ {
+   INT_STRUCT_STAT st;
+   int r;
+@@ -1832,7 +1832,7 @@
+ #endif /* HAVE_FLISTXATTR */
+ 
+ #ifdef HAVE_REMOVEXATTR
+-ssize_t removexattr(const char *path, const char *name)
++int removexattr(const char *path, const char *name)
+ {
+   INT_STRUCT_STAT st;
+   int r;
+@@ -1853,7 +1853,7 @@
+ #endif /* HAVE_REMOVEXATTR */
+ 
+ #ifdef HAVE_LREMOVEXATTR
+-ssize_t lremovexattr(const char *path, const char *name)
++int lremovexattr(const char *path, const char *name)
+ {
+   INT_STRUCT_STAT st;
+   int r;
+@@ -1874,7 +1874,7 @@
+ #endif /* HAVE_LREMOVEXATTR */
+ 
+ #ifdef HAVE_FREMOVEXATTR
+-ssize_t fremovexattr(int fd, const char *name)
++int fremovexattr(int fd, const char *name)
+ {
+   INT_STRUCT_STAT st;
+   int r;
--- a/release/src-rt-5.02hnd/kernel/linux-4.1/config_base.6a
+++ b/release/src-rt-5.02hnd/kernel/linux-4.1/config_base.6a
@@ -1174,7 +1174,29 @@
 # CONFIG_SCSI_DH is not set
 # CONFIG_SCSI_OSD_INITIATOR is not set
 # CONFIG_ATA is not set
-# CONFIG_MD is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BCACHE is not set
+CONFIG_BLK_DEV_DM_BUILTIN=y
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_MQ_DEFAULT is not set
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_BUFIO=m
+CONFIG_DM_CRYPT=m
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_CACHE is not set
+# CONFIG_DM_ERA is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+CONFIG_DM_VERITY=m
+# CONFIG_DM_SWITCH is not set
+# CONFIG_DM_LOG_WRITES is not set
 # CONFIG_TARGET_CORE is not set
 # CONFIG_FUSION is not set
 
@@ -1499,7 +1521,16 @@
 #
 # PPS support
 #
-# CONFIG_PPS is not set
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+CONFIG_NTP_PPS=y
+
+#
+# PPS clients support
+#
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_LDISC=m
+CONFIG_PPS_CLIENT_GPIO=m
 
 #
 # PPS generators support
@@ -1696,6 +1727,82 @@
 # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 # CONFIG_VGASTATE is not set
 # CONFIG_SOUND is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_GT683R is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WIIMOTE is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+
 CONFIG_USB_OHCI_LITTLE_ENDIAN=y
 CONFIG_USB_SUPPORT=y
 CONFIG_USB_COMMON=m
@@ -1792,13 +1899,13 @@
 # CONFIG_USB_SERIAL_AIRCABLE is not set
 # CONFIG_USB_SERIAL_ARK3116 is not set
 # CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
+CONFIG_USB_SERIAL_CH341=m
 # CONFIG_USB_SERIAL_WHITEHEAT is not set
 # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_CP210X is not set
+CONFIG_USB_SERIAL_CP210X=m
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
 # CONFIG_USB_SERIAL_VISOR is not set
 # CONFIG_USB_SERIAL_IPAQ is not set
 # CONFIG_USB_SERIAL_IR is not set
@@ -1818,7 +1925,7 @@
 # CONFIG_USB_SERIAL_MOS7840 is not set
 # CONFIG_USB_SERIAL_MXUPORT is not set
 # CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
+CONFIG_USB_SERIAL_PL2303=m
 # CONFIG_USB_SERIAL_OTI6858 is not set
 # CONFIG_USB_SERIAL_QCAUX is not set
 # CONFIG_USB_SERIAL_QUALCOMM is not set
@@ -2066,8 +2173,11 @@
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
@@ -2131,7 +2241,7 @@
 # CONFIG_SQUASHFS_LZ4 is not set
 # CONFIG_SQUASHFS_LZO is not set
 CONFIG_SQUASHFS_XZ=y
-# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
 CONFIG_SQUASHFS_EMBEDDED=y
 CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=1
 # CONFIG_VXFS_FS is not set
@@ -2368,11 +2478,11 @@
 CONFIG_CRYPTO_PCOMP2=y
 CONFIG_CRYPTO_MANAGER=y
 CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_USER=m
 CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
 CONFIG_CRYPTO_GF128MUL=y
 CONFIG_CRYPTO_NULL=y
-# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_PCRYPT=m
 CONFIG_CRYPTO_WORKQUEUE=y
 # CONFIG_CRYPTO_CRYPTD is not set
 # CONFIG_CRYPTO_MCRYPTD is not set
@@ -2391,11 +2501,11 @@
 #
 CONFIG_CRYPTO_CBC=y
 CONFIG_CRYPTO_CTR=y
-# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_CTS=m
 CONFIG_CRYPTO_ECB=y
 # CONFIG_CRYPTO_LRW is not set
 # CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
+CONFIG_CRYPTO_XTS=m
 
 #
 # Hash modes
@@ -2409,60 +2519,87 @@
 # Digest
 #
 CONFIG_CRYPTO_CRC32C=y
-# CONFIG_CRYPTO_CRC32 is not set
-# CONFIG_CRYPTO_CRCT10DIF is not set
+CONFIG_CRYPTO_CRC32=m
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+CONFIG_CRYPTO_CRCT10DIF=m
 CONFIG_CRYPTO_GHASH=y
 CONFIG_CRYPTO_MD4=y
 CONFIG_CRYPTO_MD5=y
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
 CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA1_MB is not set
 CONFIG_CRYPTO_SHA256=y
 CONFIG_CRYPTO_SHA512=y
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
 
 #
 # Ciphers
 #
 CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
-# CONFIG_CRYPTO_ARC4 is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_BLOWFISH_COMMON=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST_COMMON=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
 
 #
 # Compression
 #
 CONFIG_CRYPTO_DEFLATE=y
-# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_ZLIB=m
 CONFIG_CRYPTO_LZO=y
-# CONFIG_CRYPTO_LZ4 is not set
-# CONFIG_CRYPTO_LZ4HC is not set
+CONFIG_CRYPTO_LZ4=m
+CONFIG_CRYPTO_LZ4HC=m
 
 #
 # Random Number Generation
 #
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_DRBG_MENU is not set
-# CONFIG_CRYPTO_USER_API_HASH is not set
-# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
-# CONFIG_CRYPTO_USER_API_RNG is not set
+CONFIG_CRYPTO_ANSI_CPRNG=m
+CONFIG_CRYPTO_DRBG_MENU=m
+CONFIG_CRYPTO_DRBG_HMAC=y
+CONFIG_CRYPTO_DRBG_HASH=y
+CONFIG_CRYPTO_DRBG_CTR=y
+CONFIG_CRYPTO_DRBG=m
+CONFIG_CRYPTO_USER_API=m
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_CRYPTO_USER_API_RNG=m
+CONFIG_CRYPTO_HASH_INFO=y
 # CONFIG_CRYPTO_HW is not set
-# CONFIG_ARM64_CRYPTO is not set
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=m
+CONFIG_CRYPTO_SHA2_ARM64_CE=m
+CONFIG_CRYPTO_GHASH_ARM64_CE=m
+CONFIG_CRYPTO_AES_ARM64_CE=m
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=m
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=m
+CONFIG_CRYPTO_AES_ARM64_NEON_BLK=m
+CONFIG_CRYPTO_CRC32_ARM64=m
+CONFIG_ASYMMETRIC_KEY_TYPE=m
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=m
+CONFIG_PUBLIC_KEY_ALGO_RSA=m
+CONFIG_X509_CERTIFICATE_PARSER=m
+CONFIG_PKCS7_MESSAGE_PARSER=m
+CONFIG_PKCS7_TEST_KEY=m
+CONFIG_HAVE_KVM=y
+# CONFIG_VIRTUALIZATION is not set
 # CONFIG_BINARY_PRINTF is not set
 
 #

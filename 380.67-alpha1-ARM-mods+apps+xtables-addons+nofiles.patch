--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/config_base.6a
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/config_base.6a
@@ -416,7 +416,7 @@
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 CONFIG_IP_ADVANCED_ROUTER=y
-# CONFIG_IP_MROUTE_MULTIPLE_TABLES is not set
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
 CONFIG_ASK_IP_FIB_HASH=y
 # CONFIG_IP_FIB_TRIE is not set
 CONFIG_IP_FIB_HASH=y
@@ -486,7 +486,7 @@
 CONFIG_NETFILTER_NETLINK_LOG=y
 CONFIG_NF_CONNTRACK=y
 CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
+CONFIG_NF_CONNTRACK_EVENTS=y
 # CONFIG_NF_CT_PROTO_DCCP is not set
 CONFIG_NF_CT_PROTO_GRE=m
 # CONFIG_NF_CT_PROTO_SCTP is not set
@@ -529,16 +529,25 @@
 CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
 # CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
 # CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
 # CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETFILTER_XT_TARGET_ACCOUNT is not set
+CONFIG_NETFILTER_XT_TARGET_CHAOS=m
+CONFIG_NETFILTER_XT_TARGET_DELUDE=m
+# CONFIG_NETFILTER_XT_TARGET_ECHO is not set
+CONFIG_NETFILTER_XT_TARGET_RAWNAT=m
+CONFIG_NETFILTER_XT_TARGET_STEAL=m
+CONFIG_NETFILTER_XT_TARGET_TARPIT=m
 CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
 # CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
 # CONFIG_NETFILTER_XT_MATCH_LAYER7 is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG is not set
 
 #
 # Xtables matches
 #
 # CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
-# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
 CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
 CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
 CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
@@ -565,9 +574,9 @@
 # CONFIG_NETFILTER_XT_MATCH_REALM is not set
 CONFIG_NETFILTER_XT_MATCH_RECENT=y
 # CONFIG_NETFILTER_XT_MATCH_SCTP is not set
-# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
 CONFIG_NETFILTER_XT_MATCH_STATE=y
-# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
 CONFIG_NETFILTER_XT_MATCH_STRING=y
 CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
 CONFIG_NETFILTER_XT_MATCH_TIME=y
@@ -575,6 +584,13 @@
 CONFIG_NETFILTER_XT_MATCH_WEBSTR=y
 CONFIG_NETFILTER_XT_MATCH_CONDITION=m
 CONFIG_NETFILTER_XT_MATCH_GEOIP=m
+CONFIG_NETFILTER_XT_MATCH_FUZZY=m
+CONFIG_NETFILTER_XT_MATCH_IFACE=m
+CONFIG_NETFILTER_XT_MATCH_IPV4OPTIONS=m
+CONFIG_NETFILTER_XT_MATCH_LSCAN=m
+CONFIG_NETFILTER_XT_MATCH_PKNOCK=m
+CONFIG_NETFILTER_XT_MATCH_PSD=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=m
 CONFIG_IP_SET=m
 CONFIG_IP_SET_MAX=256
 CONFIG_IP_SET_BITMAP_IP=m
@@ -1025,7 +1041,28 @@
 # CONFIG_SCSI_DH is not set
 # CONFIG_SCSI_OSD_INITIATOR is not set
 # CONFIG_ATA is not set
-# CONFIG_MD is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MULTICORE_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=m
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_MULTIPATH_QL is not set
+# CONFIG_DM_MULTIPATH_ST is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
 # CONFIG_FUSION is not set
 
 #
@@ -1240,7 +1277,10 @@
 #
 # PPS support
 #
-# CONFIG_PPS is not set
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_LDISC=m
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -1273,14 +1313,14 @@
 # CONFIG_SOUND is not set
 CONFIG_HID_SUPPORT=y
 CONFIG_HID=m
-# CONFIG_HIDRAW is not set
+CONFIG_HIDRAW=y
 
 #
 # USB Input Devices
 #
 CONFIG_USB_HID=m
 # CONFIG_HID_PID is not set
-# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_HIDDEV=y
 
 #
 # USB HID Boot Protocol drivers
@@ -1427,13 +1467,13 @@
 # CONFIG_USB_SERIAL_AIRCABLE is not set
 # CONFIG_USB_SERIAL_ARK3116 is not set
 # CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
+CONFIG_USB_SERIAL_CH341=m
 # CONFIG_USB_SERIAL_WHITEHEAT is not set
 # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_CP210X is not set
+CONFIG_USB_SERIAL_CP210X=m
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
 # CONFIG_USB_SERIAL_FUNSOFT is not set
 # CONFIG_USB_SERIAL_VISOR is not set
 # CONFIG_USB_SERIAL_IPAQ is not set
@@ -1452,7 +1492,7 @@
 # CONFIG_USB_SERIAL_MOS7840 is not set
 # CONFIG_USB_SERIAL_MOTOROLA is not set
 # CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
+CONFIG_USB_SERIAL_PL2303=m
 # CONFIG_USB_SERIAL_OTI6858 is not set
 # CONFIG_USB_SERIAL_QCAUX is not set
 # CONFIG_USB_SERIAL_QUALCOMM is not set
@@ -1577,8 +1617,11 @@
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
@@ -1626,11 +1669,12 @@
 # CONFIG_JFFS2_CMODE_SIZE is not set
 # CONFIG_JFFS2_CMODE_FAVOURLZO is not set
 # CONFIG_LOGFS is not set
-# CONFIG_CRAMFS is not set
+CONFIG_CRAMFS=m
 CONFIG_SQUASHFS=y
 # CONFIG_SQUASHFS_XATTR is not set
 # CONFIG_SQUASHFS_LZO is not set
 CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
 CONFIG_SQUASHFS_EMBEDDED=y
 CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
 # CONFIG_VXFS_FS is not set
@@ -1823,7 +1867,7 @@
 CONFIG_CRYPTO_ECB=y
 # CONFIG_CRYPTO_LRW is not set
 # CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
+CONFIG_CRYPTO_XTS=m
 
 #
 # Hash modes
@@ -1840,41 +1884,42 @@
 # CONFIG_CRYPTO_MD4 is not set
 CONFIG_CRYPTO_MD5=y
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
 CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
 
 #
 # Ciphers
 #
 CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ANUBIS=m
 CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_DES=m
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
 
 #
 # Compression
 #
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=m
 
 #
 # Random Number Generation
@@ -1882,9 +1927,17 @@
 CONFIG_CRYPTO_ANSI_CPRNG=y
 CONFIG_CRYPTO_HW=y
 # CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X_RNG is not set
 # CONFIG_BINARY_PRINTF is not set
 
 #
+# User-space algorithms
+#
+CONFIG_CRYPTO_USER_API=m
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+
+#
 # Library routines
 #
 CONFIG_BITREVERSE=y
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
@@ -1868,8 +1868,20 @@
 	   are only processed once.  */
 	status = packet[0] & FTDI_STATUS_B0_MASK;
 	if (status != priv->prev_status) {
-		priv->diff_status |= status ^ priv->prev_status;
-		wake_up_interruptible(&priv->delta_msr_wait);
+                char diff_status = status ^ priv->prev_status;
+                priv->diff_status |= diff_status;
+        
+                if (diff_status & FTDI_RS0_RLSD) {
+                        struct tty_struct *tty;
+ 
+                        tty = tty_port_tty_get(&port->port);
+                        if (tty)
+                                usb_serial_handle_dcd_change(port, tty,
+                                                status & FTDI_RS0_RLSD);
+                        tty_kref_put(tty);
+                }
+
+                wake_up_interruptible(&priv->delta_msr_wait);
 		priv->prev_status = status;
 	}
 
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/serial/generic.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/serial/generic.c
@@ -491,6 +491,15 @@
 	struct tty_port *port = &usb_port->port;
 
 	dbg("%s - port %d, status %d", __func__, usb_port->number, status);
+        if (tty) {
+               struct tty_ldisc *ld = tty_ldisc_ref(tty);
+
+               if (ld) {
+                       if (ld->ops->dcd_change)
+                               ld->ops->dcd_change(tty, status, NULL);
+                       tty_ldisc_deref(ld);
+               }
+        }
 
 	if (status)
 		wake_up_interruptible(&port->open_wait);

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/Kconfig
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/Kconfig
@@ -590,6 +590,203 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_TARGET_ACCOUNT
+	tristate '"ACCOUNT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The ACCOUNT target is a high performance accounting system for large
+	  local networks. It allows per-IP accounting in whole prefixes of IPv4
+	  addresses with size of up to /8 without the need to add individual
+	  accouting rule for each IP address.
+
+	  The ACCOUNT is designed to be queried for data every second or at
+	  least every ten seconds. It is written as kernel module to handle high
+	  bandwidths without packet loss.
+
+	  The largest possible subnet size is 24 bit, meaning for example 10.0.0.0/8
+	  network. ACCOUNT uses fixed internal data structures
+	  which speeds up the processing of each packet. Furthermore,
+	  accounting data for one complete 192.168.1.X/24 network takes 4 KB of
+	  memory. Memory for 16 or 24 bit networks is only allocated when
+	  needed.
+
+	  To optimize the kernel<->userspace data transfer a bit more, the
+	  kernel module only transfers information about IPs, where the src/dst
+	  packet counter is not 0. This saves precious kernel time.
+
+	  There is no /proc interface as it would be too slow for continuous access.
+	  The read-and-flush query operation is the fastest, as no internal data
+	  snapshot needs to be created&copied for all data. Use the "read"
+	  operation without flush only for debugging purposes!
+
+	  Usage:
+
+	  ACCOUNT takes two mandatory parameters:
+
+	  --addr network/netmask
+	  where network/netmask is the subnet to account for, in CIDR syntax
+
+	  --tname NAME
+	  where NAME is the name of the table where the accounting information
+	  should be stored
+
+	  The subnet 0.0.0.0/0 is a special case: all data are then stored in the src_bytes
+	  and src_packets structure of slot "0". This is useful if you want
+	  to account the overall traffic to/from your internet provider.
+
+	  The data can be queried using the userspace libxt_ACCOUNT_cl library,
+	  and by the reference implementation to show usage of this library,
+	  the iptaccount(8) tool.
+
+	  Here is an example of use:
+
+	  iptables -A FORWARD -j ACCOUNT --addr 0.0.0.0/0 --tname all_outgoing;
+	  iptables -A FORWARD -j ACCOUNT --addr 192.168.1.0/24 --tname sales;
+
+	  This creates two tables called "all_outgoing" and "sales" which can be
+	  queried using the userspace library/iptaccount tool.
+
+	  Note that this target is non-terminating, the packet destined to it
+	  will continue traversing the chain in which it has been used.
+
+	  Also note that once a table has been defined for specific CIDR address/netmask
+	  block, it can be referenced multiple times using -j ACCOUNT, provided
+	  that both the original table name and address/netmask block are specified.
+
+	  For more information go to http://www.intra2net.com/en/developer/ipt_ACCOUNT/
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_TARGET_CHAOS
+	tristate '"CHAOS" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Causes confusion on the other end by doing odd things with incoming packets.
+	  CHAOS will randomly reply (or not) with one of its configurable subtargets:
+
+	  --delude
+	  Use the REJECT and DELUDE targets as a base to do a sudden or deferred
+	  connection reset, fooling some network scanners to return non-deterministic
+	  (randomly open/closed) results, and in case it is deemed open, it is actually
+	  closed/filtered.
+
+	  --tarpit
+	  Use the REJECT and TARPIT target as a base to hold the connection until it
+	  times out. This consumes conntrack entries when connection tracking is loaded
+	  (which usually is on most machines), and routers inbetween you and the Internet
+	  may fail to do their connection tracking if they have to handle more
+	  connections than they can.
+
+	  The randomness factor of not replying vs. replying can be set during load-time
+	  of the xt_CHAOS module or during runtime in /sys/modules/xt_CHAOS/parameters.
+
+	  See http://jengelh.medozas.de/projects/chaostables/ for more information
+	  about CHAOS, DELUDE and lscan.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_TARGET_DELUDE
+	tristate '"DELUDE" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The DELUDE target will reply to a SYN packet with SYN-ACK, and to all other
+	  packets with an RST. This will terminate the connection much like REJECT, but
+	  network scanners doing TCP half-open discovery can be spoofed to make them
+	  belive the port is open rather than closed/filtered.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_ECHO
+	tristate '"ECHO" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The ECHO target will send back all packets it received. It serves as an
+	  examples for an Xtables target.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_RAWNAT
+	tristate '"RAWNAT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The RAWSNAT and RAWDNAT targets provide stateless network address
+	  translation.
+
+	  The RAWDNAT target will rewrite the destination address in the IP header,
+	  much like the NETMAP target.
+
+	  --to-destination addr[/mask]
+	  Network address to map to. The resulting address will be constructed the
+	  following way: All 'one' bits in the mask are filled in from the new
+	  address. All bits that are zero in the mask are filled in from the
+	  original address.
+
+	  The RAWSNAT target will rewrite the source address in the IP header, much
+	  like the NETMAP target. RAWSNAT (and RAWDNAT) may only be
+	  used in the raw or rawpost tables, but can be used in all chains,
+	  which makes it possible to change the source address either when the packet
+	  enters the machine or when it leaves it. The reason for this table constraint
+	  is that RAWNAT must happen outside of connection tracking.
+
+	  --to-source addr[/mask]
+	  Network address to map to. The resulting address will be constructed the
+	  following way: All 'one' bits in the mask are filled in from the new
+	  address. All bits that are zero in the mask are filled in from the
+	  original address.
+
+	  As an example, changing the destination for packets forwarded from an internal
+	  LAN to the internet:
+
+	  -t raw -A PREROUTING -i lan0 -d 212.201.100.135 -j RAWDNAT --to-destination 199.181.132.250;
+	  -t rawpost -A POSTROUTING -o lan0 -s 199.181.132.250 -j RAWSNAT --to-source 212.201.100.135;
+
+	  Note that changing addresses may influence the route selection! Specifically,
+	  it statically NATs packets, not connections, like the normal DNAT/SNAT targets
+	  would do. Also note that it can transform already-NATed connections, as
+	  said, it is completely external to Netfilter's connection tracking/NAT.
+
+	  If the machine itself generates packets that are to be rawnat'ed, you need a
+	  rule in the OUTPUT chain instead, just like you would with the stateful NAT
+	  targets.
+
+	  It may be necessary that in doing so, you also need an extra RAWSNAT rule, to
+	  override the automatic source address selection that the routing code does
+	  before passing packets to iptables. If the connecting socket has not been
+	  explicitly bound to an address, as is the common mode of operation, the address
+	  that will be chosen is the primary address of the device through which the
+	  packet would be routed with its initial destination address - the address as
+	  seen before any RAWNAT takes place.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_STEAL
+	tristate '"STEAL" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Like the DROP target, but does not throw an error like DROP when used in the
+	  OUTPUT chain.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+	  
+config NETFILTER_XT_TARGET_TARPIT
+	tristate '"TARPIT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Adds a TARPIT target to iptables, which captures and holds
+	  incoming TCP connections using no local per-connection resources.
+	  Connections are accepted, but immediately switched to the persist
+	  state (0 byte window), in which the remote side stops sending data
+	  and asks to continue every 60-240 seconds. Attempts to close the
+	  connection are ignored, forcing the remote side to time out the
+	  connection in 12-24 minutes.
+
+	  This offers similar functionality to LaBrea
+	  <http://www.hackbusters.net/LaBrea/>, but does not require dedicated
+	  hardware or IPs. Any TCP port that you would normally DROP or REJECT
+	  can instead become a tarpit.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+  
 config NETFILTER_XT_TARGET_TCPMSS
 	tristate '"TCPMSS" target support'
 	depends on (IPV6 || IPV6=n)
@@ -1096,6 +1293,350 @@
           <file:Documentation/modules.txt>.  The module will be
           called `ipt_geoip'.  If unsure, say `N'.
 
+config NETFILTER_XT_MATCH_FUZZY
+	tristate '"MATCH" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  This module matches a rate limit based on a fuzzy logic controller (FLC).
+
+	  --lower-limit number
+	  Specifies the lower limit, in packets per second.
+
+	  --upper-limit number
+	  Specifies the upper limit, also in packets per second.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_IFACE
+	tristate '"IFACE" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Allows you to check interface states. First, an interface needs to be selected
+	  for comparison. Exactly one option of the following three must be specified:
+
+	  --iface name
+	  Check the states on the given interface.
+
+	  --dev-in
+	  Check the states on the interface on which the packet came in. If the input
+	  device is not set, because for example you are using -m iface in the OUTPUT
+	  chain, this submatch returns false.
+
+	  --dev-out
+	  Check the states on the interface on which the packet will go out. If the
+	  output device is not set, because for example you are using -m iface in the
+	  INPUT chain, this submatch returns false.
+
+	  Following that, one can select the interface properties to check for:
+
+	  [!] --up, [!] --down
+	  Check the UP flag.
+
+	  [!] --broadcast
+	  Check the BROADCAST flag.
+
+	  [!] --loopback
+	  Check the LOOPBACK flag.
+
+	  [!] --pointtopoint
+	  Check the POINTTOPOINT flag.
+
+	  [!] --running
+	  Check the RUNNING flag. Do NOT rely on it!
+
+	  [!] --noarp, [!] --arp
+	  Check the NOARP flag.
+
+	  [!] --promisc
+	  Check the PROMISC flag.
+
+	  [!] --multicast
+	  Check the MULTICAST flag.
+
+	  [!] --dynamic
+	  Check the DYNAMIC flag.
+
+	  [!] --lower-up
+	  Check the LOWER_UP flag.
+
+	  [!] --dormant
+	  Check the DORMANT flag.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_IPV4OPTIONS
+	tristate '"IPV4OPTIONS" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The "ipv4options" module allows to match against a set of IPv4 header options.
+
+	  --flags [!]symbol[,[!]symbol...]
+	  Specify the options that shall appear or not appear in the header. Each
+	  symbol specification is delimited by a comma, and a '!' can be prefixed to
+	  a symbol to negate its presence. Symbols are either the name of an IPv4 option
+	  or its number. See examples below.
+
+	  --any
+	  By default, all of the flags specified must be present/absent, that is, they
+	  form an AND condition. Use the --any flag instead to use an OR condition
+	  where only at least one symbol spec must be true.
+
+	  Known symbol names (and their number):
+
+	  1 nop
+	  2 security RFC 1108
+	  3 lsrr Loose Source Routing, RFC 791
+	  4 timestamp RFC 781, 791
+	  7 record-route RFC 791
+	  9 ssrr Strict Source Routing, RFC 791
+	  11 mtu-probe RFC 1063
+	  12 mtu-reply RFC 1063
+	  18 traceroute RFC 1393
+	  20 router-alert RFC 2113
+
+	  Examples:
+
+	  Match packets that have both Timestamp and NOP:
+	  -m ipv4options --flags nop,timestamp
+
+	  ~ that have either of Timestamp or NOP, or both:
+	  --flags nop,timestamp --any
+
+	  ~ that have Timestamp and no NOP: --flags '!nop,timestamp'
+
+	  ~ that have either no NOP or a timestamp (or both conditions):
+	  --flags '!nop,timestamp' --any
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_LSCAN
+	tristate '"LSCAN" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Detects simple low-level scan attemps based upon the packet's contents.
+	  (This is different from other implementations, which also try to match the rate of new
+	  connections.) Note that an attempt is only discovered after it has been carried
+	  out, but this information can be used in conjunction with other rules to block
+	  the remote host's future connections. So this match module will match on the
+	  (probably) last packet the remote side will send to your machine.
+
+	  --stealth
+	  Match if the packet did not belong to any known TCP connection
+	  (Stealth/FIN/XMAS/NULL scan).
+
+	  --synscan
+	  Match if the connection was a TCP half-open discovery (SYN scan), i.e. the
+	  connection was torn down after the 2nd packet in the 3-way handshake.
+
+	  --cnscan
+	  Match if the connection was a TCP full open discovery (connect scan), i.e. the
+	  connection was torn down after completion of the 3-way handshake.
+
+	  --grscan
+	  Match if data in the connection only flew in the direction of the remote side,
+	  e.g. if the connection was terminated after a locally running daemon sent its
+	  identification. (E.g. openssh, smtp, ftpd.) This may falsely trigger on
+	  warranted single-direction data flows, usually bulk data transfers such as
+	  FTP DATA connections or IRC DCC. Grab Scan Detection should only be used on
+	  ports where a protocol runs that is guaranteed to do a bidirectional exchange
+	  of bytes.
+
+	  NOTE: Some clients (Windows XP for example) may do what looks like a SYN scan,
+	  so be advised to carefully use xt_lscan in conjunction with blocking rules,
+	  as it may lock out your very own internal network.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+	  
+config NETFILTER_XT_MATCH_PKNOCK
+	tristate '"PKNOCK" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Pknock match implements so-called "port knocking", a stealthy system
+	  for network authentication: a client sends packets to selected
+	  ports in a specific sequence (= simple mode, see example 1 below), or a HMAC
+	  payload to a single port (= complex mode, see example 2 below),
+	  to a target machine that has pknock rule(s) installed. The target machine
+	  then decides whether to unblock or block (again) the pknock-protected port(s).
+	  This can be used, for instance, to avoid brute force
+	  attacks on ssh or ftp services.
+
+	  Example prerequisites:
+
+	  modprobe cn
+
+	  modprobe xt_pknock
+
+	  Example 1 (TCP mode, manual closing of opened port not possible):
+
+	  iptables -P INPUT DROP
+
+	  iptables -A INPUT -p tcp -m pknock --knockports 4002,4001,4004 --strict
+	  --name SSH --time 10 --autoclose 60 --dport 22 -j ACCEPT
+
+	  The rule will allow tcp port 22 for the attempting IP address after the successful reception of TCP SYN packets
+	  to ports 4002, 4001 and 4004, in this order (a.k.a. port-knocking).
+	  Port numbers in the connect sequence must follow the exact specification, no
+	  other ports may be "knocked" inbetween. The rule is named 'SSH', a file of
+	  the same name for tracking port knocking states will be created in
+	  /proc/net/xt_pknock .
+	  Successive port knocks must occur with delay of at most 10 seconds. Port 22 (from the example) will
+	  be automatiaclly dropped after 60 minutes after it was previously allowed.
+
+	  Example 2 (UDP mode, non-replayable and non-spoofable, manual closing
+	  of opened port possible, secure, also called "SPA" = Secure Port
+	  Authorization):
+
+	  iptables -A INPUT -p udp -m pknock --knockports 4000 --name FTP
+	  --opensecret foo --closesecret bar --autoclose 240 -j DROP
+
+	  iptables -A INPUT -p tcp -m pknock --checkip --name FTP --dport 21 -j ACCEPT
+
+	  The first rule will create an "ALLOWED" record in /proc/net/xt_pknock/FTP after
+	  the successful reception of an UDP packet to port 4000. The packet payload must be
+	  constructed as a HMAC256 using "foo" as a key. The HMAC content is the particular 
+	  client's IP address as a 32-bit network byteorder quantity,
+	  plus the number of minutes since the Unix epoch, also as a 32-bit value.
+	  (This is known as Simple Packet Authorization, also called "SPA".)
+	  In such case, any subsequent attempt to connect to port 21 from the client's IP
+	  address will cause such packets to be accepted in the second rule.
+
+	  Similarly, upon reception of an UDP packet constructed the same way, but with
+	  the key "bar", the first rule will remove a previously installed "ALLOWED" state
+	  record from /proc/net/xt_pknock/FTP, which means that the second rule will
+	  stop matching for subsequent connection attempts to port 21.
+	  In case no close-secret packet is received within 4 hours, the first rule
+	  will remove "ALLOWED" record from /proc/net/xt_pknock/FTP itself.
+
+	  Things worth noting:
+
+	  General:
+
+	  Specifying --autoclose 0 means that no automatic close will be performed at all.
+
+	  xt_pknock is capable of sending information about successful matches
+	  via a netlink socket to userspace, should you need to implement your own
+	  way of receiving and handling portknock notifications.
+	  Be sure to read the documentation in the doc/pknock/ directory,
+	  or visit the original site, http://portknocko.berlios.de/ .
+
+	  TCP mode:
+
+	  This mode is not immune against eavesdropping, spoofing and
+	  replaying of the port knock sequence by someone else (but its use may still
+	  be sufficient for scenarios where these factors are not necessarily
+	  this important, such as bare shielding of the SSH port from brute-force attacks).
+	  However, if you need these features, you should use UDP mode.
+
+	  It is always wise to specify three or more ports that are not monotonically
+	  increasing or decreasing with a small stepsize (e.g. 1024,1025,1026)
+	  to avoid accidentally triggering
+	  the rule by a portscan.
+
+	  Specifying the inter-knock timeout with --time is mandatory in TCP mode,
+	  to avoid permanent denial of services by clogging up the peer knock-state tracking table
+	  that xt_pknock internally keeps, should there be a DDoS on the
+	  first-in-row knock port from more hostile IP addresses than what the actual size
+	  of this table is (defaults to 16, can be changed via the "peer_hasht_ents" module parameter).
+	  It is also wise to use as short a time as possible (1 second) for --time
+	  for this very reason. You may also consider increasing the size
+	  of the peer knock-state tracking table. Using --strict also helps,
+	  as it requires the knock sequence to be exact. This means that if the
+	  hostile client sends more knocks to the same port, xt_pknock will
+	  mark such attempt as failed knock sequence and will forget it immediately.
+	  To completely thwart this kind of DDoS, knock-ports would need to have
+	  an additional rate-limit protection. Or you may consider using UDP mode.
+
+	  UDP mode:
+
+	  This mode is immune against eavesdropping, replaying and spoofing attacks.
+	  It is also immune against DDoS attack on the knockport.
+
+	  For this mode to work, the clock difference on the client and on the server
+	  must be below 1 minute. Synchronizing time on both ends by means
+	  of NTP or rdate is strongly suggested.
+
+	  There is a rate limiter built into xt_pknock which blocks any subsequent
+	  open attempt in UDP mode should the request arrive within less than one
+	  minute since the first successful open. This is intentional;
+	  it thwarts eventual spoofing attacks.
+
+	  Because the payload value of an UDP knock packet is influenced by client's IP address,
+	  UDP mode cannot be used across NAT.
+
+	  For sending UDP "SPA" packets, you may use either knock.sh or
+	  knock-orig.sh. These may be found in doc/pknock/util.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_PSD
+	tristate '"PSD" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Attempt to detect TCP and UDP port scans. This match was derived from
+	  Solar Designer's scanlogd.
+
+	  --psd-weight-threshold threshold
+	  Total weight of the latest TCP/UDP packets with different
+	  destination ports coming from the same host to be treated as port
+	  scan sequence.
+
+	  --psd-delay-threshold delay
+	  Delay (in hundredths of second) for the packets with different
+	  destination ports coming from the same host to be treated as
+	  possible port scan subsequence.
+
+	  --psd-lo-ports-weight weight
+	  Weight of the packet with privileged (<=1024) destination port.
+
+	  --psd-hi-ports-weight weight
+	  Weight of the packet with non-priviliged destination port.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_QUOTA2
+	tristate '"QUOTA2" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The "quota2" implements a named counter which can be increased or decreased
+	  on a per-match basis. Available modes are packet counting or byte counting.
+	  The value of the counter can be read and reset through procfs, thereby making
+	  this match a minimalist accounting tool.
+
+	  When counting down from the initial quota, the counter will stop at 0 and
+	  the match will return false, just like the original "quota" match. In growing
+	  (upcounting) mode, it will always return true.
+
+	  --grow
+	  Count upwards instead of downwards.
+
+	  --no-change
+	  Makes it so the counter or quota amount is never changed by packets matching
+	  this rule. This is only really useful in "quota" mode, as it will allow you to
+	  use complex prerouting rules in association with the quota system, without
+	  counting a packet twice.
+
+	  --name name
+	  Assign the counter a specific name. This option must be present, as an empty
+	  name is not allowed. Names starting with a dot or names containing a slash are
+	  prohibited.
+
+	  [!] --quota iq
+	  Specify the initial quota for this counter. If the counter already exists,
+	  it is not reset. An "!" may be used to invert the result of the match. The
+	  negation has no effect when --grow is used.
+
+	  --packets
+	  Count packets instead of bytes that passed the quota2 match.
+
+	  Because counters in quota2 can be shared, you can combine them for various
+	  purposes, for example, a bytebucket filter that only lets as much traffic go
+	  out as has come in:
+
+	  -A INPUT -p tcp --dport 6881 -m quota --name bt --grow;
+	  -A OUTPUT -p tcp --sport 6881 -m quota --name bt;
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
 endif # NETFILTER_XTABLES
 
 endmenu

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/Makefile
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/Makefile
@@ -40,6 +40,7 @@
 
 # generic X tables 
 obj-$(CONFIG_NETFILTER_XTABLES) += x_tables.o xt_tcpudp.o
+obj-y += compat_xtables.o
 
 # combos
 obj-$(CONFIG_NETFILTER_XT_MARK) += xt_mark.o
@@ -61,6 +62,14 @@
 obj-$(CONFIG_NETFILTER_XT_TARGET_RATEEST) += xt_RATEEST.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_SECMARK) += xt_SECMARK.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TPROXY) += xt_TPROXY.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_CHAOS) += xt_CHAOS.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_DELUDE) += xt_DELUDE.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_RAWNAT) += xt_RAWNAT.o iptable_rawpost.o
+ifneq (${CONFIG_IP6_NF_IPTABLES},)
+obj-${CONFIG_NETFILTER_XT_TARGET_RAWNAT} += ip6table_rawpost.o
+endif
+obj-$(CONFIG_NETFILTER_XT_TARGET_STEAL) += xt_STEAL.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_TARPIT) += xt_TARPIT.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TCPMSS) += xt_TCPMSS.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP) += xt_TCPOPTSTRIP.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TEE) += xt_TEE.o
@@ -109,6 +118,13 @@
 obj-$(CONFIG_NETFILTER_XT_MATCH_CONDITION) += xt_condition.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_GEOIP) += xt_geoip.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_ETHPORT) += xt_ethport.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_FUZZY) += xt_fuzzy.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_IFACE) += xt_iface.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_IPV4OPTIONS) += xt_ipv4options.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_LSCAN) += xt_lscan.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PKNOCK) += xt_pknock.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PSD) += xt_psd.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_QUOTA2) += xt_quota2.o
 
 # ipset
 obj-$(CONFIG_IP_SET) += ipset/
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/Kconfig
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/Kconfig
@@ -66,6 +66,28 @@
 
 	  If unsure, say N.
 
+config SQUASHFS_4K_DEVBLK_SIZE
+	bool "Use 4K device block size?"
+	depends on SQUASHFS
+	help
+	  By default Squashfs sets the dev block size (sb_min_blocksize)
+	  to 1K or the smallest block size supported by the block device
+	  (if larger).  This, because blocks are packed together and
+	  unaligned in Squashfs, should reduce latency.
+
+	  This, however, gives poor performance on MTD NAND devices where
+	  the optimal I/O size is 4K (even though the devices can support
+	  smaller block sizes).
+
+	  Using a 4K device block size may also improve overall I/O
+	  performance for some file access patterns (e.g. sequential
+	  accesses of files in filesystem order) on all media.
+
+	  Setting this option will force Squashfs to use a 4K device block
+	  size by default.
+
+	  If unsure, say N.
+
 config SQUASHFS_EMBEDDED
 	bool "Additional option for memory-constrained systems"
 	depends on SQUASHFS
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
@@ -37,6 +37,13 @@
 #define SQUASHFS_FILE_SIZE		131072
 #define SQUASHFS_FILE_LOG		17
 
+/* default size of block device I/O */
+#ifdef CONFIG_SQUASHFS_4K_DEVBLK_SIZE
+#define SQUASHFS_DEVBLK_SIZE 4096
+#else
+#define SQUASHFS_DEVBLK_SIZE 1024
+#endif
+
 #define SQUASHFS_FILE_MAX_SIZE		1048576
 #define SQUASHFS_FILE_MAX_LOG		20
 
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/super.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/super.c
@@ -102,7 +102,7 @@
 		goto failure;
 	}
 
-	msblk->devblksize = sb_min_blocksize(sb, BLOCK_SIZE);
+	msblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);
 	msblk->devblksize_log2 = ffz(~msblk->devblksize);
 
 	mutex_init(&msblk->read_data_mutex);
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/Makefile
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/Makefile
@@ -85,6 +85,9 @@
 obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
 obj-$(CONFIG_CRYPTO_GHASH) += ghash-generic.o
+obj-$(CONFIG_CRYPTO_USER_API) += af_alg.o
+obj-$(CONFIG_CRYPTO_USER_API_HASH) += algif_hash.o
+obj-$(CONFIG_CRYPTO_USER_API_SKCIPHER) += algif_skcipher.o
 
 #
 # generic algorithms and the async_tx api
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/Kconfig
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/Kconfig
@@ -842,6 +842,27 @@
 	  ANSI X9.31 A.2.4. Note that this option must be enabled if
 	  CRYPTO_FIPS is selected
 
+config CRYPTO_USER_API
+	tristate
+
+config CRYPTO_USER_API_HASH
+	tristate "User-space interface for hash algorithms"
+	depends on NET
+	select CRYPTO_HASH
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for hash
+	  algorithms.
+
+config CRYPTO_USER_API_SKCIPHER
+	tristate "User-space interface for symmetric key cipher algorithms"
+	depends on NET
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for symmetric
+	  key cipher algorithms.
+
 source "drivers/crypto/Kconfig"
 
 endif	# if CRYPTO
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/af_alg.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/af_alg.c
@@ -0,0 +1,483 @@
+/*
+ * af_alg: User-space algorithm interface
+ *
+ * This file provides the user-space API for algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <asm/atomic.h>
+#include <crypto/if_alg.h>
+#include <linux/crypto.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/rwsem.h>
+
+struct alg_type_list {
+	const struct af_alg_type *type;
+	struct list_head list;
+};
+
+static atomic_long_t alg_memory_allocated;
+
+static struct proto alg_proto = {
+	.name			= "ALG",
+	.owner			= THIS_MODULE,
+	.memory_allocated	= &alg_memory_allocated,
+	.obj_size		= sizeof(struct alg_sock),
+};
+
+static LIST_HEAD(alg_types);
+static DECLARE_RWSEM(alg_types_sem);
+
+static const struct af_alg_type *alg_get_type(const char *name)
+{
+	const struct af_alg_type *type = ERR_PTR(-ENOENT);
+	struct alg_type_list *node;
+
+	down_read(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, name))
+			continue;
+
+		if (try_module_get(node->type->owner))
+			type = node->type;
+		break;
+	}
+	up_read(&alg_types_sem);
+
+	return type;
+}
+
+int af_alg_register_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -EEXIST;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (!strcmp(node->type->name, type->name))
+			goto unlock;
+	}
+
+	node = kmalloc(sizeof(*node), GFP_KERNEL);
+	err = -ENOMEM;
+	if (!node)
+		goto unlock;
+
+	type->ops->owner = THIS_MODULE;
+	node->type = type;
+	list_add(&node->list, &alg_types);
+	err = 0;
+
+unlock:
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_register_type);
+
+int af_alg_unregister_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -ENOENT;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, type->name))
+			continue;
+
+		list_del(&node->list);
+		kfree(node);
+		err = 0;
+		break;
+	}
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_unregister_type);
+
+static void alg_do_release(const struct af_alg_type *type, void *private)
+{
+	if (!type)
+		return;
+
+	type->release(private);
+	module_put(type->owner);
+}
+
+int af_alg_release(struct socket *sock)
+{
+	if (sock->sk)
+		sock_put(sock->sk);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_release);
+
+static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct sockaddr_alg *sa = (void *)uaddr;
+	const struct af_alg_type *type;
+	void *private;
+
+	if (sock->state == SS_CONNECTED)
+		return -EINVAL;
+
+	if (addr_len != sizeof(*sa))
+		return -EINVAL;
+
+	sa->salg_type[sizeof(sa->salg_type) - 1] = 0;
+	sa->salg_name[sizeof(sa->salg_name) - 1] = 0;
+
+	type = alg_get_type(sa->salg_type);
+	if (IS_ERR(type) && PTR_ERR(type) == -ENOENT) {
+		request_module("algif-%s", sa->salg_type);
+		type = alg_get_type(sa->salg_type);
+	}
+
+	if (IS_ERR(type))
+		return PTR_ERR(type);
+
+	private = type->bind(sa->salg_name, sa->salg_feat, sa->salg_mask);
+	if (IS_ERR(private)) {
+		module_put(type->owner);
+		return PTR_ERR(private);
+	}
+
+	lock_sock(sk);
+
+	swap(ask->type, type);
+	swap(ask->private, private);
+
+	release_sock(sk);
+
+	alg_do_release(type, private);
+
+	return 0;
+}
+
+static int alg_setkey(struct sock *sk, char __user *ukey,
+		      unsigned int keylen)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type = ask->type;
+	u8 *key;
+	int err;
+
+	key = sock_kmalloc(sk, keylen, GFP_KERNEL);
+	if (!key)
+		return -ENOMEM;
+
+	err = -EFAULT;
+	if (copy_from_user(key, ukey, keylen))
+		goto out;
+
+	err = type->setkey(ask->private, key, keylen);
+
+out:
+	sock_kfree_s(sk, key, keylen);
+
+	return err;
+}
+
+static int alg_setsockopt(struct socket *sock, int level, int optname,
+			  char __user *optval, unsigned int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	int err = -ENOPROTOOPT;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	if (level != SOL_ALG || !type)
+		goto unlock;
+
+	switch (optname) {
+	case ALG_SET_KEY:
+		if (sock->state == SS_CONNECTED)
+			goto unlock;
+		if (!type->setkey)
+			goto unlock;
+
+		err = alg_setkey(sk, optval, optlen);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+
+int af_alg_accept(struct sock *sk, struct socket *newsock)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	struct sock *sk2;
+	int err;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	err = -EINVAL;
+	if (!type)
+		goto unlock;
+
+	sk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto);
+	err = -ENOMEM;
+	if (!sk2)
+		goto unlock;
+
+	sock_init_data(newsock, sk2);
+	sock_graft(sk2, newsock);
+
+	err = type->accept(ask->private, sk2);
+	if (err) {
+		sk_free(sk2);
+		goto unlock;
+	}
+
+	sk2->sk_family = PF_ALG;
+
+	sock_hold(sk);
+	alg_sk(sk2)->parent = sk;
+	alg_sk(sk2)->type = type;
+
+	newsock->ops = type->ops;
+	newsock->state = SS_CONNECTED;
+
+	err = 0;
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_accept);
+
+static int alg_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	return af_alg_accept(sock->sk, newsock);
+}
+
+static const struct proto_ops alg_proto_ops = {
+	.family		=	PF_ALG,
+	.owner		=	THIS_MODULE,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.sendpage	=	sock_no_sendpage,
+	.sendmsg	=	sock_no_sendmsg,
+	.recvmsg	=	sock_no_recvmsg,
+	.poll		=	sock_no_poll,
+
+	.bind		=	alg_bind,
+	.release	=	af_alg_release,
+	.setsockopt	=	alg_setsockopt,
+	.accept		=	alg_accept,
+};
+
+static void alg_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+
+	alg_do_release(ask->type, ask->private);
+}
+
+static int alg_create(struct net *net, struct socket *sock, int protocol,
+		      int kern)
+{
+	struct sock *sk;
+	int err;
+
+	if (sock->type != SOCK_SEQPACKET)
+		return -ESOCKTNOSUPPORT;
+	if (protocol != 0)
+		return -EPROTONOSUPPORT;
+
+	err = -ENOMEM;
+	sk = sk_alloc(net, PF_ALG, GFP_KERNEL, &alg_proto);
+	if (!sk)
+		goto out;
+
+	sock->ops = &alg_proto_ops;
+	sock_init_data(sock, sk);
+
+	sk->sk_family = PF_ALG;
+	sk->sk_destruct = alg_sock_destruct;
+
+	return 0;
+out:
+	return err;
+}
+
+static const struct net_proto_family alg_family = {
+	.family	=	PF_ALG,
+	.create	=	alg_create,
+	.owner	=	THIS_MODULE,
+};
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write)
+{
+	unsigned long from = (unsigned long)addr;
+	unsigned long npages;
+	unsigned off;
+	int err;
+	int i;
+
+	err = -EFAULT;
+	if (!access_ok(write ? VERIFY_READ : VERIFY_WRITE, addr, len))
+		goto out;
+
+	off = from & ~PAGE_MASK;
+	npages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	if (npages > ALG_MAX_PAGES)
+		npages = ALG_MAX_PAGES;
+
+	err = get_user_pages_fast(from, npages, write, sgl->pages);
+	if (err < 0)
+		goto out;
+
+	npages = err;
+	err = -EINVAL;
+	if (WARN_ON(npages == 0))
+		goto out;
+
+	err = 0;
+
+	sg_init_table(sgl->sg, npages);
+
+	for (i = 0; i < npages; i++) {
+		int plen = min_t(int, len, PAGE_SIZE - off);
+
+		sg_set_page(sgl->sg + i, sgl->pages[i], plen, off);
+
+		off = 0;
+		len -= plen;
+		err += plen;
+	}
+
+out:
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_make_sg);
+
+void af_alg_free_sg(struct af_alg_sgl *sgl)
+{
+	int i;
+
+	i = 0;
+	do {
+		put_page(sgl->pages[i]);
+	} while (!sg_is_last(sgl->sg + (i++)));
+}
+EXPORT_SYMBOL_GPL(af_alg_free_sg);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con)
+{
+	struct cmsghdr *cmsg;
+
+	for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
+		if (!CMSG_OK(msg, cmsg))
+			return -EINVAL;
+		if (cmsg->cmsg_level != SOL_ALG)
+			continue;
+
+		switch(cmsg->cmsg_type) {
+		case ALG_SET_IV:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(*con->iv)))
+				return -EINVAL;
+			con->iv = (void *)CMSG_DATA(cmsg);
+			if (cmsg->cmsg_len < CMSG_LEN(con->iv->ivlen +
+						      sizeof(*con->iv)))
+				return -EINVAL;
+			break;
+
+		case ALG_SET_OP:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))
+				return -EINVAL;
+			con->op = *(u32 *)CMSG_DATA(cmsg);
+			break;
+
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_cmsg_send);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion)
+{
+	switch (err) {
+	case -EINPROGRESS:
+	case -EBUSY:
+		wait_for_completion(&completion->completion);
+		INIT_COMPLETION(completion->completion);
+		err = completion->err;
+		break;
+	};
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_wait_for_completion);
+
+void af_alg_complete(struct crypto_async_request *req, int err)
+{
+	struct af_alg_completion *completion = req->data;
+
+	completion->err = err;
+	complete(&completion->completion);
+}
+EXPORT_SYMBOL_GPL(af_alg_complete);
+
+static int __init af_alg_init(void)
+{
+	int err = proto_register(&alg_proto, 0);
+
+	if (err)
+		goto out;
+
+	err = sock_register(&alg_family);
+	if (err != 0)
+		goto out_unregister_proto;
+
+out:
+	return err;
+
+out_unregister_proto:
+	proto_unregister(&alg_proto);
+	goto out;
+}
+
+static void __exit af_alg_exit(void)
+{
+	sock_unregister(PF_ALG);
+	proto_unregister(&alg_proto);
+}
+
+module_init(af_alg_init);
+module_exit(af_alg_exit);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_NETPROTO(AF_ALG);
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/algif_hash.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/algif_hash.c
@@ -0,0 +1,319 @@
+/*
+ * algif_hash: User-space interface for hash algorithms
+ *
+ * This file provides the user-space API for hash algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/hash.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct hash_ctx {
+	struct af_alg_sgl sgl;
+
+	u8 *result;
+
+	struct af_alg_completion completion;
+
+	unsigned int len;
+	bool more;
+
+	struct ahash_request req;
+};
+
+static int hash_sendmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t ignored)
+{
+	int limit = ALG_MAX_PAGES * PAGE_SIZE;
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned long iovlen;
+	struct iovec *iov;
+	long copied = 0;
+	int err;
+
+	if (limit > sk->sk_sndbuf)
+		limit = sk->sk_sndbuf;
+
+	lock_sock(sk);
+	if (!ctx->more) {
+		err = crypto_ahash_init(&ctx->req);
+		if (err)
+			goto unlock;
+	}
+
+	ctx->more = 0;
+
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			int len = min_t(unsigned long, seglen, limit);
+			int newlen;
+
+			newlen = af_alg_make_sg(&ctx->sgl, from, len, 0);
+			if (newlen < 0)
+				goto unlock;
+
+			ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL,
+						newlen);
+
+			err = af_alg_wait_for_completion(
+				crypto_ahash_update(&ctx->req),
+				&ctx->completion);
+
+			af_alg_free_sg(&ctx->sgl);
+
+			if (err)
+				goto unlock;
+
+			seglen -= newlen;
+			from += newlen;
+			copied += newlen;
+		}
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more) {
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err ?: copied;
+}
+
+static ssize_t hash_sendpage(struct socket *sock, struct page *page,
+			     int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	int err;
+
+	lock_sock(sk);
+	sg_init_table(ctx->sgl.sg, 1);
+	sg_set_page(ctx->sgl.sg, page, size, offset);
+
+	ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, ctx->result, size);
+
+	if (!(flags & MSG_MORE)) {
+		if (ctx->more)
+			err = crypto_ahash_finup(&ctx->req);
+		else
+			err = crypto_ahash_digest(&ctx->req);
+	} else {
+		if (!ctx->more) {
+			err = crypto_ahash_init(&ctx->req);
+			if (err)
+				goto unlock;
+		}
+
+		err = crypto_ahash_update(&ctx->req);
+	}
+
+	err = af_alg_wait_for_completion(err, &ctx->completion);
+	if (err)
+		goto unlock;
+
+	ctx->more = flags & MSG_MORE;
+
+unlock:
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t len, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
+	int err;
+
+	if (len > ds)
+		len = ds;
+	else if (len < ds)
+		msg->msg_flags |= MSG_TRUNC;
+
+	lock_sock(sk);
+	if (ctx->more) {
+		ctx->more = 0;
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+		if (err)
+			goto unlock;
+	}
+
+	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);
+
+unlock:
+	release_sock(sk);
+
+	return err ?: len;
+}
+
+static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	struct ahash_request *req = &ctx->req;
+	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];
+	struct sock *sk2;
+	struct alg_sock *ask2;
+	struct hash_ctx *ctx2;
+	int err;
+
+	err = crypto_ahash_export(req, state);
+	if (err)
+		return err;
+
+	err = af_alg_accept(ask->parent, newsock);
+	if (err)
+		return err;
+
+	sk2 = newsock->sk;
+	ask2 = alg_sk(sk2);
+	ctx2 = ask2->private;
+	ctx2->more = 1;
+
+	err = crypto_ahash_import(&ctx2->req, state);
+	if (err) {
+		sock_orphan(sk2);
+		sock_put(sk2);
+	}
+
+	return err;
+}
+
+static struct proto_ops algif_hash_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.setsockopt	=	sock_no_setsockopt,
+	.poll		=	sock_no_poll,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	hash_sendmsg,
+	.sendpage	=	hash_sendpage,
+	.recvmsg	=	hash_recvmsg,
+	.accept		=	hash_accept,
+};
+
+static void *hash_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ahash(name, type, mask);
+}
+
+static void hash_release(void *private)
+{
+	crypto_free_ahash(private);
+}
+
+static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ahash_setkey(private, key, keylen);
+}
+
+static void hash_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+
+	sock_kfree_s(sk, ctx->result,
+		     crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int hash_accept_parent(void *private, struct sock *sk)
+{
+	struct hash_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);
+	unsigned ds = crypto_ahash_digestsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);
+	if (!ctx->result) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->result, 0, ds);
+
+	ctx->len = len;
+	ctx->more = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ahash_request_set_tfm(&ctx->req, private);
+	ahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				   af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = hash_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_hash = {
+	.bind		=	hash_bind,
+	.release	=	hash_release,
+	.setkey		=	hash_setkey,
+	.accept		=	hash_accept_parent,
+	.ops		=	&algif_hash_ops,
+	.name		=	"hash",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_hash_init(void)
+{
+	return af_alg_register_type(&algif_type_hash);
+}
+
+static void __exit algif_hash_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_hash);
+	BUG_ON(err);
+}
+
+module_init(algif_hash_init);
+module_exit(algif_hash_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/algif_skcipher.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/algif_skcipher.c
@@ -0,0 +1,632 @@
+/*
+ * algif_skcipher: User-space interface for skcipher algorithms
+ *
+ * This file provides the user-space API for symmetric key ciphers.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/scatterwalk.h>
+#include <crypto/skcipher.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct skcipher_sg_list {
+	struct list_head list;
+
+	int cur;
+
+	struct scatterlist sg[0];
+};
+
+struct skcipher_ctx {
+	struct list_head tsgl;
+	struct af_alg_sgl rsgl;
+
+	void *iv;
+
+	struct af_alg_completion completion;
+
+	unsigned used;
+
+	unsigned int len;
+	bool more;
+	bool merge;
+	bool enc;
+
+	struct ablkcipher_request req;
+};
+
+#define MAX_SGL_ENTS ((PAGE_SIZE - sizeof(struct skcipher_sg_list)) / \
+		      sizeof(struct scatterlist) - 1)
+
+static inline int skcipher_sndbuf(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	return max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -
+			  ctx->used, 0);
+}
+
+static inline bool skcipher_writable(struct sock *sk)
+{
+	return PAGE_SIZE <= skcipher_sndbuf(sk);
+}
+
+static int skcipher_alloc_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg = NULL;
+
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+	if (!list_empty(&ctx->tsgl))
+		sg = sgl->sg;
+
+	if (!sg || sgl->cur >= MAX_SGL_ENTS) {
+		sgl = sock_kmalloc(sk, sizeof(*sgl) +
+				       sizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),
+				   GFP_KERNEL);
+		if (!sgl)
+			return -ENOMEM;
+
+		sg_init_table(sgl->sg, MAX_SGL_ENTS + 1);
+		sgl->cur = 0;
+
+		if (sg)
+			scatterwalk_sg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);
+
+		list_add_tail(&sgl->list, &ctx->tsgl);
+	}
+
+	return 0;
+}
+
+static void skcipher_pull_sgl(struct sock *sk, int used)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	int i;
+
+	while (!list_empty(&ctx->tsgl)) {
+		sgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,
+				       list);
+		sg = sgl->sg;
+
+		for (i = 0; i < sgl->cur; i++) {
+			int plen = min_t(int, used, sg[i].length);
+
+			if (!sg_page(sg + i))
+				continue;
+
+			sg[i].length -= plen;
+			sg[i].offset += plen;
+
+			used -= plen;
+			ctx->used -= plen;
+
+			if (sg[i].length)
+				return;
+
+			put_page(sg_page(sg + i));
+			sg_assign_page(sg + i, NULL);
+		}
+
+		list_del(&sgl->list);
+		sock_kfree_s(sk, sgl,
+			     sizeof(*sgl) + sizeof(sgl->sg[0]) *
+					    (MAX_SGL_ENTS + 1));
+	}
+
+	if (!ctx->used)
+		ctx->merge = 0;
+}
+
+static void skcipher_free_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	skcipher_pull_sgl(sk, ctx->used);
+}
+
+static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)
+{
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT)
+		return -EAGAIN;
+
+	set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	return err;
+}
+
+static void skcipher_wmem_wakeup(struct sock *sk)
+{
+	struct socket_wq *wq;
+
+	if (!skcipher_writable(sk))
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLIN |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
+	rcu_read_unlock();
+}
+
+static int skcipher_wait_for_data(struct sock *sk, unsigned flags)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT) {
+		return -EAGAIN;
+	}
+
+	set_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, ctx->used)) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	return err;
+}
+
+static void skcipher_data_wakeup(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct socket_wq *wq;
+
+	if (!ctx->used)
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLOUT |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);
+	rcu_read_unlock();
+}
+
+static int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+	unsigned ivsize = crypto_ablkcipher_ivsize(tfm);
+	struct skcipher_sg_list *sgl;
+	struct af_alg_control con = {};
+	long copied = 0;
+	bool enc = 0;
+	int err;
+	int i;
+
+	if (msg->msg_controllen) {
+		err = af_alg_cmsg_send(msg, &con);
+		if (err)
+			return err;
+
+		switch (con.op) {
+		case ALG_OP_ENCRYPT:
+			enc = 1;
+			break;
+		case ALG_OP_DECRYPT:
+			enc = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (con.iv && con.iv->ivlen != ivsize)
+			return -EINVAL;
+	}
+
+	err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!ctx->used) {
+		ctx->enc = enc;
+		if (con.iv)
+			memcpy(ctx->iv, con.iv->iv, ivsize);
+	}
+
+	while (size) {
+		struct scatterlist *sg;
+		unsigned long len = size;
+		int plen;
+
+		if (ctx->merge) {
+			sgl = list_entry(ctx->tsgl.prev,
+					 struct skcipher_sg_list, list);
+			sg = sgl->sg + sgl->cur - 1;
+			len = min_t(unsigned long, len,
+				    PAGE_SIZE - sg->offset - sg->length);
+
+			err = memcpy_fromiovec(page_address(sg_page(sg)) +
+					       sg->offset + sg->length,
+					       msg->msg_iov, len);
+			if (err)
+				goto unlock;
+
+			sg->length += len;
+			ctx->merge = (sg->offset + sg->length) &
+				     (PAGE_SIZE - 1);
+
+			ctx->used += len;
+			copied += len;
+			size -= len;
+			continue;
+		}
+
+		if (!skcipher_writable(sk)) {
+			err = skcipher_wait_for_wmem(sk, msg->msg_flags);
+			if (err)
+				goto unlock;
+		}
+
+		len = min_t(unsigned long, len, skcipher_sndbuf(sk));
+
+		err = skcipher_alloc_sgl(sk);
+		if (err)
+			goto unlock;
+
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+		sg = sgl->sg;
+		do {
+			i = sgl->cur;
+			plen = min_t(int, len, PAGE_SIZE);
+
+			sg_assign_page(sg + i, alloc_page(GFP_KERNEL));
+			err = -ENOMEM;
+			if (!sg_page(sg + i))
+				goto unlock;
+
+			err = memcpy_fromiovec(page_address(sg_page(sg + i)),
+					       msg->msg_iov, plen);
+			if (err) {
+				__free_page(sg_page(sg + i));
+				sg_assign_page(sg + i, NULL);
+				goto unlock;
+			}
+
+			sg[i].length = plen;
+			len -= plen;
+			ctx->used += plen;
+			copied += plen;
+			size -= plen;
+			sgl->cur++;
+		} while (len && sgl->cur < MAX_SGL_ENTS);
+
+		ctx->merge = plen & (PAGE_SIZE - 1);
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+static ssize_t skcipher_sendpage(struct socket *sock, struct page *page,
+				 int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	int err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!size)
+		goto done;
+
+	if (!skcipher_writable(sk)) {
+		err = skcipher_wait_for_wmem(sk, flags);
+		if (err)
+			goto unlock;
+	}
+
+	err = skcipher_alloc_sgl(sk);
+	if (err)
+		goto unlock;
+
+	ctx->merge = 0;
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+	get_page(page);
+	sg_set_page(sgl->sg + sgl->cur, page, size, offset);
+	sgl->cur++;
+	ctx->used += size;
+
+done:
+	ctx->more = flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t ignored, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(
+		&ctx->req));
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	unsigned long iovlen;
+	struct iovec *iov;
+	int err = -EAGAIN;
+	int used;
+	long copied = 0;
+
+	lock_sock(sk);
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			sgl = list_first_entry(&ctx->tsgl,
+					       struct skcipher_sg_list, list);
+			sg = sgl->sg;
+
+			while (!sg->length)
+				sg++;
+
+			used = ctx->used;
+			if (!used) {
+				err = skcipher_wait_for_data(sk, flags);
+				if (err)
+					goto unlock;
+			}
+
+			used = min_t(unsigned long, used, seglen);
+
+			used = af_alg_make_sg(&ctx->rsgl, from, used, 1);
+			err = used;
+			if (err < 0)
+				goto unlock;
+
+			if (ctx->more || used < ctx->used)
+				used -= used % bs;
+
+			err = -EINVAL;
+			if (!used)
+				goto free;
+
+			ablkcipher_request_set_crypt(&ctx->req, sg,
+						     ctx->rsgl.sg, used,
+						     ctx->iv);
+
+			err = af_alg_wait_for_completion(
+				ctx->enc ?
+					crypto_ablkcipher_encrypt(&ctx->req) :
+					crypto_ablkcipher_decrypt(&ctx->req),
+				&ctx->completion);
+
+free:
+			af_alg_free_sg(&ctx->rsgl);
+
+			if (err)
+				goto unlock;
+
+			copied += used;
+			from += used;
+			seglen -= used;
+			skcipher_pull_sgl(sk, used);
+		}
+	}
+
+	err = 0;
+
+unlock:
+	skcipher_wmem_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+
+static unsigned int skcipher_poll(struct file *file, struct socket *sock,
+				  poll_table *wait)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned int mask;
+
+	sock_poll_wait(file, sk_sleep(sk), wait);
+	mask = 0;
+
+	if (ctx->used)
+		mask |= POLLIN | POLLRDNORM;
+
+	if (skcipher_writable(sk))
+		mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
+
+	return mask;
+}
+
+static struct proto_ops algif_skcipher_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.accept		=	sock_no_accept,
+	.setsockopt	=	sock_no_setsockopt,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	skcipher_sendmsg,
+	.sendpage	=	skcipher_sendpage,
+	.recvmsg	=	skcipher_recvmsg,
+	.poll		=	skcipher_poll,
+};
+
+static void *skcipher_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ablkcipher(name, type, mask);
+}
+
+static void skcipher_release(void *private)
+{
+	crypto_free_ablkcipher(private);
+}
+
+static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ablkcipher_setkey(private, key, keylen);
+}
+
+static void skcipher_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+
+	skcipher_free_sgl(sk);
+	sock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int skcipher_accept_parent(void *private, struct sock *sk)
+{
+	struct skcipher_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),
+			       GFP_KERNEL);
+	if (!ctx->iv) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));
+
+	INIT_LIST_HEAD(&ctx->tsgl);
+	ctx->len = len;
+	ctx->used = 0;
+	ctx->more = 0;
+	ctx->merge = 0;
+	ctx->enc = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ablkcipher_request_set_tfm(&ctx->req, private);
+	ablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = skcipher_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_skcipher = {
+	.bind		=	skcipher_bind,
+	.release	=	skcipher_release,
+	.setkey		=	skcipher_setkey,
+	.accept		=	skcipher_accept_parent,
+	.ops		=	&algif_skcipher_ops,
+	.name		=	"skcipher",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_skcipher_init(void)
+{
+	return af_alg_register_type(&algif_type_skcipher);
+}
+
+static void __exit algif_skcipher_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_skcipher);
+	BUG_ON(err);
+}
+
+module_init(algif_skcipher_init);
+module_exit(algif_skcipher_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/core/sock.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/core/sock.c
@@ -157,7 +157,7 @@
   "sk_lock-27"       , "sk_lock-28"          , "sk_lock-AF_CAN"      ,
   "sk_lock-AF_TIPC"  , "sk_lock-AF_BLUETOOTH", "sk_lock-IUCV"        ,
   "sk_lock-AF_RXRPC" , "sk_lock-AF_ISDN"     , "sk_lock-AF_PHONET"   ,
-  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" ,
+  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" , "sk_lock-AF_ALG"      ,
   "sk_lock-AF_MAX"
 };
 static const char *const af_family_slock_key_strings[AF_MAX+1] = {
@@ -173,7 +173,7 @@
   "slock-27"       , "slock-28"          , "slock-AF_CAN"      ,
   "slock-AF_TIPC"  , "slock-AF_BLUETOOTH", "slock-AF_IUCV"     ,
   "slock-AF_RXRPC" , "slock-AF_ISDN"     , "slock-AF_PHONET"   ,
-  "slock-AF_IEEE802154", "slock-AF_CAIF" ,
+  "slock-AF_IEEE802154", "slock-AF_CAIF" , "slock-AF_ALG"      ,
   "slock-AF_MAX"
 };
 static const char *const af_family_clock_key_strings[AF_MAX+1] = {
@@ -189,7 +189,7 @@
   "clock-27"       , "clock-28"          , "clock-AF_CAN"      ,
   "clock-AF_TIPC"  , "clock-AF_BLUETOOTH", "clock-AF_IUCV"     ,
   "clock-AF_RXRPC" , "clock-AF_ISDN"     , "clock-AF_PHONET"   ,
-  "clock-AF_IEEE802154", "clock-AF_CAIF" ,
+  "clock-AF_IEEE802154", "clock-AF_CAIF" , "clock-AF_ALG"      ,
   "clock-AF_MAX"
 };
 
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/crypto/if_alg.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/crypto/if_alg.h
@@ -0,0 +1,92 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _CRYPTO_IF_ALG_H
+#define _CRYPTO_IF_ALG_H
+
+#include <linux/compiler.h>
+#include <linux/completion.h>
+#include <linux/if_alg.h>
+#include <linux/types.h>
+#include <net/sock.h>
+
+#define ALG_MAX_PAGES			16
+
+struct crypto_async_request;
+
+struct alg_sock {
+	/* struct sock must be the first member of struct alg_sock */
+	struct sock sk;
+
+	struct sock *parent;
+
+	const struct af_alg_type *type;
+	void *private;
+};
+
+struct af_alg_completion {
+	struct completion completion;
+	int err;
+};
+
+struct af_alg_control {
+	struct af_alg_iv *iv;
+	int op;
+};
+
+struct af_alg_type {
+	void *(*bind)(const char *name, u32 type, u32 mask);
+	void (*release)(void *private);
+	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
+	int (*accept)(void *private, struct sock *sk);
+
+	struct proto_ops *ops;
+	struct module *owner;
+	char name[14];
+};
+
+struct af_alg_sgl {
+	struct scatterlist sg[ALG_MAX_PAGES];
+	struct page *pages[ALG_MAX_PAGES];
+};
+
+int af_alg_register_type(const struct af_alg_type *type);
+int af_alg_unregister_type(const struct af_alg_type *type);
+
+int af_alg_release(struct socket *sock);
+int af_alg_accept(struct sock *sk, struct socket *newsock);
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write);
+void af_alg_free_sg(struct af_alg_sgl *sgl);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion);
+void af_alg_complete(struct crypto_async_request *req, int err);
+
+static inline struct alg_sock *alg_sk(struct sock *sk)
+{
+	return (struct alg_sock *)sk;
+}
+
+static inline void af_alg_release_parent(struct sock *sk)
+{
+	sock_put(alg_sk(sk)->parent);
+}
+
+static inline void af_alg_init_completion(struct af_alg_completion *completion)
+{
+	init_completion(&completion->completion);
+}
+
+#endif	/* _CRYPTO_IF_ALG_H */
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/crypto/scatterwalk.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/crypto/scatterwalk.h
@@ -68,6 +68,21 @@
 	return (++sg)->length ? sg : (void *)sg_page(sg);
 }
 
+static inline void scatterwalk_crypto_chain(struct scatterlist *head,
+					    struct scatterlist *sg,
+					    int chain, int num)
+{
+	if (chain) {
+		head->length += sg->length;
+		sg = scatterwalk_sg_next(sg);
+	}
+
+	if (sg)
+		scatterwalk_sg_chain(head, num, sg);
+	else
+		sg_mark_end(head);
+}
+
 static inline unsigned long scatterwalk_samebuf(struct scatter_walk *walk_in,
 						struct scatter_walk *walk_out)
 {
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/if_alg.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/if_alg.h
@@ -0,0 +1,40 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _LINUX_IF_ALG_H
+#define _LINUX_IF_ALG_H
+
+#include <linux/types.h>
+
+struct sockaddr_alg {
+	__u16	salg_family;
+	__u8	salg_type[14];
+	__u32	salg_feat;
+	__u32	salg_mask;
+	__u8	salg_name[64];
+};
+
+struct af_alg_iv {
+	__u32	ivlen;
+	__u8	iv[0];
+};
+
+/* Socket options */
+#define ALG_SET_KEY			1
+#define ALG_SET_IV			2
+#define ALG_SET_OP			3
+
+/* Operations */
+#define ALG_OP_DECRYPT			0
+#define ALG_OP_ENCRYPT			1
+
+#endif	/* _LINUX_IF_ALG_H */
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/socket.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/socket.h
@@ -193,7 +193,8 @@
 #define AF_PHONET	35	/* Phonet sockets		*/
 #define AF_IEEE802154	36	/* IEEE802154 sockets		*/
 #define AF_CAIF		37	/* CAIF sockets			*/
-#define AF_MAX		38	/* For now.. */
+#define AF_ALG		38	/* Algorithm sockets		*/
+#define AF_MAX		39	/* For now.. */
 
 /* Protocol families, same as address families. */
 #define PF_UNSPEC	AF_UNSPEC
@@ -234,6 +235,7 @@
 #define PF_PHONET	AF_PHONET
 #define PF_IEEE802154	AF_IEEE802154
 #define PF_CAIF		AF_CAIF
+#define PF_ALG		AF_ALG
 #define PF_MAX		AF_MAX
 
 /* Maximum queue length specifiable by listen.  */
@@ -310,6 +312,7 @@
 #define SOL_RDS		276
 #define SOL_IUCV	277
 #define SOL_CAIF	278
+#define SOL_ALG		279
 
 /* IPX options */
 #define IPX_TYPE	1
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/config_base.6a
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/config_base.6a
@@ -500,7 +500,7 @@
 CONFIG_NETFILTER_NETLINK_LOG=y
 CONFIG_NF_CONNTRACK=y
 CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
+CONFIG_NF_CONNTRACK_EVENTS=y
 # CONFIG_NF_CT_PROTO_DCCP is not set
 CONFIG_NF_CT_PROTO_GRE=m
 # CONFIG_NF_CT_PROTO_SCTP is not set
@@ -543,15 +543,25 @@
 CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
 # CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
 # CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
 # CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETFILTER_XT_TARGET_ACCOUNT is not set
+CONFIG_NETFILTER_XT_TARGET_CHAOS=m
+CONFIG_NETFILTER_XT_TARGET_DELUDE=m
+# CONFIG_NETFILTER_XT_TARGET_ECHO is not set
+CONFIG_NETFILTER_XT_TARGET_RAWNAT=m
+CONFIG_NETFILTER_XT_TARGET_STEAL=m
+CONFIG_NETFILTER_XT_TARGET_TARPIT=m
 CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
 # CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7 is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG is not set
 
 #
 # Xtables matches
 #
 # CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
-# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
 CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
 CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
 CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
@@ -578,9 +588,9 @@
 # CONFIG_NETFILTER_XT_MATCH_REALM is not set
 CONFIG_NETFILTER_XT_MATCH_RECENT=y
 # CONFIG_NETFILTER_XT_MATCH_SCTP is not set
-# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
 CONFIG_NETFILTER_XT_MATCH_STATE=y
-# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
 CONFIG_NETFILTER_XT_MATCH_STRING=y
 CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
 CONFIG_NETFILTER_XT_MATCH_TIME=y
@@ -588,6 +598,13 @@
 CONFIG_NETFILTER_XT_MATCH_WEBSTR=y
 CONFIG_NETFILTER_XT_MATCH_CONDITION=m
 CONFIG_NETFILTER_XT_MATCH_GEOIP=m
+CONFIG_NETFILTER_XT_MATCH_FUZZY=m
+CONFIG_NETFILTER_XT_MATCH_IFACE=m
+CONFIG_NETFILTER_XT_MATCH_IPV4OPTIONS=m
+CONFIG_NETFILTER_XT_MATCH_LSCAN=m
+CONFIG_NETFILTER_XT_MATCH_PKNOCK=m
+CONFIG_NETFILTER_XT_MATCH_PSD=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=m
 CONFIG_IP_SET=m
 CONFIG_IP_SET_MAX=256
 CONFIG_IP_SET_BITMAP_IP=m
@@ -1052,7 +1069,28 @@
 # CONFIG_SATA_INIC162X is not set
 # CONFIG_SATA_SIL24 is not set
 # CONFIG_ATA_SFF is not set
-# CONFIG_MD is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MULTICORE_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=m
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_MULTIPATH_QL is not set
+# CONFIG_DM_MULTIPATH_ST is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
 # CONFIG_FUSION is not set
 
 #
@@ -1269,7 +1307,10 @@
 #
 # PPS support
 #
-# CONFIG_PPS is not set
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_LDISC=m
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -1302,14 +1343,14 @@
 # CONFIG_SOUND is not set
 CONFIG_HID_SUPPORT=y
 CONFIG_HID=m
-# CONFIG_HIDRAW is not set
+CONFIG_HIDRAW=y
 
 #
 # USB Input Devices
 #
 CONFIG_USB_HID=m
 # CONFIG_HID_PID is not set
-# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_HIDDEV=y
 
 #
 # USB HID Boot Protocol drivers
@@ -1456,13 +1497,13 @@
 # CONFIG_USB_SERIAL_AIRCABLE is not set
 # CONFIG_USB_SERIAL_ARK3116 is not set
 # CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
+CONFIG_USB_SERIAL_CH341=m
 # CONFIG_USB_SERIAL_WHITEHEAT is not set
 # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_CP210X is not set
+CONFIG_USB_SERIAL_CP210X=m
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
 # CONFIG_USB_SERIAL_FUNSOFT is not set
 # CONFIG_USB_SERIAL_VISOR is not set
 # CONFIG_USB_SERIAL_IPAQ is not set
@@ -1481,7 +1522,7 @@
 # CONFIG_USB_SERIAL_MOS7840 is not set
 # CONFIG_USB_SERIAL_MOTOROLA is not set
 # CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
+CONFIG_USB_SERIAL_PL2303=m
 # CONFIG_USB_SERIAL_OTI6858 is not set
 # CONFIG_USB_SERIAL_QCAUX is not set
 # CONFIG_USB_SERIAL_QUALCOMM is not set
@@ -1606,8 +1647,11 @@
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
@@ -1656,11 +1700,12 @@
 # CONFIG_JFFS2_CMODE_SIZE is not set
 # CONFIG_JFFS2_CMODE_FAVOURLZO is not set
 # CONFIG_LOGFS is not set
-# CONFIG_CRAMFS is not set
+CONFIG_CRAMFS=m
 CONFIG_SQUASHFS=y
 # CONFIG_SQUASHFS_XATTR is not set
 # CONFIG_SQUASHFS_LZO is not set
 CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
 CONFIG_SQUASHFS_EMBEDDED=y
 CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
 # CONFIG_VXFS_FS is not set
@@ -1853,7 +1898,7 @@
 CONFIG_CRYPTO_ECB=y
 # CONFIG_CRYPTO_LRW is not set
 # CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
+CONFIG_CRYPTO_XTS=m
 
 #
 # Hash modes
@@ -1870,41 +1915,42 @@
 # CONFIG_CRYPTO_MD4 is not set
 CONFIG_CRYPTO_MD5=y
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
 CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
 
 #
 # Ciphers
 #
 CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ANUBIS=m
 CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_DES=m
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
 
 #
 # Compression
 #
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=m
 
 #
 # Random Number Generation
@@ -1912,9 +1958,17 @@
 CONFIG_CRYPTO_ANSI_CPRNG=y
 CONFIG_CRYPTO_HW=y
 # CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X_RNG is not set
 # CONFIG_BINARY_PRINTF is not set
 
 #
+# User-space algorithms
+#
+CONFIG_CRYPTO_USER_API=m
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+
+#
 # Library routines
 #
 CONFIG_BITREVERSE=y
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
@@ -1868,8 +1868,20 @@
 	   are only processed once.  */
 	status = packet[0] & FTDI_STATUS_B0_MASK;
 	if (status != priv->prev_status) {
-		priv->diff_status |= status ^ priv->prev_status;
-		wake_up_interruptible(&priv->delta_msr_wait);
+                char diff_status = status ^ priv->prev_status;
+                priv->diff_status |= diff_status;
+        
+                if (diff_status & FTDI_RS0_RLSD) {
+                        struct tty_struct *tty;
+ 
+                        tty = tty_port_tty_get(&port->port);
+                        if (tty)
+                                usb_serial_handle_dcd_change(port, tty,
+                                                status & FTDI_RS0_RLSD);
+                        tty_kref_put(tty);
+                }
+
+                wake_up_interruptible(&priv->delta_msr_wait);
 		priv->prev_status = status;
 	}
 
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/serial/generic.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/serial/generic.c
@@ -491,6 +491,15 @@
 	struct tty_port *port = &usb_port->port;
 
 	dbg("%s - port %d, status %d", __func__, usb_port->number, status);
+        if (tty) {
+               struct tty_ldisc *ld = tty_ldisc_ref(tty);
+
+               if (ld) {
+                       if (ld->ops->dcd_change)
+                               ld->ops->dcd_change(tty, status, NULL);
+                       tty_ldisc_deref(ld);
+               }
+        }
 
 	if (status)
 		wake_up_interruptible(&port->open_wait);

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/Kconfig
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/Kconfig
@@ -589,7 +589,204 @@
 	  packets, for use with security subsystems.
 
 	  To compile it as a module, choose M here.  If unsure, say N.
+	  
+config NETFILTER_XT_TARGET_ACCOUNT
+	tristate '"ACCOUNT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The ACCOUNT target is a high performance accounting system for large
+	  local networks. It allows per-IP accounting in whole prefixes of IPv4
+	  addresses with size of up to /8 without the need to add individual
+	  accouting rule for each IP address.
+
+	  The ACCOUNT is designed to be queried for data every second or at
+	  least every ten seconds. It is written as kernel module to handle high
+	  bandwidths without packet loss.
+
+	  The largest possible subnet size is 24 bit, meaning for example 10.0.0.0/8
+	  network. ACCOUNT uses fixed internal data structures
+	  which speeds up the processing of each packet. Furthermore,
+	  accounting data for one complete 192.168.1.X/24 network takes 4 KB of
+	  memory. Memory for 16 or 24 bit networks is only allocated when
+	  needed.
+
+	  To optimize the kernel<->userspace data transfer a bit more, the
+	  kernel module only transfers information about IPs, where the src/dst
+	  packet counter is not 0. This saves precious kernel time.
+
+	  There is no /proc interface as it would be too slow for continuous access.
+	  The read-and-flush query operation is the fastest, as no internal data
+	  snapshot needs to be created&copied for all data. Use the "read"
+	  operation without flush only for debugging purposes!
+
+	  Usage:
+
+	  ACCOUNT takes two mandatory parameters:
+
+	  --addr network/netmask
+	  where network/netmask is the subnet to account for, in CIDR syntax
+
+	  --tname NAME
+	  where NAME is the name of the table where the accounting information
+	  should be stored
+
+	  The subnet 0.0.0.0/0 is a special case: all data are then stored in the src_bytes
+	  and src_packets structure of slot "0". This is useful if you want
+	  to account the overall traffic to/from your internet provider.
+
+	  The data can be queried using the userspace libxt_ACCOUNT_cl library,
+	  and by the reference implementation to show usage of this library,
+	  the iptaccount(8) tool.
+
+	  Here is an example of use:
+
+	  iptables -A FORWARD -j ACCOUNT --addr 0.0.0.0/0 --tname all_outgoing;
+	  iptables -A FORWARD -j ACCOUNT --addr 192.168.1.0/24 --tname sales;
+
+	  This creates two tables called "all_outgoing" and "sales" which can be
+	  queried using the userspace library/iptaccount tool.
+
+	  Note that this target is non-terminating, the packet destined to it
+	  will continue traversing the chain in which it has been used.
+
+	  Also note that once a table has been defined for specific CIDR address/netmask
+	  block, it can be referenced multiple times using -j ACCOUNT, provided
+	  that both the original table name and address/netmask block are specified.
+
+	  For more information go to http://www.intra2net.com/en/developer/ipt_ACCOUNT/
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_TARGET_CHAOS
+	tristate '"CHAOS" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Causes confusion on the other end by doing odd things with incoming packets.
+	  CHAOS will randomly reply (or not) with one of its configurable subtargets:
+
+	  --delude
+	  Use the REJECT and DELUDE targets as a base to do a sudden or deferred
+	  connection reset, fooling some network scanners to return non-deterministic
+	  (randomly open/closed) results, and in case it is deemed open, it is actually
+	  closed/filtered.
+
+	  --tarpit
+	  Use the REJECT and TARPIT target as a base to hold the connection until it
+	  times out. This consumes conntrack entries when connection tracking is loaded
+	  (which usually is on most machines), and routers inbetween you and the Internet
+	  may fail to do their connection tracking if they have to handle more
+	  connections than they can.
+
+	  The randomness factor of not replying vs. replying can be set during load-time
+	  of the xt_CHAOS module or during runtime in /sys/modules/xt_CHAOS/parameters.
+
+	  See http://jengelh.medozas.de/projects/chaostables/ for more information
+	  about CHAOS, DELUDE and lscan.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_TARGET_DELUDE
+	tristate '"DELUDE" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The DELUDE target will reply to a SYN packet with SYN-ACK, and to all other
+	  packets with an RST. This will terminate the connection much like REJECT, but
+	  network scanners doing TCP half-open discovery can be spoofed to make them
+	  belive the port is open rather than closed/filtered.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_ECHO
+	tristate '"ECHO" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The ECHO target will send back all packets it received. It serves as an
+	  examples for an Xtables target.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_RAWNAT
+	tristate '"RAWNAT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The RAWSNAT and RAWDNAT targets provide stateless network address
+	  translation.
+
+	  The RAWDNAT target will rewrite the destination address in the IP header,
+	  much like the NETMAP target.
+
+	  --to-destination addr[/mask]
+	  Network address to map to. The resulting address will be constructed the
+	  following way: All 'one' bits in the mask are filled in from the new
+	  address. All bits that are zero in the mask are filled in from the
+	  original address.
+
+	  The RAWSNAT target will rewrite the source address in the IP header, much
+	  like the NETMAP target. RAWSNAT (and RAWDNAT) may only be
+	  used in the raw or rawpost tables, but can be used in all chains,
+	  which makes it possible to change the source address either when the packet
+	  enters the machine or when it leaves it. The reason for this table constraint
+	  is that RAWNAT must happen outside of connection tracking.
+
+	  --to-source addr[/mask]
+	  Network address to map to. The resulting address will be constructed the
+	  following way: All 'one' bits in the mask are filled in from the new
+	  address. All bits that are zero in the mask are filled in from the
+	  original address.
+
+	  As an example, changing the destination for packets forwarded from an internal
+	  LAN to the internet:
+
+	  -t raw -A PREROUTING -i lan0 -d 212.201.100.135 -j RAWDNAT --to-destination 199.181.132.250;
+	  -t rawpost -A POSTROUTING -o lan0 -s 199.181.132.250 -j RAWSNAT --to-source 212.201.100.135;
+
+	  Note that changing addresses may influence the route selection! Specifically,
+	  it statically NATs packets, not connections, like the normal DNAT/SNAT targets
+	  would do. Also note that it can transform already-NATed connections, as
+	  said, it is completely external to Netfilter's connection tracking/NAT.
+
+	  If the machine itself generates packets that are to be rawnat'ed, you need a
+	  rule in the OUTPUT chain instead, just like you would with the stateful NAT
+	  targets.
+
+	  It may be necessary that in doing so, you also need an extra RAWSNAT rule, to
+	  override the automatic source address selection that the routing code does
+	  before passing packets to iptables. If the connecting socket has not been
+	  explicitly bound to an address, as is the common mode of operation, the address
+	  that will be chosen is the primary address of the device through which the
+	  packet would be routed with its initial destination address - the address as
+	  seen before any RAWNAT takes place.
 
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_STEAL
+	tristate '"STEAL" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Like the DROP target, but does not throw an error like DROP when used in the
+	  OUTPUT chain.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+	  
+config NETFILTER_XT_TARGET_TARPIT
+	tristate '"TARPIT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Adds a TARPIT target to iptables, which captures and holds
+	  incoming TCP connections using no local per-connection resources.
+	  Connections are accepted, but immediately switched to the persist
+	  state (0 byte window), in which the remote side stops sending data
+	  and asks to continue every 60-240 seconds. Attempts to close the
+	  connection are ignored, forcing the remote side to time out the
+	  connection in 12-24 minutes.
+
+	  This offers similar functionality to LaBrea
+	  <http://www.hackbusters.net/LaBrea/>, but does not require dedicated
+	  hardware or IPs. Any TCP port that you would normally DROP or REJECT
+	  can instead become a tarpit.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+	  
 config NETFILTER_XT_TARGET_TCPMSS
 	tristate '"TCPMSS" target support'
 	depends on (IPV6 || IPV6=n)
@@ -1117,6 +1314,350 @@
           <file:Documentation/modules.txt>.  The module will be
           called `ipt_geoip'.  If unsure, say `N'.
 
+config NETFILTER_XT_MATCH_FUZZY
+	tristate '"MATCH" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  This module matches a rate limit based on a fuzzy logic controller (FLC).
+
+	  --lower-limit number
+	  Specifies the lower limit, in packets per second.
+
+	  --upper-limit number
+	  Specifies the upper limit, also in packets per second.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_IFACE
+	tristate '"IFACE" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Allows you to check interface states. First, an interface needs to be selected
+	  for comparison. Exactly one option of the following three must be specified:
+
+	  --iface name
+	  Check the states on the given interface.
+
+	  --dev-in
+	  Check the states on the interface on which the packet came in. If the input
+	  device is not set, because for example you are using -m iface in the OUTPUT
+	  chain, this submatch returns false.
+
+	  --dev-out
+	  Check the states on the interface on which the packet will go out. If the
+	  output device is not set, because for example you are using -m iface in the
+	  INPUT chain, this submatch returns false.
+
+	  Following that, one can select the interface properties to check for:
+
+	  [!] --up, [!] --down
+	  Check the UP flag.
+
+	  [!] --broadcast
+	  Check the BROADCAST flag.
+
+	  [!] --loopback
+	  Check the LOOPBACK flag.
+
+	  [!] --pointtopoint
+	  Check the POINTTOPOINT flag.
+
+	  [!] --running
+	  Check the RUNNING flag. Do NOT rely on it!
+
+	  [!] --noarp, [!] --arp
+	  Check the NOARP flag.
+
+	  [!] --promisc
+	  Check the PROMISC flag.
+
+	  [!] --multicast
+	  Check the MULTICAST flag.
+
+	  [!] --dynamic
+	  Check the DYNAMIC flag.
+
+	  [!] --lower-up
+	  Check the LOWER_UP flag.
+
+	  [!] --dormant
+	  Check the DORMANT flag.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_IPV4OPTIONS
+	tristate '"IPV4OPTIONS" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The "ipv4options" module allows to match against a set of IPv4 header options.
+
+	  --flags [!]symbol[,[!]symbol...]
+	  Specify the options that shall appear or not appear in the header. Each
+	  symbol specification is delimited by a comma, and a '!' can be prefixed to
+	  a symbol to negate its presence. Symbols are either the name of an IPv4 option
+	  or its number. See examples below.
+
+	  --any
+	  By default, all of the flags specified must be present/absent, that is, they
+	  form an AND condition. Use the --any flag instead to use an OR condition
+	  where only at least one symbol spec must be true.
+
+	  Known symbol names (and their number):
+
+	  1 nop
+	  2 security RFC 1108
+	  3 lsrr Loose Source Routing, RFC 791
+	  4 timestamp RFC 781, 791
+	  7 record-route RFC 791
+	  9 ssrr Strict Source Routing, RFC 791
+	  11 mtu-probe RFC 1063
+	  12 mtu-reply RFC 1063
+	  18 traceroute RFC 1393
+	  20 router-alert RFC 2113
+
+	  Examples:
+
+	  Match packets that have both Timestamp and NOP:
+	  -m ipv4options --flags nop,timestamp
+
+	  ~ that have either of Timestamp or NOP, or both:
+	  --flags nop,timestamp --any
+
+	  ~ that have Timestamp and no NOP: --flags '!nop,timestamp'
+
+	  ~ that have either no NOP or a timestamp (or both conditions):
+	  --flags '!nop,timestamp' --any
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_LSCAN
+	tristate '"LSCAN" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Detects simple low-level scan attemps based upon the packet's contents.
+	  (This is different from other implementations, which also try to match the rate of new
+	  connections.) Note that an attempt is only discovered after it has been carried
+	  out, but this information can be used in conjunction with other rules to block
+	  the remote host's future connections. So this match module will match on the
+	  (probably) last packet the remote side will send to your machine.
+
+	  --stealth
+	  Match if the packet did not belong to any known TCP connection
+	  (Stealth/FIN/XMAS/NULL scan).
+
+	  --synscan
+	  Match if the connection was a TCP half-open discovery (SYN scan), i.e. the
+	  connection was torn down after the 2nd packet in the 3-way handshake.
+
+	  --cnscan
+	  Match if the connection was a TCP full open discovery (connect scan), i.e. the
+	  connection was torn down after completion of the 3-way handshake.
+
+	  --grscan
+	  Match if data in the connection only flew in the direction of the remote side,
+	  e.g. if the connection was terminated after a locally running daemon sent its
+	  identification. (E.g. openssh, smtp, ftpd.) This may falsely trigger on
+	  warranted single-direction data flows, usually bulk data transfers such as
+	  FTP DATA connections or IRC DCC. Grab Scan Detection should only be used on
+	  ports where a protocol runs that is guaranteed to do a bidirectional exchange
+	  of bytes.
+
+	  NOTE: Some clients (Windows XP for example) may do what looks like a SYN scan,
+	  so be advised to carefully use xt_lscan in conjunction with blocking rules,
+	  as it may lock out your very own internal network.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+	  
+config NETFILTER_XT_MATCH_PKNOCK
+	tristate '"PKNOCK" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Pknock match implements so-called "port knocking", a stealthy system
+	  for network authentication: a client sends packets to selected
+	  ports in a specific sequence (= simple mode, see example 1 below), or a HMAC
+	  payload to a single port (= complex mode, see example 2 below),
+	  to a target machine that has pknock rule(s) installed. The target machine
+	  then decides whether to unblock or block (again) the pknock-protected port(s).
+	  This can be used, for instance, to avoid brute force
+	  attacks on ssh or ftp services.
+
+	  Example prerequisites:
+
+	  modprobe cn
+
+	  modprobe xt_pknock
+
+	  Example 1 (TCP mode, manual closing of opened port not possible):
+
+	  iptables -P INPUT DROP
+
+	  iptables -A INPUT -p tcp -m pknock --knockports 4002,4001,4004 --strict
+	  --name SSH --time 10 --autoclose 60 --dport 22 -j ACCEPT
+
+	  The rule will allow tcp port 22 for the attempting IP address after the successful reception of TCP SYN packets
+	  to ports 4002, 4001 and 4004, in this order (a.k.a. port-knocking).
+	  Port numbers in the connect sequence must follow the exact specification, no
+	  other ports may be "knocked" inbetween. The rule is named 'SSH', a file of
+	  the same name for tracking port knocking states will be created in
+	  /proc/net/xt_pknock .
+	  Successive port knocks must occur with delay of at most 10 seconds. Port 22 (from the example) will
+	  be automatiaclly dropped after 60 minutes after it was previously allowed.
+
+	  Example 2 (UDP mode, non-replayable and non-spoofable, manual closing
+	  of opened port possible, secure, also called "SPA" = Secure Port
+	  Authorization):
+
+	  iptables -A INPUT -p udp -m pknock --knockports 4000 --name FTP
+	  --opensecret foo --closesecret bar --autoclose 240 -j DROP
+
+	  iptables -A INPUT -p tcp -m pknock --checkip --name FTP --dport 21 -j ACCEPT
+
+	  The first rule will create an "ALLOWED" record in /proc/net/xt_pknock/FTP after
+	  the successful reception of an UDP packet to port 4000. The packet payload must be
+	  constructed as a HMAC256 using "foo" as a key. The HMAC content is the particular 
+	  client's IP address as a 32-bit network byteorder quantity,
+	  plus the number of minutes since the Unix epoch, also as a 32-bit value.
+	  (This is known as Simple Packet Authorization, also called "SPA".)
+	  In such case, any subsequent attempt to connect to port 21 from the client's IP
+	  address will cause such packets to be accepted in the second rule.
+
+	  Similarly, upon reception of an UDP packet constructed the same way, but with
+	  the key "bar", the first rule will remove a previously installed "ALLOWED" state
+	  record from /proc/net/xt_pknock/FTP, which means that the second rule will
+	  stop matching for subsequent connection attempts to port 21.
+	  In case no close-secret packet is received within 4 hours, the first rule
+	  will remove "ALLOWED" record from /proc/net/xt_pknock/FTP itself.
+
+	  Things worth noting:
+
+	  General:
+
+	  Specifying --autoclose 0 means that no automatic close will be performed at all.
+
+	  xt_pknock is capable of sending information about successful matches
+	  via a netlink socket to userspace, should you need to implement your own
+	  way of receiving and handling portknock notifications.
+	  Be sure to read the documentation in the doc/pknock/ directory,
+	  or visit the original site, http://portknocko.berlios.de/ .
+
+	  TCP mode:
+
+	  This mode is not immune against eavesdropping, spoofing and
+	  replaying of the port knock sequence by someone else (but its use may still
+	  be sufficient for scenarios where these factors are not necessarily
+	  this important, such as bare shielding of the SSH port from brute-force attacks).
+	  However, if you need these features, you should use UDP mode.
+
+	  It is always wise to specify three or more ports that are not monotonically
+	  increasing or decreasing with a small stepsize (e.g. 1024,1025,1026)
+	  to avoid accidentally triggering
+	  the rule by a portscan.
+
+	  Specifying the inter-knock timeout with --time is mandatory in TCP mode,
+	  to avoid permanent denial of services by clogging up the peer knock-state tracking table
+	  that xt_pknock internally keeps, should there be a DDoS on the
+	  first-in-row knock port from more hostile IP addresses than what the actual size
+	  of this table is (defaults to 16, can be changed via the "peer_hasht_ents" module parameter).
+	  It is also wise to use as short a time as possible (1 second) for --time
+	  for this very reason. You may also consider increasing the size
+	  of the peer knock-state tracking table. Using --strict also helps,
+	  as it requires the knock sequence to be exact. This means that if the
+	  hostile client sends more knocks to the same port, xt_pknock will
+	  mark such attempt as failed knock sequence and will forget it immediately.
+	  To completely thwart this kind of DDoS, knock-ports would need to have
+	  an additional rate-limit protection. Or you may consider using UDP mode.
+
+	  UDP mode:
+
+	  This mode is immune against eavesdropping, replaying and spoofing attacks.
+	  It is also immune against DDoS attack on the knockport.
+
+	  For this mode to work, the clock difference on the client and on the server
+	  must be below 1 minute. Synchronizing time on both ends by means
+	  of NTP or rdate is strongly suggested.
+
+	  There is a rate limiter built into xt_pknock which blocks any subsequent
+	  open attempt in UDP mode should the request arrive within less than one
+	  minute since the first successful open. This is intentional;
+	  it thwarts eventual spoofing attacks.
+
+	  Because the payload value of an UDP knock packet is influenced by client's IP address,
+	  UDP mode cannot be used across NAT.
+
+	  For sending UDP "SPA" packets, you may use either knock.sh or
+	  knock-orig.sh. These may be found in doc/pknock/util.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_PSD
+	tristate '"PSD" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Attempt to detect TCP and UDP port scans. This match was derived from
+	  Solar Designer's scanlogd.
+
+	  --psd-weight-threshold threshold
+	  Total weight of the latest TCP/UDP packets with different
+	  destination ports coming from the same host to be treated as port
+	  scan sequence.
+
+	  --psd-delay-threshold delay
+	  Delay (in hundredths of second) for the packets with different
+	  destination ports coming from the same host to be treated as
+	  possible port scan subsequence.
+
+	  --psd-lo-ports-weight weight
+	  Weight of the packet with privileged (<=1024) destination port.
+
+	  --psd-hi-ports-weight weight
+	  Weight of the packet with non-priviliged destination port.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_QUOTA2
+	tristate '"QUOTA2" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The "quota2" implements a named counter which can be increased or decreased
+	  on a per-match basis. Available modes are packet counting or byte counting.
+	  The value of the counter can be read and reset through procfs, thereby making
+	  this match a minimalist accounting tool.
+
+	  When counting down from the initial quota, the counter will stop at 0 and
+	  the match will return false, just like the original "quota" match. In growing
+	  (upcounting) mode, it will always return true.
+
+	  --grow
+	  Count upwards instead of downwards.
+
+	  --no-change
+	  Makes it so the counter or quota amount is never changed by packets matching
+	  this rule. This is only really useful in "quota" mode, as it will allow you to
+	  use complex prerouting rules in association with the quota system, without
+	  counting a packet twice.
+
+	  --name name
+	  Assign the counter a specific name. This option must be present, as an empty
+	  name is not allowed. Names starting with a dot or names containing a slash are
+	  prohibited.
+
+	  [!] --quota iq
+	  Specify the initial quota for this counter. If the counter already exists,
+	  it is not reset. An "!" may be used to invert the result of the match. The
+	  negation has no effect when --grow is used.
+
+	  --packets
+	  Count packets instead of bytes that passed the quota2 match.
+
+	  Because counters in quota2 can be shared, you can combine them for various
+	  purposes, for example, a bytebucket filter that only lets as much traffic go
+	  out as has come in:
+
+	  -A INPUT -p tcp --dport 6881 -m quota --name bt --grow;
+	  -A OUTPUT -p tcp --sport 6881 -m quota --name bt;
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
 endif # NETFILTER_XTABLES
 
 endmenu

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/Makefile
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/Makefile
@@ -40,6 +40,7 @@
 
 # generic X tables 
 obj-$(CONFIG_NETFILTER_XTABLES) += x_tables.o xt_tcpudp.o
+obj-y += compat_xtables.o
 
 # combos
 obj-$(CONFIG_NETFILTER_XT_MARK) += xt_mark.o
@@ -61,6 +62,14 @@
 obj-$(CONFIG_NETFILTER_XT_TARGET_RATEEST) += xt_RATEEST.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_SECMARK) += xt_SECMARK.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TPROXY) += xt_TPROXY.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_CHAOS) += xt_CHAOS.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_DELUDE) += xt_DELUDE.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_RAWNAT) += xt_RAWNAT.o iptable_rawpost.o
+ifneq (${CONFIG_IP6_NF_IPTABLES},)
+obj-${CONFIG_NETFILTER_XT_TARGET_RAWNAT} += ip6table_rawpost.o
+endif
+obj-$(CONFIG_NETFILTER_XT_TARGET_STEAL) += xt_STEAL.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_TARPIT) += xt_TARPIT.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TCPMSS) += xt_TCPMSS.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP) += xt_TCPOPTSTRIP.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TEE) += xt_TEE.o
@@ -108,6 +117,13 @@
 obj-$(CONFIG_NETFILTER_XT_MATCH_CONDITION) += xt_condition.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_GEOIP) += xt_geoip.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_ETHPORT) += xt_ethport.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_FUZZY) += xt_fuzzy.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_IFACE) += xt_iface.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_IPV4OPTIONS) += xt_ipv4options.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_LSCAN) += xt_lscan.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PKNOCK) += xt_pknock.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PSD) += xt_psd.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_QUOTA2) += xt_quota2.o
 
 # ipset
 obj-$(CONFIG_IP_SET) += ipset/
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/Kconfig
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/Kconfig
@@ -66,6 +66,28 @@
 
 	  If unsure, say N.
 
+config SQUASHFS_4K_DEVBLK_SIZE
+	bool "Use 4K device block size?"
+	depends on SQUASHFS
+	help
+	  By default Squashfs sets the dev block size (sb_min_blocksize)
+	  to 1K or the smallest block size supported by the block device
+	  (if larger).  This, because blocks are packed together and
+	  unaligned in Squashfs, should reduce latency.
+
+	  This, however, gives poor performance on MTD NAND devices where
+	  the optimal I/O size is 4K (even though the devices can support
+	  smaller block sizes).
+
+	  Using a 4K device block size may also improve overall I/O
+	  performance for some file access patterns (e.g. sequential
+	  accesses of files in filesystem order) on all media.
+
+	  Setting this option will force Squashfs to use a 4K device block
+	  size by default.
+
+	  If unsure, say N.
+
 config SQUASHFS_EMBEDDED
 	bool "Additional option for memory-constrained systems"
 	depends on SQUASHFS
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
@@ -37,6 +37,13 @@
 #define SQUASHFS_FILE_SIZE		131072
 #define SQUASHFS_FILE_LOG		17
 
+/* default size of block device I/O */
+#ifdef CONFIG_SQUASHFS_4K_DEVBLK_SIZE
+#define SQUASHFS_DEVBLK_SIZE 4096
+#else
+#define SQUASHFS_DEVBLK_SIZE 1024
+#endif
+
 #define SQUASHFS_FILE_MAX_SIZE		1048576
 #define SQUASHFS_FILE_MAX_LOG		20
 
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/super.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/super.c
@@ -102,7 +102,7 @@
 		goto failure;
 	}
 
-	msblk->devblksize = sb_min_blocksize(sb, BLOCK_SIZE);
+	msblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);
 	msblk->devblksize_log2 = ffz(~msblk->devblksize);
 
 	mutex_init(&msblk->read_data_mutex);
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/Makefile
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/Makefile
@@ -85,6 +85,9 @@
 obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
 obj-$(CONFIG_CRYPTO_GHASH) += ghash-generic.o
+obj-$(CONFIG_CRYPTO_USER_API) += af_alg.o
+obj-$(CONFIG_CRYPTO_USER_API_HASH) += algif_hash.o
+obj-$(CONFIG_CRYPTO_USER_API_SKCIPHER) += algif_skcipher.o
 
 #
 # generic algorithms and the async_tx api
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/Kconfig
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/Kconfig
@@ -842,6 +842,27 @@
 	  ANSI X9.31 A.2.4. Note that this option must be enabled if
 	  CRYPTO_FIPS is selected
 
+config CRYPTO_USER_API
+	tristate
+
+config CRYPTO_USER_API_HASH
+	tristate "User-space interface for hash algorithms"
+	depends on NET
+	select CRYPTO_HASH
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for hash
+	  algorithms.
+
+config CRYPTO_USER_API_SKCIPHER
+	tristate "User-space interface for symmetric key cipher algorithms"
+	depends on NET
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for symmetric
+	  key cipher algorithms.
+
 source "drivers/crypto/Kconfig"
 
 endif	# if CRYPTO
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/af_alg.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/af_alg.c
@@ -0,0 +1,483 @@
+/*
+ * af_alg: User-space algorithm interface
+ *
+ * This file provides the user-space API for algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <asm/atomic.h>
+#include <crypto/if_alg.h>
+#include <linux/crypto.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/rwsem.h>
+
+struct alg_type_list {
+	const struct af_alg_type *type;
+	struct list_head list;
+};
+
+static atomic_long_t alg_memory_allocated;
+
+static struct proto alg_proto = {
+	.name			= "ALG",
+	.owner			= THIS_MODULE,
+	.memory_allocated	= &alg_memory_allocated,
+	.obj_size		= sizeof(struct alg_sock),
+};
+
+static LIST_HEAD(alg_types);
+static DECLARE_RWSEM(alg_types_sem);
+
+static const struct af_alg_type *alg_get_type(const char *name)
+{
+	const struct af_alg_type *type = ERR_PTR(-ENOENT);
+	struct alg_type_list *node;
+
+	down_read(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, name))
+			continue;
+
+		if (try_module_get(node->type->owner))
+			type = node->type;
+		break;
+	}
+	up_read(&alg_types_sem);
+
+	return type;
+}
+
+int af_alg_register_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -EEXIST;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (!strcmp(node->type->name, type->name))
+			goto unlock;
+	}
+
+	node = kmalloc(sizeof(*node), GFP_KERNEL);
+	err = -ENOMEM;
+	if (!node)
+		goto unlock;
+
+	type->ops->owner = THIS_MODULE;
+	node->type = type;
+	list_add(&node->list, &alg_types);
+	err = 0;
+
+unlock:
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_register_type);
+
+int af_alg_unregister_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -ENOENT;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, type->name))
+			continue;
+
+		list_del(&node->list);
+		kfree(node);
+		err = 0;
+		break;
+	}
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_unregister_type);
+
+static void alg_do_release(const struct af_alg_type *type, void *private)
+{
+	if (!type)
+		return;
+
+	type->release(private);
+	module_put(type->owner);
+}
+
+int af_alg_release(struct socket *sock)
+{
+	if (sock->sk)
+		sock_put(sock->sk);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_release);
+
+static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct sockaddr_alg *sa = (void *)uaddr;
+	const struct af_alg_type *type;
+	void *private;
+
+	if (sock->state == SS_CONNECTED)
+		return -EINVAL;
+
+	if (addr_len != sizeof(*sa))
+		return -EINVAL;
+
+	sa->salg_type[sizeof(sa->salg_type) - 1] = 0;
+	sa->salg_name[sizeof(sa->salg_name) - 1] = 0;
+
+	type = alg_get_type(sa->salg_type);
+	if (IS_ERR(type) && PTR_ERR(type) == -ENOENT) {
+		request_module("algif-%s", sa->salg_type);
+		type = alg_get_type(sa->salg_type);
+	}
+
+	if (IS_ERR(type))
+		return PTR_ERR(type);
+
+	private = type->bind(sa->salg_name, sa->salg_feat, sa->salg_mask);
+	if (IS_ERR(private)) {
+		module_put(type->owner);
+		return PTR_ERR(private);
+	}
+
+	lock_sock(sk);
+
+	swap(ask->type, type);
+	swap(ask->private, private);
+
+	release_sock(sk);
+
+	alg_do_release(type, private);
+
+	return 0;
+}
+
+static int alg_setkey(struct sock *sk, char __user *ukey,
+		      unsigned int keylen)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type = ask->type;
+	u8 *key;
+	int err;
+
+	key = sock_kmalloc(sk, keylen, GFP_KERNEL);
+	if (!key)
+		return -ENOMEM;
+
+	err = -EFAULT;
+	if (copy_from_user(key, ukey, keylen))
+		goto out;
+
+	err = type->setkey(ask->private, key, keylen);
+
+out:
+	sock_kfree_s(sk, key, keylen);
+
+	return err;
+}
+
+static int alg_setsockopt(struct socket *sock, int level, int optname,
+			  char __user *optval, unsigned int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	int err = -ENOPROTOOPT;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	if (level != SOL_ALG || !type)
+		goto unlock;
+
+	switch (optname) {
+	case ALG_SET_KEY:
+		if (sock->state == SS_CONNECTED)
+			goto unlock;
+		if (!type->setkey)
+			goto unlock;
+
+		err = alg_setkey(sk, optval, optlen);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+
+int af_alg_accept(struct sock *sk, struct socket *newsock)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	struct sock *sk2;
+	int err;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	err = -EINVAL;
+	if (!type)
+		goto unlock;
+
+	sk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto);
+	err = -ENOMEM;
+	if (!sk2)
+		goto unlock;
+
+	sock_init_data(newsock, sk2);
+	sock_graft(sk2, newsock);
+
+	err = type->accept(ask->private, sk2);
+	if (err) {
+		sk_free(sk2);
+		goto unlock;
+	}
+
+	sk2->sk_family = PF_ALG;
+
+	sock_hold(sk);
+	alg_sk(sk2)->parent = sk;
+	alg_sk(sk2)->type = type;
+
+	newsock->ops = type->ops;
+	newsock->state = SS_CONNECTED;
+
+	err = 0;
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_accept);
+
+static int alg_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	return af_alg_accept(sock->sk, newsock);
+}
+
+static const struct proto_ops alg_proto_ops = {
+	.family		=	PF_ALG,
+	.owner		=	THIS_MODULE,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.sendpage	=	sock_no_sendpage,
+	.sendmsg	=	sock_no_sendmsg,
+	.recvmsg	=	sock_no_recvmsg,
+	.poll		=	sock_no_poll,
+
+	.bind		=	alg_bind,
+	.release	=	af_alg_release,
+	.setsockopt	=	alg_setsockopt,
+	.accept		=	alg_accept,
+};
+
+static void alg_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+
+	alg_do_release(ask->type, ask->private);
+}
+
+static int alg_create(struct net *net, struct socket *sock, int protocol,
+		      int kern)
+{
+	struct sock *sk;
+	int err;
+
+	if (sock->type != SOCK_SEQPACKET)
+		return -ESOCKTNOSUPPORT;
+	if (protocol != 0)
+		return -EPROTONOSUPPORT;
+
+	err = -ENOMEM;
+	sk = sk_alloc(net, PF_ALG, GFP_KERNEL, &alg_proto);
+	if (!sk)
+		goto out;
+
+	sock->ops = &alg_proto_ops;
+	sock_init_data(sock, sk);
+
+	sk->sk_family = PF_ALG;
+	sk->sk_destruct = alg_sock_destruct;
+
+	return 0;
+out:
+	return err;
+}
+
+static const struct net_proto_family alg_family = {
+	.family	=	PF_ALG,
+	.create	=	alg_create,
+	.owner	=	THIS_MODULE,
+};
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write)
+{
+	unsigned long from = (unsigned long)addr;
+	unsigned long npages;
+	unsigned off;
+	int err;
+	int i;
+
+	err = -EFAULT;
+	if (!access_ok(write ? VERIFY_READ : VERIFY_WRITE, addr, len))
+		goto out;
+
+	off = from & ~PAGE_MASK;
+	npages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	if (npages > ALG_MAX_PAGES)
+		npages = ALG_MAX_PAGES;
+
+	err = get_user_pages_fast(from, npages, write, sgl->pages);
+	if (err < 0)
+		goto out;
+
+	npages = err;
+	err = -EINVAL;
+	if (WARN_ON(npages == 0))
+		goto out;
+
+	err = 0;
+
+	sg_init_table(sgl->sg, npages);
+
+	for (i = 0; i < npages; i++) {
+		int plen = min_t(int, len, PAGE_SIZE - off);
+
+		sg_set_page(sgl->sg + i, sgl->pages[i], plen, off);
+
+		off = 0;
+		len -= plen;
+		err += plen;
+	}
+
+out:
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_make_sg);
+
+void af_alg_free_sg(struct af_alg_sgl *sgl)
+{
+	int i;
+
+	i = 0;
+	do {
+		put_page(sgl->pages[i]);
+	} while (!sg_is_last(sgl->sg + (i++)));
+}
+EXPORT_SYMBOL_GPL(af_alg_free_sg);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con)
+{
+	struct cmsghdr *cmsg;
+
+	for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
+		if (!CMSG_OK(msg, cmsg))
+			return -EINVAL;
+		if (cmsg->cmsg_level != SOL_ALG)
+			continue;
+
+		switch(cmsg->cmsg_type) {
+		case ALG_SET_IV:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(*con->iv)))
+				return -EINVAL;
+			con->iv = (void *)CMSG_DATA(cmsg);
+			if (cmsg->cmsg_len < CMSG_LEN(con->iv->ivlen +
+						      sizeof(*con->iv)))
+				return -EINVAL;
+			break;
+
+		case ALG_SET_OP:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))
+				return -EINVAL;
+			con->op = *(u32 *)CMSG_DATA(cmsg);
+			break;
+
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_cmsg_send);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion)
+{
+	switch (err) {
+	case -EINPROGRESS:
+	case -EBUSY:
+		wait_for_completion(&completion->completion);
+		INIT_COMPLETION(completion->completion);
+		err = completion->err;
+		break;
+	};
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_wait_for_completion);
+
+void af_alg_complete(struct crypto_async_request *req, int err)
+{
+	struct af_alg_completion *completion = req->data;
+
+	completion->err = err;
+	complete(&completion->completion);
+}
+EXPORT_SYMBOL_GPL(af_alg_complete);
+
+static int __init af_alg_init(void)
+{
+	int err = proto_register(&alg_proto, 0);
+
+	if (err)
+		goto out;
+
+	err = sock_register(&alg_family);
+	if (err != 0)
+		goto out_unregister_proto;
+
+out:
+	return err;
+
+out_unregister_proto:
+	proto_unregister(&alg_proto);
+	goto out;
+}
+
+static void __exit af_alg_exit(void)
+{
+	sock_unregister(PF_ALG);
+	proto_unregister(&alg_proto);
+}
+
+module_init(af_alg_init);
+module_exit(af_alg_exit);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_NETPROTO(AF_ALG);
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/algif_hash.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/algif_hash.c
@@ -0,0 +1,319 @@
+/*
+ * algif_hash: User-space interface for hash algorithms
+ *
+ * This file provides the user-space API for hash algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/hash.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct hash_ctx {
+	struct af_alg_sgl sgl;
+
+	u8 *result;
+
+	struct af_alg_completion completion;
+
+	unsigned int len;
+	bool more;
+
+	struct ahash_request req;
+};
+
+static int hash_sendmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t ignored)
+{
+	int limit = ALG_MAX_PAGES * PAGE_SIZE;
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned long iovlen;
+	struct iovec *iov;
+	long copied = 0;
+	int err;
+
+	if (limit > sk->sk_sndbuf)
+		limit = sk->sk_sndbuf;
+
+	lock_sock(sk);
+	if (!ctx->more) {
+		err = crypto_ahash_init(&ctx->req);
+		if (err)
+			goto unlock;
+	}
+
+	ctx->more = 0;
+
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			int len = min_t(unsigned long, seglen, limit);
+			int newlen;
+
+			newlen = af_alg_make_sg(&ctx->sgl, from, len, 0);
+			if (newlen < 0)
+				goto unlock;
+
+			ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL,
+						newlen);
+
+			err = af_alg_wait_for_completion(
+				crypto_ahash_update(&ctx->req),
+				&ctx->completion);
+
+			af_alg_free_sg(&ctx->sgl);
+
+			if (err)
+				goto unlock;
+
+			seglen -= newlen;
+			from += newlen;
+			copied += newlen;
+		}
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more) {
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err ?: copied;
+}
+
+static ssize_t hash_sendpage(struct socket *sock, struct page *page,
+			     int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	int err;
+
+	lock_sock(sk);
+	sg_init_table(ctx->sgl.sg, 1);
+	sg_set_page(ctx->sgl.sg, page, size, offset);
+
+	ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, ctx->result, size);
+
+	if (!(flags & MSG_MORE)) {
+		if (ctx->more)
+			err = crypto_ahash_finup(&ctx->req);
+		else
+			err = crypto_ahash_digest(&ctx->req);
+	} else {
+		if (!ctx->more) {
+			err = crypto_ahash_init(&ctx->req);
+			if (err)
+				goto unlock;
+		}
+
+		err = crypto_ahash_update(&ctx->req);
+	}
+
+	err = af_alg_wait_for_completion(err, &ctx->completion);
+	if (err)
+		goto unlock;
+
+	ctx->more = flags & MSG_MORE;
+
+unlock:
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t len, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
+	int err;
+
+	if (len > ds)
+		len = ds;
+	else if (len < ds)
+		msg->msg_flags |= MSG_TRUNC;
+
+	lock_sock(sk);
+	if (ctx->more) {
+		ctx->more = 0;
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+		if (err)
+			goto unlock;
+	}
+
+	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);
+
+unlock:
+	release_sock(sk);
+
+	return err ?: len;
+}
+
+static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	struct ahash_request *req = &ctx->req;
+	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];
+	struct sock *sk2;
+	struct alg_sock *ask2;
+	struct hash_ctx *ctx2;
+	int err;
+
+	err = crypto_ahash_export(req, state);
+	if (err)
+		return err;
+
+	err = af_alg_accept(ask->parent, newsock);
+	if (err)
+		return err;
+
+	sk2 = newsock->sk;
+	ask2 = alg_sk(sk2);
+	ctx2 = ask2->private;
+	ctx2->more = 1;
+
+	err = crypto_ahash_import(&ctx2->req, state);
+	if (err) {
+		sock_orphan(sk2);
+		sock_put(sk2);
+	}
+
+	return err;
+}
+
+static struct proto_ops algif_hash_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.setsockopt	=	sock_no_setsockopt,
+	.poll		=	sock_no_poll,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	hash_sendmsg,
+	.sendpage	=	hash_sendpage,
+	.recvmsg	=	hash_recvmsg,
+	.accept		=	hash_accept,
+};
+
+static void *hash_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ahash(name, type, mask);
+}
+
+static void hash_release(void *private)
+{
+	crypto_free_ahash(private);
+}
+
+static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ahash_setkey(private, key, keylen);
+}
+
+static void hash_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+
+	sock_kfree_s(sk, ctx->result,
+		     crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int hash_accept_parent(void *private, struct sock *sk)
+{
+	struct hash_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);
+	unsigned ds = crypto_ahash_digestsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);
+	if (!ctx->result) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->result, 0, ds);
+
+	ctx->len = len;
+	ctx->more = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ahash_request_set_tfm(&ctx->req, private);
+	ahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				   af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = hash_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_hash = {
+	.bind		=	hash_bind,
+	.release	=	hash_release,
+	.setkey		=	hash_setkey,
+	.accept		=	hash_accept_parent,
+	.ops		=	&algif_hash_ops,
+	.name		=	"hash",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_hash_init(void)
+{
+	return af_alg_register_type(&algif_type_hash);
+}
+
+static void __exit algif_hash_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_hash);
+	BUG_ON(err);
+}
+
+module_init(algif_hash_init);
+module_exit(algif_hash_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/algif_skcipher.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/algif_skcipher.c
@@ -0,0 +1,632 @@
+/*
+ * algif_skcipher: User-space interface for skcipher algorithms
+ *
+ * This file provides the user-space API for symmetric key ciphers.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/scatterwalk.h>
+#include <crypto/skcipher.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct skcipher_sg_list {
+	struct list_head list;
+
+	int cur;
+
+	struct scatterlist sg[0];
+};
+
+struct skcipher_ctx {
+	struct list_head tsgl;
+	struct af_alg_sgl rsgl;
+
+	void *iv;
+
+	struct af_alg_completion completion;
+
+	unsigned used;
+
+	unsigned int len;
+	bool more;
+	bool merge;
+	bool enc;
+
+	struct ablkcipher_request req;
+};
+
+#define MAX_SGL_ENTS ((PAGE_SIZE - sizeof(struct skcipher_sg_list)) / \
+		      sizeof(struct scatterlist) - 1)
+
+static inline int skcipher_sndbuf(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	return max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -
+			  ctx->used, 0);
+}
+
+static inline bool skcipher_writable(struct sock *sk)
+{
+	return PAGE_SIZE <= skcipher_sndbuf(sk);
+}
+
+static int skcipher_alloc_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg = NULL;
+
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+	if (!list_empty(&ctx->tsgl))
+		sg = sgl->sg;
+
+	if (!sg || sgl->cur >= MAX_SGL_ENTS) {
+		sgl = sock_kmalloc(sk, sizeof(*sgl) +
+				       sizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),
+				   GFP_KERNEL);
+		if (!sgl)
+			return -ENOMEM;
+
+		sg_init_table(sgl->sg, MAX_SGL_ENTS + 1);
+		sgl->cur = 0;
+
+		if (sg)
+			scatterwalk_sg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);
+
+		list_add_tail(&sgl->list, &ctx->tsgl);
+	}
+
+	return 0;
+}
+
+static void skcipher_pull_sgl(struct sock *sk, int used)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	int i;
+
+	while (!list_empty(&ctx->tsgl)) {
+		sgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,
+				       list);
+		sg = sgl->sg;
+
+		for (i = 0; i < sgl->cur; i++) {
+			int plen = min_t(int, used, sg[i].length);
+
+			if (!sg_page(sg + i))
+				continue;
+
+			sg[i].length -= plen;
+			sg[i].offset += plen;
+
+			used -= plen;
+			ctx->used -= plen;
+
+			if (sg[i].length)
+				return;
+
+			put_page(sg_page(sg + i));
+			sg_assign_page(sg + i, NULL);
+		}
+
+		list_del(&sgl->list);
+		sock_kfree_s(sk, sgl,
+			     sizeof(*sgl) + sizeof(sgl->sg[0]) *
+					    (MAX_SGL_ENTS + 1));
+	}
+
+	if (!ctx->used)
+		ctx->merge = 0;
+}
+
+static void skcipher_free_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	skcipher_pull_sgl(sk, ctx->used);
+}
+
+static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)
+{
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT)
+		return -EAGAIN;
+
+	set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	return err;
+}
+
+static void skcipher_wmem_wakeup(struct sock *sk)
+{
+	struct socket_wq *wq;
+
+	if (!skcipher_writable(sk))
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLIN |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
+	rcu_read_unlock();
+}
+
+static int skcipher_wait_for_data(struct sock *sk, unsigned flags)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT) {
+		return -EAGAIN;
+	}
+
+	set_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, ctx->used)) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	return err;
+}
+
+static void skcipher_data_wakeup(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct socket_wq *wq;
+
+	if (!ctx->used)
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLOUT |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);
+	rcu_read_unlock();
+}
+
+static int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+	unsigned ivsize = crypto_ablkcipher_ivsize(tfm);
+	struct skcipher_sg_list *sgl;
+	struct af_alg_control con = {};
+	long copied = 0;
+	bool enc = 0;
+	int err;
+	int i;
+
+	if (msg->msg_controllen) {
+		err = af_alg_cmsg_send(msg, &con);
+		if (err)
+			return err;
+
+		switch (con.op) {
+		case ALG_OP_ENCRYPT:
+			enc = 1;
+			break;
+		case ALG_OP_DECRYPT:
+			enc = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (con.iv && con.iv->ivlen != ivsize)
+			return -EINVAL;
+	}
+
+	err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!ctx->used) {
+		ctx->enc = enc;
+		if (con.iv)
+			memcpy(ctx->iv, con.iv->iv, ivsize);
+	}
+
+	while (size) {
+		struct scatterlist *sg;
+		unsigned long len = size;
+		int plen;
+
+		if (ctx->merge) {
+			sgl = list_entry(ctx->tsgl.prev,
+					 struct skcipher_sg_list, list);
+			sg = sgl->sg + sgl->cur - 1;
+			len = min_t(unsigned long, len,
+				    PAGE_SIZE - sg->offset - sg->length);
+
+			err = memcpy_fromiovec(page_address(sg_page(sg)) +
+					       sg->offset + sg->length,
+					       msg->msg_iov, len);
+			if (err)
+				goto unlock;
+
+			sg->length += len;
+			ctx->merge = (sg->offset + sg->length) &
+				     (PAGE_SIZE - 1);
+
+			ctx->used += len;
+			copied += len;
+			size -= len;
+			continue;
+		}
+
+		if (!skcipher_writable(sk)) {
+			err = skcipher_wait_for_wmem(sk, msg->msg_flags);
+			if (err)
+				goto unlock;
+		}
+
+		len = min_t(unsigned long, len, skcipher_sndbuf(sk));
+
+		err = skcipher_alloc_sgl(sk);
+		if (err)
+			goto unlock;
+
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+		sg = sgl->sg;
+		do {
+			i = sgl->cur;
+			plen = min_t(int, len, PAGE_SIZE);
+
+			sg_assign_page(sg + i, alloc_page(GFP_KERNEL));
+			err = -ENOMEM;
+			if (!sg_page(sg + i))
+				goto unlock;
+
+			err = memcpy_fromiovec(page_address(sg_page(sg + i)),
+					       msg->msg_iov, plen);
+			if (err) {
+				__free_page(sg_page(sg + i));
+				sg_assign_page(sg + i, NULL);
+				goto unlock;
+			}
+
+			sg[i].length = plen;
+			len -= plen;
+			ctx->used += plen;
+			copied += plen;
+			size -= plen;
+			sgl->cur++;
+		} while (len && sgl->cur < MAX_SGL_ENTS);
+
+		ctx->merge = plen & (PAGE_SIZE - 1);
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+static ssize_t skcipher_sendpage(struct socket *sock, struct page *page,
+				 int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	int err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!size)
+		goto done;
+
+	if (!skcipher_writable(sk)) {
+		err = skcipher_wait_for_wmem(sk, flags);
+		if (err)
+			goto unlock;
+	}
+
+	err = skcipher_alloc_sgl(sk);
+	if (err)
+		goto unlock;
+
+	ctx->merge = 0;
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+	get_page(page);
+	sg_set_page(sgl->sg + sgl->cur, page, size, offset);
+	sgl->cur++;
+	ctx->used += size;
+
+done:
+	ctx->more = flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t ignored, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(
+		&ctx->req));
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	unsigned long iovlen;
+	struct iovec *iov;
+	int err = -EAGAIN;
+	int used;
+	long copied = 0;
+
+	lock_sock(sk);
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			sgl = list_first_entry(&ctx->tsgl,
+					       struct skcipher_sg_list, list);
+			sg = sgl->sg;
+
+			while (!sg->length)
+				sg++;
+
+			used = ctx->used;
+			if (!used) {
+				err = skcipher_wait_for_data(sk, flags);
+				if (err)
+					goto unlock;
+			}
+
+			used = min_t(unsigned long, used, seglen);
+
+			used = af_alg_make_sg(&ctx->rsgl, from, used, 1);
+			err = used;
+			if (err < 0)
+				goto unlock;
+
+			if (ctx->more || used < ctx->used)
+				used -= used % bs;
+
+			err = -EINVAL;
+			if (!used)
+				goto free;
+
+			ablkcipher_request_set_crypt(&ctx->req, sg,
+						     ctx->rsgl.sg, used,
+						     ctx->iv);
+
+			err = af_alg_wait_for_completion(
+				ctx->enc ?
+					crypto_ablkcipher_encrypt(&ctx->req) :
+					crypto_ablkcipher_decrypt(&ctx->req),
+				&ctx->completion);
+
+free:
+			af_alg_free_sg(&ctx->rsgl);
+
+			if (err)
+				goto unlock;
+
+			copied += used;
+			from += used;
+			seglen -= used;
+			skcipher_pull_sgl(sk, used);
+		}
+	}
+
+	err = 0;
+
+unlock:
+	skcipher_wmem_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+
+static unsigned int skcipher_poll(struct file *file, struct socket *sock,
+				  poll_table *wait)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned int mask;
+
+	sock_poll_wait(file, sk_sleep(sk), wait);
+	mask = 0;
+
+	if (ctx->used)
+		mask |= POLLIN | POLLRDNORM;
+
+	if (skcipher_writable(sk))
+		mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
+
+	return mask;
+}
+
+static struct proto_ops algif_skcipher_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.accept		=	sock_no_accept,
+	.setsockopt	=	sock_no_setsockopt,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	skcipher_sendmsg,
+	.sendpage	=	skcipher_sendpage,
+	.recvmsg	=	skcipher_recvmsg,
+	.poll		=	skcipher_poll,
+};
+
+static void *skcipher_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ablkcipher(name, type, mask);
+}
+
+static void skcipher_release(void *private)
+{
+	crypto_free_ablkcipher(private);
+}
+
+static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ablkcipher_setkey(private, key, keylen);
+}
+
+static void skcipher_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+
+	skcipher_free_sgl(sk);
+	sock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int skcipher_accept_parent(void *private, struct sock *sk)
+{
+	struct skcipher_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),
+			       GFP_KERNEL);
+	if (!ctx->iv) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));
+
+	INIT_LIST_HEAD(&ctx->tsgl);
+	ctx->len = len;
+	ctx->used = 0;
+	ctx->more = 0;
+	ctx->merge = 0;
+	ctx->enc = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ablkcipher_request_set_tfm(&ctx->req, private);
+	ablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = skcipher_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_skcipher = {
+	.bind		=	skcipher_bind,
+	.release	=	skcipher_release,
+	.setkey		=	skcipher_setkey,
+	.accept		=	skcipher_accept_parent,
+	.ops		=	&algif_skcipher_ops,
+	.name		=	"skcipher",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_skcipher_init(void)
+{
+	return af_alg_register_type(&algif_type_skcipher);
+}
+
+static void __exit algif_skcipher_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_skcipher);
+	BUG_ON(err);
+}
+
+module_init(algif_skcipher_init);
+module_exit(algif_skcipher_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/core/sock.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/core/sock.c
@@ -157,7 +157,7 @@
   "sk_lock-27"       , "sk_lock-28"          , "sk_lock-AF_CAN"      ,
   "sk_lock-AF_TIPC"  , "sk_lock-AF_BLUETOOTH", "sk_lock-IUCV"        ,
   "sk_lock-AF_RXRPC" , "sk_lock-AF_ISDN"     , "sk_lock-AF_PHONET"   ,
-  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" ,
+  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" , "sk_lock-AF_ALG"      ,
   "sk_lock-AF_MAX"
 };
 static const char *const af_family_slock_key_strings[AF_MAX+1] = {
@@ -173,7 +173,7 @@
   "slock-27"       , "slock-28"          , "slock-AF_CAN"      ,
   "slock-AF_TIPC"  , "slock-AF_BLUETOOTH", "slock-AF_IUCV"     ,
   "slock-AF_RXRPC" , "slock-AF_ISDN"     , "slock-AF_PHONET"   ,
-  "slock-AF_IEEE802154", "slock-AF_CAIF" ,
+  "slock-AF_IEEE802154", "slock-AF_CAIF" , "slock-AF_ALG"      ,
   "slock-AF_MAX"
 };
 static const char *const af_family_clock_key_strings[AF_MAX+1] = {
@@ -189,7 +189,7 @@
   "clock-27"       , "clock-28"          , "clock-AF_CAN"      ,
   "clock-AF_TIPC"  , "clock-AF_BLUETOOTH", "clock-AF_IUCV"     ,
   "clock-AF_RXRPC" , "clock-AF_ISDN"     , "clock-AF_PHONET"   ,
-  "clock-AF_IEEE802154", "clock-AF_CAIF" ,
+  "clock-AF_IEEE802154", "clock-AF_CAIF" , "clock-AF_ALG"      ,
   "clock-AF_MAX"
 };
 
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/crypto/if_alg.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/crypto/if_alg.h
@@ -0,0 +1,92 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _CRYPTO_IF_ALG_H
+#define _CRYPTO_IF_ALG_H
+
+#include <linux/compiler.h>
+#include <linux/completion.h>
+#include <linux/if_alg.h>
+#include <linux/types.h>
+#include <net/sock.h>
+
+#define ALG_MAX_PAGES			16
+
+struct crypto_async_request;
+
+struct alg_sock {
+	/* struct sock must be the first member of struct alg_sock */
+	struct sock sk;
+
+	struct sock *parent;
+
+	const struct af_alg_type *type;
+	void *private;
+};
+
+struct af_alg_completion {
+	struct completion completion;
+	int err;
+};
+
+struct af_alg_control {
+	struct af_alg_iv *iv;
+	int op;
+};
+
+struct af_alg_type {
+	void *(*bind)(const char *name, u32 type, u32 mask);
+	void (*release)(void *private);
+	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
+	int (*accept)(void *private, struct sock *sk);
+
+	struct proto_ops *ops;
+	struct module *owner;
+	char name[14];
+};
+
+struct af_alg_sgl {
+	struct scatterlist sg[ALG_MAX_PAGES];
+	struct page *pages[ALG_MAX_PAGES];
+};
+
+int af_alg_register_type(const struct af_alg_type *type);
+int af_alg_unregister_type(const struct af_alg_type *type);
+
+int af_alg_release(struct socket *sock);
+int af_alg_accept(struct sock *sk, struct socket *newsock);
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write);
+void af_alg_free_sg(struct af_alg_sgl *sgl);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion);
+void af_alg_complete(struct crypto_async_request *req, int err);
+
+static inline struct alg_sock *alg_sk(struct sock *sk)
+{
+	return (struct alg_sock *)sk;
+}
+
+static inline void af_alg_release_parent(struct sock *sk)
+{
+	sock_put(alg_sk(sk)->parent);
+}
+
+static inline void af_alg_init_completion(struct af_alg_completion *completion)
+{
+	init_completion(&completion->completion);
+}
+
+#endif	/* _CRYPTO_IF_ALG_H */
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/crypto/scatterwalk.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/crypto/scatterwalk.h
@@ -68,6 +68,21 @@
 	return (++sg)->length ? sg : (void *)sg_page(sg);
 }
 
+static inline void scatterwalk_crypto_chain(struct scatterlist *head,
+					    struct scatterlist *sg,
+					    int chain, int num)
+{
+	if (chain) {
+		head->length += sg->length;
+		sg = scatterwalk_sg_next(sg);
+	}
+
+	if (sg)
+		scatterwalk_sg_chain(head, num, sg);
+	else
+		sg_mark_end(head);
+}
+
 static inline unsigned long scatterwalk_samebuf(struct scatter_walk *walk_in,
 						struct scatter_walk *walk_out)
 {
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/if_alg.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/if_alg.h
@@ -0,0 +1,40 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _LINUX_IF_ALG_H
+#define _LINUX_IF_ALG_H
+
+#include <linux/types.h>
+
+struct sockaddr_alg {
+	__u16	salg_family;
+	__u8	salg_type[14];
+	__u32	salg_feat;
+	__u32	salg_mask;
+	__u8	salg_name[64];
+};
+
+struct af_alg_iv {
+	__u32	ivlen;
+	__u8	iv[0];
+};
+
+/* Socket options */
+#define ALG_SET_KEY			1
+#define ALG_SET_IV			2
+#define ALG_SET_OP			3
+
+/* Operations */
+#define ALG_OP_DECRYPT			0
+#define ALG_OP_ENCRYPT			1
+
+#endif	/* _LINUX_IF_ALG_H */
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/socket.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/socket.h
@@ -193,7 +193,8 @@
 #define AF_PHONET	35	/* Phonet sockets		*/
 #define AF_IEEE802154	36	/* IEEE802154 sockets		*/
 #define AF_CAIF		37	/* CAIF sockets			*/
-#define AF_MAX		38	/* For now.. */
+#define AF_ALG		38	/* Algorithm sockets		*/
+#define AF_MAX		39	/* For now.. */
 
 /* Protocol families, same as address families. */
 #define PF_UNSPEC	AF_UNSPEC
@@ -234,6 +235,7 @@
 #define PF_PHONET	AF_PHONET
 #define PF_IEEE802154	AF_IEEE802154
 #define PF_CAIF		AF_CAIF
+#define PF_ALG		AF_ALG
 #define PF_MAX		AF_MAX
 
 /* Maximum queue length specifiable by listen.  */
@@ -310,6 +312,7 @@
 #define SOL_RDS		276
 #define SOL_IUCV	277
 #define SOL_CAIF	278
+#define SOL_ALG		279
 
 /* IPX options */
 #define IPX_TYPE	1
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/config_base.6a
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/config_base.6a
@@ -497,7 +497,7 @@
 CONFIG_NETFILTER_NETLINK_LOG=y
 CONFIG_NF_CONNTRACK=y
 CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
+CONFIG_NF_CONNTRACK_EVENTS=y
 # CONFIG_NF_CT_PROTO_DCCP is not set
 CONFIG_NF_CT_PROTO_GRE=y
 # CONFIG_NF_CT_PROTO_SCTP is not set
@@ -540,16 +540,25 @@
 CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
 # CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
 # CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
 # CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETFILTER_XT_TARGET_ACCOUNT is not set
+CONFIG_NETFILTER_XT_TARGET_CHAOS=m
+CONFIG_NETFILTER_XT_TARGET_DELUDE=m
+# CONFIG_NETFILTER_XT_TARGET_ECHO is not set
+CONFIG_NETFILTER_XT_TARGET_RAWNAT=m
+CONFIG_NETFILTER_XT_TARGET_STEAL=m
+CONFIG_NETFILTER_XT_TARGET_TARPIT=m
 CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
 # CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
 # CONFIG_NETFILTER_XT_MATCH_LAYER7 is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG is not set
 
 #
 # Xtables matches
 #
 # CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
-# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
 CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
 CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
 CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
@@ -576,8 +585,9 @@
 # CONFIG_NETFILTER_XT_MATCH_REALM is not set
 CONFIG_NETFILTER_XT_MATCH_RECENT=y
 # CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
 CONFIG_NETFILTER_XT_MATCH_STATE=y
-# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
 CONFIG_NETFILTER_XT_MATCH_STRING=y
 CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
 CONFIG_NETFILTER_XT_MATCH_TIME=y
@@ -585,6 +595,13 @@
 CONFIG_NETFILTER_XT_MATCH_WEBSTR=y
 CONFIG_NETFILTER_XT_MATCH_CONDITION=m
 CONFIG_NETFILTER_XT_MATCH_GEOIP=m
+CONFIG_NETFILTER_XT_MATCH_FUZZY=m
+CONFIG_NETFILTER_XT_MATCH_IFACE=m
+CONFIG_NETFILTER_XT_MATCH_IPV4OPTIONS=m
+CONFIG_NETFILTER_XT_MATCH_LSCAN=m
+CONFIG_NETFILTER_XT_MATCH_PKNOCK=m
+CONFIG_NETFILTER_XT_MATCH_PSD=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=m
 CONFIG_IP_SET=m
 CONFIG_IP_SET_MAX=256
 CONFIG_IP_SET_BITMAP_IP=m
@@ -1048,7 +1065,28 @@
 # CONFIG_SATA_INIC162X is not set
 # CONFIG_SATA_SIL24 is not set
 # CONFIG_ATA_SFF is not set
-# CONFIG_MD is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MULTICORE_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=m
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_MULTIPATH_QL is not set
+# CONFIG_DM_MULTIPATH_ST is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
 # CONFIG_FUSION is not set
 
 #
@@ -1210,14 +1248,14 @@
 # CONFIG_INPUT_MISC is not set
 CONFIG_HID_SUPPORT=y
 CONFIG_HID=m
-# CONFIG_HIDRAW is not set
+CONFIG_HIDRAW=y
 
 #
 # USB Input Devices
 #
 CONFIG_USB_HID=m
 # CONFIG_HID_PID is not set
-# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_HIDDEV=y
 
 #
 # USB HID Boot Protocol drivers
@@ -1321,7 +1359,10 @@
 #
 # PPS support
 #
-# CONFIG_PPS is not set
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_LDISC=m
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -1449,13 +1490,13 @@
 # CONFIG_USB_SERIAL_AIRCABLE is not set
 # CONFIG_USB_SERIAL_ARK3116 is not set
 # CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
+CONFIG_USB_SERIAL_CH341=m
 # CONFIG_USB_SERIAL_WHITEHEAT is not set
 # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_CP210X is not set
+CONFIG_USB_SERIAL_CP210X=m
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
 # CONFIG_USB_SERIAL_FUNSOFT is not set
 # CONFIG_USB_SERIAL_VISOR is not set
 # CONFIG_USB_SERIAL_IPAQ is not set
@@ -1474,7 +1515,7 @@
 # CONFIG_USB_SERIAL_MOS7840 is not set
 # CONFIG_USB_SERIAL_MOTOROLA is not set
 # CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
+CONFIG_USB_SERIAL_PL2303=m
 # CONFIG_USB_SERIAL_OTI6858 is not set
 # CONFIG_USB_SERIAL_QCAUX is not set
 # CONFIG_USB_SERIAL_QUALCOMM is not set
@@ -1599,8 +1640,11 @@
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
@@ -1649,11 +1693,12 @@
 # CONFIG_JFFS2_CMODE_SIZE is not set
 # CONFIG_JFFS2_CMODE_FAVOURLZO is not set
 # CONFIG_LOGFS is not set
-# CONFIG_CRAMFS is not set
+CONFIG_CRAMFS=m
 CONFIG_SQUASHFS=y
 # CONFIG_SQUASHFS_XATTR is not set
 # CONFIG_SQUASHFS_LZO is not set
 CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
 CONFIG_SQUASHFS_EMBEDDED=y
 CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
 # CONFIG_VXFS_FS is not set
@@ -1846,7 +1891,7 @@
 CONFIG_CRYPTO_ECB=y
 # CONFIG_CRYPTO_LRW is not set
 # CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
+CONFIG_CRYPTO_XTS=m
 
 #
 # Hash modes
@@ -1863,41 +1908,42 @@
 # CONFIG_CRYPTO_MD4 is not set
 CONFIG_CRYPTO_MD5=y
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
 CONFIG_CRYPTO_SHA1=y
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
 
 #
 # Ciphers
 #
 CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ANUBIS=m
 CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_DES=m
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
 
 #
 # Compression
 #
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=m
 
 #
 # Random Number Generation
@@ -1905,9 +1951,17 @@
 CONFIG_CRYPTO_ANSI_CPRNG=y
 CONFIG_CRYPTO_HW=y
 # CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X_RNG is not set
 # CONFIG_BINARY_PRINTF is not set
 
 #
+# User-space algorithms
+#
+CONFIG_CRYPTO_USER_API=m
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+
+#
 # Library routines
 #
 CONFIG_BITREVERSE=y
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
@@ -1868,8 +1868,20 @@
 	   are only processed once.  */
 	status = packet[0] & FTDI_STATUS_B0_MASK;
 	if (status != priv->prev_status) {
-		priv->diff_status |= status ^ priv->prev_status;
-		wake_up_interruptible(&priv->delta_msr_wait);
+                char diff_status = status ^ priv->prev_status;
+                priv->diff_status |= diff_status;
+        
+                if (diff_status & FTDI_RS0_RLSD) {
+                        struct tty_struct *tty;
+ 
+                        tty = tty_port_tty_get(&port->port);
+                        if (tty)
+                                usb_serial_handle_dcd_change(port, tty,
+                                                status & FTDI_RS0_RLSD);
+                        tty_kref_put(tty);
+                }
+
+                wake_up_interruptible(&priv->delta_msr_wait);
 		priv->prev_status = status;
 	}
 
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/drivers/usb/serial/generic.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/drivers/usb/serial/generic.c
@@ -491,6 +491,15 @@
 	struct tty_port *port = &usb_port->port;
 
 	dbg("%s - port %d, status %d", __func__, usb_port->number, status);
+        if (tty) {
+               struct tty_ldisc *ld = tty_ldisc_ref(tty);
+
+               if (ld) {
+                       if (ld->ops->dcd_change)
+                               ld->ops->dcd_change(tty, status, NULL);
+                       tty_ldisc_deref(ld);
+               }
+        }
 
 	if (status)
 		wake_up_interruptible(&port->open_wait);

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/Kconfig
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/Kconfig
@@ -589,6 +589,203 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_TARGET_ACCOUNT
+	tristate '"ACCOUNT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The ACCOUNT target is a high performance accounting system for large
+	  local networks. It allows per-IP accounting in whole prefixes of IPv4
+	  addresses with size of up to /8 without the need to add individual
+	  accouting rule for each IP address.
+
+	  The ACCOUNT is designed to be queried for data every second or at
+	  least every ten seconds. It is written as kernel module to handle high
+	  bandwidths without packet loss.
+
+	  The largest possible subnet size is 24 bit, meaning for example 10.0.0.0/8
+	  network. ACCOUNT uses fixed internal data structures
+	  which speeds up the processing of each packet. Furthermore,
+	  accounting data for one complete 192.168.1.X/24 network takes 4 KB of
+	  memory. Memory for 16 or 24 bit networks is only allocated when
+	  needed.
+
+	  To optimize the kernel<->userspace data transfer a bit more, the
+	  kernel module only transfers information about IPs, where the src/dst
+	  packet counter is not 0. This saves precious kernel time.
+
+	  There is no /proc interface as it would be too slow for continuous access.
+	  The read-and-flush query operation is the fastest, as no internal data
+	  snapshot needs to be created&copied for all data. Use the "read"
+	  operation without flush only for debugging purposes!
+
+	  Usage:
+
+	  ACCOUNT takes two mandatory parameters:
+
+	  --addr network/netmask
+	  where network/netmask is the subnet to account for, in CIDR syntax
+
+	  --tname NAME
+	  where NAME is the name of the table where the accounting information
+	  should be stored
+
+	  The subnet 0.0.0.0/0 is a special case: all data are then stored in the src_bytes
+	  and src_packets structure of slot "0". This is useful if you want
+	  to account the overall traffic to/from your internet provider.
+
+	  The data can be queried using the userspace libxt_ACCOUNT_cl library,
+	  and by the reference implementation to show usage of this library,
+	  the iptaccount(8) tool.
+
+	  Here is an example of use:
+
+	  iptables -A FORWARD -j ACCOUNT --addr 0.0.0.0/0 --tname all_outgoing;
+	  iptables -A FORWARD -j ACCOUNT --addr 192.168.1.0/24 --tname sales;
+
+	  This creates two tables called "all_outgoing" and "sales" which can be
+	  queried using the userspace library/iptaccount tool.
+
+	  Note that this target is non-terminating, the packet destined to it
+	  will continue traversing the chain in which it has been used.
+
+	  Also note that once a table has been defined for specific CIDR address/netmask
+	  block, it can be referenced multiple times using -j ACCOUNT, provided
+	  that both the original table name and address/netmask block are specified.
+
+	  For more information go to http://www.intra2net.com/en/developer/ipt_ACCOUNT/
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_TARGET_CHAOS
+	tristate '"CHAOS" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Causes confusion on the other end by doing odd things with incoming packets.
+	  CHAOS will randomly reply (or not) with one of its configurable subtargets:
+
+	  --delude
+	  Use the REJECT and DELUDE targets as a base to do a sudden or deferred
+	  connection reset, fooling some network scanners to return non-deterministic
+	  (randomly open/closed) results, and in case it is deemed open, it is actually
+	  closed/filtered.
+
+	  --tarpit
+	  Use the REJECT and TARPIT target as a base to hold the connection until it
+	  times out. This consumes conntrack entries when connection tracking is loaded
+	  (which usually is on most machines), and routers inbetween you and the Internet
+	  may fail to do their connection tracking if they have to handle more
+	  connections than they can.
+
+	  The randomness factor of not replying vs. replying can be set during load-time
+	  of the xt_CHAOS module or during runtime in /sys/modules/xt_CHAOS/parameters.
+
+	  See http://jengelh.medozas.de/projects/chaostables/ for more information
+	  about CHAOS, DELUDE and lscan.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_TARGET_DELUDE
+	tristate '"DELUDE" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The DELUDE target will reply to a SYN packet with SYN-ACK, and to all other
+	  packets with an RST. This will terminate the connection much like REJECT, but
+	  network scanners doing TCP half-open discovery can be spoofed to make them
+	  belive the port is open rather than closed/filtered.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_ECHO
+	tristate '"ECHO" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The ECHO target will send back all packets it received. It serves as an
+	  examples for an Xtables target.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_RAWNAT
+	tristate '"RAWNAT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The RAWSNAT and RAWDNAT targets provide stateless network address
+	  translation.
+
+	  The RAWDNAT target will rewrite the destination address in the IP header,
+	  much like the NETMAP target.
+
+	  --to-destination addr[/mask]
+	  Network address to map to. The resulting address will be constructed the
+	  following way: All 'one' bits in the mask are filled in from the new
+	  address. All bits that are zero in the mask are filled in from the
+	  original address.
+
+	  The RAWSNAT target will rewrite the source address in the IP header, much
+	  like the NETMAP target. RAWSNAT (and RAWDNAT) may only be
+	  used in the raw or rawpost tables, but can be used in all chains,
+	  which makes it possible to change the source address either when the packet
+	  enters the machine or when it leaves it. The reason for this table constraint
+	  is that RAWNAT must happen outside of connection tracking.
+
+	  --to-source addr[/mask]
+	  Network address to map to. The resulting address will be constructed the
+	  following way: All 'one' bits in the mask are filled in from the new
+	  address. All bits that are zero in the mask are filled in from the
+	  original address.
+
+	  As an example, changing the destination for packets forwarded from an internal
+	  LAN to the internet:
+
+	  -t raw -A PREROUTING -i lan0 -d 212.201.100.135 -j RAWDNAT --to-destination 199.181.132.250;
+	  -t rawpost -A POSTROUTING -o lan0 -s 199.181.132.250 -j RAWSNAT --to-source 212.201.100.135;
+
+	  Note that changing addresses may influence the route selection! Specifically,
+	  it statically NATs packets, not connections, like the normal DNAT/SNAT targets
+	  would do. Also note that it can transform already-NATed connections, as
+	  said, it is completely external to Netfilter's connection tracking/NAT.
+
+	  If the machine itself generates packets that are to be rawnat'ed, you need a
+	  rule in the OUTPUT chain instead, just like you would with the stateful NAT
+	  targets.
+
+	  It may be necessary that in doing so, you also need an extra RAWSNAT rule, to
+	  override the automatic source address selection that the routing code does
+	  before passing packets to iptables. If the connecting socket has not been
+	  explicitly bound to an address, as is the common mode of operation, the address
+	  that will be chosen is the primary address of the device through which the
+	  packet would be routed with its initial destination address - the address as
+	  seen before any RAWNAT takes place.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_STEAL
+	tristate '"STEAL" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Like the DROP target, but does not throw an error like DROP when used in the
+	  OUTPUT chain.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+	  
+config NETFILTER_XT_TARGET_TARPIT
+	tristate '"TARPIT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Adds a TARPIT target to iptables, which captures and holds
+	  incoming TCP connections using no local per-connection resources.
+	  Connections are accepted, but immediately switched to the persist
+	  state (0 byte window), in which the remote side stops sending data
+	  and asks to continue every 60-240 seconds. Attempts to close the
+	  connection are ignored, forcing the remote side to time out the
+	  connection in 12-24 minutes.
+
+	  This offers similar functionality to LaBrea
+	  <http://www.hackbusters.net/LaBrea/>, but does not require dedicated
+	  hardware or IPs. Any TCP port that you would normally DROP or REJECT
+	  can instead become a tarpit.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+	  
 config NETFILTER_XT_TARGET_TCPMSS
 	tristate '"TCPMSS" target support'
 	depends on (IPV6 || IPV6=n)
@@ -1115,6 +1312,350 @@
           <file:Documentation/modules.txt>.  The module will be
           called `ipt_geoip'.  If unsure, say `N'.
 
+config NETFILTER_XT_MATCH_FUZZY
+	tristate '"MATCH" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  This module matches a rate limit based on a fuzzy logic controller (FLC).
+
+	  --lower-limit number
+	  Specifies the lower limit, in packets per second.
+
+	  --upper-limit number
+	  Specifies the upper limit, also in packets per second.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_IFACE
+	tristate '"IFACE" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Allows you to check interface states. First, an interface needs to be selected
+	  for comparison. Exactly one option of the following three must be specified:
+
+	  --iface name
+	  Check the states on the given interface.
+
+	  --dev-in
+	  Check the states on the interface on which the packet came in. If the input
+	  device is not set, because for example you are using -m iface in the OUTPUT
+	  chain, this submatch returns false.
+
+	  --dev-out
+	  Check the states on the interface on which the packet will go out. If the
+	  output device is not set, because for example you are using -m iface in the
+	  INPUT chain, this submatch returns false.
+
+	  Following that, one can select the interface properties to check for:
+
+	  [!] --up, [!] --down
+	  Check the UP flag.
+
+	  [!] --broadcast
+	  Check the BROADCAST flag.
+
+	  [!] --loopback
+	  Check the LOOPBACK flag.
+
+	  [!] --pointtopoint
+	  Check the POINTTOPOINT flag.
+
+	  [!] --running
+	  Check the RUNNING flag. Do NOT rely on it!
+
+	  [!] --noarp, [!] --arp
+	  Check the NOARP flag.
+
+	  [!] --promisc
+	  Check the PROMISC flag.
+
+	  [!] --multicast
+	  Check the MULTICAST flag.
+
+	  [!] --dynamic
+	  Check the DYNAMIC flag.
+
+	  [!] --lower-up
+	  Check the LOWER_UP flag.
+
+	  [!] --dormant
+	  Check the DORMANT flag.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_IPV4OPTIONS
+	tristate '"IPV4OPTIONS" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The "ipv4options" module allows to match against a set of IPv4 header options.
+
+	  --flags [!]symbol[,[!]symbol...]
+	  Specify the options that shall appear or not appear in the header. Each
+	  symbol specification is delimited by a comma, and a '!' can be prefixed to
+	  a symbol to negate its presence. Symbols are either the name of an IPv4 option
+	  or its number. See examples below.
+
+	  --any
+	  By default, all of the flags specified must be present/absent, that is, they
+	  form an AND condition. Use the --any flag instead to use an OR condition
+	  where only at least one symbol spec must be true.
+
+	  Known symbol names (and their number):
+
+	  1 nop
+	  2 security RFC 1108
+	  3 lsrr Loose Source Routing, RFC 791
+	  4 timestamp RFC 781, 791
+	  7 record-route RFC 791
+	  9 ssrr Strict Source Routing, RFC 791
+	  11 mtu-probe RFC 1063
+	  12 mtu-reply RFC 1063
+	  18 traceroute RFC 1393
+	  20 router-alert RFC 2113
+
+	  Examples:
+
+	  Match packets that have both Timestamp and NOP:
+	  -m ipv4options --flags nop,timestamp
+
+	  ~ that have either of Timestamp or NOP, or both:
+	  --flags nop,timestamp --any
+
+	  ~ that have Timestamp and no NOP: --flags '!nop,timestamp'
+
+	  ~ that have either no NOP or a timestamp (or both conditions):
+	  --flags '!nop,timestamp' --any
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_LSCAN
+	tristate '"LSCAN" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Detects simple low-level scan attemps based upon the packet's contents.
+	  (This is different from other implementations, which also try to match the rate of new
+	  connections.) Note that an attempt is only discovered after it has been carried
+	  out, but this information can be used in conjunction with other rules to block
+	  the remote host's future connections. So this match module will match on the
+	  (probably) last packet the remote side will send to your machine.
+
+	  --stealth
+	  Match if the packet did not belong to any known TCP connection
+	  (Stealth/FIN/XMAS/NULL scan).
+
+	  --synscan
+	  Match if the connection was a TCP half-open discovery (SYN scan), i.e. the
+	  connection was torn down after the 2nd packet in the 3-way handshake.
+
+	  --cnscan
+	  Match if the connection was a TCP full open discovery (connect scan), i.e. the
+	  connection was torn down after completion of the 3-way handshake.
+
+	  --grscan
+	  Match if data in the connection only flew in the direction of the remote side,
+	  e.g. if the connection was terminated after a locally running daemon sent its
+	  identification. (E.g. openssh, smtp, ftpd.) This may falsely trigger on
+	  warranted single-direction data flows, usually bulk data transfers such as
+	  FTP DATA connections or IRC DCC. Grab Scan Detection should only be used on
+	  ports where a protocol runs that is guaranteed to do a bidirectional exchange
+	  of bytes.
+
+	  NOTE: Some clients (Windows XP for example) may do what looks like a SYN scan,
+	  so be advised to carefully use xt_lscan in conjunction with blocking rules,
+	  as it may lock out your very own internal network.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+	  
+config NETFILTER_XT_MATCH_PKNOCK
+	tristate '"PKNOCK" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Pknock match implements so-called "port knocking", a stealthy system
+	  for network authentication: a client sends packets to selected
+	  ports in a specific sequence (= simple mode, see example 1 below), or a HMAC
+	  payload to a single port (= complex mode, see example 2 below),
+	  to a target machine that has pknock rule(s) installed. The target machine
+	  then decides whether to unblock or block (again) the pknock-protected port(s).
+	  This can be used, for instance, to avoid brute force
+	  attacks on ssh or ftp services.
+
+	  Example prerequisites:
+
+	  modprobe cn
+
+	  modprobe xt_pknock
+
+	  Example 1 (TCP mode, manual closing of opened port not possible):
+
+	  iptables -P INPUT DROP
+
+	  iptables -A INPUT -p tcp -m pknock --knockports 4002,4001,4004 --strict
+	  --name SSH --time 10 --autoclose 60 --dport 22 -j ACCEPT
+
+	  The rule will allow tcp port 22 for the attempting IP address after the successful reception of TCP SYN packets
+	  to ports 4002, 4001 and 4004, in this order (a.k.a. port-knocking).
+	  Port numbers in the connect sequence must follow the exact specification, no
+	  other ports may be "knocked" inbetween. The rule is named 'SSH', a file of
+	  the same name for tracking port knocking states will be created in
+	  /proc/net/xt_pknock .
+	  Successive port knocks must occur with delay of at most 10 seconds. Port 22 (from the example) will
+	  be automatiaclly dropped after 60 minutes after it was previously allowed.
+
+	  Example 2 (UDP mode, non-replayable and non-spoofable, manual closing
+	  of opened port possible, secure, also called "SPA" = Secure Port
+	  Authorization):
+
+	  iptables -A INPUT -p udp -m pknock --knockports 4000 --name FTP
+	  --opensecret foo --closesecret bar --autoclose 240 -j DROP
+
+	  iptables -A INPUT -p tcp -m pknock --checkip --name FTP --dport 21 -j ACCEPT
+
+	  The first rule will create an "ALLOWED" record in /proc/net/xt_pknock/FTP after
+	  the successful reception of an UDP packet to port 4000. The packet payload must be
+	  constructed as a HMAC256 using "foo" as a key. The HMAC content is the particular 
+	  client's IP address as a 32-bit network byteorder quantity,
+	  plus the number of minutes since the Unix epoch, also as a 32-bit value.
+	  (This is known as Simple Packet Authorization, also called "SPA".)
+	  In such case, any subsequent attempt to connect to port 21 from the client's IP
+	  address will cause such packets to be accepted in the second rule.
+
+	  Similarly, upon reception of an UDP packet constructed the same way, but with
+	  the key "bar", the first rule will remove a previously installed "ALLOWED" state
+	  record from /proc/net/xt_pknock/FTP, which means that the second rule will
+	  stop matching for subsequent connection attempts to port 21.
+	  In case no close-secret packet is received within 4 hours, the first rule
+	  will remove "ALLOWED" record from /proc/net/xt_pknock/FTP itself.
+
+	  Things worth noting:
+
+	  General:
+
+	  Specifying --autoclose 0 means that no automatic close will be performed at all.
+
+	  xt_pknock is capable of sending information about successful matches
+	  via a netlink socket to userspace, should you need to implement your own
+	  way of receiving and handling portknock notifications.
+	  Be sure to read the documentation in the doc/pknock/ directory,
+	  or visit the original site, http://portknocko.berlios.de/ .
+
+	  TCP mode:
+
+	  This mode is not immune against eavesdropping, spoofing and
+	  replaying of the port knock sequence by someone else (but its use may still
+	  be sufficient for scenarios where these factors are not necessarily
+	  this important, such as bare shielding of the SSH port from brute-force attacks).
+	  However, if you need these features, you should use UDP mode.
+
+	  It is always wise to specify three or more ports that are not monotonically
+	  increasing or decreasing with a small stepsize (e.g. 1024,1025,1026)
+	  to avoid accidentally triggering
+	  the rule by a portscan.
+
+	  Specifying the inter-knock timeout with --time is mandatory in TCP mode,
+	  to avoid permanent denial of services by clogging up the peer knock-state tracking table
+	  that xt_pknock internally keeps, should there be a DDoS on the
+	  first-in-row knock port from more hostile IP addresses than what the actual size
+	  of this table is (defaults to 16, can be changed via the "peer_hasht_ents" module parameter).
+	  It is also wise to use as short a time as possible (1 second) for --time
+	  for this very reason. You may also consider increasing the size
+	  of the peer knock-state tracking table. Using --strict also helps,
+	  as it requires the knock sequence to be exact. This means that if the
+	  hostile client sends more knocks to the same port, xt_pknock will
+	  mark such attempt as failed knock sequence and will forget it immediately.
+	  To completely thwart this kind of DDoS, knock-ports would need to have
+	  an additional rate-limit protection. Or you may consider using UDP mode.
+
+	  UDP mode:
+
+	  This mode is immune against eavesdropping, replaying and spoofing attacks.
+	  It is also immune against DDoS attack on the knockport.
+
+	  For this mode to work, the clock difference on the client and on the server
+	  must be below 1 minute. Synchronizing time on both ends by means
+	  of NTP or rdate is strongly suggested.
+
+	  There is a rate limiter built into xt_pknock which blocks any subsequent
+	  open attempt in UDP mode should the request arrive within less than one
+	  minute since the first successful open. This is intentional;
+	  it thwarts eventual spoofing attacks.
+
+	  Because the payload value of an UDP knock packet is influenced by client's IP address,
+	  UDP mode cannot be used across NAT.
+
+	  For sending UDP "SPA" packets, you may use either knock.sh or
+	  knock-orig.sh. These may be found in doc/pknock/util.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_PSD
+	tristate '"PSD" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Attempt to detect TCP and UDP port scans. This match was derived from
+	  Solar Designer's scanlogd.
+
+	  --psd-weight-threshold threshold
+	  Total weight of the latest TCP/UDP packets with different
+	  destination ports coming from the same host to be treated as port
+	  scan sequence.
+
+	  --psd-delay-threshold delay
+	  Delay (in hundredths of second) for the packets with different
+	  destination ports coming from the same host to be treated as
+	  possible port scan subsequence.
+
+	  --psd-lo-ports-weight weight
+	  Weight of the packet with privileged (<=1024) destination port.
+
+	  --psd-hi-ports-weight weight
+	  Weight of the packet with non-priviliged destination port.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_QUOTA2
+	tristate '"QUOTA2" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The "quota2" implements a named counter which can be increased or decreased
+	  on a per-match basis. Available modes are packet counting or byte counting.
+	  The value of the counter can be read and reset through procfs, thereby making
+	  this match a minimalist accounting tool.
+
+	  When counting down from the initial quota, the counter will stop at 0 and
+	  the match will return false, just like the original "quota" match. In growing
+	  (upcounting) mode, it will always return true.
+
+	  --grow
+	  Count upwards instead of downwards.
+
+	  --no-change
+	  Makes it so the counter or quota amount is never changed by packets matching
+	  this rule. This is only really useful in "quota" mode, as it will allow you to
+	  use complex prerouting rules in association with the quota system, without
+	  counting a packet twice.
+
+	  --name name
+	  Assign the counter a specific name. This option must be present, as an empty
+	  name is not allowed. Names starting with a dot or names containing a slash are
+	  prohibited.
+
+	  [!] --quota iq
+	  Specify the initial quota for this counter. If the counter already exists,
+	  it is not reset. An "!" may be used to invert the result of the match. The
+	  negation has no effect when --grow is used.
+
+	  --packets
+	  Count packets instead of bytes that passed the quota2 match.
+
+	  Because counters in quota2 can be shared, you can combine them for various
+	  purposes, for example, a bytebucket filter that only lets as much traffic go
+	  out as has come in:
+
+	  -A INPUT -p tcp --dport 6881 -m quota --name bt --grow;
+	  -A OUTPUT -p tcp --sport 6881 -m quota --name bt;
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
 endif # NETFILTER_XTABLES
 
 endmenu

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/Makefile
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/Makefile
@@ -40,6 +40,7 @@
 
 # generic X tables 
 obj-$(CONFIG_NETFILTER_XTABLES) += x_tables.o xt_tcpudp.o
+obj-y += compat_xtables.o
 
 # combos
 obj-$(CONFIG_NETFILTER_XT_MARK) += xt_mark.o
@@ -61,6 +62,14 @@
 obj-$(CONFIG_NETFILTER_XT_TARGET_RATEEST) += xt_RATEEST.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_SECMARK) += xt_SECMARK.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TPROXY) += xt_TPROXY.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_CHAOS) += xt_CHAOS.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_DELUDE) += xt_DELUDE.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_RAWNAT) += xt_RAWNAT.o iptable_rawpost.o
+ifneq (${CONFIG_IP6_NF_IPTABLES},)
+obj-${CONFIG_NETFILTER_XT_TARGET_RAWNAT} += ip6table_rawpost.o
+endif
+obj-$(CONFIG_NETFILTER_XT_TARGET_STEAL) += xt_STEAL.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_TARPIT) += xt_TARPIT.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TCPMSS) += xt_TCPMSS.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP) += xt_TCPOPTSTRIP.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TEE) += xt_TEE.o
@@ -109,6 +118,13 @@
 obj-$(CONFIG_NETFILTER_XT_MATCH_CONDITION) += xt_condition.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_GEOIP) += xt_geoip.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_ETHPORT) += xt_ethport.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_FUZZY) += xt_fuzzy.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_IFACE) += xt_iface.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_IPV4OPTIONS) += xt_ipv4options.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_LSCAN) += xt_lscan.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PKNOCK) += xt_pknock.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PSD) += xt_psd.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_QUOTA2) += xt_quota2.o
 
 # ipset
 obj-$(CONFIG_IP_SET) += ipset/
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/Kconfig
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/Kconfig
@@ -66,6 +66,28 @@
 
 	  If unsure, say N.
 
+config SQUASHFS_4K_DEVBLK_SIZE
+	bool "Use 4K device block size?"
+	depends on SQUASHFS
+	help
+	  By default Squashfs sets the dev block size (sb_min_blocksize)
+	  to 1K or the smallest block size supported by the block device
+	  (if larger).  This, because blocks are packed together and
+	  unaligned in Squashfs, should reduce latency.
+
+	  This, however, gives poor performance on MTD NAND devices where
+	  the optimal I/O size is 4K (even though the devices can support
+	  smaller block sizes).
+
+	  Using a 4K device block size may also improve overall I/O
+	  performance for some file access patterns (e.g. sequential
+	  accesses of files in filesystem order) on all media.
+
+	  Setting this option will force Squashfs to use a 4K device block
+	  size by default.
+
+	  If unsure, say N.
+
 config SQUASHFS_EMBEDDED
 	bool "Additional option for memory-constrained systems"
 	depends on SQUASHFS
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
@@ -37,6 +37,13 @@
 #define SQUASHFS_FILE_SIZE		131072
 #define SQUASHFS_FILE_LOG		17
 
+/* default size of block device I/O */
+#ifdef CONFIG_SQUASHFS_4K_DEVBLK_SIZE
+#define SQUASHFS_DEVBLK_SIZE 4096
+#else
+#define SQUASHFS_DEVBLK_SIZE 1024
+#endif
+
 #define SQUASHFS_FILE_MAX_SIZE		1048576
 #define SQUASHFS_FILE_MAX_LOG		20
 
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/super.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/super.c
@@ -102,7 +102,7 @@
 		goto failure;
 	}
 
-	msblk->devblksize = sb_min_blocksize(sb, BLOCK_SIZE);
+	msblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);
 	msblk->devblksize_log2 = ffz(~msblk->devblksize);
 
 	mutex_init(&msblk->read_data_mutex);
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/Makefile
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/Makefile
@@ -85,6 +85,9 @@
 obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
 obj-$(CONFIG_CRYPTO_GHASH) += ghash-generic.o
+obj-$(CONFIG_CRYPTO_USER_API) += af_alg.o
+obj-$(CONFIG_CRYPTO_USER_API_HASH) += algif_hash.o
+obj-$(CONFIG_CRYPTO_USER_API_SKCIPHER) += algif_skcipher.o
 
 #
 # generic algorithms and the async_tx api
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/Kconfig
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/Kconfig
@@ -842,6 +842,27 @@
 	  ANSI X9.31 A.2.4. Note that this option must be enabled if
 	  CRYPTO_FIPS is selected
 
+config CRYPTO_USER_API
+	tristate
+
+config CRYPTO_USER_API_HASH
+	tristate "User-space interface for hash algorithms"
+	depends on NET
+	select CRYPTO_HASH
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for hash
+	  algorithms.
+
+config CRYPTO_USER_API_SKCIPHER
+	tristate "User-space interface for symmetric key cipher algorithms"
+	depends on NET
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for symmetric
+	  key cipher algorithms.
+
 source "drivers/crypto/Kconfig"
 
 endif	# if CRYPTO
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/af_alg.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/af_alg.c
@@ -0,0 +1,483 @@
+/*
+ * af_alg: User-space algorithm interface
+ *
+ * This file provides the user-space API for algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <asm/atomic.h>
+#include <crypto/if_alg.h>
+#include <linux/crypto.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/rwsem.h>
+
+struct alg_type_list {
+	const struct af_alg_type *type;
+	struct list_head list;
+};
+
+static atomic_long_t alg_memory_allocated;
+
+static struct proto alg_proto = {
+	.name			= "ALG",
+	.owner			= THIS_MODULE,
+	.memory_allocated	= &alg_memory_allocated,
+	.obj_size		= sizeof(struct alg_sock),
+};
+
+static LIST_HEAD(alg_types);
+static DECLARE_RWSEM(alg_types_sem);
+
+static const struct af_alg_type *alg_get_type(const char *name)
+{
+	const struct af_alg_type *type = ERR_PTR(-ENOENT);
+	struct alg_type_list *node;
+
+	down_read(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, name))
+			continue;
+
+		if (try_module_get(node->type->owner))
+			type = node->type;
+		break;
+	}
+	up_read(&alg_types_sem);
+
+	return type;
+}
+
+int af_alg_register_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -EEXIST;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (!strcmp(node->type->name, type->name))
+			goto unlock;
+	}
+
+	node = kmalloc(sizeof(*node), GFP_KERNEL);
+	err = -ENOMEM;
+	if (!node)
+		goto unlock;
+
+	type->ops->owner = THIS_MODULE;
+	node->type = type;
+	list_add(&node->list, &alg_types);
+	err = 0;
+
+unlock:
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_register_type);
+
+int af_alg_unregister_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -ENOENT;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, type->name))
+			continue;
+
+		list_del(&node->list);
+		kfree(node);
+		err = 0;
+		break;
+	}
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_unregister_type);
+
+static void alg_do_release(const struct af_alg_type *type, void *private)
+{
+	if (!type)
+		return;
+
+	type->release(private);
+	module_put(type->owner);
+}
+
+int af_alg_release(struct socket *sock)
+{
+	if (sock->sk)
+		sock_put(sock->sk);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_release);
+
+static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct sockaddr_alg *sa = (void *)uaddr;
+	const struct af_alg_type *type;
+	void *private;
+
+	if (sock->state == SS_CONNECTED)
+		return -EINVAL;
+
+	if (addr_len != sizeof(*sa))
+		return -EINVAL;
+
+	sa->salg_type[sizeof(sa->salg_type) - 1] = 0;
+	sa->salg_name[sizeof(sa->salg_name) - 1] = 0;
+
+	type = alg_get_type(sa->salg_type);
+	if (IS_ERR(type) && PTR_ERR(type) == -ENOENT) {
+		request_module("algif-%s", sa->salg_type);
+		type = alg_get_type(sa->salg_type);
+	}
+
+	if (IS_ERR(type))
+		return PTR_ERR(type);
+
+	private = type->bind(sa->salg_name, sa->salg_feat, sa->salg_mask);
+	if (IS_ERR(private)) {
+		module_put(type->owner);
+		return PTR_ERR(private);
+	}
+
+	lock_sock(sk);
+
+	swap(ask->type, type);
+	swap(ask->private, private);
+
+	release_sock(sk);
+
+	alg_do_release(type, private);
+
+	return 0;
+}
+
+static int alg_setkey(struct sock *sk, char __user *ukey,
+		      unsigned int keylen)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type = ask->type;
+	u8 *key;
+	int err;
+
+	key = sock_kmalloc(sk, keylen, GFP_KERNEL);
+	if (!key)
+		return -ENOMEM;
+
+	err = -EFAULT;
+	if (copy_from_user(key, ukey, keylen))
+		goto out;
+
+	err = type->setkey(ask->private, key, keylen);
+
+out:
+	sock_kfree_s(sk, key, keylen);
+
+	return err;
+}
+
+static int alg_setsockopt(struct socket *sock, int level, int optname,
+			  char __user *optval, unsigned int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	int err = -ENOPROTOOPT;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	if (level != SOL_ALG || !type)
+		goto unlock;
+
+	switch (optname) {
+	case ALG_SET_KEY:
+		if (sock->state == SS_CONNECTED)
+			goto unlock;
+		if (!type->setkey)
+			goto unlock;
+
+		err = alg_setkey(sk, optval, optlen);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+
+int af_alg_accept(struct sock *sk, struct socket *newsock)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	struct sock *sk2;
+	int err;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	err = -EINVAL;
+	if (!type)
+		goto unlock;
+
+	sk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto);
+	err = -ENOMEM;
+	if (!sk2)
+		goto unlock;
+
+	sock_init_data(newsock, sk2);
+	sock_graft(sk2, newsock);
+
+	err = type->accept(ask->private, sk2);
+	if (err) {
+		sk_free(sk2);
+		goto unlock;
+	}
+
+	sk2->sk_family = PF_ALG;
+
+	sock_hold(sk);
+	alg_sk(sk2)->parent = sk;
+	alg_sk(sk2)->type = type;
+
+	newsock->ops = type->ops;
+	newsock->state = SS_CONNECTED;
+
+	err = 0;
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_accept);
+
+static int alg_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	return af_alg_accept(sock->sk, newsock);
+}
+
+static const struct proto_ops alg_proto_ops = {
+	.family		=	PF_ALG,
+	.owner		=	THIS_MODULE,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.sendpage	=	sock_no_sendpage,
+	.sendmsg	=	sock_no_sendmsg,
+	.recvmsg	=	sock_no_recvmsg,
+	.poll		=	sock_no_poll,
+
+	.bind		=	alg_bind,
+	.release	=	af_alg_release,
+	.setsockopt	=	alg_setsockopt,
+	.accept		=	alg_accept,
+};
+
+static void alg_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+
+	alg_do_release(ask->type, ask->private);
+}
+
+static int alg_create(struct net *net, struct socket *sock, int protocol,
+		      int kern)
+{
+	struct sock *sk;
+	int err;
+
+	if (sock->type != SOCK_SEQPACKET)
+		return -ESOCKTNOSUPPORT;
+	if (protocol != 0)
+		return -EPROTONOSUPPORT;
+
+	err = -ENOMEM;
+	sk = sk_alloc(net, PF_ALG, GFP_KERNEL, &alg_proto);
+	if (!sk)
+		goto out;
+
+	sock->ops = &alg_proto_ops;
+	sock_init_data(sock, sk);
+
+	sk->sk_family = PF_ALG;
+	sk->sk_destruct = alg_sock_destruct;
+
+	return 0;
+out:
+	return err;
+}
+
+static const struct net_proto_family alg_family = {
+	.family	=	PF_ALG,
+	.create	=	alg_create,
+	.owner	=	THIS_MODULE,
+};
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write)
+{
+	unsigned long from = (unsigned long)addr;
+	unsigned long npages;
+	unsigned off;
+	int err;
+	int i;
+
+	err = -EFAULT;
+	if (!access_ok(write ? VERIFY_READ : VERIFY_WRITE, addr, len))
+		goto out;
+
+	off = from & ~PAGE_MASK;
+	npages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	if (npages > ALG_MAX_PAGES)
+		npages = ALG_MAX_PAGES;
+
+	err = get_user_pages_fast(from, npages, write, sgl->pages);
+	if (err < 0)
+		goto out;
+
+	npages = err;
+	err = -EINVAL;
+	if (WARN_ON(npages == 0))
+		goto out;
+
+	err = 0;
+
+	sg_init_table(sgl->sg, npages);
+
+	for (i = 0; i < npages; i++) {
+		int plen = min_t(int, len, PAGE_SIZE - off);
+
+		sg_set_page(sgl->sg + i, sgl->pages[i], plen, off);
+
+		off = 0;
+		len -= plen;
+		err += plen;
+	}
+
+out:
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_make_sg);
+
+void af_alg_free_sg(struct af_alg_sgl *sgl)
+{
+	int i;
+
+	i = 0;
+	do {
+		put_page(sgl->pages[i]);
+	} while (!sg_is_last(sgl->sg + (i++)));
+}
+EXPORT_SYMBOL_GPL(af_alg_free_sg);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con)
+{
+	struct cmsghdr *cmsg;
+
+	for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
+		if (!CMSG_OK(msg, cmsg))
+			return -EINVAL;
+		if (cmsg->cmsg_level != SOL_ALG)
+			continue;
+
+		switch(cmsg->cmsg_type) {
+		case ALG_SET_IV:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(*con->iv)))
+				return -EINVAL;
+			con->iv = (void *)CMSG_DATA(cmsg);
+			if (cmsg->cmsg_len < CMSG_LEN(con->iv->ivlen +
+						      sizeof(*con->iv)))
+				return -EINVAL;
+			break;
+
+		case ALG_SET_OP:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))
+				return -EINVAL;
+			con->op = *(u32 *)CMSG_DATA(cmsg);
+			break;
+
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_cmsg_send);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion)
+{
+	switch (err) {
+	case -EINPROGRESS:
+	case -EBUSY:
+		wait_for_completion(&completion->completion);
+		INIT_COMPLETION(completion->completion);
+		err = completion->err;
+		break;
+	};
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_wait_for_completion);
+
+void af_alg_complete(struct crypto_async_request *req, int err)
+{
+	struct af_alg_completion *completion = req->data;
+
+	completion->err = err;
+	complete(&completion->completion);
+}
+EXPORT_SYMBOL_GPL(af_alg_complete);
+
+static int __init af_alg_init(void)
+{
+	int err = proto_register(&alg_proto, 0);
+
+	if (err)
+		goto out;
+
+	err = sock_register(&alg_family);
+	if (err != 0)
+		goto out_unregister_proto;
+
+out:
+	return err;
+
+out_unregister_proto:
+	proto_unregister(&alg_proto);
+	goto out;
+}
+
+static void __exit af_alg_exit(void)
+{
+	sock_unregister(PF_ALG);
+	proto_unregister(&alg_proto);
+}
+
+module_init(af_alg_init);
+module_exit(af_alg_exit);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_NETPROTO(AF_ALG);
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/algif_hash.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/algif_hash.c
@@ -0,0 +1,319 @@
+/*
+ * algif_hash: User-space interface for hash algorithms
+ *
+ * This file provides the user-space API for hash algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/hash.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct hash_ctx {
+	struct af_alg_sgl sgl;
+
+	u8 *result;
+
+	struct af_alg_completion completion;
+
+	unsigned int len;
+	bool more;
+
+	struct ahash_request req;
+};
+
+static int hash_sendmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t ignored)
+{
+	int limit = ALG_MAX_PAGES * PAGE_SIZE;
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned long iovlen;
+	struct iovec *iov;
+	long copied = 0;
+	int err;
+
+	if (limit > sk->sk_sndbuf)
+		limit = sk->sk_sndbuf;
+
+	lock_sock(sk);
+	if (!ctx->more) {
+		err = crypto_ahash_init(&ctx->req);
+		if (err)
+			goto unlock;
+	}
+
+	ctx->more = 0;
+
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			int len = min_t(unsigned long, seglen, limit);
+			int newlen;
+
+			newlen = af_alg_make_sg(&ctx->sgl, from, len, 0);
+			if (newlen < 0)
+				goto unlock;
+
+			ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL,
+						newlen);
+
+			err = af_alg_wait_for_completion(
+				crypto_ahash_update(&ctx->req),
+				&ctx->completion);
+
+			af_alg_free_sg(&ctx->sgl);
+
+			if (err)
+				goto unlock;
+
+			seglen -= newlen;
+			from += newlen;
+			copied += newlen;
+		}
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more) {
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err ?: copied;
+}
+
+static ssize_t hash_sendpage(struct socket *sock, struct page *page,
+			     int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	int err;
+
+	lock_sock(sk);
+	sg_init_table(ctx->sgl.sg, 1);
+	sg_set_page(ctx->sgl.sg, page, size, offset);
+
+	ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, ctx->result, size);
+
+	if (!(flags & MSG_MORE)) {
+		if (ctx->more)
+			err = crypto_ahash_finup(&ctx->req);
+		else
+			err = crypto_ahash_digest(&ctx->req);
+	} else {
+		if (!ctx->more) {
+			err = crypto_ahash_init(&ctx->req);
+			if (err)
+				goto unlock;
+		}
+
+		err = crypto_ahash_update(&ctx->req);
+	}
+
+	err = af_alg_wait_for_completion(err, &ctx->completion);
+	if (err)
+		goto unlock;
+
+	ctx->more = flags & MSG_MORE;
+
+unlock:
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t len, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
+	int err;
+
+	if (len > ds)
+		len = ds;
+	else if (len < ds)
+		msg->msg_flags |= MSG_TRUNC;
+
+	lock_sock(sk);
+	if (ctx->more) {
+		ctx->more = 0;
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+		if (err)
+			goto unlock;
+	}
+
+	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);
+
+unlock:
+	release_sock(sk);
+
+	return err ?: len;
+}
+
+static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	struct ahash_request *req = &ctx->req;
+	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];
+	struct sock *sk2;
+	struct alg_sock *ask2;
+	struct hash_ctx *ctx2;
+	int err;
+
+	err = crypto_ahash_export(req, state);
+	if (err)
+		return err;
+
+	err = af_alg_accept(ask->parent, newsock);
+	if (err)
+		return err;
+
+	sk2 = newsock->sk;
+	ask2 = alg_sk(sk2);
+	ctx2 = ask2->private;
+	ctx2->more = 1;
+
+	err = crypto_ahash_import(&ctx2->req, state);
+	if (err) {
+		sock_orphan(sk2);
+		sock_put(sk2);
+	}
+
+	return err;
+}
+
+static struct proto_ops algif_hash_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.setsockopt	=	sock_no_setsockopt,
+	.poll		=	sock_no_poll,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	hash_sendmsg,
+	.sendpage	=	hash_sendpage,
+	.recvmsg	=	hash_recvmsg,
+	.accept		=	hash_accept,
+};
+
+static void *hash_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ahash(name, type, mask);
+}
+
+static void hash_release(void *private)
+{
+	crypto_free_ahash(private);
+}
+
+static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ahash_setkey(private, key, keylen);
+}
+
+static void hash_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+
+	sock_kfree_s(sk, ctx->result,
+		     crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int hash_accept_parent(void *private, struct sock *sk)
+{
+	struct hash_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);
+	unsigned ds = crypto_ahash_digestsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);
+	if (!ctx->result) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->result, 0, ds);
+
+	ctx->len = len;
+	ctx->more = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ahash_request_set_tfm(&ctx->req, private);
+	ahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				   af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = hash_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_hash = {
+	.bind		=	hash_bind,
+	.release	=	hash_release,
+	.setkey		=	hash_setkey,
+	.accept		=	hash_accept_parent,
+	.ops		=	&algif_hash_ops,
+	.name		=	"hash",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_hash_init(void)
+{
+	return af_alg_register_type(&algif_type_hash);
+}
+
+static void __exit algif_hash_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_hash);
+	BUG_ON(err);
+}
+
+module_init(algif_hash_init);
+module_exit(algif_hash_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/algif_skcipher.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/algif_skcipher.c
@@ -0,0 +1,632 @@
+/*
+ * algif_skcipher: User-space interface for skcipher algorithms
+ *
+ * This file provides the user-space API for symmetric key ciphers.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/scatterwalk.h>
+#include <crypto/skcipher.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct skcipher_sg_list {
+	struct list_head list;
+
+	int cur;
+
+	struct scatterlist sg[0];
+};
+
+struct skcipher_ctx {
+	struct list_head tsgl;
+	struct af_alg_sgl rsgl;
+
+	void *iv;
+
+	struct af_alg_completion completion;
+
+	unsigned used;
+
+	unsigned int len;
+	bool more;
+	bool merge;
+	bool enc;
+
+	struct ablkcipher_request req;
+};
+
+#define MAX_SGL_ENTS ((PAGE_SIZE - sizeof(struct skcipher_sg_list)) / \
+		      sizeof(struct scatterlist) - 1)
+
+static inline int skcipher_sndbuf(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	return max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -
+			  ctx->used, 0);
+}
+
+static inline bool skcipher_writable(struct sock *sk)
+{
+	return PAGE_SIZE <= skcipher_sndbuf(sk);
+}
+
+static int skcipher_alloc_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg = NULL;
+
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+	if (!list_empty(&ctx->tsgl))
+		sg = sgl->sg;
+
+	if (!sg || sgl->cur >= MAX_SGL_ENTS) {
+		sgl = sock_kmalloc(sk, sizeof(*sgl) +
+				       sizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),
+				   GFP_KERNEL);
+		if (!sgl)
+			return -ENOMEM;
+
+		sg_init_table(sgl->sg, MAX_SGL_ENTS + 1);
+		sgl->cur = 0;
+
+		if (sg)
+			scatterwalk_sg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);
+
+		list_add_tail(&sgl->list, &ctx->tsgl);
+	}
+
+	return 0;
+}
+
+static void skcipher_pull_sgl(struct sock *sk, int used)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	int i;
+
+	while (!list_empty(&ctx->tsgl)) {
+		sgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,
+				       list);
+		sg = sgl->sg;
+
+		for (i = 0; i < sgl->cur; i++) {
+			int plen = min_t(int, used, sg[i].length);
+
+			if (!sg_page(sg + i))
+				continue;
+
+			sg[i].length -= plen;
+			sg[i].offset += plen;
+
+			used -= plen;
+			ctx->used -= plen;
+
+			if (sg[i].length)
+				return;
+
+			put_page(sg_page(sg + i));
+			sg_assign_page(sg + i, NULL);
+		}
+
+		list_del(&sgl->list);
+		sock_kfree_s(sk, sgl,
+			     sizeof(*sgl) + sizeof(sgl->sg[0]) *
+					    (MAX_SGL_ENTS + 1));
+	}
+
+	if (!ctx->used)
+		ctx->merge = 0;
+}
+
+static void skcipher_free_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	skcipher_pull_sgl(sk, ctx->used);
+}
+
+static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)
+{
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT)
+		return -EAGAIN;
+
+	set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	return err;
+}
+
+static void skcipher_wmem_wakeup(struct sock *sk)
+{
+	struct socket_wq *wq;
+
+	if (!skcipher_writable(sk))
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLIN |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
+	rcu_read_unlock();
+}
+
+static int skcipher_wait_for_data(struct sock *sk, unsigned flags)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT) {
+		return -EAGAIN;
+	}
+
+	set_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, ctx->used)) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	return err;
+}
+
+static void skcipher_data_wakeup(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct socket_wq *wq;
+
+	if (!ctx->used)
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLOUT |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);
+	rcu_read_unlock();
+}
+
+static int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+	unsigned ivsize = crypto_ablkcipher_ivsize(tfm);
+	struct skcipher_sg_list *sgl;
+	struct af_alg_control con = {};
+	long copied = 0;
+	bool enc = 0;
+	int err;
+	int i;
+
+	if (msg->msg_controllen) {
+		err = af_alg_cmsg_send(msg, &con);
+		if (err)
+			return err;
+
+		switch (con.op) {
+		case ALG_OP_ENCRYPT:
+			enc = 1;
+			break;
+		case ALG_OP_DECRYPT:
+			enc = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (con.iv && con.iv->ivlen != ivsize)
+			return -EINVAL;
+	}
+
+	err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!ctx->used) {
+		ctx->enc = enc;
+		if (con.iv)
+			memcpy(ctx->iv, con.iv->iv, ivsize);
+	}
+
+	while (size) {
+		struct scatterlist *sg;
+		unsigned long len = size;
+		int plen;
+
+		if (ctx->merge) {
+			sgl = list_entry(ctx->tsgl.prev,
+					 struct skcipher_sg_list, list);
+			sg = sgl->sg + sgl->cur - 1;
+			len = min_t(unsigned long, len,
+				    PAGE_SIZE - sg->offset - sg->length);
+
+			err = memcpy_fromiovec(page_address(sg_page(sg)) +
+					       sg->offset + sg->length,
+					       msg->msg_iov, len);
+			if (err)
+				goto unlock;
+
+			sg->length += len;
+			ctx->merge = (sg->offset + sg->length) &
+				     (PAGE_SIZE - 1);
+
+			ctx->used += len;
+			copied += len;
+			size -= len;
+			continue;
+		}
+
+		if (!skcipher_writable(sk)) {
+			err = skcipher_wait_for_wmem(sk, msg->msg_flags);
+			if (err)
+				goto unlock;
+		}
+
+		len = min_t(unsigned long, len, skcipher_sndbuf(sk));
+
+		err = skcipher_alloc_sgl(sk);
+		if (err)
+			goto unlock;
+
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+		sg = sgl->sg;
+		do {
+			i = sgl->cur;
+			plen = min_t(int, len, PAGE_SIZE);
+
+			sg_assign_page(sg + i, alloc_page(GFP_KERNEL));
+			err = -ENOMEM;
+			if (!sg_page(sg + i))
+				goto unlock;
+
+			err = memcpy_fromiovec(page_address(sg_page(sg + i)),
+					       msg->msg_iov, plen);
+			if (err) {
+				__free_page(sg_page(sg + i));
+				sg_assign_page(sg + i, NULL);
+				goto unlock;
+			}
+
+			sg[i].length = plen;
+			len -= plen;
+			ctx->used += plen;
+			copied += plen;
+			size -= plen;
+			sgl->cur++;
+		} while (len && sgl->cur < MAX_SGL_ENTS);
+
+		ctx->merge = plen & (PAGE_SIZE - 1);
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+static ssize_t skcipher_sendpage(struct socket *sock, struct page *page,
+				 int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	int err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!size)
+		goto done;
+
+	if (!skcipher_writable(sk)) {
+		err = skcipher_wait_for_wmem(sk, flags);
+		if (err)
+			goto unlock;
+	}
+
+	err = skcipher_alloc_sgl(sk);
+	if (err)
+		goto unlock;
+
+	ctx->merge = 0;
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+	get_page(page);
+	sg_set_page(sgl->sg + sgl->cur, page, size, offset);
+	sgl->cur++;
+	ctx->used += size;
+
+done:
+	ctx->more = flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t ignored, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(
+		&ctx->req));
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	unsigned long iovlen;
+	struct iovec *iov;
+	int err = -EAGAIN;
+	int used;
+	long copied = 0;
+
+	lock_sock(sk);
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			sgl = list_first_entry(&ctx->tsgl,
+					       struct skcipher_sg_list, list);
+			sg = sgl->sg;
+
+			while (!sg->length)
+				sg++;
+
+			used = ctx->used;
+			if (!used) {
+				err = skcipher_wait_for_data(sk, flags);
+				if (err)
+					goto unlock;
+			}
+
+			used = min_t(unsigned long, used, seglen);
+
+			used = af_alg_make_sg(&ctx->rsgl, from, used, 1);
+			err = used;
+			if (err < 0)
+				goto unlock;
+
+			if (ctx->more || used < ctx->used)
+				used -= used % bs;
+
+			err = -EINVAL;
+			if (!used)
+				goto free;
+
+			ablkcipher_request_set_crypt(&ctx->req, sg,
+						     ctx->rsgl.sg, used,
+						     ctx->iv);
+
+			err = af_alg_wait_for_completion(
+				ctx->enc ?
+					crypto_ablkcipher_encrypt(&ctx->req) :
+					crypto_ablkcipher_decrypt(&ctx->req),
+				&ctx->completion);
+
+free:
+			af_alg_free_sg(&ctx->rsgl);
+
+			if (err)
+				goto unlock;
+
+			copied += used;
+			from += used;
+			seglen -= used;
+			skcipher_pull_sgl(sk, used);
+		}
+	}
+
+	err = 0;
+
+unlock:
+	skcipher_wmem_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+
+static unsigned int skcipher_poll(struct file *file, struct socket *sock,
+				  poll_table *wait)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned int mask;
+
+	sock_poll_wait(file, sk_sleep(sk), wait);
+	mask = 0;
+
+	if (ctx->used)
+		mask |= POLLIN | POLLRDNORM;
+
+	if (skcipher_writable(sk))
+		mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
+
+	return mask;
+}
+
+static struct proto_ops algif_skcipher_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.accept		=	sock_no_accept,
+	.setsockopt	=	sock_no_setsockopt,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	skcipher_sendmsg,
+	.sendpage	=	skcipher_sendpage,
+	.recvmsg	=	skcipher_recvmsg,
+	.poll		=	skcipher_poll,
+};
+
+static void *skcipher_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ablkcipher(name, type, mask);
+}
+
+static void skcipher_release(void *private)
+{
+	crypto_free_ablkcipher(private);
+}
+
+static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ablkcipher_setkey(private, key, keylen);
+}
+
+static void skcipher_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+
+	skcipher_free_sgl(sk);
+	sock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int skcipher_accept_parent(void *private, struct sock *sk)
+{
+	struct skcipher_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),
+			       GFP_KERNEL);
+	if (!ctx->iv) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));
+
+	INIT_LIST_HEAD(&ctx->tsgl);
+	ctx->len = len;
+	ctx->used = 0;
+	ctx->more = 0;
+	ctx->merge = 0;
+	ctx->enc = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ablkcipher_request_set_tfm(&ctx->req, private);
+	ablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = skcipher_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_skcipher = {
+	.bind		=	skcipher_bind,
+	.release	=	skcipher_release,
+	.setkey		=	skcipher_setkey,
+	.accept		=	skcipher_accept_parent,
+	.ops		=	&algif_skcipher_ops,
+	.name		=	"skcipher",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_skcipher_init(void)
+{
+	return af_alg_register_type(&algif_type_skcipher);
+}
+
+static void __exit algif_skcipher_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_skcipher);
+	BUG_ON(err);
+}
+
+module_init(algif_skcipher_init);
+module_exit(algif_skcipher_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/core/sock.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/core/sock.c
@@ -157,7 +157,7 @@
   "sk_lock-27"       , "sk_lock-28"          , "sk_lock-AF_CAN"      ,
   "sk_lock-AF_TIPC"  , "sk_lock-AF_BLUETOOTH", "sk_lock-IUCV"        ,
   "sk_lock-AF_RXRPC" , "sk_lock-AF_ISDN"     , "sk_lock-AF_PHONET"   ,
-  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" ,
+  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" , "sk_lock-AF_ALG"      ,
   "sk_lock-AF_MAX"
 };
 static const char *const af_family_slock_key_strings[AF_MAX+1] = {
@@ -173,7 +173,7 @@
   "slock-27"       , "slock-28"          , "slock-AF_CAN"      ,
   "slock-AF_TIPC"  , "slock-AF_BLUETOOTH", "slock-AF_IUCV"     ,
   "slock-AF_RXRPC" , "slock-AF_ISDN"     , "slock-AF_PHONET"   ,
-  "slock-AF_IEEE802154", "slock-AF_CAIF" ,
+  "slock-AF_IEEE802154", "slock-AF_CAIF" , "slock-AF_ALG"      ,
   "slock-AF_MAX"
 };
 static const char *const af_family_clock_key_strings[AF_MAX+1] = {
@@ -189,7 +189,7 @@
   "clock-27"       , "clock-28"          , "clock-AF_CAN"      ,
   "clock-AF_TIPC"  , "clock-AF_BLUETOOTH", "clock-AF_IUCV"     ,
   "clock-AF_RXRPC" , "clock-AF_ISDN"     , "clock-AF_PHONET"   ,
-  "clock-AF_IEEE802154", "clock-AF_CAIF" ,
+  "clock-AF_IEEE802154", "clock-AF_CAIF" , "clock-AF_ALG"      ,
   "clock-AF_MAX"
 };
 
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/crypto/if_alg.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/crypto/if_alg.h
@@ -0,0 +1,92 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _CRYPTO_IF_ALG_H
+#define _CRYPTO_IF_ALG_H
+
+#include <linux/compiler.h>
+#include <linux/completion.h>
+#include <linux/if_alg.h>
+#include <linux/types.h>
+#include <net/sock.h>
+
+#define ALG_MAX_PAGES			16
+
+struct crypto_async_request;
+
+struct alg_sock {
+	/* struct sock must be the first member of struct alg_sock */
+	struct sock sk;
+
+	struct sock *parent;
+
+	const struct af_alg_type *type;
+	void *private;
+};
+
+struct af_alg_completion {
+	struct completion completion;
+	int err;
+};
+
+struct af_alg_control {
+	struct af_alg_iv *iv;
+	int op;
+};
+
+struct af_alg_type {
+	void *(*bind)(const char *name, u32 type, u32 mask);
+	void (*release)(void *private);
+	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
+	int (*accept)(void *private, struct sock *sk);
+
+	struct proto_ops *ops;
+	struct module *owner;
+	char name[14];
+};
+
+struct af_alg_sgl {
+	struct scatterlist sg[ALG_MAX_PAGES];
+	struct page *pages[ALG_MAX_PAGES];
+};
+
+int af_alg_register_type(const struct af_alg_type *type);
+int af_alg_unregister_type(const struct af_alg_type *type);
+
+int af_alg_release(struct socket *sock);
+int af_alg_accept(struct sock *sk, struct socket *newsock);
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write);
+void af_alg_free_sg(struct af_alg_sgl *sgl);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion);
+void af_alg_complete(struct crypto_async_request *req, int err);
+
+static inline struct alg_sock *alg_sk(struct sock *sk)
+{
+	return (struct alg_sock *)sk;
+}
+
+static inline void af_alg_release_parent(struct sock *sk)
+{
+	sock_put(alg_sk(sk)->parent);
+}
+
+static inline void af_alg_init_completion(struct af_alg_completion *completion)
+{
+	init_completion(&completion->completion);
+}
+
+#endif	/* _CRYPTO_IF_ALG_H */
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/crypto/scatterwalk.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/crypto/scatterwalk.h
@@ -68,6 +68,21 @@
 	return (++sg)->length ? sg : (void *)sg_page(sg);
 }
 
+static inline void scatterwalk_crypto_chain(struct scatterlist *head,
+					    struct scatterlist *sg,
+					    int chain, int num)
+{
+	if (chain) {
+		head->length += sg->length;
+		sg = scatterwalk_sg_next(sg);
+	}
+
+	if (sg)
+		scatterwalk_sg_chain(head, num, sg);
+	else
+		sg_mark_end(head);
+}
+
 static inline unsigned long scatterwalk_samebuf(struct scatter_walk *walk_in,
 						struct scatter_walk *walk_out)
 {
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/linux/if_alg.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/linux/if_alg.h
@@ -0,0 +1,40 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _LINUX_IF_ALG_H
+#define _LINUX_IF_ALG_H
+
+#include <linux/types.h>
+
+struct sockaddr_alg {
+	__u16	salg_family;
+	__u8	salg_type[14];
+	__u32	salg_feat;
+	__u32	salg_mask;
+	__u8	salg_name[64];
+};
+
+struct af_alg_iv {
+	__u32	ivlen;
+	__u8	iv[0];
+};
+
+/* Socket options */
+#define ALG_SET_KEY			1
+#define ALG_SET_IV			2
+#define ALG_SET_OP			3
+
+/* Operations */
+#define ALG_OP_DECRYPT			0
+#define ALG_OP_ENCRYPT			1
+
+#endif	/* _LINUX_IF_ALG_H */
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/linux/socket.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/linux/socket.h
@@ -193,7 +193,8 @@
 #define AF_PHONET	35	/* Phonet sockets		*/
 #define AF_IEEE802154	36	/* IEEE802154 sockets		*/
 #define AF_CAIF		37	/* CAIF sockets			*/
-#define AF_MAX		38	/* For now.. */
+#define AF_ALG		38	/* Algorithm sockets		*/
+#define AF_MAX		39	/* For now.. */
 
 /* Protocol families, same as address families. */
 #define PF_UNSPEC	AF_UNSPEC
@@ -234,6 +235,7 @@
 #define PF_PHONET	AF_PHONET
 #define PF_IEEE802154	AF_IEEE802154
 #define PF_CAIF		AF_CAIF
+#define PF_ALG		AF_ALG
 #define PF_MAX		AF_MAX
 
 /* Maximum queue length specifiable by listen.  */
@@ -310,6 +312,7 @@
 #define SOL_RDS		276
 #define SOL_IUCV	277
 #define SOL_CAIF	278
+#define SOL_ALG		279
 
 /* IPX options */
 #define IPX_TYPE	1
--- a/release/src-rt/Makefile
+++ b/release/src-rt/Makefile
@@ -2556,12 +2556,6 @@
 	else \
 		echo "CONFIG_LINUX_MTD=$(LINUX_MTD)" >>$(1); \
 	fi; \
-	sed -i "/CONFIG_NF_CONNTRACK_EVENTS/d" $(1); \
-	if [ "$(BWDPI)" = "y" ]; then \
-		echo "CONFIG_NF_CONNTRACK_EVENTS=y" >>$(1); \
-	else \
-		echo "# CONFIG_NF_CONNTRACK_EVENTS is not set" >>$(1); \
-	fi; \
 	if [ "$(USB_DEBUG)" = "y" ]; then \
 		sed -i "/CONFIG_USB_DEBUG/d" $(1); \
 		echo "CONFIG_USB_DEBUG=y" >>$(1); \
--- a/release/src-rt/target.mak
+++ b/release/src-rt/target.mak
@@ -1,91 +1,91 @@
 # Broadcom MIPS platform
 export RT-N66U := IPV6SUPP=y HTTPS=y MIPS32=r2 BCM57=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=y \
-                  MEDIASRV=y MODEM=y MODEMPIN=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y WEBDAV=y SMARTSYNCBASE=y \
+                  MEDIASRV=n MODEM=y MODEMPIN=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y WEBDAV=n SMARTSYNCBASE=n \
                   USB="USB" GRO=n APP="nolocaldm" BUILD_NAME="RT-N66U" DNSMQ=y LFP=y NVRAM_64K=y NFS=y STAINFO=y \
                   RTN66U=y BECEEM=y ODMPID=y OPENVPN=y OPTIMIZE_XBOX=y JFFS2=y SSH=y DISK_MONITOR=y BCMWL6=y \
                   USER_LOW_RSSI=y  TIMEMACHINE=n MDNS=n VPNC=y JFFS2LOG=n JFFS2USERICON=y \
-                  PROXYSTA=y AUTODICT=y CFE_NVRAM_CHK=y DUMP_OOPS_MSG=y DEBUGFS=n SNMPD=y ROG=y \
-                  TFAT=n HFS="none" NTFS="paragon" IPSECMOD=y REPEATER=y DUALWAN=y YANDEXDNS=n DNSFILTER=y SAMBA36=y \
-                  CLOUDCHECK=y NATNL=y REBOOT_SCHEDULE=y MULTICASTIPTV=y QUAGGA=y LAN50=y ATCOVER=y GETREALIP=y \
+                  PROXYSTA=y AUTODICT=y CFE_NVRAM_CHK=y DUMP_OOPS_MSG=y DEBUGFS=n SNMPD=n ROG=y \
+                  TFAT=n HFS="none" NTFS="paragon" IPSECMOD=y REPEATER=y DUALWAN=n YANDEXDNS=n DNSFILTER=n SAMBA36=y \
+                  CLOUDCHECK=n NATNL=y REBOOT_SCHEDULE=y MULTICASTIPTV=y QUAGGA=y LAN50=y ATCOVER=y GETREALIP=n \
                   TOR=y UPNPIGD2=n DNSSEC=y NANO=y
 
 export RT-AC66U := IPV6SUPP=y HTTPS=y MIPS32=r2 BCM57=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=y STAINFO=y \
-                   MEDIASRV=y MODEM=y MODEMPIN=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y WEBDAV=y SMARTSYNCBASE=y \
+                   MEDIASRV=n MODEM=y MODEMPIN=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y WEBDAV=n SMARTSYNCBASE=n \
                    USB="USB" GRO=n APP="nolocaldm" BUILD_NAME="RT-AC66U" DNSMQ=y LFP=y NVRAM_64K=y ROG=y \
                    RTAC66U=y BCMWL6=y BCMNAND=y PROXYSTA=y BECEEM=y ODMPID=y OPENVPN=y JFFS2=y AUTODICT=y \
-                   SSH=y BOOTLZMA=y DUAL_TRX=n DISK_MONITOR=y OPTIMIZE_XBOX=y NFS=y USER_LOW_RSSI=y SNMPD=y \
+                   SSH=y BOOTLZMA=y DUAL_TRX=n DISK_MONITOR=y OPTIMIZE_XBOX=y NFS=y USER_LOW_RSSI=y SNMPD=n \
                    TIMEMACHINE=n MDNS=n VPNC=y JFFS2LOG=y DUMP_OOPS_MSG=y DEBUGFS=n TEMPROOTFS=y \
-                   TOR=y UPNPIGD2=n STAINFO=y CLOUDCHECK=y NATNL=y EMAIL=y \
+                   TOR=y UPNPIGD2=n STAINFO=y CLOUDCHECK=n NATNL=y EMAIL=n \
                    REBOOT_SCHEDULE=y TFAT=n HFS="none" NTFS="paragon" MULTICASTIPTV=y QUAGGA=y JFFS2USERICON=y \
-                   LAN50=y ATCOVER=y GETREALIP=y \
-                   IPSECMOD=y REPEATER=y DUALWAN=y YANDEXDNS=n DNSFILTER=y SAMBA36=y DNSSEC=y NANO=y
+                   LAN50=y ATCOVER=y GETREALIP=n \
+                   IPSECMOD=y REPEATER=y DUALWAN=n YANDEXDNS=n DNSFILTER=n SAMBA36=y DNSSEC=y NANO=y
 
 # Broadcom ARM platform
 export RT-AC68U_BASE := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y \
-                        SAMBA3=y MEDIASRV=y MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y STAINFO=y \
-                        WEBDAV=y SMARTSYNCBASE=y USB="USB" GRO=y APP="nolocaldm" PROXYSTA=y JFFS2USERICON=y \
+                        SAMBA3=y MEDIASRV=n MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y STAINFO=y \
+                        WEBDAV=n SMARTSYNCBASE=n USB="USB" GRO=y APP="nolocaldm" PROXYSTA=y JFFS2USERICON=y \
                         DNSMQ=y SHP=y NVRAM_64K=y RTAC68U=y BCMWL6=y BCMWL6A=y TUNEK="n" BCM5301X=y DISK_MONITOR=y \
-                        BTN_WIFITOG=y LOGO_LED=y OPTIMIZE_XBOX=y ODMPID=y LED_BTN=y ROG=y SSD=n EMAIL=y \
+                        BTN_WIFITOG=y LOGO_LED=y OPTIMIZE_XBOX=y ODMPID=y LED_BTN=y ROG=y SSD=n EMAIL=n \
                         BCMSMP=y XHCI=y SSH=y JFFS2=y NFS=y OPENVPN=y USER_LOW_RSSI=y \
-                        TIMEMACHINE=y MDNS=y VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y BWDPI=y HSPOT=y \
-                        DUMP_OOPS_MSG=y LINUX_MTD="64" BCM7=n TEMPROOTFS=y DEBUGFS=y SNMPD=y TOR=y \
-                        MULTICASTIPTV=y QUAGGA=y BCM_RECVFILE=y LAN50=y ATCOVER=y GETREALIP=y \
-                        BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=y NATNL=y REBOOT_SCHEDULE=y \
-                        TFAT=y HFS="tuxera" NTFS="tuxera" IPSECMOD=n REPEATER=y DUALWAN=y DNSFILTER=y SAMBA36=y UPNPIGD2=n \
+                        TIMEMACHINE=n MDNS=n VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y BWDPI=n HSPOT=n \
+                        DUMP_OOPS_MSG=y LINUX_MTD="64" BCM7=n TEMPROOTFS=y DEBUGFS=y SNMPD=n TOR=y \
+                        MULTICASTIPTV=y QUAGGA=y BCM_RECVFILE=y LAN50=y ATCOVER=y GETREALIP=n \
+                        BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=n NATNL=y REBOOT_SCHEDULE=y \
+                        TFAT=y HFS="tuxera" NTFS="tuxera" IPSECMOD=n REPEATER=y DUALWAN=n DNSFILTER=n SAMBA36=y UPNPIGD2=n \
                         DNSSEC=y NANO=y
 
 export RT-AC68U := $(RT-AC68U_BASE) FAKEHDR=y FORCE_SN=380 FORCE_EN=1031
 export RT-AC68U += BUILD_NAME="RT-AC68U"
 
 export RT-AC56U := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y ROMCCODE=y \
-                   SAMBA3=y MEDIASRV=y MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y STAINFO=y \
-                   WEBDAV=y SMARTSYNCBASE=y USB="USB" GRO=y APP="nolocaldm" BUILD_NAME="RT-AC56U" PROXYSTA=y BCM_RECVFILE=y \
+                   SAMBA3=y MEDIASRV=n MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y STAINFO=y \
+                   WEBDAV=n SMARTSYNCBASE=n USB="USB" GRO=y APP="nolocaldm" BUILD_NAME="RT-AC56U" PROXYSTA=y BCM_RECVFILE=y \
                    DNSMQ=y SHP=y NVRAM_64K=y RTAC56U=y BCMWL6=y BCMWL6A=y TUNEK="n" BCM5301X=y DISK_MONITOR=y \
                    BTN_WIFITOG=y TURBO=y BCM4352_5G=y LANWAN_LED=y OPTIMIZE_XBOX=y ODMPID=y BCMSMP=y \
-                   LED_ALL=y XHCI=y SSH=y JFFS2=y NFS=y OPENVPN=y LINUX_MTD="64" USER_LOW_RSSI=y ROG=y EMAIL=y \
-                   TIMEMACHINE=y MDNS=y VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y XHCIMODE=y LAN50=y ATCOVER=y GETREALIP=y \
-                   TEMPROOTFS=y SNMPD=y DEBUGFS=y BWDPI=y TOR=y \
-                   BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=y DUMP_OOPS_MSG=y REBOOT_SCHEDULE=y MULTICASTIPTV=y QUAGGA=y \
-                   TFAT=y HFS="tuxera" NTFS="tuxera" IPSECMOD=n REPEATER=y DUALWAN=y DNSFILTER=y SAMBA36=y UPNPIGD2=n \
+                   LED_ALL=y XHCI=y SSH=y JFFS2=y NFS=y OPENVPN=y LINUX_MTD="64" USER_LOW_RSSI=y ROG=y EMAIL=n \
+                   TIMEMACHINE=n MDNS=n VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y XHCIMODE=y LAN50=y ATCOVER=y GETREALIP=n \
+                   TEMPROOTFS=y SNMPD=n DEBUGFS=y BWDPI=n TOR=y \
+                   BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=n DUMP_OOPS_MSG=y REBOOT_SCHEDULE=y MULTICASTIPTV=y QUAGGA=y \
+                   TFAT=y HFS="tuxera" NTFS="tuxera" IPSECMOD=n REPEATER=y DUALWAN=n DNSFILTER=n SAMBA36=y UPNPIGD2=n \
                    DNSSEC=y NANO=y
 
 export RT-AC87U := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y WPS_DUALBAND=y ROG=y \
-                   SAMBA3=y MEDIASRV=y MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y STAINFO=y \
-                   WEBDAV=y SMARTSYNCBASE=y USB="USB" GRO=y APP="nolocaldm" BUILD_NAME="RT-AC87U" PROXYSTA=y \
+                   SAMBA3=y MEDIASRV=n MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y STAINFO=y \
+                   WEBDAV=n SMARTSYNCBASE=n USB="USB" GRO=y APP="nolocaldm" BUILD_NAME="RT-AC87U" PROXYSTA=y \
                    DNSMQ=y SHP=y NVRAM_64K=y BCMWL6=y BCMWL6A=y TUNEK="n" BCM5301X=y DISK_MONITOR=y JFFS2=y BCM_RECVFILE=y \
                    BTN_WIFITOG=y OPTIMIZE_XBOX=y ODMPID=y LED_BTN=y LED2_BTN=y DUMP_OOPS_MSG=y \
-                   BCMSMP=y XHCI=y DUALWAN=y REPEATER=y USER_LOW_RSSI=y OPENVPN=y TIMEMACHINE=y EMAIL=y \
-                   MDNS=y VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y RGMII_BCM_FA=y XHCIMODE=y DISABLE_REPEATER_UI=y \
-                   QTN=y TFTP=y LINUX_MTD="64" RGMII_BRCM5301X=y BWDPI=y RTAC87U=y EXT_LED_WPS=y DEBUGFS=y \
-                   BCM5301X_TRAFFIC_MONITOR=n NATNL=y JFFS2USERICON=y CLOUDCHECK=y LACP=n HW_DUALWAN=y \
-                   TEMPROOTFS=y JFFS2ND_BACKUP=y SNMPD=y TOR=y REBOOT_SCHEDULE=y \
-                   MULTICASTIPTV=y QUAGGA=y LAN50=y ATCOVER=y GETREALIP=y NANO=y \
-                   TFAT=y HFS="tuxera" NTFS="tuxera" NFS=y SSH=y IPSECMOD=n DNSFILTER=y SAMBA36=y UPNPIGD2=n DNSSEC=y
+                   BCMSMP=y XHCI=y DUALWAN=n REPEATER=y USER_LOW_RSSI=y OPENVPN=y TIMEMACHINE=n EMAIL=n \
+                   MDNS=n VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y RGMII_BCM_FA=y XHCIMODE=y DISABLE_REPEATER_UI=y \
+                   QTN=y TFTP=y LINUX_MTD="64" RGMII_BRCM5301X=y BWDPI=n RTAC87U=y EXT_LED_WPS=y DEBUGFS=y \
+                   BCM5301X_TRAFFIC_MONITOR=n NATNL=y JFFS2USERICON=y CLOUDCHECK=n LACP=n HW_DUALWAN=n \
+                   TEMPROOTFS=y JFFS2ND_BACKUP=y SNMPD=n TOR=y REBOOT_SCHEDULE=y \
+                   MULTICASTIPTV=y QUAGGA=y LAN50=y ATCOVER=y GETREALIP=n NANO=y \
+                   TFAT=y HFS="tuxera" NTFS="tuxera" NFS=y SSH=y IPSECMOD=n DNSFILTER=n SAMBA36=y UPNPIGD2=n DNSSEC=y
 
-export RT-AC3200 := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=y MEDIASRV=y \
-                    MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y WEBDAV=y SMARTSYNCBASE=y \
+export RT-AC3200 := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=y MEDIASRV=n \
+                    MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y WEBDAV=n SMARTSYNCBASE=n \
                     USB="USB" GRO=y APP="nolocaldm" BUILD_NAME="RT-AC3200" PROXYSTA=y DNSMQ=y SHP=y NVRAM_64K=y STAINFO=y \
                     RTAC3200=y BCMWL6=y BCMWL6A=y BCM7=y TUNEK="n" BCM5301X=y DISK_MONITOR=y BTN_WIFITOG=y OPTIMIZE_XBOX=y \
-                    ODMPID=y LED_BTN=y BCMSMP=y DUALWAN=y REPEATER=y USER_LOW_RSSI=y OPENVPN=y DPSTA=y \
-                    TIMEMACHINE=y MDNS=y TFAT=y NTFS="tuxera" HFS="tuxera" VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y \
-                    XHCI=y BWDPI=y DUMP_OOPS_MSG=y DHDAP=y GMAC3=y HSPOT=n LINUX_MTD="64" DEBUGFS=y NVSIZE="64" \
-                    TEMPROOTFS=y SSH=y NOWL=y EMAIL=y BCM_RECVFILE=y REBOOT_SCHEDULE=y JFFS2USERICON=y \
-                    BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=y NATNL=y DISABLE_REPEATER_UI=y \
-                    MULTICASTIPTV=y QUAGGA=y LAN50=y ATCOVER=y GETREALIP=y NANO=y \
-                    NFS=y IPSECMOD=n DNSFILTER=y SAMBA36=y SNMPD=y TOR=y UPNPIGD2=n DNSSEC=y
+                    ODMPID=y LED_BTN=y BCMSMP=y DUALWAN=n REPEATER=y USER_LOW_RSSI=y OPENVPN=y DPSTA=y \
+                    TIMEMACHINE=n MDNS=n TFAT=y NTFS="tuxera" HFS="tuxera" VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y \
+                    XHCI=y BWDPI=n DUMP_OOPS_MSG=y DHDAP=y GMAC3=y HSPOT=n LINUX_MTD="64" DEBUGFS=y NVSIZE="64" \
+                    TEMPROOTFS=y SSH=y NOWL=y EMAIL=n BCM_RECVFILE=y REBOOT_SCHEDULE=y JFFS2USERICON=y \
+                    BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=n NATNL=y DISABLE_REPEATER_UI=y \
+                    MULTICASTIPTV=y QUAGGA=y LAN50=y ATCOVER=y GETREALIP=n NANO=y \
+                    NFS=y IPSECMOD=n DNSFILTER=n SAMBA36=y SNMPD=n TOR=y UPNPIGD2=n DNSSEC=y
 
 
-export RT-AC88U_BASE := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=y MEDIASRV=y \
-                        MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y WEBDAV=y SMARTSYNCBASE=y \
+export RT-AC88U_BASE := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=y MEDIASRV=n \
+                        MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y WEBDAV=n SMARTSYNCBASE=n \
                         USB="USB" GRO=y APP="nolocaldm" DNSMQ=y SHP=y BCMWL6=y BCMWL6A=y TUNEK="n" BCM5301X=y JFFS2USERICON=y \
                         DISK_MONITOR=y BTN_WIFITOG=y OPTIMIZE_XBOX=y LED_BTN=y ODMPID=y BCMSMP=y XHCI=y \
-                        DUALWAN=y REPEATER=y USER_LOW_RSSI=y OPENVPN=y TIMEMACHINE=y MDNS=y VPNC=y BRCM_NAND_JFFS2=y \
+                        DUALWAN=n REPEATER=y USER_LOW_RSSI=y OPENVPN=y TIMEMACHINE=n MDNS=n VPNC=y BRCM_NAND_JFFS2=y \
                         REBOOT_SCHEDULE=y FORCE_AUTO_UPGRADE=n FAKEID=n MULTICASTIPTV=y QUAGGA=y \
-                        JFFS2LOG=y BWDPI=y DUMP_OOPS_MSG=y LINUX_MTD="64" DEBUGFS=y TEMPROOTFS=y SSH=y WIFILOGO=n \
-                        EMAIL=y ROG=y SSD=n STAINFO=y BCM5301X_TRAFFIC_MONITOR=n PROXYSTA=y \
-                        BCM_RECVFILE=y TFAT=y NTFS="tuxera" HFS="tuxera" CFEZ=y NATNL=y ERPTEST=n CLOUDCHECK=y \
-                        ASPMD=n BCMEVENT=n WLCLMLOAD=n BCM_MUMIMO=y LAN50=y ATCOVER=y GETREALIP=y \
-                        NFS=y IPSECMOD=n DNSFILTER=y SAMBA36=y SNMPD=y TOR=y UPNPIGD2=n DNSSEC=y NANO=y
+                        JFFS2LOG=y BWDPI=n DUMP_OOPS_MSG=y LINUX_MTD="64" DEBUGFS=y TEMPROOTFS=y SSH=y WIFILOGO=n \
+                        EMAIL=n ROG=y SSD=n STAINFO=y BCM5301X_TRAFFIC_MONITOR=n PROXYSTA=y \
+                        BCM_RECVFILE=y TFAT=y NTFS="tuxera" HFS="tuxera" CFEZ=y NATNL=y ERPTEST=n CLOUDCHECK=n \
+                        ASPMD=n BCMEVENT=n WLCLMLOAD=n BCM_MUMIMO=y LAN50=y ATCOVER=y GETREALIP=n \
+                        NFS=y IPSECMOD=n DNSFILTER=n SAMBA36=y SNMPD=n TOR=y UPNPIGD2=n DNSSEC=y NANO=y
 
 export RT-AC88U := $(RT-AC88U_BASE)
 export RT-AC88U += BUILD_NAME="RT-AC88U" RGMII_BRCM5301X=y SWITCH2="RTL8365MB" BCM_MMC=n BCM_7114=y NOWLALL=n \
--- a/release/src/router/config_base
+++ b/release/src/router/config_base
@@ -300,7 +300,7 @@
 # RTCONFIG_MULTICAST_IPTV is not set
 # RTCONFIG_DYN_MODEM is not set
 # RTCONFIG_NOTIFICATION_CENTER is not set
-RTCONFIG_PROTECTION_SERVER=y
+# RTCONFIG_PROTECTION_SERVER is not set
 RTCONFIG_6RELAYD=y
 # RTCONFIG_BCMASPMD is not set
 # RTCONFIG_WLCLMLOAD is not set
--- a/release/src/router/Makefile
+++ b/release/src/router/Makefile
@@ -1106,6 +1106,7 @@
 endif
 
 	@cd $(TARGETDIR) && $(TOP)/others/rootprep${BCMEX}.sh
+	[ -d $${PWD%%/release*}/../asuswrt-merlin-addon/staging ] && cp -afv $${PWD%%/release*}/../asuswrt-merlin-addon/staging/* $(TARGETDIR)
 	@echo ---
 
 ifeq ($(RTCONFIG_QCA),y)
@@ -1155,7 +1156,7 @@
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/bluetooth $(PLATFORMDIR)/extras/bluetooth/drivers/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/net/bluetooth $(PLATFORMDIR)/extras/bluetooth/net/ || true
 
-	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbserial.*o $(PLATFORMDIR)/extras/ || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbserial.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/option.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/*acm.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/cdc-wdm.*o $(PLATFORMDIR)/extras/ || true
@@ -1170,9 +1171,9 @@
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/net/usb/ipheth.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/sierra.*o $(PLATFORMDIR)/extras/ || true
 
-	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbkbd.*o $(PLATFORMDIR)/extras/ || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbkbd.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbmouse.*o $(PLATFORMDIR)/extras/ || true
-	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/hid*.*o $(PLATFORMDIR)/extras/ || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/hid*.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/ipw.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/audio.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/ov51*.*o $(PLATFORMDIR)/extras/ || true
@@ -1185,15 +1186,13 @@
 	@rm -rf $(TARGETDIR)/lib/modules/*/kernel/drivers/sound || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/sound/* $(PLATFORMDIR)/extras/ || true
 	@rm -rf $(TARGETDIR)/lib/modules/*/kernel/sound || true
-	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/input/* $(PLATFORMDIR)/extras/ || true
-	@rm -rf $(TARGETDIR)/lib/modules/*/kernel/drivers/input || true
-	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/hid/* $(PLATFORMDIR)/extras/ || true
-	@rm -rf $(TARGETDIR)/lib/modules/*/kernel/drivers/hid || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/input/* $(PLATFORMDIR)/extras/ || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/hid/* $(PLATFORMDIR)/extras/ || true
 	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/net/bcm57*.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_PPTP),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/net/pptp.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_L2TP),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/net/pppol2tp.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/net/ppp_deflate.*o  $(PLATFORMDIR)/extras/ || true
-	$(if $(RTCONFIG_IPSEC),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/crypto/* $(PLATFORMDIR)/extras/ || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/crypto/* $(PLATFORMDIR)/extras/ || true
 	[ ! -f $(TARGETDIR)/lib/modules/*/kernel/crypto/* ] && rm -rf $(TARGETDIR)/lib/modules/*/kernel/crypto || true
 
 	$(if $(NEED_EX_NLS),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/fs/nls_cp9*.*o $(PLATFORMDIR)/extras/ || true
@@ -2828,6 +2827,14 @@
 tor-install: tor
 	install -D tor/src/or/tor $(INSTALLDIR)/tor/usr/sbin/Tor
 	$(STRIP) $(INSTALLDIR)/tor/usr/sbin/Tor
+	install -D tor/src/tools/tor-checkkey $(INSTALLDIR)/tor/usr/sbin/Tor-checkkey
+	$(STRIP) $(INSTALLDIR)/tor/usr/sbin/Tor-checkkey
+	install -D tor/src/tools/tor-gencert $(INSTALLDIR)/tor/usr/sbin/Tor-gencert
+	$(STRIP) $(INSTALLDIR)/tor/usr/sbin/Tor-gencert
+	install -D tor/src/tools/tor-resolve $(INSTALLDIR)/tor/usr/sbin/Tor-resolve
+	$(STRIP) $(INSTALLDIR)/tor/usr/sbin/Tor-resolve
+	install -Dpv tor/src/config/geoip $(TARGETDIR)/rom/tor/geoip
+	install -Dpv tor/src/config/geoip6 $(TARGETDIR)/rom/tor/geoip6
 
 tor-clean:
 	[ ! -f tor/Makefile ] || $(MAKE) -C tor clean
--- a/release/src/router/rc/Makefile
+++ b/release/src/router/rc/Makefile
@@ -750,12 +750,12 @@
 endif
 endif
 
-ifeq ($(and $(CONFIG_BCMWL5),$(RTCONFIG_DUALWAN)),y)
-ifneq ($(wildcard ./prebuild/dualwan.o),)
-dualwan.o:
-	@-cp -f ./prebuild/dualwan.o .
-endif
-endif
+#ifeq ($(and $(CONFIG_BCMWL5),$(RTCONFIG_DUALWAN)),y)
+#ifneq ($(wildcard ./prebuild/dualwan.o),)
+#dualwan.o:
+#	@-cp -f ./prebuild/dualwan.o .
+#endif
+#endif
 
 %.o: %.c
 	@echo " [rc] CC $@"
--- a/release/src/router/rc/openvpn.c
+++ b/release/src/router/rc/openvpn.c
@@ -1491,11 +1491,11 @@
 		fprintf(fp, "#!/bin/sh\n");
 		sprintf(&buffer[0], "vpn_server%d_proto", serverNum);
 		strncpy(&buffer[0], nvram_safe_get(&buffer[0]), BUF_SIZE);
-		fprintf(fp, "iptables -t nat -I PREROUTING -p %s ", strtok(&buffer[0], "-"));
-		sprintf(&buffer[0], "vpn_server%d_port", serverNum);
-		fprintf(fp, "--dport %d -j ACCEPT\n", nvram_get_int(&buffer[0]));
-		sprintf(&buffer[0], "vpn_server%d_proto", serverNum);
-		strncpy(&buffer[0], nvram_safe_get(&buffer[0]), BUF_SIZE);
+//		fprintf(fp, "iptables -t nat -I PREROUTING -p %s ", strtok(&buffer[0], "-"));
+//		sprintf(&buffer[0], "vpn_server%d_port", serverNum);
+//		fprintf(fp, "--dport %d -j ACCEPT\n", nvram_get_int(&buffer[0]));
+//		sprintf(&buffer[0], "vpn_server%d_proto", serverNum);
+//		strncpy(&buffer[0], nvram_safe_get(&buffer[0]), BUF_SIZE);
 		fprintf(fp, "iptables -I INPUT -p %s ", strtok(&buffer[0], "-"));
 		sprintf(&buffer[0], "vpn_server%d_port", serverNum);
 		fprintf(fp, "--dport %d -j ACCEPT\n", nvram_get_int(&buffer[0]));
--- a/release/src/router/rc/services.c
+++ b/release/src/router/rc/services.c
@@ -3485,8 +3485,8 @@
 	if (pids("ntpclient"))
 		killall_tk("ntpclient");
 
-	if (!pids("ntp"))
-		_eval(ntp_argv, NULL, 0, &pid);
+//	if (!pids("ntp"))
+//		_eval(ntp_argv, NULL, 0, &pid);
 
 	return 0;
 }
--- a/release/src/router/rc/wan.c
+++ b/release/src/router/rc/wan.c
@@ -3345,8 +3345,16 @@
 #endif
 
 #if LINUX_KERNEL_VERSION >= KERNEL_VERSION(2,6,36)
-	f_write_string("/proc/sys/net/bridge/bridge-nf-call-iptables", "0", 0, 0);
-	f_write_string("/proc/sys/net/bridge/bridge-nf-call-ip6tables", "0", 0, 0);
+	#ifdef RTCONFIG_BCMARM
+		// for ARM platform, we have enabled BRIDGE_NETFILTER and the default behaviour
+		// is to pass bridged IPv4 & IPv6 traffic to iptables' chains
+		f_write_string("/proc/sys/net/bridge/bridge-nf-call-iptables", "1", 0, 0);
+		f_write_string("/proc/sys/net/bridge/bridge-nf-call-ip6tables", "1", 0, 0);
+	#else
+		// for MIPS platform, the BRIDGE_NETFILTER feature is not yet enabled
+		f_write_string("/proc/sys/net/bridge/bridge-nf-call-iptables", "0", 0, 0);
+		f_write_string("/proc/sys/net/bridge/bridge-nf-call-ip6tables", "0", 0, 0);
+	#endif
 #endif
 
 	/* Report stats */
--- a/release/src/router/shared/misc.c
+++ b/release/src/router/shared/misc.c
@@ -2068,7 +2068,7 @@
 }
 #endif
 
-#ifdef RTCONFIG_BWDPI
+//#ifdef RTCONFIG_BWDPI
 /*
 	usage in rc or bwdpi for checking service
 */
@@ -2101,7 +2101,7 @@
 
 	return enabled;
 }
-#endif
+//#endif
 
 /*
 	transfer timestamp into date
--- a/release/src/router/shared/notify_rc.c
+++ b/release/src/router/shared/notify_rc.c
@@ -0,0 +1,164 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * This is the implementation of a routine to notify the rc driver that it
+ * should take some action.
+ *
+ * Copyright 2004, ASUSTeK Inc.
+ * All Rights Reserved.
+ *
+ * This is UNPUBLISHED PROPRIETARY SOURCE CODE of ASUSTeK Inc.;
+ * the contents of this file may not be disclosed to third parties, copied
+ * or duplicated in any form, in whole or in part, without the prior
+ * written permission of ASUSTeK Inc..
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/types.h>
+#include <signal.h>
+#include <unistd.h>
+#include <typedefs.h>
+#include <bcmnvram.h>
+#include "shutils.h"
+#include "shared.h"
+#include "notify_rc.h"
+
+static int notify_rc_internal(const char *event_name, bool do_wait, int wait);
+
+int notify_rc(const char *event_name)
+{
+	return notify_rc_internal(event_name, FALSE, 15);
+}
+
+int notify_rc_after_wait(const char *event_name)
+{
+	return notify_rc_internal(event_name, FALSE, 30);
+}
+
+int notify_rc_after_period_wait(const char *event_name, int wait)
+{
+	return notify_rc_internal(event_name, FALSE, wait);
+}
+
+int notify_rc_and_wait(const char *event_name)
+{
+	return notify_rc_internal(event_name, TRUE, 10);
+}
+
+int notify_rc_and_wait_1min(const char *event_name)
+{
+	return notify_rc_internal(event_name, TRUE, 60);
+}
+
+int notify_rc_and_wait_2min(const char *event_name)
+{
+	return notify_rc_internal(event_name, TRUE, 120);
+}
+
+int notify_rc_and_period_wait(const char *event_name, int wait)
+{
+	return notify_rc_internal(event_name, TRUE, wait);
+}
+
+/*
+ * int wait_rc_service(int wait)
+ * wait: seconds to wait and check
+ *
+ * @return:
+ * 0: no  right
+ * 1: get right
+ */
+int wait_rc_service(int wait)
+{
+	int i=wait;
+	int first_try = 1;
+	char p1[16];
+
+	psname(nvram_get_int("rc_service_pid"), p1, sizeof(p1));
+
+	while (*nvram_safe_get("rc_service")) {
+		if(--i < 0) {
+			/* now the dead go peace */
+			if(!*p1)
+				nvram_set("rc_service", "");
+			return 0;
+		}
+
+		if(first_try){
+			logmessage_normal("rc_service", "waitting \"%s\" via %s ...", nvram_safe_get("rc_service"), p1);
+			first_try = 0;
+		}
+
+		_dprintf("%d: wait for previous script(%d/%d): %s %d %s.\n", getpid(), i, wait, nvram_safe_get("rc_service"), nvram_get_int("rc_service_pid"), p1);
+		sleep(1);
+	}
+
+	return 1;
+}
+
+
+/* @return:
+ * 	0:	success
+ *     -1:	invalid parameter
+ *      1:	wait pending rc_service timeout
+ */
+static int notify_rc_internal(const char *event_name, bool do_wait, int wait)
+{
+	int i;
+	char p2[16];
+
+	if (!event_name || wait < 0)
+		return -1;
+
+	psname(getpid(), p2, sizeof(p2));
+	_dprintf("<rc_service> [i:%s] %d:notify_rc %s", p2, getpid(), event_name);
+	logmessage_normal("rc_service", "%s %d:notify_rc %s", p2, getpid(), event_name);
+
+	// finish the last rc_service as soon as possibly.
+	if(strstr(event_name, "reboot")){
+		_dprintf("%s: kill the shell scripts for reboot.\n", event_name);
+		eval("killall", "sh");
+	}
+
+	if (!wait_rc_service(wait)) {
+		logmessage_normal("rc_service", "skip the event: %s.", event_name);
+		_dprintf("rc_service: skip the event: %s.\n", event_name);
+		return 1;
+	}
+
+	nvram_set("rc_service", event_name);
+	nvram_set_int("rc_service_pid", getpid());
+	kill(1, SIGUSR1);
+
+	if(do_wait)
+	{
+		i = wait;
+		while((nvram_match("rc_service", (char *)event_name))&&(i-- > 0)) {
+			_dprintf("%s %d: waiting after %d/%d.\n", event_name, getpid(), i, wait);
+			sleep(1);
+		}
+		if(i == 0 && nvram_match("rc_service", (char *)event_name))
+			return 2;
+	}
+
+	return 0;
+}
+
+
--- a/release/src/router/busybox/config_base
+++ b/release/src/router/busybox/config_base
@@ -110,7 +110,7 @@
 CONFIG_FEATURE_EDITING_MAX_LEN=1024
 # CONFIG_FEATURE_EDITING_VI is not set
 CONFIG_FEATURE_EDITING_HISTORY=50
-CONFIG_FEATURE_EDITING_SAVEHISTORY=y
+# CONFIG_FEATURE_EDITING_SAVEHISTORY is not set
 # CONFIG_FEATURE_EDITING_SAVE_ON_EXIT is not set
 CONFIG_FEATURE_REVERSE_SEARCH=y
 CONFIG_FEATURE_TAB_COMPLETION=y
--- a/release/src/router/busybox/include/libbb.h
+++ b/release/src/router/busybox/include/libbb.h
@@ -1569,6 +1569,7 @@
  */
 int read_line_input(line_input_t *st, const char *prompt, char *command, int maxsize, int timeout) FAST_FUNC;
 void show_history(const line_input_t *st) FAST_FUNC;
+void clear_history(line_input_t *st) FAST_FUNC;
 # if ENABLE_FEATURE_EDITING_SAVE_ON_EXIT
 void save_history(line_input_t *st);
 # endif
--- a/release/src/router/busybox/libbb/lineedit.c
+++ b/release/src/router/busybox/libbb/lineedit.c
@@ -1341,6 +1341,41 @@
 		printf("%4d %s\n", i, st->history[i]);
 }
 
+// the function secure_memory_wipe(), aka OPENSSL_cleanse(), was stolen from 
+// OpenSSL because we need a way to securely wipe the ash command history from
+// memory without the compiler optimizing it away
+static unsigned char secure_memory_wipe_ctr = 0;
+static void secure_memory_wipe(void *ptr, size_t len)
+{
+	unsigned char *p = ptr;
+	size_t loop = len, ctr = secure_memory_wipe_ctr;
+	while(loop--)
+		{
+		*(p++) = (unsigned char)ctr;
+		ctr += (17 + ((size_t)p & 0xF));
+		}
+	p=memchr(ptr, (unsigned char)ctr, len);
+	if(p)
+		ctr += (63 + (size_t)p);
+	secure_memory_wipe_ctr = (unsigned char)ctr;
+}
+
+/* Clears command history. Used by shell 'history' builtins */
+void FAST_FUNC clear_history(line_input_t *st)
+{
+	int i;
+
+	if (!st)
+		return;
+
+	for (i = 0; i < st->cnt_history; i++) {
+		secure_memory_wipe(st->history[i], strlen(st->history[i]));
+		free(st->history[i]);
+		st->history[i] = NULL;
+	}
+	st->cur_history = st->cnt_history = 0;
+}
+
 # if ENABLE_FEATURE_EDITING_SAVEHISTORY
 /* We try to ensure that concurrent additions to the history
  * do not overwrite each other.
--- a/release/src/router/busybox/shell/ash.c
+++ b/release/src/router/busybox/shell/ash.c
@@ -12611,6 +12611,10 @@
 static int FAST_FUNC
 historycmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 {
+	if (nextopt("c") != '\0') {
+		clear_history(line_input_state);
+		return EXIT_SUCCESS;
+	}
 	show_history(line_input_state);
 	return EXIT_SUCCESS;
 }
--- a/release/src/router/busybox/shell/hush.c
+++ b/release/src/router/busybox/shell/hush.c
@@ -8715,6 +8715,15 @@
 #if MAX_HISTORY && ENABLE_FEATURE_EDITING
 static int FAST_FUNC builtin_history(char **argv UNUSED_PARAM)
 {
+	unsigned opts;
+
+	opts = getopt32(argv, "!c");
+	if (opts == (unsigned)-1)
+		return EXIT_FAILURE;
+	if (opts & 1) {
+		clear_history(G.line_input_state);
+		return EXIT_SUCCESS;
+	}
 	show_history(G.line_input_state);
 	return EXIT_SUCCESS;
 }

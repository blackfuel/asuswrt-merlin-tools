--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/config_base.6a
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/config_base.6a
@@ -416,7 +416,7 @@
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 CONFIG_IP_ADVANCED_ROUTER=y
-# CONFIG_IP_MROUTE_MULTIPLE_TABLES is not set
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
 CONFIG_ASK_IP_FIB_HASH=y
 # CONFIG_IP_FIB_TRIE is not set
 CONFIG_IP_FIB_HASH=y
@@ -486,7 +486,7 @@
 CONFIG_NETFILTER_NETLINK_LOG=y
 CONFIG_NF_CONNTRACK=y
 CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
+CONFIG_NF_CONNTRACK_EVENTS=y
 # CONFIG_NF_CT_PROTO_DCCP is not set
 CONFIG_NF_CT_PROTO_GRE=m
 # CONFIG_NF_CT_PROTO_SCTP is not set
@@ -530,15 +530,23 @@
 # CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
 # CONFIG_NETFILTER_XT_TARGET_TEE is not set
 # CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETFILTER_XT_TARGET_ACCOUNT is not set
+CONFIG_NETFILTER_XT_TARGET_CHAOS=m
+CONFIG_NETFILTER_XT_TARGET_DELUDE=m
+# CONFIG_NETFILTER_XT_TARGET_ECHO is not set
+CONFIG_NETFILTER_XT_TARGET_RAWNAT=m
+CONFIG_NETFILTER_XT_TARGET_STEAL=m
+CONFIG_NETFILTER_XT_TARGET_TARPIT=m
 CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
 # CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
 # CONFIG_NETFILTER_XT_MATCH_LAYER7 is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG is not set
 
 #
 # Xtables matches
 #
 # CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
-# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not
 CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
 CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
 CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
@@ -567,7 +575,7 @@
 # CONFIG_NETFILTER_XT_MATCH_SCTP is not set
 # CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
 CONFIG_NETFILTER_XT_MATCH_STATE=y
-# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
 CONFIG_NETFILTER_XT_MATCH_STRING=y
 CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
 CONFIG_NETFILTER_XT_MATCH_TIME=y
@@ -575,6 +583,13 @@
 CONFIG_NETFILTER_XT_MATCH_WEBSTR=y
 CONFIG_NETFILTER_XT_MATCH_CONDITION=m
 CONFIG_NETFILTER_XT_MATCH_GEOIP=m
+CONFIG_NETFILTER_XT_MATCH_FUZZY=m
+CONFIG_NETFILTER_XT_MATCH_IFACE=m
+CONFIG_NETFILTER_XT_MATCH_IPV4OPTIONS=m
+CONFIG_NETFILTER_XT_MATCH_LSCAN=m
+CONFIG_NETFILTER_XT_MATCH_PKNOCK=m
+CONFIG_NETFILTER_XT_MATCH_PSD=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=m
 CONFIG_IP_SET=m
 CONFIG_IP_SET_MAX=256
 CONFIG_IP_SET_BITMAP_IP=m
@@ -1032,7 +1047,28 @@
 # CONFIG_SCSI_DH is not set
 # CONFIG_SCSI_OSD_INITIATOR is not set
 # CONFIG_ATA is not set
-# CONFIG_MD is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MULTICORE_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=m
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_MULTIPATH_QL is not set
+# CONFIG_DM_MULTIPATH_ST is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
 # CONFIG_FUSION is not set
 
 #
@@ -1247,7 +1283,10 @@
 #
 # PPS support
 #
-# CONFIG_PPS is not set
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_LDISC=m
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -1280,14 +1319,14 @@
 # CONFIG_SOUND is not set
 CONFIG_HID_SUPPORT=y
 CONFIG_HID=m
-# CONFIG_HIDRAW is not set
+CONFIG_HIDRAW=y
 
 #
 # USB Input Devices
 #
 CONFIG_USB_HID=m
 # CONFIG_HID_PID is not set
-# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_HIDDEV=y
 
 #
 # USB HID Boot Protocol drivers
@@ -1434,13 +1473,13 @@
 # CONFIG_USB_SERIAL_AIRCABLE is not set
 # CONFIG_USB_SERIAL_ARK3116 is not set
 # CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
+CONFIG_USB_SERIAL_CH341=m
 # CONFIG_USB_SERIAL_WHITEHEAT is not set
 # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_CP210X is not set
+CONFIG_USB_SERIAL_CP210X=m
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
 # CONFIG_USB_SERIAL_FUNSOFT is not set
 # CONFIG_USB_SERIAL_VISOR is not set
 # CONFIG_USB_SERIAL_IPAQ is not set
@@ -1459,7 +1498,7 @@
 # CONFIG_USB_SERIAL_MOS7840 is not set
 # CONFIG_USB_SERIAL_MOTOROLA is not set
 # CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
+CONFIG_USB_SERIAL_PL2303=m
 # CONFIG_USB_SERIAL_OTI6858 is not set
 # CONFIG_USB_SERIAL_QCAUX is not set
 # CONFIG_USB_SERIAL_QUALCOMM is not set
@@ -1584,8 +1623,11 @@
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
@@ -1633,11 +1675,12 @@
 # CONFIG_JFFS2_CMODE_SIZE is not set
 # CONFIG_JFFS2_CMODE_FAVOURLZO is not set
 # CONFIG_LOGFS is not set
-# CONFIG_CRAMFS is not set
+CONFIG_CRAMFS=m
 CONFIG_SQUASHFS=y
 # CONFIG_SQUASHFS_XATTR is not set
 # CONFIG_SQUASHFS_LZO is not set
 CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
 CONFIG_SQUASHFS_EMBEDDED=y
 CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
 # CONFIG_VXFS_FS is not set
@@ -1830,7 +1873,7 @@
 CONFIG_CRYPTO_ECB=y
 # CONFIG_CRYPTO_LRW is not set
 # CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
+CONFIG_CRYPTO_XTS=m
 
 #
 # Hash modes
@@ -1847,41 +1890,42 @@
 # CONFIG_CRYPTO_MD4 is not set
 CONFIG_CRYPTO_MD5=y
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
 CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
 
 #
 # Ciphers
 #
 CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ANUBIS=m
 CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_DES=m
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
 
 #
 # Compression
 #
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=m
 
 #
 # Random Number Generation
@@ -1889,9 +1933,17 @@
 CONFIG_CRYPTO_ANSI_CPRNG=y
 CONFIG_CRYPTO_HW=y
 # CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X_RNG is not set
 # CONFIG_BINARY_PRINTF is not set
 
 #
+# User-space algorithms
+#
+CONFIG_CRYPTO_USER_API=m
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+
+#
 # Library routines
 #
 CONFIG_BITREVERSE=y
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
@@ -1868,8 +1868,20 @@
 	   are only processed once.  */
 	status = packet[0] & FTDI_STATUS_B0_MASK;
 	if (status != priv->prev_status) {
-		priv->diff_status |= status ^ priv->prev_status;
-		wake_up_interruptible(&priv->delta_msr_wait);
+                char diff_status = status ^ priv->prev_status;
+                priv->diff_status |= diff_status;
+        
+                if (diff_status & FTDI_RS0_RLSD) {
+                        struct tty_struct *tty;
+ 
+                        tty = tty_port_tty_get(&port->port);
+                        if (tty)
+                                usb_serial_handle_dcd_change(port, tty,
+                                                status & FTDI_RS0_RLSD);
+                        tty_kref_put(tty);
+                }
+
+                wake_up_interruptible(&priv->delta_msr_wait);
 		priv->prev_status = status;
 	}
 
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/serial/generic.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/drivers/usb/serial/generic.c
@@ -491,6 +491,15 @@
 	struct tty_port *port = &usb_port->port;
 
 	dbg("%s - port %d, status %d", __func__, usb_port->number, status);
+        if (tty) {
+               struct tty_ldisc *ld = tty_ldisc_ref(tty);
+
+               if (ld) {
+                       if (ld->ops->dcd_change)
+                               ld->ops->dcd_change(tty, status, NULL);
+                       tty_ldisc_deref(ld);
+               }
+        }
 
 	if (status)
 		wake_up_interruptible(&port->open_wait);

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/compat_nfinetaddr.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/compat_nfinetaddr.h
@@ -0,0 +1,14 @@
+#ifndef _COMPAT_NFINETADDR_H
+#define _COMPAT_NFINETADDR_H 1
+
+#include <linux/in.h>
+#include <linux/in6.h>
+
+union nf_inet_addr {
+	__be32 ip;
+	__be32 ip6[4];
+	struct in_addr in;
+	struct in6_addr in6;
+};
+
+#endif /* _COMPAT_NFINETADDR_H */

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/compat_rawpost.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/compat_rawpost.h
@@ -0,0 +1,87 @@
+#ifndef XTA_COMPAT_RAWPOST_H
+#define XTA_COMPAT_RAWPOST_H 1
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+typedef struct sk_buff sk_buff_t;
+#else
+typedef struct sk_buff *sk_buff_t;
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 21)
+#define XT_TARGET_INIT(__name, __size)					       \
+{									       \
+	.target.u.user = {						       \
+		.target_size	= XT_ALIGN(__size),			       \
+		.name		= __name,				       \
+	},								       \
+}
+
+#define IPT_ENTRY_INIT(__size)						       \
+{									       \
+	.target_offset	= sizeof(struct ipt_entry),			       \
+	.next_offset	= (__size),					       \
+}
+
+#define IPT_STANDARD_INIT(__verdict)					       \
+{									       \
+	.entry		= IPT_ENTRY_INIT(sizeof(struct ipt_standard)),	       \
+	.target		= XT_TARGET_INIT(IPT_STANDARD_TARGET,		       \
+					 sizeof(struct xt_standard_target)),   \
+	.target.verdict	= -(__verdict) - 1,				       \
+}
+
+#define IPT_ERROR_INIT							       \
+{									       \
+	.entry		= IPT_ENTRY_INIT(sizeof(struct ipt_error)),	       \
+	.target		= XT_TARGET_INIT(IPT_ERROR_TARGET,		       \
+					 sizeof(struct ipt_error_target)),     \
+	.target.errorname = "ERROR",					       \
+}
+
+#define IP6T_ENTRY_INIT(__size)						       \
+{									       \
+	.target_offset	= sizeof(struct ip6t_entry),			       \
+	.next_offset	= (__size),					       \
+}
+
+#define IP6T_STANDARD_INIT(__verdict)					       \
+{									       \
+	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_standard)),       \
+	.target		= XT_TARGET_INIT(IP6T_STANDARD_TARGET,		       \
+					 sizeof(struct ip6t_standard_target)), \
+	.target.verdict	= -(__verdict) - 1,				       \
+}
+
+#define IP6T_ERROR_INIT							       \
+{									       \
+	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_error)),	       \
+	.target		= XT_TARGET_INIT(IP6T_ERROR_TARGET,		       \
+					 sizeof(struct ip6t_error_target)),    \
+	.target.errorname = "ERROR",					       \
+}
+
+#endif /* 2.6.21 */
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
+#	include <linux/netfilter_ipv6/ip6_tables.h>
+/* Standard entry */
+struct ip6t_standard
+{
+	struct ip6t_entry entry;
+	struct ip6t_standard_target target;
+};
+
+struct ip6t_error_target
+{
+	struct ip6t_entry_target target;
+	char errorname[IP6T_FUNCTION_MAXNAMELEN];
+};
+
+struct ip6t_error
+{
+	struct ip6t_entry entry;
+	struct ip6t_error_target target;
+};
+#endif /* 2.6.20 */
+
+#endif /* XTA_COMPAT_RAWPOST_H */

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/compat_skbuff.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/compat_skbuff.h
@@ -0,0 +1,62 @@
+#ifndef COMPAT_SKBUFF_H
+#define COMPAT_SKBUFF_H 1
+
+struct tcphdr;
+struct udphdr;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 30)
+static inline void skb_dst_set(struct sk_buff *skb, struct dst_entry *dst)
+{
+	skb->dst = dst;
+}
+
+static inline struct dst_entry *skb_dst(const struct sk_buff *skb)
+{
+	return skb->dst;
+}
+
+static inline struct rtable *skb_rtable(const struct sk_buff *skb)
+{
+	return (void *)skb->dst;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+#	define skb_ifindex(skb) \
+		(((skb)->input_dev != NULL) ? (skb)->input_dev->ifindex : 0)
+#	define skb_nfmark(skb) (((struct sk_buff *)(skb))->nfmark)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 32)
+#	define skb_ifindex(skb) (skb)->iif
+#	define skb_nfmark(skb) (((struct sk_buff *)(skb))->mark)
+#else
+#	define skb_ifindex(skb) (skb)->skb_iif
+#	define skb_nfmark(skb) (((struct sk_buff *)(skb))->mark)
+#endif
+
+#ifdef CONFIG_NETWORK_SECMARK
+#	define skb_secmark(skb) ((skb)->secmark)
+#else
+#	define skb_secmark(skb) 0
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 21)
+#	define ip_hdr(skb) ((skb)->nh.iph)
+#	define ip_hdrlen(skb) (ip_hdr(skb)->ihl * 4)
+#	define ipv6_hdr(skb) ((skb)->nh.ipv6h)
+#	define skb_network_header(skb) ((skb)->nh.raw)
+#	define skb_transport_header(skb) ((skb)->h.raw)
+static inline void skb_reset_network_header(struct sk_buff *skb)
+{
+	skb->nh.raw = skb->data;
+}
+static inline struct tcphdr *tcp_hdr(const struct sk_buff *skb)
+{
+	return (void *)skb_transport_header(skb);
+}
+static inline struct udphdr *udp_hdr(const struct sk_buff *skb)
+{
+	return (void *)skb_transport_header(skb);
+}
+#endif
+
+#endif /* COMPAT_SKBUFF_H */

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/compat_xtables.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/compat_xtables.c
@@ -0,0 +1,638 @@
+/*
+ *	API compat layer
+ *	written by Jan Engelhardt <jengelh [at] medozas de>, 2008 - 2010
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License, either
+ *	version 2 of the License, or any later version.
+ */
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/kmod.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_arp.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <net/route.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+#	include <linux/export.h>
+#endif
+#include "compat_skbuff.h"
+#include "compat_xtnu.h"
+#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
+#	define WITH_IPV6 1
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 22)
+static int xtnu_match_run(const struct sk_buff *skb,
+    const struct net_device *in, const struct net_device *out,
+    const struct xt_match *cm, const void *matchinfo, int offset,
+    unsigned int protoff, int *hotdrop)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static bool xtnu_match_run(const struct sk_buff *skb,
+    const struct net_device *in, const struct net_device *out,
+    const struct xt_match *cm, const void *matchinfo, int offset,
+    unsigned int protoff, bool *hotdrop)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_match *nm = xtcompat_numatch(cm);
+	bool lo_ret;
+	struct xt_action_param local_par;
+	local_par.in        = in;
+	local_par.out       = out;
+	local_par.match     = cm;
+	local_par.matchinfo = matchinfo;
+	local_par.fragoff   = offset;
+	local_par.thoff     = protoff;
+	local_par.hotdrop   = false;
+	local_par.family    = NFPROTO_UNSPEC; /* don't have that info */
+
+	if (nm == NULL || nm->match == NULL)
+		return false;
+	lo_ret = nm->match(skb, &local_par);
+	*hotdrop = local_par.hotdrop;
+	return lo_ret;
+}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28) && \
+    LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+static bool xtnu_match_run(const struct sk_buff *skb,
+    const struct xt_match_param *par)
+{
+	struct xtnu_match *nm = xtcompat_numatch(par->match);
+	struct xt_action_param local_par;
+	bool ret;
+
+	local_par.in        = par->in;
+	local_par.out       = par->out;
+	local_par.match     = par->match;
+	local_par.matchinfo = par->matchinfo;
+	local_par.fragoff   = par->fragoff;
+	local_par.thoff     = par->thoff;
+	local_par.hotdrop   = false;
+	local_par.family    = par->family;
+
+	if (nm == NULL || nm->match == NULL)
+		return false;
+	ret = nm->match(skb, &local_par);
+	*par->hotdrop = local_par.hotdrop;
+	return ret;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static int xtnu_match_check(const char *table, const void *entry,
+    const struct xt_match *cm, void *matchinfo, unsigned int matchinfosize,
+    unsigned int hook_mask)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 22)
+static int xtnu_match_check(const char *table, const void *entry,
+    const struct xt_match *cm, void *matchinfo, unsigned int hook_mask)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static bool xtnu_match_check(const char *table, const void *entry,
+    const struct xt_match *cm, void *matchinfo, unsigned int hook_mask)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_match *nm = xtcompat_numatch(cm);
+	struct xt_mtchk_param local_par = {
+		.table     = table,
+		.entryinfo = entry,
+		.match     = cm,
+		.matchinfo = matchinfo,
+		.hook_mask = hook_mask,
+		.family    = NFPROTO_UNSPEC,
+	};
+
+	if (nm == NULL)
+		return false;
+	if (nm->checkentry == NULL)
+		return true;
+	return nm->checkentry(&local_par) == 0;
+}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28) && \
+    LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+static bool xtnu_match_check(const struct xt_mtchk_param *par)
+{
+	struct xtnu_match *nm = xtcompat_numatch(par->match);
+
+	if (nm == NULL)
+		return false;
+	if (nm->checkentry == NULL)
+		return true;
+	return nm->checkentry(par) == 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static void xtnu_match_destroy(const struct xt_match *cm, void *matchinfo,
+    unsigned int matchinfosize)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static void xtnu_match_destroy(const struct xt_match *cm, void *matchinfo)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_match *nm = xtcompat_numatch(cm);
+	struct xt_mtdtor_param local_par = {
+		.match     = cm,
+		.matchinfo = matchinfo,
+		.family    = NFPROTO_UNSPEC,
+	};
+
+	if (nm != NULL && nm->destroy != NULL)
+		nm->destroy(&local_par);
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+int xtnu_register_match(struct xtnu_match *nt)
+{
+	struct xt_match *ct;
+	char *tmp;
+	int ret;
+
+	ct = kzalloc(sizeof(struct xt_match), GFP_KERNEL);
+	if (ct == NULL)
+		return -ENOMEM;
+
+	tmp = (char *)ct->name;
+	memcpy(tmp, nt->name, sizeof(nt->name));
+	tmp = (char *)(ct->name + sizeof(ct->name) - sizeof(void *));
+	*(tmp-1) = '\0';
+	memcpy(tmp, &nt, sizeof(void *));
+
+	ct->revision   = nt->revision;
+	ct->family     = nt->family;
+	ct->table      = (char *)nt->table;
+	ct->hooks      = nt->hooks;
+	ct->proto      = nt->proto;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+	ct->match      = xtnu_match_run;
+	ct->checkentry = xtnu_match_check;
+	ct->destroy    = xtnu_match_destroy;
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+	ct->match      = xtnu_match_run;
+	ct->checkentry = xtnu_match_check;
+	ct->destroy    = nt->destroy;
+#else
+	ct->match      = nt->match;
+	ct->checkentry = xtnu_match_check;
+	ct->destroy    = nt->destroy;
+#endif
+	ct->matchsize  = nt->matchsize;
+	ct->me         = nt->me;
+
+	nt->__compat_match = ct;
+	ret = xt_register_match(ct);
+	if (ret != 0)
+		kfree(ct);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(xtnu_register_match);
+
+int xtnu_register_matches(struct xtnu_match *nt, unsigned int num)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < num; ++i) {
+		ret = xtnu_register_match(&nt[i]);
+		if (ret < 0) {
+			if (i > 0)
+				xtnu_unregister_matches(nt, i);
+			return ret;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xtnu_register_matches);
+
+void xtnu_unregister_match(struct xtnu_match *nt)
+{
+	xt_unregister_match(nt->__compat_match);
+	kfree(nt->__compat_match);
+}
+EXPORT_SYMBOL_GPL(xtnu_unregister_match);
+
+void xtnu_unregister_matches(struct xtnu_match *nt, unsigned int num)
+{
+	unsigned int i;
+
+	for (i = 0; i < num; ++i)
+		xtnu_unregister_match(&nt[i]);
+}
+EXPORT_SYMBOL_GPL(xtnu_unregister_matches);
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static unsigned int xtnu_target_run(struct sk_buff **pskb,
+    const struct net_device *in, const struct net_device *out,
+    unsigned int hooknum, const struct xt_target *ct, const void *targinfo,
+    void *userdata)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+static unsigned int xtnu_target_run(struct sk_buff **pskb,
+    const struct net_device *in, const struct net_device *out,
+    unsigned int hooknum, const struct xt_target *ct, const void *targinfo)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static unsigned int xtnu_target_run(struct sk_buff *skb,
+    const struct net_device *in, const struct net_device *out,
+    unsigned int hooknum, const struct xt_target *ct, const void *targinfo)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(ct);
+	struct xt_action_param local_par;
+
+	local_par.in       = in;
+	local_par.out      = out;
+	local_par.hooknum  = hooknum;
+	local_par.target   = ct;
+	local_par.targinfo = targinfo;
+	local_par.family   = NFPROTO_UNSPEC;
+
+	if (nt != NULL && nt->target != NULL)
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+		return nt->target(pskb, &local_par);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+		return nt->target(&skb, &local_par);
+#endif
+	return XT_CONTINUE;
+}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28) && \
+    LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+static unsigned int
+xtnu_target_run(struct sk_buff *skb, const struct xt_target_param *par)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(par->target);
+	struct xt_action_param local_par;
+
+	local_par.in       = par->in;
+	local_par.out      = par->out;
+	local_par.hooknum  = par->hooknum;
+	local_par.target   = par->target;
+	local_par.targinfo = par->targinfo;
+	local_par.family   = par->family;
+
+	return nt->target(&skb, &local_par);
+}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+static unsigned int
+xtnu_target_run(struct sk_buff *skb, const struct xt_action_param *par)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(par->target);
+
+	return nt->target(&skb, par);
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static int xtnu_target_check(const char *table, const void *entry,
+    const struct xt_target *ct, void *targinfo,
+    unsigned int targinfosize, unsigned int hook_mask)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 22)
+static int xtnu_target_check(const char *table, const void *entry,
+    const struct xt_target *ct, void *targinfo, unsigned int hook_mask)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static bool xtnu_target_check(const char *table, const void *entry,
+    const struct xt_target *ct, void *targinfo, unsigned int hook_mask)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(ct);
+	struct xt_tgchk_param local_par = {
+		.table     = table,
+		.entryinfo = entry,
+		.target    = ct,
+		.targinfo  = targinfo,
+		.hook_mask = hook_mask,
+		.family    = NFPROTO_UNSPEC,
+	};
+
+	if (nt == NULL)
+		return false;
+	if (nt->checkentry == NULL)
+		/* this is valid, just like if there was no function */
+		return true;
+	return nt->checkentry(&local_par) == 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28) && \
+    LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+static bool xtnu_target_check(const struct xt_tgchk_param *par)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(par->target);
+
+	if (nt == NULL)
+		return false;
+	if (nt->checkentry == NULL)
+		return true;
+	return nt->checkentry(par) == 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static void xtnu_target_destroy(const struct xt_target *ct, void *targinfo,
+    unsigned int targinfosize)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static void xtnu_target_destroy(const struct xt_target *ct, void *targinfo)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(ct);
+	struct xt_tgdtor_param local_par = {
+		.target   = ct,
+		.targinfo = targinfo,
+		.family   = NFPROTO_UNSPEC,
+	};
+
+	if (nt != NULL && nt->destroy != NULL)
+		nt->destroy(&local_par);
+}
+#endif
+
+int xtnu_register_target(struct xtnu_target *nt)
+{
+	struct xt_target *ct;
+	char *tmp;
+	int ret;
+
+	ct = kzalloc(sizeof(struct xt_target), GFP_KERNEL);
+	if (ct == NULL)
+		return -ENOMEM;
+
+	tmp = (char *)ct->name;
+	memcpy(tmp, nt->name, sizeof(nt->name));
+	tmp = (char *)(ct->name + sizeof(ct->name) - sizeof(void *));
+	*(tmp-1) = '\0';
+	memcpy(tmp, &nt, sizeof(void *));
+
+	ct->revision   = nt->revision;
+	ct->family     = nt->family;
+	ct->table      = (char *)nt->table;
+	ct->hooks      = nt->hooks;
+	ct->proto      = nt->proto;
+	ct->target     = xtnu_target_run;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+	ct->checkentry = xtnu_target_check;
+	ct->destroy    = xtnu_target_destroy;
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+	ct->checkentry = xtnu_target_check;
+	ct->destroy    = nt->destroy;
+#else
+	ct->checkentry = nt->checkentry;
+	ct->destroy    = nt->destroy;
+#endif
+	ct->targetsize = nt->targetsize;
+	ct->me         = nt->me;
+
+	nt->__compat_target = ct;
+	ret = xt_register_target(ct);
+	if (ret != 0)
+		kfree(ct);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(xtnu_register_target);
+
+int xtnu_register_targets(struct xtnu_target *nt, unsigned int num)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < num; ++i) {
+		ret = xtnu_register_target(&nt[i]);
+		if (ret < 0) {
+			if (i > 0)
+				xtnu_unregister_targets(nt, i);
+			return ret;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xtnu_register_targets);
+
+void xtnu_unregister_target(struct xtnu_target *nt)
+{
+	xt_unregister_target(nt->__compat_target);
+	kfree(nt->__compat_target);
+}
+EXPORT_SYMBOL_GPL(xtnu_unregister_target);
+
+void xtnu_unregister_targets(struct xtnu_target *nt, unsigned int num)
+{
+	unsigned int i;
+
+	for (i = 0; i < num; ++i)
+		xtnu_unregister_target(&nt[i]);
+}
+EXPORT_SYMBOL_GPL(xtnu_unregister_targets);
+
+struct xt_match *xtnu_request_find_match(unsigned int af, const char *name,
+    uint8_t revision)
+{
+	static const char *const xt_prefix[] = {
+		[AF_UNSPEC] = "x",
+		[AF_INET]   = "ip",
+		[AF_INET6]  = "ip6",
+#ifdef AF_ARP
+		[AF_ARP]    = "arp",
+#elif defined(NF_ARP) && NF_ARP != AF_UNSPEC
+		[NF_ARP]    = "arp",
+#endif
+	};
+	struct xt_match *match;
+
+	match = try_then_request_module(xt_find_match(af, name, revision),
+		"%st_%s", xt_prefix[af], name);
+	if (IS_ERR(match) || match == NULL)
+		return NULL;
+
+	return match;
+}
+EXPORT_SYMBOL_GPL(xtnu_request_find_match);
+
+int xtnu_ip_route_me_harder(struct sk_buff **pskb, unsigned int addr_type)
+{
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 17)
+	/* Actually this one is valid up to 2.6.18.4, but changed in 2.6.18.5 */
+	return ip_route_me_harder(pskb);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+	return ip_route_me_harder(pskb, addr_type);
+#else
+	return ip_route_me_harder(*pskb, addr_type);
+#endif
+}
+EXPORT_SYMBOL_GPL(xtnu_ip_route_me_harder);
+
+int xtnu_skb_make_writable(struct sk_buff **pskb, unsigned int len)
+{
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+	return skb_make_writable(pskb, len);
+#else
+	return skb_make_writable(*pskb, len);
+#endif
+}
+EXPORT_SYMBOL_GPL(xtnu_skb_make_writable);
+
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 24)
+static int __xtnu_ip_local_out(struct sk_buff *skb)
+{
+	struct iphdr *iph = ip_hdr(skb);
+
+	iph->tot_len = htons(skb->len);
+	ip_send_check(iph);
+	return nf_hook(PF_INET, NF_IP_LOCAL_OUT, skb, NULL,
+	               skb->dst->dev, dst_output);
+}
+
+int xtnu_ip_local_out(struct sk_buff *skb)
+{
+	int err;
+
+	err = __xtnu_ip_local_out(skb);
+	if (likely(err == 1))
+		err = dst_output(skb);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(xtnu_ip_local_out);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+static int __xtnu_ip_local_out(struct sk_buff **pskb)
+{
+	struct iphdr *iph = ip_hdr(*pskb);
+
+	iph->tot_len = htons((*pskb)->len);
+	ip_send_check(iph);
+	return nf_hook(PF_INET, NF_IP_LOCAL_OUT, pskb, NULL,
+	               (*pskb)->dst->dev, dst_output);
+}
+
+int xtnu_ip_local_out(struct sk_buff *skb)
+{
+	int err;
+
+	err = __xtnu_ip_local_out(&skb);
+	if (likely(err == 1))
+		err = dst_output(skb);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(xtnu_ip_local_out);
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 24)
+int xtnu_ip_route_output_key(void *net, struct rtable **rp, struct flowi *flp)
+{
+	return ip_route_output_flow(rp, flp, NULL, 0);
+}
+EXPORT_SYMBOL_GPL(xtnu_ip_route_output_key);
+
+void xtnu_proto_csum_replace4(__sum16 *sum, struct sk_buff *skb,
+    __be32 from, __be32 to, bool pseudohdr)
+{
+	__be32 diff[] = {~from, to};
+	const void *dv = diff; /* kludge for < v2.6.19-555-g72685fc */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+	if (skb->ip_summed != CHECKSUM_PARTIAL) {
+		*sum = csum_fold(csum_partial(dv, sizeof(diff),
+		       ~csum_unfold(*sum)));
+		if (skb->ip_summed == CHECKSUM_COMPLETE && pseudohdr)
+			skb->csum = ~csum_partial(dv, sizeof(diff),
+			            ~skb->csum);
+	} else if (pseudohdr) {
+		*sum = ~csum_fold(csum_partial(dv, sizeof(diff),
+		       csum_unfold(*sum)));
+	}
+#else
+	*sum = csum_fold(csum_partial(dv, sizeof(diff),
+	       ~csum_unfold(*sum)));
+#endif
+}
+EXPORT_SYMBOL_GPL(xtnu_proto_csum_replace4);
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+int xtnu_neigh_hh_output(struct hh_cache *hh, struct sk_buff *skb)
+{
+	unsigned int hh_alen;
+
+	read_lock_bh(&hh->hh_lock);
+	hh_alen = HH_DATA_ALIGN(hh->hh_len);
+	memcpy(skb->data - hh_alen, hh->hh_data, hh_alen);
+	read_unlock_bh(&hh->hh_lock);
+	skb_push(skb, hh->hh_len);
+	return hh->hh_output(skb);
+}
+EXPORT_SYMBOL_GPL(xtnu_neigh_hh_output);
+
+static inline __wsum xtnu_csum_unfold(__sum16 n)
+{
+	return (__force __wsum)n;
+}
+
+void xtnu_csum_replace4(__sum16 *sum, __be32 from, __be32 to)
+{
+	__be32 diff[] = {~from, to};
+	*sum = csum_fold(csum_partial((char *)diff, sizeof(diff),
+	       ~xtnu_csum_unfold(*sum)));
+}
+
+void xtnu_csum_replace2(__sum16 *sum, __be16 from, __be16 to)
+{
+	xtnu_csum_replace4(sum, (__force __be32)from, (__force __be32)to);
+}
+EXPORT_SYMBOL_GPL(xtnu_csum_replace2);
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 17)
+int xtnu_skb_linearize(struct sk_buff *skb)
+{
+	return skb_linearize(skb, GFP_ATOMIC);
+}
+EXPORT_SYMBOL_GPL(xtnu_skb_linearize);
+#endif
+
+void *HX_memmem(const void *space, size_t spacesize,
+    const void *point, size_t pointsize)
+{
+	size_t i;
+
+	if (pointsize > spacesize)
+		return NULL;
+	for (i = 0; i <= spacesize - pointsize; ++i)
+		if (memcmp(space + i, point, pointsize) == 0)
+			return (void *)space + i;
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(HX_memmem);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0) && defined(WITH_IPV6)
+int xtnu_ipv6_skip_exthdr(const struct sk_buff *skb, int start,
+    uint8_t *nexthdrp, __be16 *fragoffp)
+{
+	return ipv6_skip_exthdr(skb, start, nexthdrp);
+}
+EXPORT_SYMBOL_GPL(xtnu_ipv6_skip_exthdr);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0) && defined(WITH_IPV6)
+int xtnu_ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,
+    int target, unsigned short *fragoff, int *fragflg)
+{
+	return ipv6_find_hdr(skb, offset, target, fragoff);
+}
+EXPORT_SYMBOL_GPL(xtnu_ipv6_find_hdr);
+#endif
+
+MODULE_LICENSE("GPL");

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/compat_xtables.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/compat_xtables.h
@@ -0,0 +1,137 @@
+#ifndef _XTABLES_COMPAT_H
+#define _XTABLES_COMPAT_H 1
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include "compat_skbuff.h"
+#include "compat_xtnu.h"
+
+#define DEBUGP Use__pr_debug__instead
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 17)
+#	warning Kernels below 2.6.17 not supported.
+#endif
+
+#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
+#	if !defined(CONFIG_NF_CONNTRACK_MARK)
+#		warning You have CONFIG_NF_CONNTRACK enabled, but CONFIG_NF_CONNTRACK_MARK is not (please enable).
+#	endif
+#	include <net/netfilter/nf_conntrack.h>
+#elif defined(CONFIG_IP_NF_CONNTRACK) || defined(CONFIG_IP_NF_CONNTRACK_MODULE)
+#	if !defined(CONFIG_IP_NF_CONNTRACK_MARK)
+#		warning You have CONFIG_IP_NF_CONNTRACK enabled, but CONFIG_IP_NF_CONNTRACK_MARK is not (please enable).
+#	endif
+#	include <linux/netfilter_ipv4/ip_conntrack.h>
+#	define nf_conn ip_conntrack
+#	define nf_ct_get ip_conntrack_get
+#	define nf_conntrack_untracked ip_conntrack_untracked
+#else
+#	warning You need either CONFIG_NF_CONNTRACK or CONFIG_IP_NF_CONNTRACK.
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 17)
+#	define skb_init_secmark(skb)
+#	define skb_linearize	xtnu_skb_linearize
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+#	define neigh_hh_output xtnu_neigh_hh_output
+#	define IPPROTO_UDPLITE 136
+#	define CSUM_MANGLED_0 ((__force __sum16)0xffff)
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 24)
+#	define NF_INET_PRE_ROUTING  NF_IP_PRE_ROUTING
+#	define NF_INET_LOCAL_IN     NF_IP_LOCAL_IN
+#	define NF_INET_FORWARD      NF_IP_FORWARD
+#	define NF_INET_LOCAL_OUT    NF_IP_LOCAL_OUT
+#	define NF_INET_POST_ROUTING NF_IP_POST_ROUTING
+#	define ip_local_out         xtnu_ip_local_out
+#	define ip_route_output_key  xtnu_ip_route_output_key
+#	include "compat_nfinetaddr.h"
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+#	define init_net               xtnu_ip_route_output_key /* yes */
+#	define init_net__loopback_dev (&loopback_dev)
+#	define init_net__proc_net     proc_net
+#else
+#	define init_net__loopback_dev init_net.loopback_dev
+#	define init_net__proc_net     init_net.proc_net
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+#	define xt_match              xtnu_match
+#	define xt_register_match     xtnu_register_match
+#	define xt_unregister_match   xtnu_unregister_match
+#	define xt_register_matches   xtnu_register_matches
+#	define xt_unregister_matches xtnu_unregister_matches
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+#	define csum_replace2 xtnu_csum_replace2
+#	define csum_replace4 xtnu_csum_replace4
+#	define inet_proto_csum_replace4 xtnu_proto_csum_replace4
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 24)
+#	define csum_replace2 nf_csum_replace2
+#	define csum_replace4 nf_csum_replace4
+#	define inet_proto_csum_replace4 xtnu_proto_csum_replace4
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+#	define ipt_unregister_table(tbl) ipt_unregister_table(&init_net, (tbl))
+#	define ip6t_unregister_table(tbl) ip6t_unregister_table(&init_net, (tbl))
+#else
+#	define ipt_unregister_table(tbl) ipt_unregister_table(tbl)
+#	define ip6t_unregister_table(tbl) ip6t_unregister_table(tbl)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+#	define rt_dst(rt)	(&(rt)->dst)
+#else
+#	define rt_dst(rt)	(&(rt)->u.dst)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0)
+#	define nf_nat_ipv4_multi_range_compat nf_nat_multi_range_compat
+#	define nf_nat_ipv4_range nf_nat_range
+#	define NF_NAT_RANGE_MAP_IPS IP_NAT_RANGE_MAP_IPS
+#	define ipv6_skip_exthdr xtnu_ipv6_skip_exthdr
+#endif
+
+#if !defined(NIP6) && !defined(NIP6_FMT)
+#	define NIP6(addr) \
+		ntohs((addr).s6_addr16[0]), \
+		ntohs((addr).s6_addr16[1]), \
+		ntohs((addr).s6_addr16[2]), \
+		ntohs((addr).s6_addr16[3]), \
+		ntohs((addr).s6_addr16[4]), \
+		ntohs((addr).s6_addr16[5]), \
+		ntohs((addr).s6_addr16[6]), \
+		ntohs((addr).s6_addr16[7])
+#	define NIP6_FMT "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x"
+#endif
+#if !defined(NIPQUAD) && !defined(NIPQUAD_FMT)
+#	define NIPQUAD(addr) \
+		((const unsigned char *)&addr)[0], \
+		((const unsigned char *)&addr)[1], \
+		((const unsigned char *)&addr)[2], \
+		((const unsigned char *)&addr)[3]
+#	define NIPQUAD_FMT "%u.%u.%u.%u"
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
+#	define ipv6_find_hdr xtnu_ipv6_find_hdr
+#endif
+
+#define ip_route_me_harder    xtnu_ip_route_me_harder
+#define skb_make_writable     xtnu_skb_make_writable
+#define xt_target             xtnu_target
+#define xt_register_target    xtnu_register_target
+#define xt_unregister_target  xtnu_unregister_target
+#define xt_register_targets   xtnu_register_targets
+#define xt_unregister_targets xtnu_unregister_targets
+
+#define xt_request_find_match xtnu_request_find_match
+
+#endif /* _XTABLES_COMPAT_H */

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/compat_xtnu.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/compat_xtnu.h
@@ -0,0 +1,172 @@
+#ifndef _COMPAT_XTNU_H
+#define _COMPAT_XTNU_H 1
+
+#include <linux/list.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/spinlock.h>
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+typedef _Bool bool;
+enum { false = 0, true = 1, };
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+typedef __u16 __bitwise __sum16;
+typedef __u32 __bitwise __wsum;
+#endif
+
+struct flowi;
+struct hh_cache;
+struct module;
+struct net_device;
+struct rtable;
+struct sk_buff;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+enum {
+	NFPROTO_UNSPEC =  0,
+	NFPROTO_IPV4   =  2,
+	NFPROTO_ARP    =  3,
+	NFPROTO_BRIDGE =  7,
+	NFPROTO_IPV6   = 10,
+	NFPROTO_DECNET = 12,
+	NFPROTO_NUMPROTO,
+};
+
+struct xt_mtchk_param {
+	const char *table;
+	const void *entryinfo;
+	const struct xt_match *match;
+	void *matchinfo;
+	unsigned int hook_mask;
+	u_int8_t family;
+};
+
+struct xt_mtdtor_param {
+	const struct xt_match *match;
+	void *matchinfo;
+	u_int8_t family;
+};
+
+struct xt_target_param {
+	const struct net_device *in, *out;
+	unsigned int hooknum;
+	const struct xt_target *target;
+	const void *targinfo;
+	u_int8_t family;
+};
+
+struct xt_tgchk_param {
+	const char *table;
+	const void *entryinfo;
+	const struct xt_target *target;
+	void *targinfo;
+	unsigned int hook_mask;
+	u_int8_t family;
+};
+
+struct xt_tgdtor_param {
+	const struct xt_target *target;
+	void *targinfo;
+	u_int8_t family;
+};
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+struct xt_action_param {
+	union {
+		const struct xt_match *match;
+		const struct xt_target *target;
+	};
+	union {
+		const void *matchinfo, *targinfo;
+	};
+	const struct net_device *in, *out;
+	int fragoff;
+	unsigned int thoff, hooknum;
+	u_int8_t family;
+	bool hotdrop;
+};
+#endif
+
+struct xtnu_match {
+	/*
+	 * Making it smaller by sizeof(void *) on purpose to catch
+	 * lossy translation, if any.
+	 */
+	char name[sizeof(((struct xt_match *)NULL)->name) - 1 - sizeof(void *)];
+	uint8_t revision;
+	bool (*match)(const struct sk_buff *, struct xt_action_param *);
+	int (*checkentry)(const struct xt_mtchk_param *);
+	void (*destroy)(const struct xt_mtdtor_param *);
+	struct module *me;
+	const char *table;
+	unsigned int matchsize, hooks;
+	unsigned short proto, family;
+
+	void *__compat_match;
+};
+
+struct xtnu_target {
+	char name[sizeof(((struct xt_target *)NULL)->name) - 1 - sizeof(void *)];
+	uint8_t revision;
+	unsigned int (*target)(struct sk_buff **,
+		const struct xt_action_param *);
+	int (*checkentry)(const struct xt_tgchk_param *);
+	void (*destroy)(const struct xt_tgdtor_param *);
+	struct module *me;
+	const char *table;
+	unsigned int targetsize, hooks;
+	unsigned short proto, family;
+
+	void *__compat_target;
+};
+
+static inline struct xtnu_match *xtcompat_numatch(const struct xt_match *m)
+{
+	void *q;
+	memcpy(&q, m->name + sizeof(m->name) - sizeof(void *), sizeof(void *));
+	return q;
+}
+
+static inline struct xtnu_target *xtcompat_nutarget(const struct xt_target *t)
+{
+	void *q;
+	memcpy(&q, t->name + sizeof(t->name) - sizeof(void *), sizeof(void *));
+	return q;
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+static inline __wsum csum_unfold(__sum16 n)
+{
+	return (__force __wsum)n;
+}
+#endif
+
+extern int xtnu_ip_local_out(struct sk_buff *);
+extern int xtnu_ip_route_me_harder(struct sk_buff **, unsigned int);
+extern int xtnu_skb_make_writable(struct sk_buff **, unsigned int);
+extern int xtnu_register_match(struct xtnu_match *);
+extern int xtnu_ip_route_output_key(void *, struct rtable **, struct flowi *);
+extern void xtnu_unregister_match(struct xtnu_match *);
+extern int xtnu_register_matches(struct xtnu_match *, unsigned int);
+extern void xtnu_unregister_matches(struct xtnu_match *, unsigned int);
+extern int xtnu_register_target(struct xtnu_target *);
+extern void xtnu_unregister_target(struct xtnu_target *);
+extern int xtnu_register_targets(struct xtnu_target *, unsigned int);
+extern void xtnu_unregister_targets(struct xtnu_target *, unsigned int);
+extern struct xt_match *xtnu_request_find_match(unsigned int,
+	const char *, uint8_t);
+extern int xtnu_neigh_hh_output(struct hh_cache *, struct sk_buff *);
+extern void xtnu_csum_replace2(__u16 __bitwise *, __be16, __be16);
+extern void xtnu_csum_replace4(__u16 __bitwise *, __be32, __be32);
+extern void xtnu_proto_csum_replace4(__u16 __bitwise *, struct sk_buff *,
+	__be32, __be32, bool);
+extern int xtnu_skb_linearize(struct sk_buff *);
+extern int xtnu_ipv6_skip_exthdr(const struct sk_buff *, int,
+	uint8_t *, __be16 *);
+extern int xtnu_ipv6_find_hdr(const struct sk_buff *, unsigned int *,
+	int, unsigned short *, int *);
+
+extern void *HX_memmem(const void *, size_t, const void *, size_t);
+
+#endif /* _COMPAT_XTNU_H */

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/ip6table_rawpost.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/ip6table_rawpost.c
@@ -0,0 +1,107 @@
+/*
+ *	rawpost table for ip6_tables
+ *	written by Jan Engelhardt <jengelh [at] medozas de>, 2008 - 2009
+ *	placed in the Public Domain
+ */
+#include <linux/module.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <net/ip.h>
+#include "compat_xtables.h"
+#include "compat_rawpost.h"
+
+enum {
+	RAWPOST_VALID_HOOKS = 1 << NF_INET_POST_ROUTING,
+};
+
+static struct {
+	struct ip6t_replace repl;
+	struct ip6t_standard entries[1];
+	struct ip6t_error term;
+} rawpost6_initial __initdata = {
+	.repl = {
+		.name        = "rawpost",
+		.valid_hooks = RAWPOST_VALID_HOOKS,
+		.num_entries = 2,
+		.size        = sizeof(struct ip6t_standard) +
+		               sizeof(struct ip6t_error),
+		.hook_entry  = {
+			[NF_INET_POST_ROUTING] = 0,
+		},
+		.underflow = {
+			[NF_INET_POST_ROUTING] = 0,
+		},
+	},
+	.entries = {
+		IP6T_STANDARD_INIT(NF_ACCEPT),	/* POST_ROUTING */
+	},
+	.term = IP6T_ERROR_INIT,		/* ERROR */
+};
+
+static struct xt_table *rawpost6_ptable;
+
+static struct xt_table rawpost6_itable = {
+	.name        = "rawpost",
+	.af          = NFPROTO_IPV6,
+	.valid_hooks = RAWPOST_VALID_HOOKS,
+	.me          = THIS_MODULE,
+};
+
+static unsigned int rawpost6_hook_fn(unsigned int hook, sk_buff_t *skb,
+    const struct net_device *in, const struct net_device *out,
+    int (*okfn)(struct sk_buff *))
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+	return ip6t_do_table(skb, hook, in, out, rawpost6_ptable);
+#else
+	return ip6t_do_table(skb, hook, in, out, rawpost6_ptable, NULL);
+#endif
+}
+
+static struct nf_hook_ops rawpost6_hook_ops __read_mostly = {
+	.hook     = rawpost6_hook_fn,
+	.pf       = NFPROTO_IPV6,
+	.hooknum  = NF_INET_POST_ROUTING,
+	.priority = NF_IP6_PRI_LAST,
+	.owner    = THIS_MODULE,
+};
+
+static int __init rawpost6_table_init(void)
+{
+	int ret;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 29)
+	rwlock_init(&rawpost6_itable.lock);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	rawpost6_ptable = ip6t_register_table(&init_net, &rawpost6_itable,
+	                  &rawpost6_initial.repl);
+	if (IS_ERR(rawpost6_ptable))
+		return PTR_ERR(rawpost6_ptable);
+#else
+	ret = ip6t_register_table(&rawpost6_itable, &rawpost6_initial.repl);
+	if (ret < 0)
+		return ret;
+	rawpost6_ptable = &rawpost6_itable;
+#endif
+
+	ret = nf_register_hook(&rawpost6_hook_ops);
+	if (ret < 0)
+		goto out;
+
+	return ret;
+
+ out:
+	ip6t_unregister_table(rawpost6_ptable);
+	return ret;
+}
+
+static void __exit rawpost6_table_exit(void)
+{
+	nf_unregister_hook(&rawpost6_hook_ops);
+	ip6t_unregister_table(rawpost6_ptable);
+}
+
+module_init(rawpost6_table_init);
+module_exit(rawpost6_table_exit);
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/iptable_rawpost.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/iptable_rawpost.c
@@ -0,0 +1,109 @@
+/*
+ *	rawpost table for ip_tables
+ *	written by Jan Engelhardt <jengelh [at] medozas de>, 2008 - 2009
+ *	placed in the Public Domain
+ */
+#include <linux/module.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/version.h>
+#include <net/ip.h>
+#include "compat_xtables.h"
+#include "compat_rawpost.h"
+
+enum {
+	RAWPOST_VALID_HOOKS = 1 << NF_INET_POST_ROUTING,
+};
+
+static struct {
+	struct ipt_replace repl;
+	struct ipt_standard entries[1];
+	struct ipt_error term;
+} rawpost4_initial __initdata = {
+	.repl = {
+		.name        = "rawpost",
+		.valid_hooks = RAWPOST_VALID_HOOKS,
+		.num_entries = 2,
+		.size        = sizeof(struct ipt_standard) +
+		               sizeof(struct ipt_error),
+		.hook_entry  = {
+			[NF_INET_POST_ROUTING] = 0,
+		},
+		.underflow = {
+			[NF_INET_POST_ROUTING] = 0,
+		},
+	},
+	.entries = {
+		IPT_STANDARD_INIT(NF_ACCEPT),	/* POST_ROUTING */
+	},
+	.term = IPT_ERROR_INIT,			/* ERROR */
+};
+
+static struct xt_table *rawpost4_ptable;
+
+static struct xt_table rawpost4_itable = {
+	.name        = "rawpost",
+	.af          = NFPROTO_IPV4,
+	.valid_hooks = RAWPOST_VALID_HOOKS,
+	.me          = THIS_MODULE,
+};
+
+static unsigned int rawpost4_hook_fn(unsigned int hook, sk_buff_t *skb,
+    const struct net_device *in, const struct net_device *out,
+    int (*okfn)(struct sk_buff *))
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+	return ipt_do_table(skb, hook, in, out, rawpost4_ptable);
+#else
+	return ipt_do_table(skb, hook, in, out, rawpost4_ptable, NULL);
+#endif
+}
+
+static struct nf_hook_ops rawpost4_hook_ops __read_mostly = {
+	.hook     = rawpost4_hook_fn,
+	.pf       = NFPROTO_IPV4,
+	.hooknum  = NF_INET_POST_ROUTING,
+	.priority = NF_IP_PRI_LAST,
+	.owner    = THIS_MODULE,
+};
+
+static int __init rawpost4_table_init(void)
+{
+	int ret;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 29)
+	rwlock_init(&rawpost4_itable.lock);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	rawpost4_ptable = ipt_register_table(&init_net, &rawpost4_itable,
+	                  &rawpost4_initial.repl);
+	if (IS_ERR(rawpost4_ptable))
+		return PTR_ERR(rawpost4_ptable);
+#else
+	ret = ipt_register_table(&rawpost4_itable, &rawpost4_initial.repl);
+	if (ret < 0)
+		return ret;
+	rawpost4_ptable = &rawpost4_itable;
+#endif
+
+	ret = nf_register_hook(&rawpost4_hook_ops);
+	if (ret < 0)
+		goto out;
+
+	return ret;
+
+ out:
+	ipt_unregister_table(rawpost4_ptable);
+	return ret;
+}
+
+static void __exit rawpost4_table_exit(void)
+{
+	nf_unregister_hook(&rawpost4_hook_ops);
+	ipt_unregister_table(rawpost4_ptable);
+}
+
+module_init(rawpost4_table_init);
+module_exit(rawpost4_table_exit);
+MODULE_DESCRIPTION("Xtables: rawpost table for use with RAWNAT");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/Kconfig
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/Kconfig
@@ -590,6 +590,203 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_TARGET_ACCOUNT
+	tristate '"ACCOUNT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The ACCOUNT target is a high performance accounting system for large
+	  local networks. It allows per-IP accounting in whole prefixes of IPv4
+	  addresses with size of up to /8 without the need to add individual
+	  accouting rule for each IP address.
+
+	  The ACCOUNT is designed to be queried for data every second or at
+	  least every ten seconds. It is written as kernel module to handle high
+	  bandwidths without packet loss.
+
+	  The largest possible subnet size is 24 bit, meaning for example 10.0.0.0/8
+	  network. ACCOUNT uses fixed internal data structures
+	  which speeds up the processing of each packet. Furthermore,
+	  accounting data for one complete 192.168.1.X/24 network takes 4 KB of
+	  memory. Memory for 16 or 24 bit networks is only allocated when
+	  needed.
+
+	  To optimize the kernel<->userspace data transfer a bit more, the
+	  kernel module only transfers information about IPs, where the src/dst
+	  packet counter is not 0. This saves precious kernel time.
+
+	  There is no /proc interface as it would be too slow for continuous access.
+	  The read-and-flush query operation is the fastest, as no internal data
+	  snapshot needs to be created&copied for all data. Use the "read"
+	  operation without flush only for debugging purposes!
+
+	  Usage:
+
+	  ACCOUNT takes two mandatory parameters:
+
+	  --addr network/netmask
+	  where network/netmask is the subnet to account for, in CIDR syntax
+
+	  --tname NAME
+	  where NAME is the name of the table where the accounting information
+	  should be stored
+
+	  The subnet 0.0.0.0/0 is a special case: all data are then stored in the src_bytes
+	  and src_packets structure of slot "0". This is useful if you want
+	  to account the overall traffic to/from your internet provider.
+
+	  The data can be queried using the userspace libxt_ACCOUNT_cl library,
+	  and by the reference implementation to show usage of this library,
+	  the iptaccount(8) tool.
+
+	  Here is an example of use:
+
+	  iptables -A FORWARD -j ACCOUNT --addr 0.0.0.0/0 --tname all_outgoing;
+	  iptables -A FORWARD -j ACCOUNT --addr 192.168.1.0/24 --tname sales;
+
+	  This creates two tables called "all_outgoing" and "sales" which can be
+	  queried using the userspace library/iptaccount tool.
+
+	  Note that this target is non-terminating, the packet destined to it
+	  will continue traversing the chain in which it has been used.
+
+	  Also note that once a table has been defined for specific CIDR address/netmask
+	  block, it can be referenced multiple times using -j ACCOUNT, provided
+	  that both the original table name and address/netmask block are specified.
+
+	  For more information go to http://www.intra2net.com/en/developer/ipt_ACCOUNT/
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_TARGET_CHAOS
+	tristate '"CHAOS" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Causes confusion on the other end by doing odd things with incoming packets.
+	  CHAOS will randomly reply (or not) with one of its configurable subtargets:
+
+	  --delude
+	  Use the REJECT and DELUDE targets as a base to do a sudden or deferred
+	  connection reset, fooling some network scanners to return non-deterministic
+	  (randomly open/closed) results, and in case it is deemed open, it is actually
+	  closed/filtered.
+
+	  --tarpit
+	  Use the REJECT and TARPIT target as a base to hold the connection until it
+	  times out. This consumes conntrack entries when connection tracking is loaded
+	  (which usually is on most machines), and routers inbetween you and the Internet
+	  may fail to do their connection tracking if they have to handle more
+	  connections than they can.
+
+	  The randomness factor of not replying vs. replying can be set during load-time
+	  of the xt_CHAOS module or during runtime in /sys/modules/xt_CHAOS/parameters.
+
+	  See http://jengelh.medozas.de/projects/chaostables/ for more information
+	  about CHAOS, DELUDE and lscan.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_TARGET_DELUDE
+	tristate '"DELUDE" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The DELUDE target will reply to a SYN packet with SYN-ACK, and to all other
+	  packets with an RST. This will terminate the connection much like REJECT, but
+	  network scanners doing TCP half-open discovery can be spoofed to make them
+	  belive the port is open rather than closed/filtered.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_ECHO
+	tristate '"ECHO" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The ECHO target will send back all packets it received. It serves as an
+	  examples for an Xtables target.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_RAWNAT
+	tristate '"RAWNAT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The RAWSNAT and RAWDNAT targets provide stateless network address
+	  translation.
+
+	  The RAWDNAT target will rewrite the destination address in the IP header,
+	  much like the NETMAP target.
+
+	  --to-destination addr[/mask]
+	  Network address to map to. The resulting address will be constructed the
+	  following way: All 'one' bits in the mask are filled in from the new
+	  address. All bits that are zero in the mask are filled in from the
+	  original address.
+
+	  The RAWSNAT target will rewrite the source address in the IP header, much
+	  like the NETMAP target. RAWSNAT (and RAWDNAT) may only be
+	  used in the raw or rawpost tables, but can be used in all chains,
+	  which makes it possible to change the source address either when the packet
+	  enters the machine or when it leaves it. The reason for this table constraint
+	  is that RAWNAT must happen outside of connection tracking.
+
+	  --to-source addr[/mask]
+	  Network address to map to. The resulting address will be constructed the
+	  following way: All 'one' bits in the mask are filled in from the new
+	  address. All bits that are zero in the mask are filled in from the
+	  original address.
+
+	  As an example, changing the destination for packets forwarded from an internal
+	  LAN to the internet:
+
+	  -t raw -A PREROUTING -i lan0 -d 212.201.100.135 -j RAWDNAT --to-destination 199.181.132.250;
+	  -t rawpost -A POSTROUTING -o lan0 -s 199.181.132.250 -j RAWSNAT --to-source 212.201.100.135;
+
+	  Note that changing addresses may influence the route selection! Specifically,
+	  it statically NATs packets, not connections, like the normal DNAT/SNAT targets
+	  would do. Also note that it can transform already-NATed connections, as
+	  said, it is completely external to Netfilter's connection tracking/NAT.
+
+	  If the machine itself generates packets that are to be rawnat'ed, you need a
+	  rule in the OUTPUT chain instead, just like you would with the stateful NAT
+	  targets.
+
+	  It may be necessary that in doing so, you also need an extra RAWSNAT rule, to
+	  override the automatic source address selection that the routing code does
+	  before passing packets to iptables. If the connecting socket has not been
+	  explicitly bound to an address, as is the common mode of operation, the address
+	  that will be chosen is the primary address of the device through which the
+	  packet would be routed with its initial destination address - the address as
+	  seen before any RAWNAT takes place.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_STEAL
+	tristate '"STEAL" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Like the DROP target, but does not throw an error like DROP when used in the
+	  OUTPUT chain.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+	  
+config NETFILTER_XT_TARGET_TARPIT
+	tristate '"TARPIT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Adds a TARPIT target to iptables, which captures and holds
+	  incoming TCP connections using no local per-connection resources.
+	  Connections are accepted, but immediately switched to the persist
+	  state (0 byte window), in which the remote side stops sending data
+	  and asks to continue every 60-240 seconds. Attempts to close the
+	  connection are ignored, forcing the remote side to time out the
+	  connection in 12-24 minutes.
+
+	  This offers similar functionality to LaBrea
+	  <http://www.hackbusters.net/LaBrea/>, but does not require dedicated
+	  hardware or IPs. Any TCP port that you would normally DROP or REJECT
+	  can instead become a tarpit.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+  
 config NETFILTER_XT_TARGET_TCPMSS
 	tristate '"TCPMSS" target support'
 	depends on (IPV6 || IPV6=n)
@@ -1096,6 +1293,350 @@
           <file:Documentation/modules.txt>.  The module will be
           called `ipt_geoip'.  If unsure, say `N'.
 
+config NETFILTER_XT_MATCH_FUZZY
+	tristate '"MATCH" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  This module matches a rate limit based on a fuzzy logic controller (FLC).
+
+	  --lower-limit number
+	  Specifies the lower limit, in packets per second.
+
+	  --upper-limit number
+	  Specifies the upper limit, also in packets per second.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_IFACE
+	tristate '"IFACE" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Allows you to check interface states. First, an interface needs to be selected
+	  for comparison. Exactly one option of the following three must be specified:
+
+	  --iface name
+	  Check the states on the given interface.
+
+	  --dev-in
+	  Check the states on the interface on which the packet came in. If the input
+	  device is not set, because for example you are using -m iface in the OUTPUT
+	  chain, this submatch returns false.
+
+	  --dev-out
+	  Check the states on the interface on which the packet will go out. If the
+	  output device is not set, because for example you are using -m iface in the
+	  INPUT chain, this submatch returns false.
+
+	  Following that, one can select the interface properties to check for:
+
+	  [!] --up, [!] --down
+	  Check the UP flag.
+
+	  [!] --broadcast
+	  Check the BROADCAST flag.
+
+	  [!] --loopback
+	  Check the LOOPBACK flag.
+
+	  [!] --pointtopoint
+	  Check the POINTTOPOINT flag.
+
+	  [!] --running
+	  Check the RUNNING flag. Do NOT rely on it!
+
+	  [!] --noarp, [!] --arp
+	  Check the NOARP flag.
+
+	  [!] --promisc
+	  Check the PROMISC flag.
+
+	  [!] --multicast
+	  Check the MULTICAST flag.
+
+	  [!] --dynamic
+	  Check the DYNAMIC flag.
+
+	  [!] --lower-up
+	  Check the LOWER_UP flag.
+
+	  [!] --dormant
+	  Check the DORMANT flag.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_IPV4OPTIONS
+	tristate '"IPV4OPTIONS" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The "ipv4options" module allows to match against a set of IPv4 header options.
+
+	  --flags [!]symbol[,[!]symbol...]
+	  Specify the options that shall appear or not appear in the header. Each
+	  symbol specification is delimited by a comma, and a '!' can be prefixed to
+	  a symbol to negate its presence. Symbols are either the name of an IPv4 option
+	  or its number. See examples below.
+
+	  --any
+	  By default, all of the flags specified must be present/absent, that is, they
+	  form an AND condition. Use the --any flag instead to use an OR condition
+	  where only at least one symbol spec must be true.
+
+	  Known symbol names (and their number):
+
+	  1 nop
+	  2 security RFC 1108
+	  3 lsrr Loose Source Routing, RFC 791
+	  4 timestamp RFC 781, 791
+	  7 record-route RFC 791
+	  9 ssrr Strict Source Routing, RFC 791
+	  11 mtu-probe RFC 1063
+	  12 mtu-reply RFC 1063
+	  18 traceroute RFC 1393
+	  20 router-alert RFC 2113
+
+	  Examples:
+
+	  Match packets that have both Timestamp and NOP:
+	  -m ipv4options --flags nop,timestamp
+
+	  ~ that have either of Timestamp or NOP, or both:
+	  --flags nop,timestamp --any
+
+	  ~ that have Timestamp and no NOP: --flags '!nop,timestamp'
+
+	  ~ that have either no NOP or a timestamp (or both conditions):
+	  --flags '!nop,timestamp' --any
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_LSCAN
+	tristate '"LSCAN" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Detects simple low-level scan attemps based upon the packet's contents.
+	  (This is different from other implementations, which also try to match the rate of new
+	  connections.) Note that an attempt is only discovered after it has been carried
+	  out, but this information can be used in conjunction with other rules to block
+	  the remote host's future connections. So this match module will match on the
+	  (probably) last packet the remote side will send to your machine.
+
+	  --stealth
+	  Match if the packet did not belong to any known TCP connection
+	  (Stealth/FIN/XMAS/NULL scan).
+
+	  --synscan
+	  Match if the connection was a TCP half-open discovery (SYN scan), i.e. the
+	  connection was torn down after the 2nd packet in the 3-way handshake.
+
+	  --cnscan
+	  Match if the connection was a TCP full open discovery (connect scan), i.e. the
+	  connection was torn down after completion of the 3-way handshake.
+
+	  --grscan
+	  Match if data in the connection only flew in the direction of the remote side,
+	  e.g. if the connection was terminated after a locally running daemon sent its
+	  identification. (E.g. openssh, smtp, ftpd.) This may falsely trigger on
+	  warranted single-direction data flows, usually bulk data transfers such as
+	  FTP DATA connections or IRC DCC. Grab Scan Detection should only be used on
+	  ports where a protocol runs that is guaranteed to do a bidirectional exchange
+	  of bytes.
+
+	  NOTE: Some clients (Windows XP for example) may do what looks like a SYN scan,
+	  so be advised to carefully use xt_lscan in conjunction with blocking rules,
+	  as it may lock out your very own internal network.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+	  
+config NETFILTER_XT_MATCH_PKNOCK
+	tristate '"PKNOCK" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Pknock match implements so-called "port knocking", a stealthy system
+	  for network authentication: a client sends packets to selected
+	  ports in a specific sequence (= simple mode, see example 1 below), or a HMAC
+	  payload to a single port (= complex mode, see example 2 below),
+	  to a target machine that has pknock rule(s) installed. The target machine
+	  then decides whether to unblock or block (again) the pknock-protected port(s).
+	  This can be used, for instance, to avoid brute force
+	  attacks on ssh or ftp services.
+
+	  Example prerequisites:
+
+	  modprobe cn
+
+	  modprobe xt_pknock
+
+	  Example 1 (TCP mode, manual closing of opened port not possible):
+
+	  iptables -P INPUT DROP
+
+	  iptables -A INPUT -p tcp -m pknock --knockports 4002,4001,4004 --strict
+	  --name SSH --time 10 --autoclose 60 --dport 22 -j ACCEPT
+
+	  The rule will allow tcp port 22 for the attempting IP address after the successful reception of TCP SYN packets
+	  to ports 4002, 4001 and 4004, in this order (a.k.a. port-knocking).
+	  Port numbers in the connect sequence must follow the exact specification, no
+	  other ports may be "knocked" inbetween. The rule is named 'SSH', a file of
+	  the same name for tracking port knocking states will be created in
+	  /proc/net/xt_pknock .
+	  Successive port knocks must occur with delay of at most 10 seconds. Port 22 (from the example) will
+	  be automatiaclly dropped after 60 minutes after it was previously allowed.
+
+	  Example 2 (UDP mode, non-replayable and non-spoofable, manual closing
+	  of opened port possible, secure, also called "SPA" = Secure Port
+	  Authorization):
+
+	  iptables -A INPUT -p udp -m pknock --knockports 4000 --name FTP
+	  --opensecret foo --closesecret bar --autoclose 240 -j DROP
+
+	  iptables -A INPUT -p tcp -m pknock --checkip --name FTP --dport 21 -j ACCEPT
+
+	  The first rule will create an "ALLOWED" record in /proc/net/xt_pknock/FTP after
+	  the successful reception of an UDP packet to port 4000. The packet payload must be
+	  constructed as a HMAC256 using "foo" as a key. The HMAC content is the particular 
+	  client's IP address as a 32-bit network byteorder quantity,
+	  plus the number of minutes since the Unix epoch, also as a 32-bit value.
+	  (This is known as Simple Packet Authorization, also called "SPA".)
+	  In such case, any subsequent attempt to connect to port 21 from the client's IP
+	  address will cause such packets to be accepted in the second rule.
+
+	  Similarly, upon reception of an UDP packet constructed the same way, but with
+	  the key "bar", the first rule will remove a previously installed "ALLOWED" state
+	  record from /proc/net/xt_pknock/FTP, which means that the second rule will
+	  stop matching for subsequent connection attempts to port 21.
+	  In case no close-secret packet is received within 4 hours, the first rule
+	  will remove "ALLOWED" record from /proc/net/xt_pknock/FTP itself.
+
+	  Things worth noting:
+
+	  General:
+
+	  Specifying --autoclose 0 means that no automatic close will be performed at all.
+
+	  xt_pknock is capable of sending information about successful matches
+	  via a netlink socket to userspace, should you need to implement your own
+	  way of receiving and handling portknock notifications.
+	  Be sure to read the documentation in the doc/pknock/ directory,
+	  or visit the original site, http://portknocko.berlios.de/ .
+
+	  TCP mode:
+
+	  This mode is not immune against eavesdropping, spoofing and
+	  replaying of the port knock sequence by someone else (but its use may still
+	  be sufficient for scenarios where these factors are not necessarily
+	  this important, such as bare shielding of the SSH port from brute-force attacks).
+	  However, if you need these features, you should use UDP mode.
+
+	  It is always wise to specify three or more ports that are not monotonically
+	  increasing or decreasing with a small stepsize (e.g. 1024,1025,1026)
+	  to avoid accidentally triggering
+	  the rule by a portscan.
+
+	  Specifying the inter-knock timeout with --time is mandatory in TCP mode,
+	  to avoid permanent denial of services by clogging up the peer knock-state tracking table
+	  that xt_pknock internally keeps, should there be a DDoS on the
+	  first-in-row knock port from more hostile IP addresses than what the actual size
+	  of this table is (defaults to 16, can be changed via the "peer_hasht_ents" module parameter).
+	  It is also wise to use as short a time as possible (1 second) for --time
+	  for this very reason. You may also consider increasing the size
+	  of the peer knock-state tracking table. Using --strict also helps,
+	  as it requires the knock sequence to be exact. This means that if the
+	  hostile client sends more knocks to the same port, xt_pknock will
+	  mark such attempt as failed knock sequence and will forget it immediately.
+	  To completely thwart this kind of DDoS, knock-ports would need to have
+	  an additional rate-limit protection. Or you may consider using UDP mode.
+
+	  UDP mode:
+
+	  This mode is immune against eavesdropping, replaying and spoofing attacks.
+	  It is also immune against DDoS attack on the knockport.
+
+	  For this mode to work, the clock difference on the client and on the server
+	  must be below 1 minute. Synchronizing time on both ends by means
+	  of NTP or rdate is strongly suggested.
+
+	  There is a rate limiter built into xt_pknock which blocks any subsequent
+	  open attempt in UDP mode should the request arrive within less than one
+	  minute since the first successful open. This is intentional;
+	  it thwarts eventual spoofing attacks.
+
+	  Because the payload value of an UDP knock packet is influenced by client's IP address,
+	  UDP mode cannot be used across NAT.
+
+	  For sending UDP "SPA" packets, you may use either knock.sh or
+	  knock-orig.sh. These may be found in doc/pknock/util.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_PSD
+	tristate '"PSD" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Attempt to detect TCP and UDP port scans. This match was derived from
+	  Solar Designer's scanlogd.
+
+	  --psd-weight-threshold threshold
+	  Total weight of the latest TCP/UDP packets with different
+	  destination ports coming from the same host to be treated as port
+	  scan sequence.
+
+	  --psd-delay-threshold delay
+	  Delay (in hundredths of second) for the packets with different
+	  destination ports coming from the same host to be treated as
+	  possible port scan subsequence.
+
+	  --psd-lo-ports-weight weight
+	  Weight of the packet with privileged (<=1024) destination port.
+
+	  --psd-hi-ports-weight weight
+	  Weight of the packet with non-priviliged destination port.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_QUOTA2
+	tristate '"QUOTA2" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The "quota2" implements a named counter which can be increased or decreased
+	  on a per-match basis. Available modes are packet counting or byte counting.
+	  The value of the counter can be read and reset through procfs, thereby making
+	  this match a minimalist accounting tool.
+
+	  When counting down from the initial quota, the counter will stop at 0 and
+	  the match will return false, just like the original "quota" match. In growing
+	  (upcounting) mode, it will always return true.
+
+	  --grow
+	  Count upwards instead of downwards.
+
+	  --no-change
+	  Makes it so the counter or quota amount is never changed by packets matching
+	  this rule. This is only really useful in "quota" mode, as it will allow you to
+	  use complex prerouting rules in association with the quota system, without
+	  counting a packet twice.
+
+	  --name name
+	  Assign the counter a specific name. This option must be present, as an empty
+	  name is not allowed. Names starting with a dot or names containing a slash are
+	  prohibited.
+
+	  [!] --quota iq
+	  Specify the initial quota for this counter. If the counter already exists,
+	  it is not reset. An "!" may be used to invert the result of the match. The
+	  negation has no effect when --grow is used.
+
+	  --packets
+	  Count packets instead of bytes that passed the quota2 match.
+
+	  Because counters in quota2 can be shared, you can combine them for various
+	  purposes, for example, a bytebucket filter that only lets as much traffic go
+	  out as has come in:
+
+	  -A INPUT -p tcp --dport 6881 -m quota --name bt --grow;
+	  -A OUTPUT -p tcp --sport 6881 -m quota --name bt;
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
 endif # NETFILTER_XTABLES
 
 endmenu

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/Makefile
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/Makefile
@@ -40,6 +40,7 @@
 
 # generic X tables 
 obj-$(CONFIG_NETFILTER_XTABLES) += x_tables.o xt_tcpudp.o
+obj-y += compat_xtables.o
 
 # combos
 obj-$(CONFIG_NETFILTER_XT_MARK) += xt_mark.o
@@ -61,6 +62,14 @@
 obj-$(CONFIG_NETFILTER_XT_TARGET_RATEEST) += xt_RATEEST.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_SECMARK) += xt_SECMARK.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TPROXY) += xt_TPROXY.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_CHAOS) += xt_CHAOS.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_DELUDE) += xt_DELUDE.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_RAWNAT) += xt_RAWNAT.o iptable_rawpost.o
+ifneq (${CONFIG_IP6_NF_IPTABLES},)
+obj-${CONFIG_NETFILTER_XT_TARGET_RAWNAT} += ip6table_rawpost.o
+endif
+obj-$(CONFIG_NETFILTER_XT_TARGET_STEAL) += xt_STEAL.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_TARPIT) += xt_TARPIT.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TCPMSS) += xt_TCPMSS.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP) += xt_TCPOPTSTRIP.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TEE) += xt_TEE.o
@@ -109,6 +118,13 @@
 obj-$(CONFIG_NETFILTER_XT_MATCH_CONDITION) += xt_condition.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_GEOIP) += xt_geoip.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_ETHPORT) += xt_ethport.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_FUZZY) += xt_fuzzy.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_IFACE) += xt_iface.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_IPV4OPTIONS) += xt_ipv4options.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_LSCAN) += xt_lscan.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PKNOCK) += xt_pknock.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PSD) += xt_psd.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_QUOTA2) += xt_quota2.o
 
 # ipset
 obj-$(CONFIG_IP_SET) += ipset/

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_CHAOS.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_CHAOS.c
@@ -0,0 +1,279 @@
+/*
+ *	"CHAOS" target extension for Xtables
+ *	Copyright © Jan Engelhardt <jengelh [at] medozas de>, 2006 - 2008
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <linux/icmp.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/version.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_tcpudp.h>
+#include <linux/netfilter_ipv4/ipt_REJECT.h>
+#include <net/ip.h>
+#include "xt_CHAOS.h"
+static struct xt_match *xm_tcp;
+static struct xt_target *xt_delude, *xt_reject, *xt_tarpit;
+#include "compat_xtables.h"
+#define PFX KBUILD_MODNAME ": "
+
+/* Module parameters */
+static unsigned int reject_percentage = ~0U * .01;
+static unsigned int delude_percentage = ~0U * .0101;
+module_param(reject_percentage, uint, S_IRUGO | S_IWUSR);
+module_param(delude_percentage, uint, S_IRUGO | S_IWUSR);
+
+/* References to other matches/targets */
+
+static int have_delude, have_tarpit;
+
+/* Static data for other matches/targets */
+static const struct ipt_reject_info reject_params = {
+	.with = ICMP_HOST_UNREACH,
+};
+
+static const struct xt_tcp tcp_params = {
+	.spts = {0, ~0},
+	.dpts = {0, ~0},
+};
+
+/* CHAOS functions */
+static void
+xt_chaos_total(struct sk_buff *skb, const struct xt_action_param *par)
+{
+	const struct xt_chaos_tginfo *info = par->targinfo;
+	const struct iphdr *iph = ip_hdr(skb);
+	const int thoff         = 4 * iph->ihl;
+	const int fragoff       = ntohs(iph->frag_off) & IP_OFFSET;
+	typeof(xt_tarpit) destiny;
+	bool ret;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 22)
+	int hotdrop = false;
+#else
+	bool hotdrop = false;
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+	ret = xm_tcp->match(skb, par->in, par->out, xm_tcp, &tcp_params,
+	                    fragoff, thoff, &hotdrop);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+	{
+		struct xt_match_param local_par = {
+			.in        = par->in,
+			.out       = par->out,
+			.match     = xm_tcp,
+			.matchinfo = &tcp_params,
+			.fragoff   = fragoff,
+			.thoff     = thoff,
+			.hotdrop   = &hotdrop,
+		};
+		ret = xm_tcp->match(skb, &local_par);
+	}
+#else
+	{
+		struct xt_action_param local_par;
+		local_par.in        = par->in,
+		local_par.out       = par->out,
+		local_par.match     = xm_tcp;
+		local_par.matchinfo = &tcp_params;
+		local_par.fragoff   = fragoff;
+		local_par.thoff     = thoff;
+		local_par.hotdrop   = false;
+		ret = xm_tcp->match(skb, &local_par);
+		hotdrop = local_par.hotdrop;
+	}
+#endif
+	if (!ret || hotdrop || (unsigned int)net_random() > delude_percentage)
+		return;
+
+	destiny = (info->variant == XTCHAOS_TARPIT) ? xt_tarpit : xt_delude;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+	destiny->target(&skb, par->in, par->out, par->hooknum, destiny, NULL, NULL);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+	destiny->target(&skb, par->in, par->out, par->hooknum, destiny, NULL);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+	destiny->target(skb, par->in, par->out, par->hooknum, destiny, NULL);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+	{
+		struct xt_target_param local_par = {
+			.in       = par->in,
+			.out      = par->out,
+			.hooknum  = par->hooknum,
+			.target   = destiny,
+			.targinfo = par->targinfo,
+			.family   = par->family,
+		};
+		destiny->target(skb, &local_par);
+	}
+#else
+	{
+		struct xt_action_param local_par;
+		local_par.in       = par->in;
+		local_par.out      = par->out;
+		local_par.hooknum  = par->hooknum;
+		local_par.target   = destiny;
+		local_par.targinfo = par->targinfo;
+		local_par.family   = par->family;
+		destiny->target(skb, &local_par);
+	}
+#endif
+}
+
+static unsigned int
+chaos_tg(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	/*
+	 * Equivalent to:
+	 * -A chaos -m statistic --mode random --probability \
+	 *         $reject_percentage -j REJECT --reject-with host-unreach;
+	 * -A chaos -p tcp -m statistic --mode random --probability \
+	 *         $delude_percentage -j DELUDE;
+	 * -A chaos -j DROP;
+	 */
+	const struct xt_chaos_tginfo *info = par->targinfo;
+	struct sk_buff *skb = *pskb;
+	const struct iphdr *iph = ip_hdr(skb);
+
+	if ((unsigned int)net_random() <= reject_percentage) {
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+		return xt_reject->target(pskb, par->in, par->out, par->hooknum,
+		       xt_reject, &reject_params, NULL);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+		return xt_reject->target(pskb, par->in, par->out, par->hooknum,
+		       xt_reject, &reject_params);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+		return xt_reject->target(skb, par->in, par->out, par->hooknum,
+		       xt_reject, &reject_params);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+		struct xt_target_param local_par = {
+			.in       = par->in,
+			.out      = par->out,
+			.hooknum  = par->hooknum,
+			.target   = xt_reject,
+			.targinfo = &reject_params,
+		};
+		return xt_reject->target(skb, &local_par);
+#else
+		struct xt_action_param local_par;
+		local_par.in       = par->in;
+		local_par.out      = par->out;
+		local_par.hooknum  = par->hooknum;
+		local_par.target   = xt_reject;
+		local_par.targinfo = &reject_params;
+		return xt_reject->target(skb, &local_par);
+#endif
+	}
+
+	/* TARPIT/DELUDE may not be called from the OUTPUT chain */
+	if (iph->protocol == IPPROTO_TCP &&
+	    info->variant != XTCHAOS_NORMAL &&
+	    par->hooknum != NF_INET_LOCAL_OUT)
+		xt_chaos_total(skb, par);
+
+	return NF_DROP;
+}
+
+static int chaos_tg_check(const struct xt_tgchk_param *par)
+{
+	const struct xt_chaos_tginfo *info = par->targinfo;
+
+	if (info->variant == XTCHAOS_DELUDE && !have_delude) {
+		printk(KERN_WARNING PFX "Error: Cannot use --delude when "
+		       "DELUDE module not available\n");
+		return -EINVAL;
+	}
+	if (info->variant == XTCHAOS_TARPIT && !have_tarpit) {
+		printk(KERN_WARNING PFX "Error: Cannot use --tarpit when "
+		       "TARPIT module not available\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct xt_target chaos_tg_reg = {
+	.name       = "CHAOS",
+	.revision   = 0,
+	.family     = NFPROTO_IPV4,
+	.table      = "filter",
+	.hooks      = (1 << NF_INET_LOCAL_IN) | (1 << NF_INET_FORWARD) |
+	              (1 << NF_INET_LOCAL_OUT),
+	.target     = chaos_tg,
+	.checkentry = chaos_tg_check,
+	.targetsize = sizeof(struct xt_chaos_tginfo),
+	.me         = THIS_MODULE,
+};
+
+static int __init chaos_tg_init(void)
+{
+	int ret = -EINVAL;
+
+	xm_tcp = xt_request_find_match(NFPROTO_IPV4, "tcp", 0);
+	if (xm_tcp == NULL) {
+		printk(KERN_WARNING PFX "Error: Could not find or load "
+		       "\"tcp\" match\n");
+		return -EINVAL;
+	}
+
+	xt_reject = xt_request_find_target(NFPROTO_IPV4, "REJECT", 0);
+	if (xt_reject == NULL) {
+		printk(KERN_WARNING PFX "Error: Could not find or load "
+		       "\"REJECT\" target\n");
+		goto out2;
+	}
+
+	xt_tarpit   = xt_request_find_target(NFPROTO_IPV4, "TARPIT", 0);
+	have_tarpit = xt_tarpit != NULL;
+	if (!have_tarpit)
+		printk(KERN_WARNING PFX "Warning: Could not find or load "
+		       "\"TARPIT\" target\n");
+
+	xt_delude   = xt_request_find_target(NFPROTO_IPV4, "DELUDE", 0);
+	have_delude = xt_delude != NULL;
+	if (!have_delude)
+		printk(KERN_WARNING PFX "Warning: Could not find or load "
+		       "\"DELUDE\" target\n");
+
+	if ((ret = xt_register_target(&chaos_tg_reg)) != 0) {
+		printk(KERN_WARNING PFX "xt_register_target returned "
+		       "error %d\n", ret);
+		goto out3;
+	}
+
+	return 0;
+
+ out3:
+ 	if (have_delude)
+ 		module_put(xt_delude->me);
+	if (have_tarpit)
+		module_put(xt_tarpit->me);
+	module_put(xt_reject->me);
+ out2:
+	module_put(xm_tcp->me);
+	return ret;
+}
+
+static void __exit chaos_tg_exit(void)
+{
+	xt_unregister_target(&chaos_tg_reg);
+	module_put(xm_tcp->me);
+	module_put(xt_reject->me);
+	if (have_delude)
+		module_put(xt_delude->me);
+	if (have_tarpit)
+		module_put(xt_tarpit->me);
+}
+
+module_init(chaos_tg_init);
+module_exit(chaos_tg_exit);
+MODULE_DESCRIPTION("Xtables: Network scan slowdown with non-deterministic results");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_CHAOS");

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_CHAOS.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_CHAOS.h
@@ -0,0 +1,14 @@
+#ifndef _LINUX_NETFILTER_XT_CHAOS_H
+#define _LINUX_NETFILTER_XT_CHAOS_H 1
+
+enum xt_chaos_target_variant {
+	XTCHAOS_NORMAL,
+	XTCHAOS_TARPIT,
+	XTCHAOS_DELUDE,
+};
+
+struct xt_chaos_tginfo {
+	uint8_t variant;
+};
+
+#endif /* _LINUX_NETFILTER_XT_CHAOS_H */

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_DELUDE.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_DELUDE.c
@@ -0,0 +1,182 @@
+/*
+ *	"DELUDE" target extension for Xtables
+ *	Copyright © Jan Engelhardt <jengelh [at] medozas de>, 2007 - 2008
+ *
+ *	Based upon linux-2.6.18.5/net/ipv4/netfilter/ipt_REJECT.c:
+ *	(C) 1999-2001 Paul `Rusty' Russell
+ *	(C) 2002-2004 Netfilter Core Team <coreteam@netfilter.org>
+ *
+ *	xt_DELUDE acts like REJECT, but does reply with SYN-ACK on SYN.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License version 2 as
+ *	published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/version.h>
+#include <linux/netfilter/x_tables.h>
+#ifdef CONFIG_BRIDGE_NETFILTER
+#	include <linux/netfilter_bridge.h>
+#endif
+#include <net/tcp.h>
+#include "compat_xtables.h"
+#define PFX KBUILD_MODNAME ": "
+
+static void delude_send_reset(struct sk_buff *oldskb, unsigned int hook)
+{
+	struct tcphdr _otcph, *tcph;
+	const struct tcphdr *oth;
+	const struct iphdr *oiph;
+	unsigned int addr_type;
+	struct sk_buff *nskb;
+	struct iphdr *niph;
+
+	oiph = ip_hdr(oldskb);
+
+	/* IP header checks: fragment. */
+	if (oiph->frag_off & htons(IP_OFFSET))
+		return;
+
+	oth = skb_header_pointer(oldskb, ip_hdrlen(oldskb),
+				 sizeof(_otcph), &_otcph);
+	if (oth == NULL)
+		return;
+
+	/* No RST for RST. */
+	if (oth->rst)
+		return;
+
+	/* Check checksum */
+	if (nf_ip_checksum(oldskb, hook, ip_hdrlen(oldskb), IPPROTO_TCP))
+		return;
+
+	nskb = alloc_skb(sizeof(struct iphdr) + sizeof(struct tcphdr) +
+	                 LL_MAX_HEADER, GFP_ATOMIC);
+	if (nskb == NULL)
+		return;
+
+	skb_reserve(nskb, LL_MAX_HEADER);
+	skb_reset_network_header(nskb);
+	niph = (struct iphdr *)skb_put(nskb, sizeof(struct iphdr));
+	niph->version  = 4;
+	niph->ihl      = sizeof(struct iphdr) / 4;
+	niph->tos      = 0;
+	niph->id       = 0;
+	niph->frag_off = htons(IP_DF);
+	niph->protocol = IPPROTO_TCP;
+	niph->check    = 0;
+	niph->saddr    = oiph->daddr;
+	niph->daddr    = oiph->saddr;
+
+	tcph = (struct tcphdr *)skb_put(nskb, sizeof(struct tcphdr));
+	memset(tcph, 0, sizeof(*tcph));
+	tcph->source = oth->dest;
+	tcph->dest   = oth->source;
+	tcph->doff   = sizeof(struct tcphdr) / 4;
+
+	/* DELUDE essential part */
+	if (oth->syn && !oth->ack && !oth->rst && !oth->fin) {
+		tcph->syn     = true;
+		tcph->seq     = 0;
+		tcph->ack     = true;
+		tcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn + oth->fin +
+		                oldskb->len - ip_hdrlen(oldskb) -
+		                (oth->doff << 2));
+	} else {
+		tcph->rst = true;
+		if (!oth->ack) {
+			tcph->seq     = 0;
+			tcph->ack     = true;
+			tcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn +
+			                oth->fin + oldskb->len -
+			                ip_hdrlen(oldskb) - (oth->doff << 2));
+		} else {
+			tcph->seq     = oth->ack_seq;
+			tcph->ack     = false;
+			tcph->ack_seq = 0;
+		}
+	}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
+	tcph->check = tcp_v4_check(tcph, sizeof(struct tcphdr), niph->saddr,
+	              niph->daddr, csum_partial((char *)tcph,
+	              sizeof(struct tcphdr), 0));
+#else
+	tcph->check = tcp_v4_check(sizeof(struct tcphdr), niph->saddr,
+	              niph->daddr, csum_partial((char *)tcph,
+	              sizeof(struct tcphdr), 0));
+#endif
+
+	addr_type = RTN_UNSPEC;
+#ifdef CONFIG_BRIDGE_NETFILTER
+	if (hook != NF_INET_FORWARD || (nskb->nf_bridge != NULL &&
+	    nskb->nf_bridge->mask & BRNF_BRIDGED))
+#else
+	if (hook != NF_INET_FORWARD)
+#endif
+		addr_type = RTN_LOCAL;
+
+	/* ip_route_me_harder expects skb->dst to be set */
+	skb_dst_set(nskb, dst_clone(skb_dst(oldskb)));
+
+	if (ip_route_me_harder(&nskb, addr_type))
+		goto free_nskb;
+	else
+		niph = ip_hdr(nskb);
+
+	niph->ttl       = dst_metric(skb_dst(nskb), RTAX_HOPLIMIT);
+	nskb->ip_summed = CHECKSUM_NONE;
+
+	/* "Never happens" */
+	if (nskb->len > dst_mtu(skb_dst(nskb)))
+		goto free_nskb;
+
+	nf_ct_attach(nskb, oldskb);
+
+	ip_local_out(nskb);
+	return;
+
+ free_nskb:
+	kfree_skb(nskb);
+}
+
+static unsigned int
+delude_tg(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	/* WARNING: This code causes reentry within iptables.
+	   This means that the iptables jump stack is now crap.  We
+	   must return an absolute verdict. --RR */
+	delude_send_reset(*pskb, par->hooknum);
+	return NF_DROP;
+}
+
+static struct xt_target delude_tg_reg __read_mostly = {
+	.name     = "DELUDE",
+	.revision = 0,
+	.family   = NFPROTO_IPV4,
+	.table    = "filter",
+	.hooks    = (1 << NF_INET_LOCAL_IN) | (1 << NF_INET_FORWARD),
+	.proto    = IPPROTO_TCP,
+	.target   = delude_tg,
+	.me       = THIS_MODULE,
+};
+
+static int __init delude_tg_init(void)
+{
+	return xt_register_target(&delude_tg_reg);
+}
+
+static void __exit delude_tg_exit(void)
+{
+	xt_unregister_target(&delude_tg_reg);
+}
+
+module_init(delude_tg_init);
+module_exit(delude_tg_exit);
+MODULE_DESCRIPTION("Xtables: Close TCP connections after handshake");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_DELUDE");

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_fuzzy.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_fuzzy.c
@@ -0,0 +1,174 @@
+/*
+ *	This module implements a simple TSK FLC (Takagi-Sugeno-Kang Fuzzy Logic
+ *	Controller) that aims to limit, in an adaptive and flexible way, the
+ *	packet rate crossing a given stream. It serves as an initial and very
+ *	simple (but effective) example of how Fuzzy Logic techniques can be
+ *	applied to defeat DoS attacks.
+ *
+ *	As a matter of fact, Fuzzy Logic can help us to insert any "behavior"
+ *	into our code in a precise, adaptive and efficient manner.
+ *
+ *	The goal is very similar to that of "limit" match, but using techniques
+ *	of Fuzzy Control, that allow us to shape the transfer functions
+ *	precisely, avoiding over and undershoots - and stuff like that.
+ *
+ * 2002-08-10  Hime Aguiar e Oliveira Jr. <hime@engineer.com> : Initial version.
+ * 2002-08-17  : Changed to eliminate floating point operations .
+ * 2002-08-23  : Coding style changes .
+ * 2003-04-08  Maciej Soltysiak <solt@dns.toxicilms.tv> : IPv6 Port
+ */
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/random.h>
+#include <net/tcp.h>
+#include <linux/netfilter/x_tables.h>
+#include "xt_fuzzy.h"
+#include "compat_xtables.h"
+
+/*
+ * Packet Acceptance Rate - LOW and Packet Acceptance Rate - HIGH
+ * Expressed in percentage.
+ */
+
+#define PAR_LOW		1/100
+#define PAR_HIGH	1
+
+MODULE_AUTHOR("Hime Aguiar e Oliveira Junior <hime@engineer.com>");
+MODULE_DESCRIPTION("Xtables: Fuzzy Logic Controller match");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_fuzzy");
+MODULE_ALIAS("ip6t_fuzzy");
+
+static uint8_t mf_high(uint32_t tx, uint32_t mini, uint32_t maxi)
+{
+	if (tx >= maxi)
+		return 100;
+	if (tx <= mini)
+		return 0;
+	return 100 * (tx - mini) / (maxi - mini);
+}
+
+static uint8_t mf_low(uint32_t tx, uint32_t mini, uint32_t maxi)
+{
+	if (tx <= mini)
+		return 100;
+	if (tx >= maxi)
+		return 0;
+	return 100 * (maxi - tx) / (maxi - mini);
+
+}
+
+static bool
+fuzzy_mt(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	struct xt_fuzzy_mtinfo *info = (void *)par->matchinfo;
+	unsigned long amount;
+	uint8_t howhigh, howlow, random_number;
+
+	info->bytes_total += skb->len;
+	++info->packets_total;
+	info->present_time = jiffies;
+
+	if (info->present_time >= info->previous_time) {
+		amount = info->present_time - info->previous_time;
+	} else {
+		/*
+		 * There was a transition: I choose to re-sample
+		 * and keep the old acceptance rate...
+	         */
+		amount = 0;
+		info->previous_time = info->present_time;
+		info->bytes_total = info->packets_total = 0;
+	}
+
+	if (amount > HZ / 10) {
+		/* More than 100 ms elapsed ... */
+
+		info->mean_rate     = HZ * info->packets_total / amount;
+		info->previous_time = info->present_time;
+		info->bytes_total   = info->packets_total = 0;
+
+		howhigh = mf_high(info->mean_rate, info->minimum_rate,
+		          info->maximum_rate);
+		howlow  = mf_low(info->mean_rate, info->minimum_rate,
+		          info->maximum_rate);
+
+		info->acceptance_rate = howhigh * PAR_LOW + PAR_HIGH * howlow;
+
+		/*
+		 * In fact, the above defuzzification would require a
+		 * denominator proportional to (howhigh+howlow) but, in this
+		 * particular case, that expression is constant.
+		 *
+		 * An imediate consequence is that it is not necessary to call
+		 * both mf_high and mf_low - but to keep things understandable,
+		 * I did so.
+		 */
+	}
+
+	if (info->acceptance_rate < 100) {
+		get_random_bytes(&random_number, sizeof(random_number));
+
+		if (random_number <= 255 * info->acceptance_rate / 100)
+			/*
+			 * If within the acceptance, it can pass
+			 * => do not match.
+			 */
+			return false;
+		else
+			/* It cannot pass (it matches) */
+			return true;
+	};
+
+	/* acceptance_rate == 100 % => Everything passes ... */
+	return false;
+}
+
+static int fuzzy_mt_check(const struct xt_mtchk_param *par)
+{
+	const struct xt_fuzzy_mtinfo *info = par->matchinfo;
+
+	if (info->minimum_rate < FUZZY_MIN_RATE ||
+	    info->maximum_rate > FUZZY_MAX_RATE ||
+	    info->minimum_rate >= info->maximum_rate) {
+		printk(KERN_INFO KBUILD_MODNAME ": bad values, please check.\n");
+		return -EDOM;
+	}
+
+	return 0;
+}
+
+static struct xt_match fuzzy_mt_reg[] __read_mostly = {
+	{
+		.name       = "fuzzy",
+		.revision   = 1,
+		.family     = NFPROTO_IPV4,
+		.match      = fuzzy_mt,
+		.checkentry = fuzzy_mt_check,
+		.matchsize  = sizeof(struct xt_fuzzy_mtinfo),
+		.me         = THIS_MODULE,
+	},
+	{
+		.name       = "fuzzy",
+		.revision   = 1,
+		.family     = NFPROTO_IPV6,
+		.match      = fuzzy_mt,
+		.checkentry = fuzzy_mt_check,
+		.matchsize  = sizeof(struct xt_fuzzy_mtinfo),
+		.me         = THIS_MODULE,
+	},
+};
+
+static int __init fuzzy_mt_init(void)
+{
+	return xt_register_matches(fuzzy_mt_reg, ARRAY_SIZE(fuzzy_mt_reg));
+}
+
+static void __exit fuzzy_mt_exit(void)
+{
+	xt_unregister_matches(fuzzy_mt_reg, ARRAY_SIZE(fuzzy_mt_reg));
+}
+
+module_init(fuzzy_mt_init);
+module_exit(fuzzy_mt_exit);

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_fuzzy.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_fuzzy.h
@@ -0,0 +1,20 @@
+#ifndef _LINUX_NETFILTER_XT_FUZZY_H
+#define _LINUX_NETFILTER_XT_FUZZY_H 1
+
+enum {
+	FUZZY_MIN_RATE = 3,
+	FUZZY_MAX_RATE = 10000000,
+};
+
+struct xt_fuzzy_mtinfo {
+	uint32_t minimum_rate;
+	uint32_t maximum_rate;
+	uint32_t packets_total;
+	uint32_t bytes_total;
+	uint32_t previous_time;
+	uint32_t present_time;
+	uint32_t mean_rate;
+	uint8_t acceptance_rate;
+};
+
+#endif /* _LINUX_NETFILTER_XT_FUZZY_H */

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_iface.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_iface.c
@@ -0,0 +1,118 @@
+/*
+ *	xt_iface - kernel module to match interface state flags
+ *
+ *	Original author: Gáspár Lajos <gaspar.lajos@glsys.eu>
+ */
+
+#include <linux/if.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <linux/netfilter/x_tables.h>
+#include "xt_iface.h"
+#include "compat_xtables.h"
+
+struct xt_iface_flag_pairs {
+	uint16_t iface_flag;
+	uint32_t iff_flag;
+};
+
+MODULE_AUTHOR("Gáspár Lajos <gaspar.lajos@glsys.eu>");
+MODULE_DESCRIPTION("Xtables: iface match module");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_iface");
+MODULE_ALIAS("ip6t_iface");
+//MODULE_ALIAS("arpt_iface");
+
+static const struct xt_iface_flag_pairs xt_iface_lookup[] =
+{
+	{.iface_flag = XT_IFACE_UP,		.iff_flag = IFF_UP},
+	{.iface_flag = XT_IFACE_BROADCAST,	.iff_flag = IFF_BROADCAST},
+	{.iface_flag = XT_IFACE_LOOPBACK,	.iff_flag = IFF_LOOPBACK},
+	{.iface_flag = XT_IFACE_POINTOPOINT,	.iff_flag = IFF_POINTOPOINT},
+	{.iface_flag = XT_IFACE_RUNNING,	.iff_flag = IFF_RUNNING},
+	{.iface_flag = XT_IFACE_NOARP,		.iff_flag = IFF_NOARP},
+	{.iface_flag = XT_IFACE_PROMISC,	.iff_flag = IFF_PROMISC},
+	{.iface_flag = XT_IFACE_MULTICAST,	.iff_flag = IFF_MULTICAST},
+	{.iface_flag = XT_IFACE_DYNAMIC,	.iff_flag = IFF_DYNAMIC},
+	{.iface_flag = XT_IFACE_LOWER_UP,	.iff_flag = IFF_LOWER_UP},
+	{.iface_flag = XT_IFACE_DORMANT,	.iff_flag = IFF_DORMANT},
+};
+
+static const struct net_device *iface_get(const struct xt_iface_mtinfo *info,
+    const struct xt_action_param *par, struct net_device **put)
+{
+	if (info->flags & XT_IFACE_DEV_IN)
+		return par->in;
+	else if (info->flags & XT_IFACE_DEV_OUT)
+		return par->out;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+	return *put = dev_get_by_name(&init_net, info->ifname);
+#else
+	return *put = dev_get_by_name(info->ifname);
+#endif
+}
+
+static bool iface_flagtest(unsigned int devflags, unsigned int flags,
+    unsigned int invflags)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(xt_iface_lookup); ++i)
+		if ((flags & xt_iface_lookup[i].iface_flag) &&
+		    !!(devflags & xt_iface_lookup[i].iff_flag) ^
+		    !(invflags & xt_iface_lookup[i].iface_flag))
+			return false;
+	return true;
+}
+
+static bool xt_iface_mt(const struct sk_buff *skb,
+    struct xt_action_param *par)
+{
+	const struct xt_iface_mtinfo *info = par->matchinfo;
+	struct net_device *put = NULL;
+	const struct net_device *dev = iface_get(info, par, &put);
+	bool retval;
+
+	if (dev == NULL)
+		return false;
+	retval = iface_flagtest(dev->flags, info->flags, info->invflags);
+	if (put != NULL)
+		dev_put(put);
+	return retval;
+}
+
+static struct xt_match xt_iface_mt_reg[] __read_mostly = {
+	{
+		.name       = "iface",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.matchsize  = sizeof(struct xt_iface_mtinfo),
+		.match      = xt_iface_mt,
+		.me         = THIS_MODULE,
+	},
+	{
+		.name       = "iface",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.matchsize  = sizeof(struct xt_iface_mtinfo),
+		.match      = xt_iface_mt,
+		.me         = THIS_MODULE,
+	},
+};
+
+static int __init xt_iface_match_init(void)
+{
+	return xt_register_matches(xt_iface_mt_reg,
+		ARRAY_SIZE(xt_iface_mt_reg));
+}
+
+static void __exit xt_iface_match_exit(void)
+{
+	xt_unregister_matches(xt_iface_mt_reg, ARRAY_SIZE(xt_iface_mt_reg));
+}
+
+module_init(xt_iface_match_init);
+module_exit(xt_iface_match_exit);

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_iface.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_iface.h
@@ -0,0 +1,26 @@
+#ifndef _LINUX_NETFILTER_XT_IFACE_H
+#define _LINUX_NETFILTER_XT_IFACE_H 1
+
+enum {
+	XT_IFACE_UP          = 1 << 0,
+	XT_IFACE_BROADCAST   = 1 << 1,
+	XT_IFACE_LOOPBACK    = 1 << 2,
+	XT_IFACE_POINTOPOINT = 1 << 3,
+	XT_IFACE_RUNNING     = 1 << 4,
+	XT_IFACE_NOARP       = 1 << 5,
+	XT_IFACE_PROMISC     = 1 << 6,
+	XT_IFACE_MULTICAST   = 1 << 7,
+	XT_IFACE_DYNAMIC     = 1 << 8,
+	XT_IFACE_LOWER_UP    = 1 << 9,
+	XT_IFACE_DORMANT     = 1 << 10,
+	XT_IFACE_DEV_IN      = 1 << 11,
+	XT_IFACE_DEV_OUT     = 1 << 12,
+};
+
+struct xt_iface_mtinfo {
+	char ifname[IFNAMSIZ];
+	__u16 flags;
+	__u16 invflags;
+};
+
+#endif

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_ipv4options.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_ipv4options.c
@@ -0,0 +1,83 @@
+/*
+ *	xt_ipv4opts - Xtables module to match IPv4 options
+ *	Copyright © Jan Engelhardt, 2009
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <linux/ip.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/netfilter/x_tables.h>
+#include <net/ip.h>
+#include "xt_ipv4options.h"
+#include "compat_xtables.h"
+
+static uint32_t ipv4options_rd(const uint8_t *data, int len)
+{
+	uint32_t opts = 0;
+
+	while (len >= 2) {
+		switch (data[0]) {
+		case IPOPT_END:
+			return opts;
+		case IPOPT_NOOP:
+			--len;
+			++data;
+			continue;
+		}
+
+		if (data[1] < 2 || data[1] > len)
+			return opts;
+		opts |= 1 << (data[0] & 0x1F);
+		len  -= data[1];
+		data += data[1];
+	}
+
+	return opts;
+}
+
+static bool ipv4options_mt(const struct sk_buff *skb,
+    struct xt_action_param *par)
+{
+	const struct xt_ipv4options_mtinfo1 *info = par->matchinfo;
+	const struct iphdr *iph = ip_hdr(skb);
+	uint32_t opts = 0;
+	uint16_t len  = ip_hdrlen(skb) - sizeof(struct iphdr);
+
+	if (len > 0)
+		opts = ipv4options_rd((const void *)iph +
+		       sizeof(struct iphdr), len);
+
+	opts ^= info->invert;
+	opts &= info->map;
+	return (info->flags & XT_V4OPTS_ANY) ? opts : opts == info->map;
+}
+
+static struct xt_match ipv4options_mt_reg __read_mostly = {
+	.name      = "ipv4options",
+	.revision  = 1,
+	.family    = NFPROTO_IPV4,
+	.match     = ipv4options_mt,
+	.matchsize = sizeof(struct xt_ipv4options_mtinfo1),
+	.me        = THIS_MODULE,
+};
+
+static int __init ipv4options_mt_init(void)
+{
+	return xt_register_match(&ipv4options_mt_reg);
+}
+
+static void __exit ipv4options_mt_exit(void)
+{
+	xt_unregister_match(&ipv4options_mt_reg);
+}
+
+MODULE_DESCRIPTION("Xatblse: IPv4 option match");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_ipv4options");
+module_init(ipv4options_mt_init);
+module_exit(ipv4options_mt_exit);

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_ipv4options.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_ipv4options.h
@@ -0,0 +1,26 @@
+#ifndef _LINUX_NETFILTER_XT_IPV4OPTIONS_H
+#define _LINUX_NETFILTER_XT_IPV4OPTIONS_H 1
+
+/* IPv4 allows for a 5-bit option number - 32 options */
+
+/**
+ * %XT_V4OPTS_ALL:	all options in @map must be present (respecting @invert)
+ * %XT_V4OPTS_ANY:	any of the option in @map
+ */
+enum xt_ipv4options_flags {
+	XT_V4OPTS_ALL = 1 << 0,
+	XT_V4OPTS_ANY = 1 << 1,
+};
+
+/**
+ * @map:	bitmask of options that should appear
+ * @invert:	inversion map
+ * @flags:	see above
+ */
+struct xt_ipv4options_mtinfo1 {
+	__u32 map;
+	__u32 invert;
+	__u8 flags;
+};
+
+#endif /* _LINUX_NETFILTER_XT_IPV4OPTIONS_H */

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_lscan.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_lscan.c
@@ -0,0 +1,271 @@
+/*
+ *	LSCAN match for Xtables
+ *	Copyright © Jan Engelhardt, 2006 - 2009
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License; either version
+ *	2 or 3 as published by the Free Software Foundation.
+ */
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_tcpudp.h>
+#include "xt_lscan.h"
+#include "compat_xtables.h"
+#define PFX KBUILD_MODNAME ": "
+
+enum {
+	TCP_FLAGS_ALL3 = TCP_FLAG_FIN | TCP_FLAG_RST | TCP_FLAG_SYN,
+	TCP_FLAGS_ALL4 = TCP_FLAGS_ALL3 | TCP_FLAG_ACK,
+	TCP_FLAGS_ALL6 = TCP_FLAGS_ALL4 | TCP_FLAG_PSH | TCP_FLAG_URG,
+};
+
+/* Module parameters */
+static unsigned int
+	connmark_mask = ~0,
+	packet_mask   = ~0,
+	mark_seen     = 0x9,
+	mark_synrcv   = 0x1,
+	mark_closed   = 0x2,
+	mark_synscan  = 0x3,
+	mark_estab1   = 0x4,
+	mark_estab2   = 0x5,
+	mark_cnscan   = 0x6,
+	mark_grscan   = 0x7,
+	mark_valid    = 0x8;
+
+module_param(connmark_mask, uint, S_IRUGO | S_IWUSR);
+module_param(packet_mask,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_seen,     uint, S_IRUGO | S_IWUSR);
+module_param(mark_synrcv,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_closed,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_synscan,  uint, S_IRUGO | S_IWUSR);
+module_param(mark_estab1,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_estab2,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_cnscan,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_grscan,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_valid,    uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(connmark_mask, "only set specified bits in connection mark");
+MODULE_PARM_DESC(packet_mask,   "only set specified bits in packet mark");
+MODULE_PARM_DESC(mark_seen,     "nfmark value for packet-seen state");
+MODULE_PARM_DESC(mark_synrcv,   "connmark value for SYN Received state");
+MODULE_PARM_DESC(mark_closed,   "connmark value for closed state");
+MODULE_PARM_DESC(mark_synscan,  "connmark value for SYN Scan state");
+MODULE_PARM_DESC(mark_estab1,   "connmark value for Established-1 state");
+MODULE_PARM_DESC(mark_estab2,   "connmark value for Established-2 state");
+MODULE_PARM_DESC(mark_cnscan,   "connmark value for Connect Scan state");
+MODULE_PARM_DESC(mark_grscan,   "connmark value for Grab Scan state");
+MODULE_PARM_DESC(mark_valid,    "connmark value for Valid state");
+
+/* TCP flag functions */
+static inline bool tflg_ack4(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL4) == TCP_FLAG_ACK;
+}
+
+static inline bool tflg_ack6(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL6) == TCP_FLAG_ACK;
+}
+
+static inline bool tflg_fin(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL3) == TCP_FLAG_FIN;
+}
+
+static inline bool tflg_rst(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL3) == TCP_FLAG_RST;
+}
+
+static inline bool tflg_rstack(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL4) ==
+	       (TCP_FLAG_ACK | TCP_FLAG_RST);
+}
+
+static inline bool tflg_syn(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL4) == TCP_FLAG_SYN;
+}
+
+static inline bool tflg_synack(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL4) ==
+	       (TCP_FLAG_SYN | TCP_FLAG_ACK);
+}
+
+/* lscan functions */
+static inline bool lscan_mt_stealth(const struct tcphdr *th)
+{
+	/*
+	 * "Connection refused" replies to our own probes must not be matched.
+	 */
+	if (tflg_rstack(th))
+		return false;
+
+	if (tflg_rst(th) && printk_ratelimit()) {
+		printk(KERN_WARNING PFX "Warning: Pure RST received\n");
+		return false;
+	}
+
+	/*
+	 * -p tcp ! --syn -m conntrack --ctstate INVALID: Looking for non-start
+	 * packets that are not associated with any connection -- this will
+	 * match most scan types (NULL, XMAS, FIN) and ridiculous flag
+	 * combinations (SYN-RST, SYN-FIN, SYN-FIN-RST, FIN-RST, etc.).
+	 */
+	return !tflg_syn(th);
+}
+
+static inline unsigned int lscan_mt_full(int mark,
+    enum ip_conntrack_info ctstate, bool loopback, const struct tcphdr *tcph,
+    unsigned int payload_len)
+{
+	if (mark == mark_estab2) {
+		/*
+		 * -m connmark --mark $ESTAB2
+		 */
+		if (tflg_ack4(tcph) && payload_len == 0)
+			return mark; /* keep mark */
+		else if (tflg_rst(tcph) || tflg_fin(tcph))
+			return mark_grscan;
+		else
+			return mark_valid;
+	} else if (mark == mark_estab1) {
+		/*
+		 * -m connmark --mark $ESTAB1
+		 */
+		if (tflg_rst(tcph) || tflg_fin(tcph))
+			return mark_cnscan;
+		else if (!loopback && tflg_ack4(tcph) && payload_len == 0)
+			return mark_estab2;
+		else
+			return mark_valid;
+	} else if (mark == mark_synrcv) {
+		/*
+		 * -m connmark --mark $SYN
+		 */
+		if (loopback && tflg_synack(tcph))
+			return mark; /* keep mark */
+		else if (loopback && tflg_rstack(tcph))
+			return mark_closed;
+		else if (tflg_ack6(tcph))
+			return mark_estab1;
+		else
+			return mark_synscan;
+	} else if (ctstate == IP_CT_NEW && tflg_syn(tcph)) {
+		/*
+		 * -p tcp --syn --ctstate NEW
+		 */
+		return mark_synrcv;
+	}
+	return mark;
+}
+
+static bool
+lscan_mt(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	const struct xt_lscan_mtinfo *info = par->matchinfo;
+	enum ip_conntrack_info ctstate;
+	const struct tcphdr *tcph;
+	struct nf_conn *ctdata;
+	struct tcphdr tcph_buf;
+
+	tcph = skb_header_pointer(skb, par->thoff, sizeof(tcph_buf), &tcph_buf);
+	if (tcph == NULL)
+		return false;
+
+	/* Check for invalid packets: -m conntrack --ctstate INVALID */
+	if ((ctdata = nf_ct_get(skb, &ctstate)) == NULL) {
+		if (info->match_stealth)
+			return lscan_mt_stealth(tcph);
+		/*
+		 * If @ctdata is NULL, we cannot match the other scan
+		 * types, return.
+		 */
+		return false;
+	}
+
+	/*
+	 * If -m lscan was previously applied to this packet, the rules we
+	 * simulate must not be run through again. And for speedup, do not call
+	 * it either when the connection is already VALID.
+	 */
+	if ((ctdata->mark & connmark_mask) == mark_valid ||
+	     (skb_nfmark(skb) & packet_mask) != mark_seen) {
+		unsigned int n;
+
+		n = lscan_mt_full(ctdata->mark & connmark_mask, ctstate,
+		    par->in == init_net__loopback_dev, tcph,
+		    skb->len - par->thoff - 4 * tcph->doff);
+
+		ctdata->mark = (ctdata->mark & ~connmark_mask) | n;
+		skb_nfmark(skb) = (skb_nfmark(skb) & ~packet_mask) ^ mark_seen;
+	}
+
+	return (info->match_syn && ctdata->mark == mark_synscan) ||
+	       (info->match_cn && ctdata->mark == mark_cnscan) ||
+	       (info->match_gr && ctdata->mark == mark_grscan);
+}
+
+static int lscan_mt_check(const struct xt_mtchk_param *par)
+{
+	const struct xt_lscan_mtinfo *info = par->matchinfo;
+
+	if ((info->match_stealth & ~1) || (info->match_syn & ~1) ||
+	    (info->match_cn & ~1) || (info->match_gr & ~1)) {
+		printk(KERN_WARNING PFX "Invalid flags\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct xt_match lscan_mt_reg[] __read_mostly = {
+	{
+		.name       = "lscan",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.match      = lscan_mt,
+		.checkentry = lscan_mt_check,
+		.matchsize  = sizeof(struct xt_lscan_mtinfo),
+		.proto      = IPPROTO_TCP,
+		.me         = THIS_MODULE,
+	},
+	{
+		.name       = "lscan",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.match      = lscan_mt,
+		.checkentry = lscan_mt_check,
+		.matchsize  = sizeof(struct xt_lscan_mtinfo),
+		.proto      = IPPROTO_TCP,
+		.me         = THIS_MODULE,
+	},
+};
+
+static int __init lscan_mt_init(void)
+{
+	return xt_register_matches(lscan_mt_reg,
+	       ARRAY_SIZE(lscan_mt_reg));
+}
+
+static void __exit lscan_mt_exit(void)
+{
+	xt_unregister_matches(lscan_mt_reg, ARRAY_SIZE(lscan_mt_reg));
+}
+
+module_init(lscan_mt_init);
+module_exit(lscan_mt_exit);
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_DESCRIPTION("Xtables: Low-level scan (e.g. nmap) match");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_lscan");
+MODULE_ALIAS("ip6t_lscan");

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_lscan.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_lscan.h
@@ -0,0 +1,8 @@
+#ifndef _LINUX_NETFILTER_XT_LSCAN_H
+#define _LINUX_NETFILTER_XT_LSCAN_H 1
+
+struct xt_lscan_mtinfo {
+	uint8_t match_stealth, match_syn, match_cn, match_gr;
+};
+
+#endif /* _LINUX_NETFILTER_XT_LSCAN_H */

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_pknock.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_pknock.c
@@ -0,0 +1,1199 @@
+/*
+ * Kernel module to implement Port Knocking and SPA matching support.
+ *
+ * (C) 2006-2009 J. Federico Hernandez Scarso <fede.hernandez@gmail.com>
+ * (C) 2006 Luis A. Floreani <luis.floreani@gmail.com>
+ *
+ * This program is released under the terms of GNU GPL version 2.
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/in.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/jhash.h>
+#include <linux/random.h>
+#include <linux/crypto.h>
+#include <linux/proc_fs.h>
+#include <linux/scatterlist.h>
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+#include <linux/timer.h>
+#include <linux/seq_file.h>
+#include <linux/connector.h>
+
+#include <linux/netfilter/x_tables.h>
+#include "xt_pknock.h"
+#include "compat_xtables.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+#	define PK_CRYPTO 1
+#endif
+
+enum status {
+	ST_INIT = 1,
+	ST_MATCHING,
+	ST_ALLOWED,
+};
+
+/**
+ * @timestamp:	seconds, but not since epoch (uses jiffies/HZ)
+ * @login_sec: seconds at login since the epoch
+ */
+struct peer {
+	struct list_head head;
+	__be32 ip;
+	uint32_t accepted_knock_count;
+	unsigned long timestamp;
+	unsigned long login_sec;
+	enum status status;
+	uint8_t proto;
+};
+
+/**
+ * @timer:	garbage collector timer
+ * @max_time:	max matching time between ports
+ */
+struct xt_pknock_rule {
+	struct list_head head;
+	char rule_name[XT_PKNOCK_MAX_BUF_LEN+1];
+	int rule_name_len;
+	unsigned int ref_count;
+	struct timer_list timer;
+	struct list_head *peer_head;
+	struct proc_dir_entry *status_proc;
+	unsigned long max_time;
+	unsigned long autoclose_time;
+};
+
+/**
+ * @port:	destination port
+ */
+struct transport_data {
+	uint8_t proto;
+	uint16_t port;
+	int payload_len;
+	const unsigned char *payload;
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("J. Federico Hernandez Scarso, Luis A. Floreani");
+MODULE_DESCRIPTION("netfilter match for Port Knocking and SPA");
+MODULE_ALIAS("ipt_pknock");
+
+enum {
+	DEFAULT_GC_EXPIRATION_TIME = 65000, /* in msecs */
+	DEFAULT_RULE_HASH_SIZE  = 8,
+	DEFAULT_PEER_HASH_SIZE  = 16,
+};
+
+#define hashtable_for_each_safe(pos, n, head, size, i)	\
+	for ((i) = 0; (i) < (size); ++(i)) \
+		list_for_each_safe((pos), (n), (&head[(i)]))
+
+#define pk_debug(msg, peer) pr_debug( \
+			"(S) peer: " NIPQUAD_FMT " - %s.\n", \
+			NIPQUAD((peer)->ip), msg)
+
+static uint32_t ipt_pknock_hash_rnd;
+
+static unsigned int rule_hashsize	= DEFAULT_RULE_HASH_SIZE;
+static unsigned int peer_hashsize	= DEFAULT_PEER_HASH_SIZE;
+static unsigned int gc_expir_time = DEFAULT_GC_EXPIRATION_TIME;
+static int nl_multicast_group		= -1;
+
+static struct list_head *rule_hashtable;
+static struct proc_dir_entry *pde;
+
+static DEFINE_SPINLOCK(list_lock);
+
+#ifdef PK_CRYPTO
+static struct {
+	const char *algo;
+	struct crypto_hash	*tfm;
+	unsigned int size;
+	struct hash_desc	desc;
+} crypto = {
+	.algo	= "hmac(sha256)",
+	.tfm	= NULL,
+	.size	= 0
+};
+#endif
+
+module_param(rule_hashsize, int, S_IRUGO);
+MODULE_PARM_DESC(rule_hashsize, "Buckets in rule hash table (default: 8)");
+module_param(peer_hashsize, int, S_IRUGO);
+MODULE_PARM_DESC(peer_hashsize, "Buckets in peer hash table (default: 16)");
+module_param(gc_expir_time, int, S_IRUGO);
+MODULE_PARM_DESC(gc_expir_time, "Time until garbage collection after valid knock packet (default: 65000 msec)");
+module_param(nl_multicast_group, int, S_IRUGO);
+MODULE_PARM_DESC(nl_multicast_group, "Netlink multicast group number for pknock messages");
+
+/**
+ * Calculates a value from 0 to max from a hash of the arguments.
+ *
+ * @key
+ * @len: length
+ * @initval
+ * @max
+ * @return: a 32 bits index
+ */
+static inline uint32_t
+pknock_hash(const void *key, uint32_t len, uint32_t initval, uint32_t max)
+{
+	return jhash(key, len, initval) % max;
+}
+
+/**
+ * Alloc a hashtable with n buckets.
+ *
+ * @size
+ * @return: hashtable
+ */
+static struct list_head *
+alloc_hashtable(unsigned int size)
+{
+	struct list_head *hash;
+	unsigned int i;
+
+	hash = kmalloc(sizeof(*hash) * size, GFP_KERNEL);
+	if (hash == NULL)
+		return NULL;
+	for (i = 0; i < size; ++i)
+		INIT_LIST_HEAD(&hash[i]);
+
+	return hash;
+}
+
+/**
+ * This function converts the status from integer to string.
+ *
+ * @status
+ * @return: status
+ */
+static inline const char *
+status_itoa(enum status status)
+{
+	switch (status) {
+		case ST_INIT: 	  	return "INIT";
+		case ST_MATCHING: 	return "MATCHING";
+		case ST_ALLOWED:  	return "ALLOWED";
+		default: 			return "UNKNOWN";
+	}
+}
+
+/**
+ * @s
+ * @pos
+ * @return: private value used by the iterator
+ */
+static void *
+pknock_seq_start(struct seq_file *s, loff_t *pos)
+{
+	const struct proc_dir_entry *pde = s->private;
+	const struct xt_pknock_rule *rule = pde->data;
+
+	spin_lock_bh(&list_lock);
+
+	if (*pos >= peer_hashsize)
+		return NULL;
+
+	return rule->peer_head + *pos;
+}
+
+/**
+ * @s
+ * @v
+ * @pos
+ * @return: next value for the iterator
+ */
+static void *
+pknock_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	const struct proc_dir_entry *pde = s->private;
+	const struct xt_pknock_rule *rule = pde->data;
+
+	++*pos;
+	if (*pos >= peer_hashsize)
+		return NULL;
+
+	return rule->peer_head + *pos;
+}
+
+/**
+ * @s
+ * @v
+ */
+static void
+pknock_seq_stop(struct seq_file *s, void *v)
+{
+	spin_unlock_bh(&list_lock);
+}
+
+/**
+ * @s
+ * @v
+ * @return: 0 if OK
+ */
+static int
+pknock_seq_show(struct seq_file *s, void *v)
+{
+	const struct list_head *pos, *n;
+	const struct peer *peer;
+	unsigned long time;
+	const struct list_head *peer_head = v;
+
+	const struct proc_dir_entry *pde = s->private;
+	const struct xt_pknock_rule *rule = pde->data;
+
+	list_for_each_safe(pos, n, peer_head) {
+		peer = list_entry(pos, struct peer, head);
+
+		seq_printf(s, "src=" NIPQUAD_FMT " ", NIPQUAD(peer->ip));
+		seq_printf(s, "proto=%s ", (peer->proto == IPPROTO_TCP) ?
+                                                "TCP" : "UDP");
+		seq_printf(s, "status=%s ", status_itoa(peer->status));
+		seq_printf(s, "accepted_knock_count=%lu ",
+			(unsigned long)peer->accepted_knock_count);
+		if (peer->status == ST_MATCHING) {
+			time = 0;
+			if (time_before(jiffies / HZ, peer->timestamp +
+			    rule->max_time))
+				time = peer->timestamp + rule->max_time -
+				       jiffies / HZ;
+			seq_printf(s, "expir_time=%lu [secs] ", time);
+		}
+		if (peer->status == ST_ALLOWED && rule->autoclose_time != 0) {
+			time = 0;
+			if (time_before(get_seconds(), peer->login_sec +
+			    rule->autoclose_time * 60))
+				time = peer->login_sec +
+				       rule->autoclose_time * 60 -
+				       get_seconds();
+			seq_printf(s, "autoclose_time=%lu [secs] ", time);
+		}
+		seq_printf(s, "\n");
+	}
+
+	return 0;
+}
+
+static const struct seq_operations pknock_seq_ops = {
+	.start = pknock_seq_start,
+	.next = pknock_seq_next,
+	.stop = pknock_seq_stop,
+	.show = pknock_seq_show
+};
+
+/**
+ * @inode
+ * @file
+ */
+static int
+pknock_proc_open(struct inode *inode, struct file *file)
+{
+	int ret = seq_open(file, &pknock_seq_ops);
+	if (ret == 0) {
+		struct seq_file *sf = file->private_data;
+		sf->private = PDE(inode);
+	}
+	return ret;
+}
+
+static const struct file_operations pknock_proc_ops = {
+	.owner = THIS_MODULE,
+	.open = pknock_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release
+};
+
+/**
+ * It updates the rule timer to execute garbage collector.
+ *
+ * @rule
+ */
+static void update_rule_gc_timer(struct xt_pknock_rule *rule)
+{
+	if (timer_pending(&rule->timer))
+		del_timer(&rule->timer);
+
+	rule->timer.expires = jiffies + msecs_to_jiffies(gc_expir_time);
+	add_timer(&rule->timer);
+}
+
+/**
+ * @peer
+ * @autoclose_time
+ *
+ * Returns true if autoclose due, or false if still valid.
+ */
+static inline bool
+autoclose_time_passed(const struct peer *peer, unsigned int autoclose_time)
+{
+	return peer != NULL && autoclose_time != 0 && time_after(get_seconds(),
+	       peer->login_sec + autoclose_time * 60);
+}
+
+/**
+ * @peer
+ * @max_time
+ * @return: 1 time exceeded, 0 still valid
+ */
+static inline bool
+is_interknock_time_exceeded(const struct peer *peer, unsigned int max_time)
+{
+	return peer != NULL && time_after(jiffies / HZ,
+	       peer->timestamp + max_time);
+}
+
+/**
+ * @peer
+ * @return: 1 has logged, 0 otherwise
+ */
+static inline bool
+has_logged_during_this_minute(const struct peer *peer)
+{
+	return peer != NULL && peer->login_sec / 60 == get_seconds() / 60;
+}
+
+/**
+ * Garbage collector. It removes the old entries after tis timers have expired.
+ *
+ * @r: rule
+ */
+static void
+peer_gc(unsigned long r)
+{
+	unsigned int i;
+	struct xt_pknock_rule *rule = (struct xt_pknock_rule *)r;
+	struct peer *peer;
+	struct list_head *pos, *n;
+
+	pr_debug("(S) running %s\n", __func__);
+	hashtable_for_each_safe(pos, n, rule->peer_head, peer_hashsize, i) {
+		peer = list_entry(pos, struct peer, head);
+
+		/*
+		 * Remove any peer whose (inter-knock) max_time
+		 * or autoclose_time passed.
+		 */
+		if ((peer->status != ST_ALLOWED &&
+		    is_interknock_time_exceeded(peer, rule->max_time)) ||
+		    (peer->status == ST_ALLOWED &&
+		    autoclose_time_passed(peer, rule->autoclose_time)))
+		{
+			pk_debug("GC-DELETED", peer);
+			list_del(pos);
+			kfree(peer);
+		}
+	}
+}
+
+/**
+ * Compares length and name equality for the rules.
+ */
+static inline bool
+rulecmp(const struct xt_pknock_mtinfo *info, const struct xt_pknock_rule *rule)
+{
+	if (info->rule_name_len != rule->rule_name_len)
+		return false;
+	if (strncmp(info->rule_name, rule->rule_name, info->rule_name_len) != 0)
+		return false;
+	return true;
+}
+
+/**
+ * Search the rule and returns a pointer if it exists.
+ *
+ * @info
+ * @return: rule or NULL
+ */
+static struct xt_pknock_rule *search_rule(const struct xt_pknock_mtinfo *info)
+{
+	struct xt_pknock_rule *rule;
+	struct list_head *pos, *n;
+	unsigned int hash = pknock_hash(info->rule_name, info->rule_name_len,
+					ipt_pknock_hash_rnd, rule_hashsize);
+
+	list_for_each_safe(pos, n, &rule_hashtable[hash]) {
+		rule = list_entry(pos, struct xt_pknock_rule, head);
+		if (rulecmp(info, rule))
+			return rule;
+	}
+	return NULL;
+}
+
+/**
+ * It adds a rule to list only if it doesn't exist.
+ *
+ * @info
+ * @return: 1 success, 0 failure
+ */
+static bool
+add_rule(struct xt_pknock_mtinfo *info)
+{
+	struct xt_pknock_rule *rule;
+	struct list_head *pos, *n;
+	unsigned int hash = pknock_hash(info->rule_name, info->rule_name_len,
+                                ipt_pknock_hash_rnd, rule_hashsize);
+
+	list_for_each_safe(pos, n, &rule_hashtable[hash]) {
+		rule = list_entry(pos, struct xt_pknock_rule, head);
+
+		if (!rulecmp(info, rule))
+			continue;
+		++rule->ref_count;
+
+		if (info->option & XT_PKNOCK_OPENSECRET) {
+			rule->max_time       = info->max_time;
+			rule->autoclose_time = info->autoclose_time;
+		}
+
+		if (info->option & XT_PKNOCK_CHECKIP)
+			pr_debug("add_rule() (AC) rule found: %s - "
+				"ref_count: %d\n",
+				rule->rule_name, rule->ref_count);
+		return true;
+	}
+
+	rule = kmalloc(sizeof(*rule), GFP_KERNEL);
+	if (rule == NULL)
+		return false;
+
+	INIT_LIST_HEAD(&rule->head);
+
+	memset(rule->rule_name, 0, sizeof(rule->rule_name));
+	strncpy(rule->rule_name, info->rule_name, info->rule_name_len);
+	rule->rule_name_len = info->rule_name_len;
+
+	rule->ref_count      = 1;
+	rule->max_time       = info->max_time;
+	rule->autoclose_time = info->autoclose_time;
+	rule->peer_head      = alloc_hashtable(peer_hashsize);
+	if (rule->peer_head == NULL)
+		goto out;
+
+	init_timer(&rule->timer);
+	rule->timer.function	= peer_gc;
+	rule->timer.data	= (unsigned long)rule;
+
+	rule->status_proc = create_proc_entry(info->rule_name, 0, pde);
+	if (rule->status_proc == NULL)
+		goto out;
+
+	rule->status_proc->proc_fops = &pknock_proc_ops;
+	rule->status_proc->data = rule;
+
+	list_add(&rule->head, &rule_hashtable[hash]);
+	pr_debug("(A) rule_name: %s - created.\n", rule->rule_name);
+	return true;
+ out:
+	kfree(rule->peer_head);
+	kfree(rule);
+	return false;
+}
+
+/**
+ * It removes a rule only if it exists.
+ *
+ * @info
+ */
+static void
+remove_rule(struct xt_pknock_mtinfo *info)
+{
+	struct xt_pknock_rule *rule = NULL;
+	struct list_head *pos, *n;
+	struct peer *peer;
+	unsigned int i;
+	int found = 0;
+	unsigned int hash = pknock_hash(info->rule_name, info->rule_name_len,
+                                ipt_pknock_hash_rnd, rule_hashsize);
+
+	if (list_empty(&rule_hashtable[hash]))
+		return;
+
+	list_for_each_safe(pos, n, &rule_hashtable[hash]) {
+		rule = list_entry(pos, struct xt_pknock_rule, head);
+
+		if (rulecmp(info, rule)) {
+			found = 1;
+			rule->ref_count--;
+			break;
+		}
+	}
+	if (!found) {
+		pr_debug("(N) rule not found: %s.\n", info->rule_name);
+		return;
+	}
+	if (rule == NULL || rule->ref_count != 0)
+		return;
+
+	hashtable_for_each_safe(pos, n, rule->peer_head, peer_hashsize, i) {
+		peer = list_entry(pos, struct peer, head);
+		pk_debug("DELETED", peer);
+		list_del(pos);
+		kfree(peer);
+	}
+
+	if (rule->status_proc != NULL)
+		remove_proc_entry(info->rule_name, pde);
+	pr_debug("(D) rule deleted: %s.\n", rule->rule_name);
+	if (timer_pending(&rule->timer))
+		del_timer(&rule->timer);
+
+	list_del(&rule->head);
+	kfree(rule->peer_head);
+	kfree(rule);
+}
+
+/**
+ * If peer status exist in the list it returns peer status, if not it returns NULL.
+ *
+ * @rule
+ * @ip
+ * @return: peer or NULL
+ */
+static struct peer *get_peer(struct xt_pknock_rule *rule, __be32 ip)
+{
+	struct peer *peer;
+	struct list_head *pos, *n;
+	unsigned int hash;
+
+	hash = pknock_hash(&ip, sizeof(ip), ipt_pknock_hash_rnd, peer_hashsize);
+
+	list_for_each_safe(pos, n, &rule->peer_head[hash]) {
+		peer = list_entry(pos, struct peer, head);
+		if (peer->ip == ip)
+			return peer;
+	}
+	return NULL;
+}
+
+/**
+ * Reset the knock sequence status of the peer.
+ *
+ * @peer
+ */
+static void reset_knock_status(struct peer *peer)
+{
+	peer->accepted_knock_count = 0;
+	peer->status = ST_INIT;
+}
+
+/**
+ * It creates a new peer matching status.
+ *
+ * @rule
+ * @ip
+ * @proto
+ * @return: peer or NULL
+ */
+static struct peer *new_peer(__be32 ip, uint8_t proto)
+{
+	struct peer *peer = kmalloc(sizeof(*peer), GFP_ATOMIC);
+
+	if (peer == NULL)
+		return NULL;
+
+	INIT_LIST_HEAD(&peer->head);
+	peer->ip	= ip;
+	peer->proto	= proto;
+	peer->timestamp = jiffies/HZ;
+	peer->login_sec = 0;
+	reset_knock_status(peer);
+
+	return peer;
+}
+
+/**
+ * It adds a new peer matching status to the list.
+ *
+ * @peer
+ * @rule
+ */
+static void add_peer(struct peer *peer, struct xt_pknock_rule *rule)
+{
+	unsigned int hash = pknock_hash(&peer->ip, sizeof(peer->ip),
+                                ipt_pknock_hash_rnd, peer_hashsize);
+	list_add(&peer->head, &rule->peer_head[hash]);
+}
+
+/**
+ * It removes a peer matching status.
+ *
+ * @peer
+ */
+static void remove_peer(struct peer *peer)
+{
+	list_del(&peer->head);
+	if (peer != NULL)
+		kfree(peer);
+}
+
+/**
+ * @peer
+ * @info
+ * @port
+ * @return: 1 success, 0 failure
+ */
+static inline bool
+is_first_knock(const struct peer *peer, const struct xt_pknock_mtinfo *info,
+                uint16_t port)
+{
+	return peer == NULL && info->port[0] == port;
+}
+
+/**
+ * @peer
+ * @info
+ * @port
+ * @return: 1 success, 0 failure
+ */
+static inline bool
+is_wrong_knock(const struct peer *peer, const struct xt_pknock_mtinfo *info,
+		uint16_t port)
+{
+	return peer != NULL && info->port[peer->accepted_knock_count] != port;
+}
+
+/**
+ * @peer
+ * @info
+ * @return: 1 success, 0 failure
+ */
+static inline bool
+is_last_knock(const struct peer *peer, const struct xt_pknock_mtinfo *info)
+{
+	return peer != NULL && peer->accepted_knock_count == info->ports_count;
+}
+
+/**
+ * @peer
+ * @return: 1 success, 0 failure
+ */
+static inline bool
+is_allowed(const struct peer *peer)
+{
+	return peer != NULL && peer->status == ST_ALLOWED;
+}
+
+/**
+ * Sends a message to user space through netlink sockets.
+ *
+ * @info
+ * @peer
+ * @return: 1 success, 0 otherwise
+ */
+static bool
+msg_to_userspace_nl(const struct xt_pknock_mtinfo *info,
+                const struct peer *peer, int multicast_group)
+{
+#if defined(CONFIG_CONNECTOR) || defined(CONFIG_CONNECTOR_MODULE)
+	struct cn_msg *m;
+	struct xt_pknock_nl_msg msg;
+
+	m = kmalloc(sizeof(*m) + sizeof(msg), GFP_ATOMIC);
+	if (m == NULL)
+		return false;
+
+	memset(m, 0, sizeof(*m) + sizeof(msg));
+	m->seq = 0;
+	m->len = sizeof(msg);
+
+	msg.peer_ip = peer->ip;
+	scnprintf(msg.rule_name, info->rule_name_len + 1, info->rule_name);
+
+	memcpy(m + 1, &msg, m->len);
+
+	cn_netlink_send(m, multicast_group, GFP_ATOMIC);
+
+	kfree(m);
+#endif
+	return true;
+}
+
+#ifdef PK_CRYPTO
+/**
+ * Transforms a sequence of characters to hexadecimal.
+ *
+ * @out: the hexadecimal result
+ * @crypt: the original sequence
+ * @size
+ */
+static void
+crypt_to_hex(char *out, const char *crypt, unsigned int size)
+{
+	unsigned int i;
+	for (i = 0; i < size; ++i) {
+		unsigned char c = crypt[i];
+		*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);
+		*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);
+	}
+}
+
+/**
+ * Checks that the payload has the hmac(secret+ipsrc+epoch_min).
+ *
+ * @secret
+ * @secret_len
+ * @ipsrc
+ * @payload
+ * @payload_len
+ * @return: 1 success, 0 failure
+ */
+static bool
+has_secret(const unsigned char *secret, unsigned int secret_len, uint32_t ipsrc,
+    const unsigned char *payload, unsigned int payload_len)
+{
+	struct scatterlist sg[2];
+	char result[64]; // 64 bytes * 8 = 512 bits
+	char *hexresult;
+	unsigned int hexa_size;
+	int ret;
+	bool fret = false;
+	unsigned int epoch_min;
+
+	if (payload_len == 0)
+		return false;
+
+	/*
+	 * hexa:  4bits
+	 * ascii: 8bits
+	 * hexa = ascii * 2
+	 */
+	hexa_size = crypto.size * 2;
+
+	/* + 1 cause we MUST add NULL in the payload */
+	if (payload_len != hexa_size + 1)
+		return false;
+
+	hexresult = kmalloc(hexa_size, GFP_ATOMIC);
+	if (hexresult == NULL)
+		return false;
+
+	memset(result, 0, sizeof(result));
+	memset(hexresult, 0, hexa_size);
+
+	epoch_min = get_seconds() / 60;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+	sg_init_table(sg, ARRAY_SIZE(sg));
+#endif
+	sg_set_buf(&sg[0], &ipsrc, sizeof(ipsrc));
+	sg_set_buf(&sg[1], &epoch_min, sizeof(epoch_min));
+
+	ret = crypto_hash_setkey(crypto.tfm, secret, secret_len);
+	if (ret != 0) {
+		printk("crypto_hash_setkey() failed ret=%d\n", ret);
+		goto out;
+	}
+
+	/*
+	 * The third parameter is the number of bytes INSIDE the sg!
+	 * 4 bytes IP (32 bits) +
+	 * 4 bytes int epoch_min (32 bits)
+	 */
+	ret = crypto_hash_digest(&crypto.desc, sg,
+	      sizeof(ipsrc) + sizeof(epoch_min), result);
+	if (ret != 0) {
+		printk("crypto_hash_digest() failed ret=%d\n", ret);
+		goto out;
+	}
+
+	crypt_to_hex(hexresult, result, crypto.size);
+
+	if (memcmp(hexresult, payload, hexa_size) != 0)
+		pr_debug("secret match failed\n");
+	else
+		fret = true;
+
+ out:
+	kfree(hexresult);
+	return fret;
+}
+#endif /* PK_CRYPTO */
+
+/**
+ * If the peer pass the security policy.
+ *
+ * @peer
+ * @info
+ * @payload
+ * @payload_len
+ * @return: 1 if pass security, 0 otherwise
+ */
+static bool
+pass_security(struct peer *peer, const struct xt_pknock_mtinfo *info,
+        const unsigned char *payload, unsigned int payload_len)
+{
+	if (is_allowed(peer))
+		return true;
+
+	/* The peer can't log more than once during the same minute. */
+	if (has_logged_during_this_minute(peer)) {
+		pk_debug("DENIED (anti-spoof protection)", peer);
+		return false;
+	}
+#ifdef PK_CRYPTO
+	/* Check for OPEN secret */
+	if (has_secret(info->open_secret,
+					info->open_secret_len, peer->ip,
+					payload, payload_len))
+		return true;
+#endif
+
+	return false;
+}
+
+/**
+ * Validates the peer and updates the peer status for an initiating or
+ * in-sequence knock packet.
+ *
+ * @peer
+ * @info
+ * @rule
+ * @hdr
+ *
+ * Returns true if allowed, false otherwise.
+ */
+static bool
+update_peer(struct peer *peer, const struct xt_pknock_mtinfo *info,
+		struct xt_pknock_rule *rule,
+		const struct transport_data *hdr)
+{
+	unsigned long time;
+
+	if (is_wrong_knock(peer, info, hdr->port)) {
+		pk_debug("DIDN'T MATCH", peer);
+		/* Peer must start the sequence from scratch. */
+		if (info->option & XT_PKNOCK_STRICT)
+			remove_peer(peer);
+
+		return false;
+	}
+
+	/* If security is needed. */
+	if (info->option & XT_PKNOCK_OPENSECRET ) {
+		if (hdr->proto != IPPROTO_UDP && hdr->proto != IPPROTO_UDPLITE)
+			return false;
+
+		if (!pass_security(peer, info, hdr->payload, hdr->payload_len))
+			return false;
+	}
+
+	/* Update the gc timer when there is a state change. */
+	update_rule_gc_timer(rule);
+
+	++peer->accepted_knock_count;
+
+	if (is_last_knock(peer, info)) {
+		peer->status = ST_ALLOWED;
+
+		pk_debug("ALLOWED", peer);
+		peer->login_sec = get_seconds();
+
+		if (nl_multicast_group > 0)
+			msg_to_userspace_nl(info, peer, nl_multicast_group);
+
+		return true;
+	}
+
+	/* Immediate control over the maximum time between knocks. */
+	if (info->option & XT_PKNOCK_TIME) {
+		time = jiffies/HZ;
+
+		if (is_interknock_time_exceeded(peer, info->max_time)) {
+			pk_debug("ST_MATCHING knock received after interknock "
+				"time passed => destroyed", peer);
+			pr_debug("max_time: %ld - time: %ld\n",
+					peer->timestamp + info->max_time,
+					time);
+			remove_peer(peer);
+			return false;
+		}
+		peer->timestamp = time;
+	}
+	pk_debug("MATCHING", peer);
+	peer->status = ST_MATCHING;
+	return false;
+}
+
+/**
+ * Make the peer no more ALLOWED sending a payload with a special secret for
+ * closure.
+ *
+ * @peer
+ * @info
+ * @payload
+ * @payload_len
+ * @return: 1 if close knock, 0 otherwise
+ */
+static bool
+is_close_knock(const struct peer *peer, const struct xt_pknock_mtinfo *info,
+		const unsigned char *payload, unsigned int payload_len)
+{
+#ifdef PK_CRYPTO
+	/* Check for CLOSE secret. */
+	if (has_secret(info->close_secret,
+				info->close_secret_len, peer->ip,
+				payload, payload_len))
+	{
+		pk_debug("BLOCKED", peer);
+		return true;
+	}
+#endif
+	return false;
+}
+
+static bool pknock_mt(const struct sk_buff *skb,
+    struct xt_action_param *par)
+{
+	const struct xt_pknock_mtinfo *info = par->matchinfo;
+	struct xt_pknock_rule *rule;
+	struct peer *peer;
+	const struct iphdr *iph = ip_hdr(skb);
+	unsigned int hdr_len = 0;
+	__be16 _ports[2];
+	const __be16 *pptr;
+	struct transport_data hdr = {0, 0, 0, NULL};
+	bool ret = false;
+
+	pptr = skb_header_pointer(skb, par->thoff, sizeof _ports, &_ports);
+	if (pptr == NULL) {
+		/* We've been asked to examine this packet, and we
+		 * can't. Hence, no choice but to drop.
+		 */
+		par->hotdrop = true;
+		return false;
+	}
+
+	hdr.port = ntohs(pptr[1]);
+	hdr.proto = iph->protocol;
+
+	switch (hdr.proto) {
+	case IPPROTO_TCP:
+		break;
+
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+#ifdef PK_CRYPTO
+		hdr_len = (iph->ihl * 4) + sizeof(struct udphdr);
+		break;
+#else
+		pr_debug("UDP protocol not supported\n");
+		return false;
+#endif
+
+	default:
+		pr_debug("IP payload protocol is neither tcp nor udp.\n");
+		return false;
+	}
+
+	spin_lock_bh(&list_lock);
+
+	/* Searches a rule from the list depending on info structure options. */
+	rule = search_rule(info);
+	if (rule == NULL) {
+		printk(KERN_INFO PKNOCK "The rule %s doesn't exist.\n",
+						info->rule_name);
+		goto out;
+	}
+
+	/* Gives the peer matching status added to rule depending on ip src. */
+	peer = get_peer(rule, iph->saddr);
+
+	if (info->option & XT_PKNOCK_CHECKIP) {
+		ret = is_allowed(peer);
+		goto out;
+	}
+
+	if (iph->protocol == IPPROTO_UDP || iph->protocol == IPPROTO_UDPLITE) {
+		hdr.payload = (void *)iph + hdr_len;
+		hdr.payload_len = skb->len - hdr_len;
+	}
+
+	/* Sets, updates, removes or checks the peer matching status. */
+	if (info->option & XT_PKNOCK_KNOCKPORT) {
+		if ((ret = is_allowed(peer))) {
+			if (info->option & XT_PKNOCK_CLOSESECRET &&
+			    (iph->protocol == IPPROTO_UDP ||
+			    iph->protocol == IPPROTO_UDPLITE))
+			{
+				if (is_close_knock(peer, info, hdr.payload, hdr.payload_len))
+				{
+					reset_knock_status(peer);
+					ret = false;
+				}
+			}
+			goto out;
+		}
+
+		if (is_first_knock(peer, info, hdr.port)) {
+			peer = new_peer(iph->saddr, iph->protocol);
+			add_peer(peer, rule);
+		}
+
+		if (peer == NULL)
+			goto out;
+
+		update_peer(peer, info, rule, &hdr);
+	}
+
+out:
+	/* Handle cur.peer matching and deletion after autoclose_time passed */
+	if (ret && autoclose_time_passed(peer, rule->autoclose_time)) {
+		pk_debug("AUTOCLOSE TIME PASSED => BLOCKED", peer);
+		ret = false;
+		if (iph->protocol == IPPROTO_TCP ||
+		    !has_logged_during_this_minute(peer))
+			remove_peer(peer);
+	}
+
+	if (ret)
+		pk_debug("PASS OK", peer);
+	spin_unlock_bh(&list_lock);
+	return ret;
+}
+
+#define RETURN_ERR(err) do { printk(KERN_ERR PKNOCK err); return -EINVAL; } while (false)
+
+static int pknock_mt_check(const struct xt_mtchk_param *par)
+{
+	struct xt_pknock_mtinfo *info = par->matchinfo;
+
+	/* Singleton. */
+	if (rule_hashtable == NULL) {
+		rule_hashtable = alloc_hashtable(rule_hashsize);
+		if (rule_hashtable == NULL)
+			RETURN_ERR("alloc_hashtable() error in checkentry()\n");
+
+		get_random_bytes(&ipt_pknock_hash_rnd, sizeof (ipt_pknock_hash_rnd));
+	}
+
+	if (!(info->option & XT_PKNOCK_NAME))
+		RETURN_ERR("You must specify --name option.\n");
+
+#ifndef PK_CRYPTO
+	if (info->option & (XT_PKNOCK_OPENSECRET | XT_PKNOCK_CLOSESECRET))
+		RETURN_ERR("No crypto support available; "
+			"cannot use opensecret/closescret\n");
+#endif
+	if (info->option & XT_PKNOCK_OPENSECRET && info->ports_count != 1)
+		RETURN_ERR("--opensecret must have just one knock port\n");
+	if (info->option & XT_PKNOCK_KNOCKPORT) {
+		if (info->option & XT_PKNOCK_CHECKIP)
+			RETURN_ERR("Can't specify --knockports with --checkip.\n");
+		if (info->option & XT_PKNOCK_OPENSECRET &&
+				!(info->option & XT_PKNOCK_CLOSESECRET))
+			RETURN_ERR("--opensecret must go with --closesecret.\n");
+		if (info->option & XT_PKNOCK_CLOSESECRET &&
+				!(info->option & XT_PKNOCK_OPENSECRET))
+			RETURN_ERR("--closesecret must go with --opensecret.\n");
+	}
+
+	if (info->option & XT_PKNOCK_CHECKIP) {
+		if (info->option & XT_PKNOCK_KNOCKPORT)
+			RETURN_ERR("Can't specify --checkip with --knockports.\n");
+		if ((info->option & XT_PKNOCK_OPENSECRET) ||
+				(info->option & XT_PKNOCK_CLOSESECRET))
+			RETURN_ERR("Can't specify --opensecret and --closesecret"
+							" with --checkip.\n");
+		if (info->option & XT_PKNOCK_TIME)
+			RETURN_ERR("Can't specify --time with --checkip.\n");
+		if (info->option & XT_PKNOCK_AUTOCLOSE)
+			RETURN_ERR("Can't specify --autoclose with --checkip.\n");
+	} else if (!(info->option & (XT_PKNOCK_OPENSECRET | XT_PKNOCK_TIME))) {
+		RETURN_ERR("you must specify --time.\n");
+	}
+
+	if (info->option & XT_PKNOCK_OPENSECRET &&
+	    info->open_secret_len == info->close_secret_len &&
+	    memcmp(info->open_secret, info->close_secret,
+	    info->open_secret_len) == 0)
+		RETURN_ERR("opensecret & closesecret cannot be equal.\n");
+
+	if (!add_rule(info))
+		/* should ENOMEM here */
+		RETURN_ERR("add_rule() error in checkentry() function.\n");
+
+	return 0;
+}
+
+static void pknock_mt_destroy(const struct xt_mtdtor_param *par)
+{
+	struct xt_pknock_mtinfo *info = par->matchinfo;
+	/* Removes a rule only if it exits and ref_count is equal to 0. */
+	remove_rule(info);
+}
+
+static struct xt_match xt_pknock_mt_reg __read_mostly = {
+	.name		= "pknock",
+	.revision   = 1,
+	.family		= NFPROTO_IPV4,
+	.matchsize  = sizeof(struct xt_pknock_mtinfo),
+	.match      = pknock_mt,
+	.checkentry = pknock_mt_check,
+	.destroy    = pknock_mt_destroy,
+	.me			= THIS_MODULE
+};
+
+static int __init xt_pknock_mt_init(void)
+{
+#if !defined(CONFIG_CONNECTOR) && !defined(CONFIG_CONNECTOR_MODULE)
+	if (nl_multicast_group != -1)
+		pr_info("CONFIG_CONNECTOR not present; "
+		        "netlink messages disabled\n");
+#endif
+
+	if (gc_expir_time < DEFAULT_GC_EXPIRATION_TIME)
+		gc_expir_time = DEFAULT_GC_EXPIRATION_TIME;
+#ifdef PK_CRYPTO
+	if (request_module(crypto.algo) < 0) {
+		printk(KERN_ERR PKNOCK "request_module('%s') error.\n",
+                        crypto.algo);
+		return -ENXIO;
+	}
+
+	crypto.tfm = crypto_alloc_hash(crypto.algo, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(crypto.tfm)) {
+		printk(KERN_ERR PKNOCK "failed to load transform for %s\n",
+						crypto.algo);
+		return PTR_ERR(crypto.tfm);
+	}
+
+	crypto.size = crypto_hash_digestsize(crypto.tfm);
+	crypto.desc.tfm = crypto.tfm;
+	crypto.desc.flags = 0;
+#else
+	pr_info("No crypto support for < 2.6.19\n");
+#endif
+
+	pde = proc_mkdir("xt_pknock", init_net__proc_net);
+	if (pde == NULL) {
+		printk(KERN_ERR PKNOCK "proc_mkdir() error in _init().\n");
+		return -ENXIO;
+	}
+	return xt_register_match(&xt_pknock_mt_reg);
+}
+
+static void __exit xt_pknock_mt_exit(void)
+{
+	remove_proc_entry("xt_pknock", init_net__proc_net);
+	xt_unregister_match(&xt_pknock_mt_reg);
+	kfree(rule_hashtable);
+
+#ifdef PK_CRYPTO
+	if (crypto.tfm != NULL)
+		crypto_free_hash(crypto.tfm);
+#endif
+}
+
+module_init(xt_pknock_mt_init);
+module_exit(xt_pknock_mt_exit);

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_pknock.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_pknock.h
@@ -0,0 +1,53 @@
+/*
+ * Kernel module to implement Port Knocking and SPA matching support.
+ *
+ * (C) 2006-2008 J. Federico Hernandez <fede.hernandez@gmail.com>
+ * (C) 2006 Luis Floreani <luis.floreani@gmail.com>
+ *
+ * $Id$
+ *
+ * This program is released under the terms of GNU GPL version 2.
+ */
+#ifndef _XT_PKNOCK_H
+#define _XT_PKNOCK_H
+
+#define PKNOCK "xt_pknock: "
+
+enum {
+	XT_PKNOCK_KNOCKPORT   = 1 << 0,
+	XT_PKNOCK_TIME        = 1 << 1,
+	XT_PKNOCK_NAME        = 1 << 2,
+	XT_PKNOCK_STRICT      = 1 << 3,
+	XT_PKNOCK_CHECKIP     = 1 << 4,
+	XT_PKNOCK_OPENSECRET  = 1 << 5,
+	XT_PKNOCK_CLOSESECRET = 1 << 6,
+	XT_PKNOCK_AUTOCLOSE   = 1 << 7,
+
+	/* Can never change these, as they are make up the user protocol. */
+	XT_PKNOCK_MAX_PORTS      = 15,
+	XT_PKNOCK_MAX_BUF_LEN    = 31,
+	XT_PKNOCK_MAX_PASSWD_LEN = 31,
+};
+
+#define DEBUG 1
+
+struct xt_pknock_mtinfo {
+	char rule_name[XT_PKNOCK_MAX_BUF_LEN+1];
+	uint32_t			rule_name_len;
+	char open_secret[XT_PKNOCK_MAX_PASSWD_LEN+1];
+	uint32_t			open_secret_len;
+	char close_secret[XT_PKNOCK_MAX_PASSWD_LEN+1];
+	uint32_t			close_secret_len;
+	uint8_t	option;		/* --time, --knock-port, ... */
+	uint8_t	ports_count;	/* number of ports */
+	uint16_t	port[XT_PKNOCK_MAX_PORTS]; /* port[,port,port,...] */
+	uint32_t	max_time;	/* max matching time between ports */
+	uint32_t autoclose_time;
+};
+
+struct xt_pknock_nl_msg {
+	char rule_name[XT_PKNOCK_MAX_BUF_LEN+1];
+	__be32 peer_ip;
+};
+
+#endif /* _XT_PKNOCK_H */

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_psd.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_psd.c
@@ -0,0 +1,601 @@
+/*
+  This is a module which is used for PSD (portscan detection)
+  Derived from scanlogd v2.1 written by Solar Designer <solar@false.com>
+  and LOG target module.
+
+  Copyright (C) 2000,2001 astaro AG
+
+  This file is distributed under the terms of the GNU General Public
+  License (GPL). Copies of the GPL can be obtained from:
+     ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+  2000-05-04 Markus Hennig <hennig@astaro.de> : initial
+  2000-08-18 Dennis Koslowski <koslowski@astaro.de> : first release
+  2000-12-01 Dennis Koslowski <koslowski@astaro.de> : UDP scans detection added
+  2001-01-02 Dennis Koslowski <koslowski@astaro.de> : output modified
+  2001-02-04 Jan Rekorajski <baggins@pld.org.pl> : converted from target to match
+  2004-05-05 Martijn Lievaart <m@rtij.nl> : ported to 2.6
+  2007-04-05 Mohd Nawawi Mohamad Jamili <nawawi@tracenetworkcorporation.com> : ported to 2.6.18
+  2008-03-21 Mohd Nawawi Mohamad Jamili <nawawi@tracenetworkcorporation.com> : ported to 2.6.24
+  2009-08-07 Mohd Nawawi Mohamad Jamili <nawawi@tracenetworkcorporation.com> : ported to xtables-addons
+*/
+
+#define pr_fmt(x) KBUILD_MODNAME ": " x
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/types.h>
+#include <linux/tcp.h>
+#include <linux/spinlock.h>
+#include <linux/vmalloc.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include "xt_psd.h"
+#include "compat_xtables.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Dennis Koslowski <koslowski@astaro.com>");
+MODULE_AUTHOR("Martijn Lievaart <m@rtij.nl>");
+MODULE_AUTHOR("Jan Rekorajski <baggins@pld.org.pl>");
+MODULE_AUTHOR(" Mohd Nawawi Mohamad Jamili <nawawi@tracenetworkcorporation.com>");
+MODULE_DESCRIPTION("Xtables: PSD - portscan detection");
+MODULE_ALIAS("ipt_psd");
+MODULE_ALIAS("ip6t_psd");
+
+/*
+ * Keep track of up to LIST_SIZE source addresses, using a hash table of
+ * HASH_SIZE entries for faster lookups, but limiting hash collisions to
+ * HASH_MAX source addresses per the same hash value.
+ */
+#define LIST_SIZE			0x100
+#define HASH_LOG			9
+#define HASH_SIZE			(1 << HASH_LOG)
+#define HASH_MAX			0x10
+
+#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
+#	define WITH_IPV6 1
+#endif
+
+/*
+ * Information we keep per each target port
+ */
+struct port {
+	u_int16_t number;      /* port number */
+	u_int8_t proto;        /* protocol number */
+};
+
+/**
+ * Information we keep per each source address.
+ * @next:	next entry with the same hash
+ * @timestamp:	last update time
+ * @count:	number of ports in the list
+ * @weight:	total weight of ports in the list
+ */
+struct host {
+	struct host *next;
+	unsigned long timestamp;
+	__be16 src_port;
+	uint16_t count;
+	uint8_t weight;
+	struct port ports[SCAN_MAX_COUNT-1];
+};
+
+/**
+ * Information we keep per ipv4 source address.
+ */
+struct host4 {
+	struct host host;
+	__be32 saddr;
+};
+
+static struct host4 *host_to_host4(const struct host *h)
+{
+	return (struct host4 *)h;
+}
+
+struct host6 {
+	struct host host;
+	struct in6_addr saddr;
+};
+
+/**
+ * State information for IPv4 portscan detection.
+ * @list:	list of source addresses
+ * @hash:	pointers into the list
+ * @index:	oldest entry to be replaced
+ */
+static struct {
+	spinlock_t lock;
+	struct host4 list[LIST_SIZE];
+	struct host *hash[HASH_SIZE];
+	int index;
+} state;
+
+#ifdef WITH_IPV6
+/**
+ * State information for IPv6 portscan detection.
+ * @list:	list of source addresses
+ * @hash:	pointers into the list
+ * @index:	oldest entry to be replaced
+ */
+static struct {
+	spinlock_t lock;
+	struct host6 *list;
+	struct host **hash;
+	int index;
+} state6;
+
+static struct host6 *host_to_host6(const struct host *h)
+{
+	return (struct host6 *) h;
+}
+
+/**
+ * allocate state6 memory only when needed
+ */
+static bool state6_alloc_mem(void)
+{
+	if (state6.hash != NULL)
+		return true;
+
+	state6.list = vmalloc(LIST_SIZE * sizeof(struct host6));
+	if (state6.list == NULL)
+		return false;
+	memset(state6.list, 0, LIST_SIZE * sizeof(struct host6));
+
+	state6.hash = vmalloc(HASH_SIZE * sizeof(struct host*));
+	if (state6.hash == NULL) {
+		vfree(state6.list);
+		return false;
+	}
+	memset(state6.hash, 0, HASH_SIZE * sizeof(struct host *));
+	return true;
+}
+#endif
+
+/*
+ * Convert an IP address into a hash table index.
+ */
+static unsigned int hashfunc(__be32 addr)
+{
+	unsigned int value;
+	unsigned int hash;
+
+	value = addr;
+	hash = 0;
+	do {
+		hash ^= value;
+	} while ((value >>= HASH_LOG) != 0);
+
+	return hash & (HASH_SIZE - 1);
+}
+
+static inline unsigned int hashfunc6(const struct in6_addr *addr)
+{
+	__be32 h = addr->s6_addr32[0] ^ addr->s6_addr32[1];
+	return hashfunc(h ^ addr->s6_addr32[2] ^ addr->s6_addr32[3]);
+}
+
+static bool port_in_list(struct host *host, uint8_t proto, uint16_t port)
+{
+	unsigned int i;
+
+	for (i = 0; i < host->count; ++i) {
+		if (host->ports[i].proto != proto)
+			continue;
+		if (host->ports[i].number == port)
+			return true;
+	}
+	return false;
+}
+
+static uint16_t get_port_weight(const struct xt_psd_info *psd, __be16 port)
+{
+	return ntohs(port) < 1024 ? psd->lo_ports_weight : psd->hi_ports_weight;
+}
+
+static bool
+is_portscan(struct host *host, const struct xt_psd_info *psdinfo,
+            const struct tcphdr *tcph, uint8_t proto)
+{
+	if (port_in_list(host, proto, tcph->dest))
+		return false;
+
+	/*
+	 * TCP/ACK and/or TCP/RST to a new port? This could be an
+	 * outgoing connection.
+	 */
+	if (proto == IPPROTO_TCP && (tcph->ack || tcph->rst))
+		return false;
+
+	host->timestamp = jiffies;
+
+	if (host->weight >= psdinfo->weight_threshold) /* already matched */
+		return true;
+
+	/* Update the total weight */
+	host->weight += get_port_weight(psdinfo, tcph->dest);
+
+	/* Got enough destination ports to decide that this is a scan? */
+	if (host->weight >= psdinfo->weight_threshold)
+		return true;
+
+	/* Remember the new port */
+	if (host->count < ARRAY_SIZE(host->ports)) {
+		host->ports[host->count].number = tcph->dest;
+		host->ports[host->count].proto = proto;
+		host->count++;
+	}
+	return false;
+}
+
+static struct host *host_get_next(struct host *h, struct host **last)
+{
+	if (h->next != NULL)
+		*last = h;
+	return h->next;
+}
+
+static void ht_unlink(struct host **head, struct host *last)
+{
+	if (last != NULL)
+		last->next = last->next->next;
+	else if (*head != NULL)
+		*head = (*head)->next;
+}
+
+static bool
+entry_is_recent(const struct host *h, unsigned long delay_threshold,
+                unsigned long now)
+{
+	return now - h->timestamp <= (delay_threshold * HZ) / 100 &&
+	       time_after_eq(now, h->timestamp);
+}
+
+static void remove_oldest(struct host **head, struct host *curr)
+{
+	struct host *h, *last = NULL;
+
+	/*
+	 * We are going to re-use the oldest list entry, so remove it from the
+	 * hash table first, if it is really already in use.
+	 */
+	h = *head;
+	while (h != NULL) {
+		if (curr == h)
+			break;
+		last = h;
+		h = h->next;
+	}
+
+	/* Then, remove it */
+	if (h != NULL)
+		ht_unlink(head, last);
+}
+
+static void *
+get_header_pointer4(const struct sk_buff *skb, unsigned int thoff, void *mem)
+{
+	const struct iphdr *iph = ip_hdr(skb);
+	int hdrlen;
+
+	switch (iph->protocol) {
+	case IPPROTO_TCP:
+		hdrlen = sizeof(struct tcphdr);
+		break;
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+		hdrlen = sizeof(struct udphdr);
+		break;
+	default:
+		return NULL;
+	}
+
+	return skb_header_pointer(skb, thoff, hdrlen, mem);
+}
+
+static bool
+handle_packet4(const struct iphdr *iph, const struct tcphdr *tcph,
+               const struct xt_psd_info *psdinfo, unsigned int hash)
+{
+	unsigned long now;
+	struct host *curr, *last = NULL, **head;
+	struct host4 *curr4;
+	int count = 0;
+
+	now = jiffies;
+	head = &state.hash[hash];
+
+	/* Do we know this source address already? */
+	curr = *head;
+	while (curr != NULL) {
+		curr4 = host_to_host4(curr);
+		if (curr4->saddr == iph->saddr)
+			break;
+		count++;
+		curr = host_get_next(curr, &last);
+	}
+
+	if (curr != NULL) {
+		/* We know this address, and the entry isn't too old. Update it. */
+		if (entry_is_recent(curr, psdinfo->delay_threshold, now))
+			return is_portscan(curr, psdinfo, tcph, iph->protocol);
+
+		/* We know this address, but the entry is outdated. Mark it unused, and
+		 * remove from the hash table. We'll allocate a new entry instead since
+		 * this one might get re-used too soon. */
+		curr4 = host_to_host4(curr);
+		curr4->saddr = 0;
+		ht_unlink(head, last);
+		last = NULL;
+	}
+
+	/* We don't need an ACK from a new source address */
+	if (iph->protocol == IPPROTO_TCP && tcph->ack)
+		return false;
+
+	/* Got too many source addresses with the same hash value? Then remove the
+	 * oldest one from the hash table, so that they can't take too much of our
+	 * CPU time even with carefully chosen spoofed IP addresses. */
+	if (count >= HASH_MAX && last != NULL)
+		last->next = NULL;
+
+	if (state.list[state.index].saddr != 0)
+		head = &state.hash[hashfunc(state.list[state.index].saddr)];
+	else
+		head = &last;
+
+	/* Get our list entry */
+	curr4 = &state.list[state.index++];
+	curr = &curr4->host;
+	remove_oldest(head, curr);
+	if (state.index >= LIST_SIZE)
+		state.index = 0;
+
+	/* Link it into the hash table */
+	head = &state.hash[hash];
+	curr->next = *head;
+	*head = curr;
+
+	/* And fill in the fields */
+	curr4 = host_to_host4(curr);
+	curr4->saddr = iph->saddr;
+	curr->timestamp = now;
+	curr->count = 1;
+	curr->weight = get_port_weight(psdinfo, tcph->dest);
+	curr->ports[0].number = tcph->dest;
+	curr->ports[0].proto = iph->protocol;
+	return false;
+}
+
+static bool
+xt_psd_match(const struct sk_buff *pskb, struct xt_action_param *match)
+{
+	struct iphdr *iph = ip_hdr(pskb);
+	struct tcphdr _tcph;
+	struct tcphdr *tcph;
+	bool matched;
+	unsigned int hash;
+	/* Parameters from userspace */
+	const struct xt_psd_info *psdinfo = match->matchinfo;
+
+	if (iph->frag_off & htons(IP_OFFSET)) {
+		pr_debug("sanity check failed\n");
+		return false;
+	}
+
+	/*
+	 * We are using IP address 0.0.0.0 for a special purpose here, so do
+	 * not let them spoof us. [DHCP needs this feature - HW]
+	 */
+	if (iph->saddr == 0) {
+		pr_debug("spoofed source address (0.0.0.0)\n");
+		return false;
+	}
+
+	tcph = get_header_pointer4(pskb, match->thoff, &_tcph);
+	if (tcph == NULL)
+		return false;
+
+	hash = hashfunc(iph->saddr);
+
+	spin_lock(&state.lock);
+	matched = handle_packet4(iph, tcph, psdinfo, hash);
+	spin_unlock(&state.lock);
+	return matched;
+}
+
+#ifdef WITH_IPV6
+static bool
+handle_packet6(const struct ipv6hdr *ip6h, const struct tcphdr *tcph,
+	       const struct xt_psd_info *psdinfo, uint8_t proto, int hash)
+{
+	unsigned long now;
+	struct host *curr, *last = NULL, **head;
+	struct host6 *curr6;
+	int count = 0;
+
+	now = jiffies;
+	head = &state6.hash[hash];
+
+	curr = *head;
+	while (curr != NULL) {
+		curr6 = host_to_host6(curr);
+		if (ipv6_addr_equal(&curr6->saddr, &ip6h->saddr))
+			break;
+		count++;
+		curr = host_get_next(curr, &last);
+	}
+
+	if (curr != NULL) {
+		if (entry_is_recent(curr, psdinfo->delay_threshold, now))
+			return is_portscan(curr, psdinfo, tcph, proto);
+		curr6 = host_to_host6(curr);
+		memset(&curr6->saddr, 0, sizeof(curr6->saddr));
+		ht_unlink(head, last);
+		last = NULL;
+	}
+
+	if (proto == IPPROTO_TCP && tcph->ack)
+		return false;
+
+	if (count >= HASH_MAX && last != NULL)
+		last->next = NULL;
+
+	if (!ipv6_addr_any(&state6.list[state6.index].saddr))
+		head = &state6.hash[hashfunc6(&state6.list[state6.index].saddr)];
+	else
+		head = &last;
+
+	curr6 = &state6.list[state6.index++];
+	curr = &curr6->host;
+	remove_oldest(head, curr);
+	if (state6.index >= LIST_SIZE)
+		state6.index = 0;
+
+	head = &state6.hash[hash];
+	curr->next = *head;
+	*head = curr;
+
+	curr6 = host_to_host6(curr);
+	curr6->saddr = ip6h->saddr;
+	curr->timestamp = now;
+	curr->count = 1;
+	curr->weight = get_port_weight(psdinfo, tcph->dest);
+	curr->ports[0].number = tcph->dest;
+	curr->ports[0].proto = proto;
+	return false;
+}
+
+static void *
+get_header_pointer6(const struct sk_buff *skb, void *mem, uint8_t *proto)
+{
+	static const uint8_t types[] = {IPPROTO_TCP,
+				        IPPROTO_UDP, IPPROTO_UDPLITE};
+	unsigned int i, offset = 0;
+	int err;
+	size_t hdrlen;
+
+	for (i = 0; i < ARRAY_SIZE(types); ++i) {
+		err = ipv6_find_hdr(skb, &offset, types[i], NULL, NULL);
+		if (err < 0)
+			continue;
+
+		switch (types[i]) {
+		case IPPROTO_TCP:
+			hdrlen = sizeof(struct tcphdr);
+			break;
+		case IPPROTO_UDP:
+		case IPPROTO_UDPLITE:
+			hdrlen = sizeof(struct udphdr);
+			break;
+		default:
+			return NULL;
+		}
+		*proto = types[i];
+		return skb_header_pointer(skb, offset, hdrlen, mem);
+	}
+	return NULL;
+}
+
+static bool
+xt_psd_match6(const struct sk_buff *pskb, struct xt_action_param *match)
+{
+	const struct ipv6hdr *ip6h = ipv6_hdr(pskb);
+	struct tcphdr _tcph;
+	struct tcphdr *tcph;
+	uint8_t proto = 0;
+	bool matched;
+	int hash;
+	const struct xt_psd_info *psdinfo = match->matchinfo;
+
+	if (ipv6_addr_any(&ip6h->saddr))
+		return false;
+
+	tcph = get_header_pointer6(pskb, &_tcph, &proto);
+	if (tcph == NULL)
+		return false;
+
+	hash = hashfunc6(&ip6h->saddr);
+
+	spin_lock(&state6.lock);
+	matched = handle_packet6(ip6h, tcph, psdinfo, proto, hash);
+	spin_unlock(&state6.lock);
+	return matched;
+}
+#endif
+
+static int psd_mt_check(const struct xt_mtchk_param *par)
+{
+	const struct xt_psd_info *info = par->matchinfo;
+
+	if (info->weight_threshold == 0)
+		/* 0 would match on every 1st packet */
+		return -EINVAL;
+
+	if ((info->lo_ports_weight | info->hi_ports_weight) == 0)
+		/* would never match */
+		return -EINVAL;
+
+	if (info->delay_threshold > PSD_MAX_RATE ||
+	    info->weight_threshold > PSD_MAX_RATE ||
+	    info->lo_ports_weight > PSD_MAX_RATE ||
+	    info->hi_ports_weight > PSD_MAX_RATE)
+		return -EINVAL;
+
+	return 0;
+}
+
+#ifdef WITH_IPV6
+static int psd_mt_check6(const struct xt_mtchk_param *par)
+{
+	if (!state6_alloc_mem())
+		return -ENOMEM;
+	return psd_mt_check(par);
+}
+#endif
+
+static struct xt_match xt_psd_reg[] __read_mostly = {
+	{
+		.name       = "psd",
+		.family     = NFPROTO_IPV4,
+		.revision   = 1,
+		.checkentry = psd_mt_check,
+		.match      = xt_psd_match,
+		.matchsize  = sizeof(struct xt_psd_info),
+		.me         = THIS_MODULE,
+#ifdef WITH_IPV6
+	}, {
+		.name       = "psd",
+		.family     = NFPROTO_IPV6,
+		.revision   = 1,
+		.checkentry = psd_mt_check6,
+		.match      = xt_psd_match6,
+		.matchsize  = sizeof(struct xt_psd_info),
+		.me         = THIS_MODULE,
+#endif
+	}
+};
+
+static int __init xt_psd_init(void)
+{
+	spin_lock_init(&(state.lock));
+#ifdef WITH_IPV6
+	spin_lock_init(&(state6.lock));
+#endif
+	return xt_register_matches(xt_psd_reg, ARRAY_SIZE(xt_psd_reg));
+}
+
+static void __exit xt_psd_exit(void)
+{
+        xt_unregister_matches(xt_psd_reg, ARRAY_SIZE(xt_psd_reg));
+#ifdef WITH_IPV6
+	vfree(state6.list);
+	vfree(state6.hash);
+#endif
+}
+
+module_init(xt_psd_init);
+module_exit(xt_psd_exit);
+

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_psd.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_psd.h
@@ -0,0 +1,30 @@
+#ifndef _LINUX_NETFILTER_XT_PSD_H
+#define _LINUX_NETFILTER_XT_PSD_H 1
+
+#include <linux/param.h>
+#include <linux/types.h>
+
+/*
+ * High port numbers have a lower weight to reduce the frequency of false
+ * positives, such as from passive mode FTP transfers.
+ */
+#define PORT_WEIGHT_PRIV		3
+#define PORT_WEIGHT_HIGH		1
+#define	PSD_MAX_RATE			10000
+
+/*
+ * Port scan detection thresholds: at least COUNT ports need to be scanned
+ * from the same source, with no longer than DELAY ticks between ports.
+ */
+#define SCAN_MIN_COUNT			7
+#define SCAN_MAX_COUNT			(SCAN_MIN_COUNT * PORT_WEIGHT_PRIV)
+#define SCAN_WEIGHT_THRESHOLD		SCAN_MAX_COUNT
+
+struct xt_psd_info {
+	__u32 weight_threshold;
+	__u32 delay_threshold;
+	__u16 lo_ports_weight;
+	__u16 hi_ports_weight;
+};
+
+#endif /*_LINUX_NETFILTER_XT_PSD_H*/

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_quota2.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_quota2.c
@@ -0,0 +1,276 @@
+/*
+ * xt_quota2 - enhanced xt_quota that can count upwards and in packets
+ * as a minimal accounting match.
+ * by Jan Engelhardt <jengelh@medozas.de>, 2008
+ *
+ * Originally based on xt_quota.c:
+ * 	Xtables module to enforce network quotas
+ * 	Sam Johnston <samj@samj.net>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License
+ *	version 2, as published by the Free Software Foundation.
+ */
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#include <asm/atomic.h>
+
+#include <linux/netfilter/x_tables.h>
+#include "xt_quota2.h"
+#include "compat_xtables.h"
+
+/**
+ * @lock:	lock to protect quota writers from each other
+ */
+struct xt_quota_counter {
+	u_int64_t quota;
+	spinlock_t lock;
+	struct list_head list;
+	atomic_t ref;
+	char name[sizeof(((struct xt_quota_mtinfo2 *)NULL)->name)];
+	struct proc_dir_entry *procfs_entry;
+};
+
+static LIST_HEAD(counter_list);
+static DEFINE_SPINLOCK(counter_list_lock);
+
+static struct proc_dir_entry *proc_xt_quota;
+static unsigned int quota_list_perms = S_IRUGO | S_IWUSR;
+static unsigned int quota_list_uid   = 0;
+static unsigned int quota_list_gid   = 0;
+module_param_named(perms, quota_list_perms, uint, S_IRUGO | S_IWUSR);
+module_param_named(uid, quota_list_uid, uint, S_IRUGO | S_IWUSR);
+module_param_named(gid, quota_list_gid, uint, S_IRUGO | S_IWUSR);
+
+static int quota_proc_read(char *page, char **start, off_t offset,
+                           int count, int *eof, void *data)
+{
+	struct xt_quota_counter *e = data;
+	int ret;
+
+	spin_lock_bh(&e->lock);
+	ret = snprintf(page, PAGE_SIZE, "%llu\n", e->quota);
+	spin_unlock_bh(&e->lock);
+	return ret;
+}
+
+static int quota_proc_write(struct file *file, const char __user *input,
+                            unsigned long size, void *data)
+{
+	struct xt_quota_counter *e = data;
+	char buf[sizeof("18446744073709551616")];
+
+	if (size > sizeof(buf))
+		size = sizeof(buf);
+	if (copy_from_user(buf, input, size) != 0)
+		return -EFAULT;
+	buf[sizeof(buf)-1] = '\0';
+
+	spin_lock_bh(&e->lock);
+	e->quota = simple_strtoull(buf, NULL, 0);
+	spin_unlock_bh(&e->lock);
+	return size;
+}
+
+static struct xt_quota_counter *
+q2_new_counter(const struct xt_quota_mtinfo2 *q, bool anon)
+{
+	struct xt_quota_counter *e;
+	unsigned int size;
+
+	/* Do not need all the procfs things for anonymous counters. */
+	size = anon ? offsetof(typeof(*e), list) : sizeof(*e);
+	e = kmalloc(size, GFP_KERNEL);
+	if (e == NULL)
+		return NULL;
+
+	e->quota = q->quota;
+	spin_lock_init(&e->lock);
+	if (!anon) {
+		INIT_LIST_HEAD(&e->list);
+		atomic_set(&e->ref, 1);
+		strncpy(e->name, q->name, sizeof(e->name));
+	}
+	return e;
+}
+
+/**
+ * q2_get_counter - get ref to counter or create new
+ * @name:	name of counter
+ */
+static struct xt_quota_counter *
+q2_get_counter(const struct xt_quota_mtinfo2 *q)
+{
+	struct proc_dir_entry *p;
+	struct xt_quota_counter *e;
+
+	if (*q->name == '\0')
+		return q2_new_counter(q, true);
+
+	spin_lock_bh(&counter_list_lock);
+	list_for_each_entry(e, &counter_list, list)
+		if (strcmp(e->name, q->name) == 0) {
+			atomic_inc(&e->ref);
+			spin_unlock_bh(&counter_list_lock);
+			return e;
+		}
+
+	e = q2_new_counter(q, false);
+	if (e == NULL)
+		goto out;
+
+	p = e->procfs_entry = create_proc_entry(e->name, quota_list_perms,
+	                      proc_xt_quota);
+	if (p == NULL || IS_ERR(p))
+		goto out;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 29)
+	p->owner        = THIS_MODULE;
+#endif
+	p->data         = e;
+	p->read_proc    = quota_proc_read;
+	p->write_proc   = quota_proc_write;
+	p->uid          = quota_list_uid;
+	p->gid          = quota_list_gid;
+	list_add_tail(&e->list, &counter_list);
+	spin_unlock_bh(&counter_list_lock);
+	return e;
+
+ out:
+	spin_unlock_bh(&counter_list_lock);
+	kfree(e);
+	return NULL;
+}
+
+static int quota_mt2_check(const struct xt_mtchk_param *par)
+{
+	struct xt_quota_mtinfo2 *q = par->matchinfo;
+
+	if (q->flags & ~XT_QUOTA_MASK)
+		return -EINVAL;
+
+	q->name[sizeof(q->name)-1] = '\0';
+	if (*q->name == '.' || strchr(q->name, '/') != NULL) {
+		printk(KERN_ERR "xt_quota.3: illegal name\n");
+		return -EINVAL;
+	}
+
+	q->master = q2_get_counter(q);
+	if (q->master == NULL) {
+		printk(KERN_ERR "xt_quota.3: memory alloc failure\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void quota_mt2_destroy(const struct xt_mtdtor_param *par)
+{
+	struct xt_quota_mtinfo2 *q = par->matchinfo;
+	struct xt_quota_counter *e = q->master;
+
+	if (*q->name == '\0') {
+		kfree(e);
+		return;
+	}
+
+	spin_lock_bh(&counter_list_lock);
+	if (!atomic_dec_and_test(&e->ref)) {
+		spin_unlock_bh(&counter_list_lock);
+		return;
+	}
+
+	list_del(&e->list);
+	remove_proc_entry(e->name, proc_xt_quota);
+	spin_unlock_bh(&counter_list_lock);
+	kfree(e);
+}
+
+static bool
+quota_mt2(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	struct xt_quota_mtinfo2 *q = (void *)par->matchinfo;
+	struct xt_quota_counter *e = q->master;
+	bool ret = q->flags & XT_QUOTA_INVERT;
+
+	spin_lock_bh(&e->lock);
+	if (q->flags & XT_QUOTA_GROW) {
+		/*
+		 * While no_change is pointless in "grow" mode, we will
+		 * implement it here simply to have a consistent behavior.
+		 */
+		if (!(q->flags & XT_QUOTA_NO_CHANGE)) {
+			e->quota += (q->flags & XT_QUOTA_PACKET) ? 1 : skb->len;
+			q->quota = e->quota;
+		}
+		ret = true;
+	} else {
+		if (e->quota >= skb->len) {
+			if (!(q->flags & XT_QUOTA_NO_CHANGE))
+				e->quota -= (q->flags & XT_QUOTA_PACKET) ? 1 : skb->len;
+			ret = !ret;
+		} else {
+			/* we do not allow even small packets from now on */
+			e->quota = 0;
+		}
+		q->quota = e->quota;
+	}
+	spin_unlock_bh(&e->lock);
+	return ret;
+}
+
+static struct xt_match quota_mt2_reg[] __read_mostly = {
+	{
+		.name       = "quota2",
+		.revision   = 3,
+		.family     = NFPROTO_IPV4,
+		.checkentry = quota_mt2_check,
+		.match      = quota_mt2,
+		.destroy    = quota_mt2_destroy,
+		.matchsize  = sizeof(struct xt_quota_mtinfo2),
+		.me         = THIS_MODULE,
+	},
+	{
+		.name       = "quota2",
+		.revision   = 3,
+		.family     = NFPROTO_IPV6,
+		.checkentry = quota_mt2_check,
+		.match      = quota_mt2,
+		.destroy    = quota_mt2_destroy,
+		.matchsize  = sizeof(struct xt_quota_mtinfo2),
+		.me         = THIS_MODULE,
+	},
+};
+
+static int __init quota_mt2_init(void)
+{
+	int ret;
+
+	proc_xt_quota = proc_mkdir("xt_quota", init_net__proc_net);
+	if (proc_xt_quota == NULL)
+		return -EACCES;
+
+	ret = xt_register_matches(quota_mt2_reg, ARRAY_SIZE(quota_mt2_reg));
+	if (ret < 0)
+		remove_proc_entry("xt_quota", init_net__proc_net);
+	return ret;
+}
+
+static void __exit quota_mt2_exit(void)
+{
+	xt_unregister_matches(quota_mt2_reg, ARRAY_SIZE(quota_mt2_reg));
+	remove_proc_entry("xt_quota", init_net__proc_net);
+}
+
+module_init(quota_mt2_init);
+module_exit(quota_mt2_exit);
+MODULE_DESCRIPTION("Xtables: countdown quota match; up counter");
+MODULE_AUTHOR("Sam Johnston <samj@samj.net>");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_quota2");
+MODULE_ALIAS("ip6t_quota2");

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_quota2.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_quota2.h
@@ -0,0 +1,25 @@
+#ifndef _XT_QUOTA_H
+#define _XT_QUOTA_H
+
+enum xt_quota_flags {
+	XT_QUOTA_INVERT    = 1 << 0,
+	XT_QUOTA_GROW      = 1 << 1,
+	XT_QUOTA_PACKET    = 1 << 2,
+	XT_QUOTA_NO_CHANGE = 1 << 3,
+	XT_QUOTA_MASK      = 0x0F,
+};
+
+struct xt_quota_counter;
+
+struct xt_quota_mtinfo2 {
+	char name[15];
+	u_int8_t flags;
+
+	/* Comparison-invariant */
+	aligned_u64 quota;
+
+	/* Used internally by the kernel */
+	struct xt_quota_counter *master __attribute__((aligned(8)));
+};
+
+#endif /* _XT_QUOTA_H */

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_RAWNAT.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_RAWNAT.c
@@ -0,0 +1,358 @@
+/*
+ *	"RAWNAT" target extension for Xtables - untracked NAT
+ *	Copyright © Jan Engelhardt, 2008 - 2009
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/version.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter/nf_conntrack_common.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include "compat_xtables.h"
+#include "xt_RAWNAT.h"
+#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
+#	define WITH_IPV6 1
+#endif
+
+static inline __be32
+remask(__be32 addr, __be32 repl, unsigned int shift)
+{
+	uint32_t mask = (shift == 32) ? 0 : (~(uint32_t)0 >> shift);
+	return htonl((ntohl(addr) & mask) | (ntohl(repl) & ~mask));
+}
+
+#ifdef WITH_IPV6
+static void
+rawnat_ipv6_mask(__be32 *addr, const __be32 *repl, unsigned int mask)
+{
+	switch (mask) {
+	case 0:
+		break;
+	case 1 ... 31:
+		addr[0] = remask(addr[0], repl[0], mask);
+		break;
+	case 32:
+		addr[0] = repl[0];
+		break;
+	case 33 ... 63:
+		addr[0] = repl[0];
+		addr[1] = remask(addr[1], repl[1], mask - 32);
+		break;
+	case 64:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		break;
+	case 65 ... 95:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		addr[2] = remask(addr[2], repl[2], mask - 64);
+	case 96:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		addr[2] = repl[2];
+		break;
+	case 97 ... 127:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		addr[2] = repl[2];
+		addr[3] = remask(addr[3], repl[3], mask - 96);
+		break;
+	case 128:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		addr[2] = repl[2];
+		addr[3] = repl[3];
+		break;
+	}
+}
+#endif
+
+static void rawnat4_update_l4(struct sk_buff *skb, __be32 oldip, __be32 newip)
+{
+	struct iphdr *iph = ip_hdr(skb);
+	void *transport_hdr = (void *)iph + ip_hdrlen(skb);
+	struct tcphdr *tcph;
+	struct udphdr *udph;
+	bool cond;
+
+	switch (iph->protocol) {
+	case IPPROTO_TCP:
+		tcph = transport_hdr;
+		inet_proto_csum_replace4(&tcph->check, skb, oldip, newip, true);
+		break;
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+		udph = transport_hdr;
+		cond = udph->check != 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+		cond |= skb->ip_summed == CHECKSUM_PARTIAL;
+#endif
+		if (cond) {
+			inet_proto_csum_replace4(&udph->check, skb,
+				oldip, newip, true);
+			if (udph->check == 0)
+				udph->check = CSUM_MANGLED_0;
+		}
+		break;
+	}
+}
+
+static unsigned int rawnat4_writable_part(const struct iphdr *iph)
+{
+	unsigned int wlen = sizeof(*iph);
+
+	switch (iph->protocol) {
+	case IPPROTO_TCP:
+		wlen += sizeof(struct tcphdr);
+		break;
+	case IPPROTO_UDP:
+		wlen += sizeof(struct udphdr);
+		break;
+	}
+	return wlen;
+}
+
+static unsigned int
+rawsnat_tg4(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct xt_rawnat_tginfo *info = par->targinfo;
+	struct iphdr *iph;
+	__be32 new_addr;
+
+	iph = ip_hdr(*pskb);
+	new_addr = remask(iph->saddr, info->addr.ip, info->mask);
+	if (iph->saddr == new_addr)
+		return XT_CONTINUE;
+
+	if (!skb_make_writable(pskb, rawnat4_writable_part(iph)))
+		return NF_DROP;
+
+	iph = ip_hdr(*pskb);
+	csum_replace4(&iph->check, iph->saddr, new_addr);
+	rawnat4_update_l4(*pskb, iph->saddr, new_addr);
+	iph->saddr = new_addr;
+	return XT_CONTINUE;
+}
+
+static unsigned int
+rawdnat_tg4(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct xt_rawnat_tginfo *info = par->targinfo;
+	struct iphdr *iph;
+	__be32 new_addr;
+
+	iph = ip_hdr(*pskb);
+	new_addr = remask(iph->daddr, info->addr.ip, info->mask);
+	if (iph->daddr == new_addr)
+		return XT_CONTINUE;
+
+	if (!skb_make_writable(pskb, rawnat4_writable_part(iph)))
+		return NF_DROP;
+
+	iph = ip_hdr(*pskb);
+	csum_replace4(&iph->check, iph->daddr, new_addr);
+	rawnat4_update_l4(*pskb, iph->daddr, new_addr);
+	iph->daddr = new_addr;
+	return XT_CONTINUE;
+}
+
+#ifdef WITH_IPV6
+static bool rawnat6_prepare_l4(struct sk_buff **pskb, unsigned int *l4offset,
+    unsigned int *l4proto)
+{
+	static const unsigned int types[] =
+		{IPPROTO_TCP, IPPROTO_UDP, IPPROTO_UDPLITE};
+	unsigned int i;
+	int err;
+
+	*l4proto = NEXTHDR_MAX;
+
+	for (i = 0; i < ARRAY_SIZE(types); ++i) {
+		err = ipv6_find_hdr(*pskb, l4offset, types[i], NULL, NULL);
+		if (err >= 0) {
+			*l4proto = types[i];
+			break;
+		}
+		if (err != -ENOENT)
+			return false;
+	}
+
+	switch (*l4proto) {
+	case IPPROTO_TCP:
+		if (!skb_make_writable(pskb, *l4offset + sizeof(struct tcphdr)))
+			return false;
+		break;
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+		if (!skb_make_writable(pskb, *l4offset + sizeof(struct udphdr)))
+			return false;
+		break;
+	}
+
+	return true;
+}
+
+static void rawnat6_update_l4(struct sk_buff *skb, unsigned int l4proto,
+    unsigned int l4offset, const struct in6_addr *oldip,
+    const struct in6_addr *newip)
+{
+	const struct ipv6hdr *iph = ipv6_hdr(skb);
+	struct tcphdr *tcph;
+	struct udphdr *udph;
+	unsigned int i;
+	bool cond;
+
+	switch (l4proto) {
+	case IPPROTO_TCP:
+		tcph = (void *)iph + l4offset;
+		for (i = 0; i < 4; ++i)
+			inet_proto_csum_replace4(&tcph->check, skb,
+				oldip->s6_addr32[i], newip->s6_addr32[i], true);
+		break;
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+		udph = (void *)iph + l4offset;
+		cond = udph->check;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+		cond |= skb->ip_summed == CHECKSUM_PARTIAL;
+#endif
+		if (cond) {
+			for (i = 0; i < 4; ++i)
+				inet_proto_csum_replace4(&udph->check, skb,
+					oldip->s6_addr32[i],
+					newip->s6_addr32[i], true);
+			if (udph->check == 0)
+				udph->check = CSUM_MANGLED_0;
+		}
+		break;
+	}
+}
+
+static unsigned int
+rawsnat_tg6(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct xt_rawnat_tginfo *info = par->targinfo;
+	unsigned int l4offset = 0, l4proto;
+	struct ipv6hdr *iph;
+	struct in6_addr new_addr;
+
+	iph = ipv6_hdr(*pskb);
+	memcpy(&new_addr, &iph->saddr, sizeof(new_addr));
+	rawnat_ipv6_mask(new_addr.s6_addr32, info->addr.ip6, info->mask);
+	if (ipv6_addr_cmp(&iph->saddr, &new_addr) == 0)
+		return XT_CONTINUE;
+	if (!rawnat6_prepare_l4(pskb, &l4offset, &l4proto))
+		return NF_DROP;
+	iph = ipv6_hdr(*pskb);
+	rawnat6_update_l4(*pskb, l4proto, l4offset, &iph->saddr, &new_addr);
+	memcpy(&iph->saddr, &new_addr, sizeof(new_addr));
+	return XT_CONTINUE;
+}
+
+static unsigned int
+rawdnat_tg6(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct xt_rawnat_tginfo *info = par->targinfo;
+	unsigned int l4offset = 0, l4proto;
+	struct ipv6hdr *iph;
+	struct in6_addr new_addr;
+
+	iph = ipv6_hdr(*pskb);
+	memcpy(&new_addr, &iph->daddr, sizeof(new_addr));
+	rawnat_ipv6_mask(new_addr.s6_addr32, info->addr.ip6, info->mask);
+	if (ipv6_addr_cmp(&iph->daddr, &new_addr) == 0)
+		return XT_CONTINUE;
+	if (!rawnat6_prepare_l4(pskb, &l4offset, &l4proto))
+		return NF_DROP;
+	iph = ipv6_hdr(*pskb);
+	rawnat6_update_l4(*pskb, l4proto, l4offset, &iph->daddr, &new_addr);
+	memcpy(&iph->daddr, &new_addr, sizeof(new_addr));
+	return XT_CONTINUE;
+}
+#endif
+
+static int rawnat_tg_check(const struct xt_tgchk_param *par)
+{
+	if (strcmp(par->table, "raw") == 0 ||
+	    strcmp(par->table, "rawpost") == 0)
+		return 0;
+
+	printk(KERN_ERR KBUILD_MODNAME " may only be used in the \"raw\" or "
+	       "\"rawpost\" table.\n");
+	return -EINVAL;
+}
+
+static struct xt_target rawnat_tg_reg[] __read_mostly = {
+	{
+		.name       = "RAWSNAT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.target     = rawsnat_tg4,
+		.targetsize = sizeof(struct xt_rawnat_tginfo),
+		.checkentry = rawnat_tg_check,
+		.me         = THIS_MODULE,
+	},
+#ifdef WITH_IPV6
+	{
+		.name       = "RAWSNAT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.target     = rawsnat_tg6,
+		.targetsize = sizeof(struct xt_rawnat_tginfo),
+		.checkentry = rawnat_tg_check,
+		.me         = THIS_MODULE,
+	},
+#endif
+	{
+		.name       = "RAWDNAT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.target     = rawdnat_tg4,
+		.targetsize = sizeof(struct xt_rawnat_tginfo),
+		.checkentry = rawnat_tg_check,
+		.me         = THIS_MODULE,
+	},
+#ifdef WITH_IPV6
+	{
+		.name       = "RAWDNAT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.target     = rawdnat_tg6,
+		.targetsize = sizeof(struct xt_rawnat_tginfo),
+		.checkentry = rawnat_tg_check,
+		.me         = THIS_MODULE,
+	},
+#endif
+};
+
+static int __init rawnat_tg_init(void)
+{
+	return xt_register_targets(rawnat_tg_reg, ARRAY_SIZE(rawnat_tg_reg));
+}
+
+static void __exit rawnat_tg_exit(void)
+{
+	xt_unregister_targets(rawnat_tg_reg, ARRAY_SIZE(rawnat_tg_reg));
+}
+
+module_init(rawnat_tg_init);
+module_exit(rawnat_tg_exit);
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_DESCRIPTION("Xtables: conntrack-less raw NAT");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_RAWSNAT");
+MODULE_ALIAS("ipt_RAWDNAT");
+MODULE_ALIAS("ip6t_RAWSNAT");
+MODULE_ALIAS("ip6t_RAWDNAT");

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_RAWNAT.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_RAWNAT.h
@@ -0,0 +1,9 @@
+#ifndef _LINUX_NETFILTER_XT_TARGET_RAWNAT
+#define _LINUX_NETFILTER_XT_TARGET_RAWNAT 1
+
+struct xt_rawnat_tginfo {
+	union nf_inet_addr addr;
+	__u8 mask;
+};
+
+#endif /* _LINUX_NETFILTER_XT_TARGET_RAWNAT */

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_STEAL.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_STEAL.c
@@ -0,0 +1,67 @@
+/*
+ *	"STEAL" demo target extension for Xtables
+ *	written by Jan Engelhardt <jengelh [at] medozas de>, 2008 - 2009
+ *	placed in the Public Domain
+ */
+#include <linux/module.h>
+#include <linux/netfilter.h>
+#include <linux/skbuff.h>
+#include "compat_xtables.h"
+
+static unsigned int
+steal_tg(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	kfree_skb(*pskb);
+	return NF_STOLEN;
+}
+
+static struct xt_target steal_tg_reg[] __read_mostly = {
+	{
+		.name     = "STEAL",
+		.revision = 0,
+		.family   = NFPROTO_UNSPEC,
+		.target   = steal_tg,
+		.me       = THIS_MODULE,
+	},
+	{
+		.name     = "STEAL",
+		.revision = 0,
+		.family   = NFPROTO_IPV6,
+		.target   = steal_tg,
+		.me       = THIS_MODULE,
+	},
+	{
+		.name     = "STEAL",
+		.revision = 0,
+		.family   = NFPROTO_ARP,
+		.target   = steal_tg,
+		.me       = THIS_MODULE,
+	},
+	{
+		.name     = "STEAL",
+		.revision = 0,
+		.family   = NFPROTO_BRIDGE,
+		.target   = steal_tg,
+		.me       = THIS_MODULE,
+	},
+};
+
+static int __init steal_tg_init(void)
+{
+	return xt_register_targets(steal_tg_reg, ARRAY_SIZE(steal_tg_reg));
+}
+
+static void __exit steal_tg_exit(void)
+{
+	xt_unregister_targets(steal_tg_reg, ARRAY_SIZE(steal_tg_reg));
+}
+
+module_init(steal_tg_init);
+module_exit(steal_tg_exit);
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_DESCRIPTION("Xtables: Silently DROP packets on output chain");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_STEAL");
+MODULE_ALIAS("ip6t_STEAL");
+MODULE_ALIAS("arpt_STEAL");
+MODULE_ALIAS("ebt_STEAL");

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_TARPIT.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_TARPIT.c
@@ -0,0 +1,549 @@
+/*
+ *	"TARPIT" target extension to Xtables
+ *	Kernel module to capture and hold incoming TCP connections using
+ *	no local per-connection resources.
+ *
+ *	Copyright © Aaron Hopkins <tools [at] die net>, 2002
+ *
+ *	Based on ipt_REJECT.c and offering functionality similar to
+ *	LaBrea <http://www.hackbusters.net/LaBrea/>.
+ *
+ *	<<<
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *	>>>
+ *
+ * Goal:
+ * - Allow incoming TCP connections to be established.
+ * - Passing data should result in the connection being switched to the
+ *   persist state (0 byte window), in which the remote side stops sending
+ *   data and asks to continue every 60 seconds.
+ * - Attempts to shut down the connection should be ignored completely, so
+ *   the remote side ends up having to time it out.
+ *
+ * This means:
+ * - Reply to TCP SYN,!ACK,!RST,!FIN with SYN-ACK, window 5 bytes
+ * - Reply to TCP SYN,ACK,!RST,!FIN with RST to prevent spoofing
+ * - Reply to TCP !SYN,!RST,!FIN with ACK, window 0 bytes, rate-limited
+ */
+
+#include <linux/ip.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <linux/netfilter_ipv6.h>
+#include <linux/netfilter/x_tables.h>
+#ifdef CONFIG_BRIDGE_NETFILTER
+#	include <linux/netfilter_bridge.h>
+#endif
+#include <net/addrconf.h>
+#include <net/ip6_checksum.h>
+#include <net/ip6_route.h>
+#include <net/ipv6.h>
+#include <net/route.h>
+#include <net/tcp.h>
+#include "compat_xtables.h"
+#include "xt_TARPIT.h"
+#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
+#	define WITH_IPV6 1
+#endif
+
+static bool xttarpit_tarpit(struct tcphdr *tcph, const struct tcphdr *oth)
+{
+	/* No replies for RST, FIN or !SYN,!ACK */
+	if (oth->rst || oth->fin || (!oth->syn && !oth->ack))
+		return false;
+	tcph->seq = oth->ack ? oth->ack_seq : 0;
+
+	/* Our SYN-ACKs must have a >0 window */
+	tcph->window = (oth->syn && !oth->ack) ? htons(5) : 0;
+	if (oth->syn && oth->ack) {
+		tcph->rst     = true;
+		tcph->ack_seq = false;
+	} else {
+		tcph->syn     = oth->syn;
+		tcph->ack     = true;
+		tcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn);
+	}
+#if 0
+	/* Rate-limit replies to !SYN,ACKs */
+	if (!oth->syn && oth->ack)
+		if (!xrlim_allow(rt_dst(ort), HZ))
+			return false;
+#endif
+
+	return true;
+}
+
+static bool xttarpit_honeypot(struct tcphdr *tcph, const struct tcphdr *oth,
+    uint16_t payload)
+{
+	/* Do not answer any resets regardless of combination */
+	if (oth->rst || oth->seq == 0xDEADBEEF)
+		return false;
+	/* Send a reset to scanners. They like that. */
+	if (oth->syn && oth->ack) {
+		tcph->window  = 0;
+		tcph->ack     = false;
+		tcph->psh     = true;
+		tcph->ack_seq = 0xdeadbeef; /* see if they ack it */
+		tcph->seq     = oth->ack_seq;
+		tcph->rst     = true;
+	}
+
+	/* SYN > SYN-ACK */
+	if (oth->syn && !oth->ack) {
+		tcph->syn     = true;
+		tcph->ack     = true;
+		tcph->window  = oth->window &
+			((net_random() & 0x1f) - 0xf);
+		tcph->seq     = htonl(net_random() & ~oth->seq);
+		tcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn);
+	}
+
+	/* ACK > ACK */
+	if (oth->ack && (!(oth->fin || oth->syn))) {
+		tcph->syn     = false;
+		tcph->ack     = true;
+		tcph->window  = oth->window &
+			((net_random() & 0x1f) - 0xf);
+		tcph->ack_seq = payload > 100 ?
+			htonl(ntohl(oth->seq) + payload) :
+			oth->seq;
+		tcph->seq     = oth->ack_seq;
+	}
+
+	/*
+	 * FIN > RST.
+	 * We cannot terminate gracefully so just be abrupt.
+	 */
+	if (oth->fin) {
+		tcph->window  = 0;
+		tcph->seq     = oth->ack_seq;
+		tcph->ack_seq = oth->ack_seq;
+		tcph->fin     = false;
+		tcph->ack     = false;
+		tcph->rst     = true;
+	}
+
+	return true;
+}
+
+static void xttarpit_reset(struct tcphdr *tcph, const struct tcphdr *oth)
+{
+	tcph->window  = 0;
+	tcph->ack     = false;
+	tcph->syn     = false;
+	tcph->rst     = true;
+	tcph->seq     = oth->ack_seq;
+	tcph->ack_seq = oth->seq;
+}
+
+static bool tarpit_generic(struct tcphdr *tcph, const struct tcphdr *oth,
+    uint16_t payload, unsigned int mode)
+{
+	switch(mode) {
+	case XTTARPIT_TARPIT:
+		if (!xttarpit_tarpit(tcph, oth))
+			return false;
+		break;
+	case XTTARPIT_HONEYPOT:
+		if (!xttarpit_honeypot(tcph, oth, payload))
+			return false;
+		break;
+	case XTTARPIT_RESET:
+		xttarpit_reset(tcph, oth);
+		break;
+	}
+
+	return true;
+}
+
+static void tarpit_tcp4(struct sk_buff *oldskb, unsigned int hook,
+    unsigned int mode)
+{
+	struct tcphdr _otcph, *tcph;
+	const struct tcphdr *oth;
+	unsigned int addr_type = RTN_UNSPEC;
+	struct sk_buff *nskb;
+	const struct iphdr *oldhdr;
+	struct iphdr *niph;
+	uint16_t tmp, payload;
+
+	/* A truncated TCP header is not going to be useful */
+	if (oldskb->len < ip_hdrlen(oldskb) + sizeof(struct tcphdr))
+		return;
+
+	oth = skb_header_pointer(oldskb, ip_hdrlen(oldskb),
+	                         sizeof(_otcph), &_otcph);
+	if (oth == NULL)
+		return;
+
+	/* Check checksum. */
+	if (nf_ip_checksum(oldskb, hook, ip_hdrlen(oldskb), IPPROTO_TCP))
+		return;
+
+	/*
+	 * Copy skb (even if skb is about to be dropped, we cannot just
+	 * clone it because there may be other things, such as tcpdump,
+	 * interested in it)
+	 */
+	nskb = skb_copy_expand(oldskb, LL_MAX_HEADER,
+	                       skb_tailroom(oldskb), GFP_ATOMIC);
+	if (nskb == NULL)
+		return;
+
+	/* This packet will not be the same as the other: clear nf fields */
+	nf_reset(nskb);
+	skb_nfmark(nskb) = 0;
+	skb_init_secmark(nskb);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+	skb_shinfo(nskb)->gso_size = 0;
+	skb_shinfo(nskb)->gso_segs = 0;
+	skb_shinfo(nskb)->gso_type = 0;
+#endif
+
+	oldhdr = ip_hdr(oldskb);
+	tcph = (struct tcphdr *)(skb_network_header(nskb) + ip_hdrlen(nskb));
+
+	/* Swap source and dest */
+	niph         = ip_hdr(nskb);
+	niph->daddr  = xchg(&niph->saddr, niph->daddr);
+	tmp          = tcph->source;
+	tcph->source = tcph->dest;
+	tcph->dest   = tmp;
+
+	/* Calculate payload size?? */
+	payload = nskb->len - ip_hdrlen(nskb) - sizeof(struct tcphdr);
+
+	/* Truncate to length (no data) */
+	tcph->doff    = sizeof(struct tcphdr) / 4;
+	skb_trim(nskb, ip_hdrlen(nskb) + sizeof(struct tcphdr));
+	niph->tot_len = htons(nskb->len);
+	tcph->urg_ptr = 0;
+	/* Reset flags */
+	((u_int8_t *)tcph)[13] = 0;
+
+	if (!tarpit_generic(tcph, oth, payload, mode))
+		goto free_nskb;
+
+	/* Adjust TCP checksum */
+	tcph->check = 0;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
+	tcph->check = tcp_v4_check(tcph, sizeof(struct tcphdr), niph->saddr,
+	              niph->daddr, csum_partial((char *)tcph,
+	              sizeof(struct tcphdr), 0));
+#else
+	tcph->check = tcp_v4_check(sizeof(struct tcphdr), niph->saddr,
+	              niph->daddr, csum_partial((char *)tcph,
+	              sizeof(struct tcphdr), 0));
+#endif
+
+	/* Set DF, id = 0 */
+	niph->frag_off = htons(IP_DF);
+	if (mode == XTTARPIT_TARPIT || mode == XTTARPIT_RESET)
+		niph->id = 0;
+	else if (mode == XTTARPIT_HONEYPOT)
+		niph->id = ~oldhdr->id + 1;
+
+#ifdef CONFIG_BRIDGE_NETFILTER
+	if (hook != NF_INET_FORWARD || (nskb->nf_bridge != NULL &&
+	    nskb->nf_bridge->mask & BRNF_BRIDGED))
+#else
+	if (hook != NF_INET_FORWARD)
+#endif
+		addr_type = RTN_LOCAL;
+
+	if (ip_route_me_harder(&nskb, addr_type))
+		goto free_nskb;
+	else
+		niph = ip_hdr(nskb);
+
+	nskb->ip_summed = CHECKSUM_NONE;
+
+	/* Adjust IP TTL */
+	if (mode == XTTARPIT_HONEYPOT)
+		niph->ttl = 128;
+	else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+		niph->ttl = ip4_dst_hoplimit(skb_dst(nskb));
+#else
+		niph->ttl = dst_metric(skb_dst(nskb), RTAX_HOPLIMIT);
+#endif
+
+	/* Adjust IP checksum */
+	niph->check = 0;
+	niph->check = ip_fast_csum(skb_network_header(nskb), niph->ihl);
+
+	/* "Never happens" */
+	if (nskb->len > dst_mtu(skb_dst(nskb)))
+		goto free_nskb;
+
+	nf_ct_attach(nskb, oldskb);
+
+	NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_OUT, nskb, NULL,
+		skb_dst(nskb)->dev, dst_output);
+	return;
+
+ free_nskb:
+	kfree_skb(nskb);
+}
+
+#ifdef WITH_IPV6
+static void tarpit_tcp6(struct sk_buff *oldskb, unsigned int hook,
+    unsigned int mode)
+{
+	struct sk_buff *nskb;
+	struct tcphdr *tcph, oth;
+	unsigned int otcplen;
+	int tcphoff;
+	const struct ipv6hdr *oip6h = ipv6_hdr(oldskb);
+	struct ipv6hdr *ip6h;
+	const uint8_t tclass = 0;
+	uint8_t proto;
+	uint16_t payload;
+	__be16 frag_off;
+
+	proto   = oip6h->nexthdr;
+	tcphoff = ipv6_skip_exthdr(oldskb,
+	          (uint8_t *)(oip6h + 1) - oldskb->data, &proto, &frag_off);
+
+	if (tcphoff < 0 || tcphoff > oldskb->len) {
+		pr_debug("Cannot get TCP header.\n");
+		return;
+	}
+
+	otcplen = oldskb->len - tcphoff;
+
+	/* IP header checks: fragment, too short. */
+	if (proto != IPPROTO_TCP || otcplen < sizeof(struct tcphdr)) {
+		pr_debug("proto(%d) != IPPROTO_TCP, "
+		         "or too short. otcplen = %d\n",
+		         proto, otcplen);
+		return;
+	}
+
+	if (skb_copy_bits(oldskb, tcphoff, &oth, sizeof(struct tcphdr))) {
+		WARN_ON(1);
+		return;
+	}
+
+	/* Check checksum. */
+	if (csum_ipv6_magic(&oip6h->saddr, &oip6h->daddr, otcplen, IPPROTO_TCP,
+	    skb_checksum(oldskb, tcphoff, otcplen, 0))) {
+		pr_debug("TCP checksum is invalid\n");
+		return;
+	}
+
+	nskb = skb_copy_expand(oldskb, LL_MAX_HEADER,
+	       skb_tailroom(oldskb), GFP_ATOMIC);
+	if (nskb == NULL) {
+		if (net_ratelimit())
+			pr_debug("cannot alloc skb\n");
+		return;
+	}
+
+	/* This packet will not be the same as the other: clear nf fields */
+	nf_reset(nskb);
+	skb_nfmark(nskb) = 0;
+	skb_init_secmark(nskb);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+	skb_shinfo(nskb)->gso_size = 0;
+	skb_shinfo(nskb)->gso_segs = 0;
+	skb_shinfo(nskb)->gso_type = 0;
+#endif
+
+	skb_put(nskb, sizeof(struct ipv6hdr));
+	ip6h = ipv6_hdr(nskb);
+	*(__be32 *)ip6h =  htonl(0x60000000 | (tclass << 20));
+	ip6h->nexthdr = IPPROTO_TCP;
+	ip6h->saddr = oip6h->daddr;
+	ip6h->daddr = oip6h->saddr;
+
+	/* Adjust IP TTL */
+	if (mode == XTTARPIT_HONEYPOT) {
+		ip6h->hop_limit = 128;
+	} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+		ip6h->hop_limit = ip6_dst_hoplimit(skb_dst(nskb));
+#else
+		ip6h->hop_limit = dst_metric(skb_dst(nskb), RTAX_HOPLIMIT);
+#endif
+	}
+
+	tcph = (struct tcphdr *)(skb_network_header(nskb) +
+	       sizeof(struct ipv6hdr));
+
+	/* Truncate to length (no data) */
+	skb_trim(nskb, sizeof(struct ipv6hdr) + sizeof(struct tcphdr));
+	tcph->doff    = sizeof(struct tcphdr)/4;
+	tcph->source  = oth.dest;
+	tcph->dest    = oth.source;
+	tcph->urg_ptr = 0;
+	/* Reset flags */
+	((uint8_t *)tcph)[13] = 0;
+
+	payload = nskb->len - sizeof(struct ipv6hdr) - sizeof(struct tcphdr);
+	if (!tarpit_generic(&oth, tcph, payload, mode))
+		goto free_nskb;
+
+	ip6h->payload_len = htons(sizeof(struct tcphdr));
+	tcph->check = 0;
+
+	/* Adjust TCP checksum */
+	tcph->check = csum_ipv6_magic(&ipv6_hdr(nskb)->saddr,
+	              &ipv6_hdr(nskb)->daddr, sizeof(struct tcphdr),
+	              IPPROTO_TCP,
+	              csum_partial(tcph, sizeof(struct tcphdr), 0));
+
+	if (ip6_route_me_harder(nskb))
+		goto free_nskb;
+
+	nskb->ip_summed = CHECKSUM_NONE;
+
+	nf_ct_attach(nskb, oldskb);
+
+	NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, nskb, NULL,
+	        skb_dst(nskb)->dev, dst_output);
+	return;
+
+ free_nskb:
+	kfree_skb(nskb);
+}
+#endif
+
+static unsigned int
+tarpit_tg4(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct sk_buff *skb = *pskb;
+	const struct iphdr *iph = ip_hdr(skb);
+	const struct rtable *rt = skb_rtable(skb);
+	const struct xt_tarpit_tginfo *info = par->targinfo;
+
+	/* Do we have an input route cache entry? (Not in PREROUTING.) */
+	if (rt == NULL)
+		return NF_DROP;
+
+	/* No replies to physical multicast/broadcast */
+	/* skb != PACKET_OTHERHOST handled by ip_rcv() */
+	if (skb->pkt_type != PACKET_HOST)
+		return NF_DROP;
+
+	/* Now check at the protocol level */
+	if (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))
+		return NF_DROP;
+
+	/*
+	 * Our naive response construction does not deal with IP
+	 * options, and probably should not try.
+	 */
+	if (ip_hdrlen(skb) != sizeof(struct iphdr))
+		return NF_DROP;
+
+	/* We are not interested in fragments */
+	if (iph->frag_off & htons(IP_OFFSET))
+		return NF_DROP;
+
+	tarpit_tcp4(*pskb, par->hooknum, info->variant);
+	return NF_DROP;
+}
+
+#ifdef WITH_IPV6
+static unsigned int
+tarpit_tg6(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct sk_buff *skb = *pskb;
+	const struct ipv6hdr *iph = ipv6_hdr(skb);
+	const struct rt6_info *rt = (struct rt6_info *)skb_dst(skb);
+	const struct xt_tarpit_tginfo *info = par->targinfo;
+	uint8_t proto;
+	__be16 frag_off;
+
+	/* Do we have an input route cache entry? (Not in PREROUTING.) */
+	if (rt == NULL) {
+		pr_debug("Dropping no input route cache entry\n");
+		return NF_DROP;
+	}
+
+	/* No replies to physical multicast/broadcast */
+	/* skb != PACKET_OTHERHOST handled by ip_rcv() */
+	if (skb->pkt_type != PACKET_HOST) {
+		pr_debug("type != PACKET_HOST");
+		return NF_DROP;
+	}
+
+	/*
+	 * Our naive response construction does not deal with IP
+	 * options, and probably should not try.
+	 */
+	proto = iph->nexthdr;
+	if (ipv6_skip_exthdr(skb, skb_network_header_len(skb), &proto,
+	    &frag_off) != sizeof(struct ipv6hdr))
+		return NF_DROP;
+
+	if ((!(ipv6_addr_type(&iph->saddr) & IPV6_ADDR_UNICAST)) ||
+	    (!(ipv6_addr_type(&iph->daddr) & IPV6_ADDR_UNICAST))) {
+		pr_debug("addr is not unicast.\n");
+		return NF_DROP;
+	}
+
+	tarpit_tcp6(*pskb, par->hooknum, info->variant);
+	return NF_DROP;
+}
+#endif
+
+static struct xt_target tarpit_tg_reg[] __read_mostly = {
+	{
+		.name       = "TARPIT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.hooks      = (1 << NF_INET_LOCAL_IN) | (1 << NF_INET_FORWARD),
+		.proto      = IPPROTO_TCP,
+		.target     = tarpit_tg4,
+		.targetsize = sizeof(struct xt_tarpit_tginfo),
+		.me         = THIS_MODULE,
+	},
+#ifdef WITH_IPV6
+	{
+		.name       = "TARPIT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.hooks      = (1 << NF_INET_LOCAL_IN) | (1 << NF_INET_FORWARD),
+		.proto      = IPPROTO_TCP,
+		.target     = tarpit_tg6,
+		.targetsize = sizeof(struct xt_tarpit_tginfo),
+		.me         = THIS_MODULE,
+	},
+#endif
+};
+
+static int __init tarpit_tg_init(void)
+{
+	return xt_register_targets(tarpit_tg_reg, ARRAY_SIZE(tarpit_tg_reg));
+}
+
+static void __exit tarpit_tg_exit(void)
+{
+	xt_unregister_targets(tarpit_tg_reg, ARRAY_SIZE(tarpit_tg_reg));
+}
+
+module_init(tarpit_tg_init);
+module_exit(tarpit_tg_exit);
+MODULE_DESCRIPTION("Xtables: \"TARPIT\", capture and hold TCP connections");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_TARPIT");
+MODULE_ALIAS("ip6t_TARPIT");

--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_TARPIT.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/netfilter/xt_TARPIT.h
@@ -0,0 +1,14 @@
+#ifndef _LINUX_NETFILTER_XT_TARPIT_H
+#define _LINUX_NETFILTER_XT_TARPIT_H 1
+
+enum xt_tarpit_target_variant {
+	XTTARPIT_TARPIT,
+	XTTARPIT_HONEYPOT,
+	XTTARPIT_RESET,
+};
+
+struct xt_tarpit_tginfo {
+	uint8_t variant;
+};
+
+#endif /* _LINUX_NETFILTER_XT_TARPIT_H */
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/Kconfig
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/Kconfig
@@ -66,6 +66,28 @@
 
 	  If unsure, say N.
 
+config SQUASHFS_4K_DEVBLK_SIZE
+	bool "Use 4K device block size?"
+	depends on SQUASHFS
+	help
+	  By default Squashfs sets the dev block size (sb_min_blocksize)
+	  to 1K or the smallest block size supported by the block device
+	  (if larger).  This, because blocks are packed together and
+	  unaligned in Squashfs, should reduce latency.
+
+	  This, however, gives poor performance on MTD NAND devices where
+	  the optimal I/O size is 4K (even though the devices can support
+	  smaller block sizes).
+
+	  Using a 4K device block size may also improve overall I/O
+	  performance for some file access patterns (e.g. sequential
+	  accesses of files in filesystem order) on all media.
+
+	  Setting this option will force Squashfs to use a 4K device block
+	  size by default.
+
+	  If unsure, say N.
+
 config SQUASHFS_EMBEDDED
 	bool "Additional option for memory-constrained systems"
 	depends on SQUASHFS
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
@@ -37,6 +37,13 @@
 #define SQUASHFS_FILE_SIZE		131072
 #define SQUASHFS_FILE_LOG		17
 
+/* default size of block device I/O */
+#ifdef CONFIG_SQUASHFS_4K_DEVBLK_SIZE
+#define SQUASHFS_DEVBLK_SIZE 4096
+#else
+#define SQUASHFS_DEVBLK_SIZE 1024
+#endif
+
 #define SQUASHFS_FILE_MAX_SIZE		1048576
 #define SQUASHFS_FILE_MAX_LOG		20
 
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/super.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/fs/squashfs/super.c
@@ -102,7 +102,7 @@
 		goto failure;
 	}
 
-	msblk->devblksize = sb_min_blocksize(sb, BLOCK_SIZE);
+	msblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);
 	msblk->devblksize_log2 = ffz(~msblk->devblksize);
 
 	mutex_init(&msblk->read_data_mutex);
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/Makefile
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/Makefile
@@ -85,6 +85,9 @@
 obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
 obj-$(CONFIG_CRYPTO_GHASH) += ghash-generic.o
+obj-$(CONFIG_CRYPTO_USER_API) += af_alg.o
+obj-$(CONFIG_CRYPTO_USER_API_HASH) += algif_hash.o
+obj-$(CONFIG_CRYPTO_USER_API_SKCIPHER) += algif_skcipher.o
 
 #
 # generic algorithms and the async_tx api
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/Kconfig
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/Kconfig
@@ -842,6 +842,27 @@
 	  ANSI X9.31 A.2.4. Note that this option must be enabled if
 	  CRYPTO_FIPS is selected
 
+config CRYPTO_USER_API
+	tristate
+
+config CRYPTO_USER_API_HASH
+	tristate "User-space interface for hash algorithms"
+	depends on NET
+	select CRYPTO_HASH
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for hash
+	  algorithms.
+
+config CRYPTO_USER_API_SKCIPHER
+	tristate "User-space interface for symmetric key cipher algorithms"
+	depends on NET
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for symmetric
+	  key cipher algorithms.
+
 source "drivers/crypto/Kconfig"
 
 endif	# if CRYPTO
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/af_alg.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/af_alg.c
@@ -0,0 +1,483 @@
+/*
+ * af_alg: User-space algorithm interface
+ *
+ * This file provides the user-space API for algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <asm/atomic.h>
+#include <crypto/if_alg.h>
+#include <linux/crypto.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/rwsem.h>
+
+struct alg_type_list {
+	const struct af_alg_type *type;
+	struct list_head list;
+};
+
+static atomic_long_t alg_memory_allocated;
+
+static struct proto alg_proto = {
+	.name			= "ALG",
+	.owner			= THIS_MODULE,
+	.memory_allocated	= &alg_memory_allocated,
+	.obj_size		= sizeof(struct alg_sock),
+};
+
+static LIST_HEAD(alg_types);
+static DECLARE_RWSEM(alg_types_sem);
+
+static const struct af_alg_type *alg_get_type(const char *name)
+{
+	const struct af_alg_type *type = ERR_PTR(-ENOENT);
+	struct alg_type_list *node;
+
+	down_read(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, name))
+			continue;
+
+		if (try_module_get(node->type->owner))
+			type = node->type;
+		break;
+	}
+	up_read(&alg_types_sem);
+
+	return type;
+}
+
+int af_alg_register_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -EEXIST;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (!strcmp(node->type->name, type->name))
+			goto unlock;
+	}
+
+	node = kmalloc(sizeof(*node), GFP_KERNEL);
+	err = -ENOMEM;
+	if (!node)
+		goto unlock;
+
+	type->ops->owner = THIS_MODULE;
+	node->type = type;
+	list_add(&node->list, &alg_types);
+	err = 0;
+
+unlock:
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_register_type);
+
+int af_alg_unregister_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -ENOENT;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, type->name))
+			continue;
+
+		list_del(&node->list);
+		kfree(node);
+		err = 0;
+		break;
+	}
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_unregister_type);
+
+static void alg_do_release(const struct af_alg_type *type, void *private)
+{
+	if (!type)
+		return;
+
+	type->release(private);
+	module_put(type->owner);
+}
+
+int af_alg_release(struct socket *sock)
+{
+	if (sock->sk)
+		sock_put(sock->sk);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_release);
+
+static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct sockaddr_alg *sa = (void *)uaddr;
+	const struct af_alg_type *type;
+	void *private;
+
+	if (sock->state == SS_CONNECTED)
+		return -EINVAL;
+
+	if (addr_len != sizeof(*sa))
+		return -EINVAL;
+
+	sa->salg_type[sizeof(sa->salg_type) - 1] = 0;
+	sa->salg_name[sizeof(sa->salg_name) - 1] = 0;
+
+	type = alg_get_type(sa->salg_type);
+	if (IS_ERR(type) && PTR_ERR(type) == -ENOENT) {
+		request_module("algif-%s", sa->salg_type);
+		type = alg_get_type(sa->salg_type);
+	}
+
+	if (IS_ERR(type))
+		return PTR_ERR(type);
+
+	private = type->bind(sa->salg_name, sa->salg_feat, sa->salg_mask);
+	if (IS_ERR(private)) {
+		module_put(type->owner);
+		return PTR_ERR(private);
+	}
+
+	lock_sock(sk);
+
+	swap(ask->type, type);
+	swap(ask->private, private);
+
+	release_sock(sk);
+
+	alg_do_release(type, private);
+
+	return 0;
+}
+
+static int alg_setkey(struct sock *sk, char __user *ukey,
+		      unsigned int keylen)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type = ask->type;
+	u8 *key;
+	int err;
+
+	key = sock_kmalloc(sk, keylen, GFP_KERNEL);
+	if (!key)
+		return -ENOMEM;
+
+	err = -EFAULT;
+	if (copy_from_user(key, ukey, keylen))
+		goto out;
+
+	err = type->setkey(ask->private, key, keylen);
+
+out:
+	sock_kfree_s(sk, key, keylen);
+
+	return err;
+}
+
+static int alg_setsockopt(struct socket *sock, int level, int optname,
+			  char __user *optval, unsigned int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	int err = -ENOPROTOOPT;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	if (level != SOL_ALG || !type)
+		goto unlock;
+
+	switch (optname) {
+	case ALG_SET_KEY:
+		if (sock->state == SS_CONNECTED)
+			goto unlock;
+		if (!type->setkey)
+			goto unlock;
+
+		err = alg_setkey(sk, optval, optlen);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+
+int af_alg_accept(struct sock *sk, struct socket *newsock)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	struct sock *sk2;
+	int err;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	err = -EINVAL;
+	if (!type)
+		goto unlock;
+
+	sk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto);
+	err = -ENOMEM;
+	if (!sk2)
+		goto unlock;
+
+	sock_init_data(newsock, sk2);
+	sock_graft(sk2, newsock);
+
+	err = type->accept(ask->private, sk2);
+	if (err) {
+		sk_free(sk2);
+		goto unlock;
+	}
+
+	sk2->sk_family = PF_ALG;
+
+	sock_hold(sk);
+	alg_sk(sk2)->parent = sk;
+	alg_sk(sk2)->type = type;
+
+	newsock->ops = type->ops;
+	newsock->state = SS_CONNECTED;
+
+	err = 0;
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_accept);
+
+static int alg_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	return af_alg_accept(sock->sk, newsock);
+}
+
+static const struct proto_ops alg_proto_ops = {
+	.family		=	PF_ALG,
+	.owner		=	THIS_MODULE,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.sendpage	=	sock_no_sendpage,
+	.sendmsg	=	sock_no_sendmsg,
+	.recvmsg	=	sock_no_recvmsg,
+	.poll		=	sock_no_poll,
+
+	.bind		=	alg_bind,
+	.release	=	af_alg_release,
+	.setsockopt	=	alg_setsockopt,
+	.accept		=	alg_accept,
+};
+
+static void alg_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+
+	alg_do_release(ask->type, ask->private);
+}
+
+static int alg_create(struct net *net, struct socket *sock, int protocol,
+		      int kern)
+{
+	struct sock *sk;
+	int err;
+
+	if (sock->type != SOCK_SEQPACKET)
+		return -ESOCKTNOSUPPORT;
+	if (protocol != 0)
+		return -EPROTONOSUPPORT;
+
+	err = -ENOMEM;
+	sk = sk_alloc(net, PF_ALG, GFP_KERNEL, &alg_proto);
+	if (!sk)
+		goto out;
+
+	sock->ops = &alg_proto_ops;
+	sock_init_data(sock, sk);
+
+	sk->sk_family = PF_ALG;
+	sk->sk_destruct = alg_sock_destruct;
+
+	return 0;
+out:
+	return err;
+}
+
+static const struct net_proto_family alg_family = {
+	.family	=	PF_ALG,
+	.create	=	alg_create,
+	.owner	=	THIS_MODULE,
+};
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write)
+{
+	unsigned long from = (unsigned long)addr;
+	unsigned long npages;
+	unsigned off;
+	int err;
+	int i;
+
+	err = -EFAULT;
+	if (!access_ok(write ? VERIFY_READ : VERIFY_WRITE, addr, len))
+		goto out;
+
+	off = from & ~PAGE_MASK;
+	npages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	if (npages > ALG_MAX_PAGES)
+		npages = ALG_MAX_PAGES;
+
+	err = get_user_pages_fast(from, npages, write, sgl->pages);
+	if (err < 0)
+		goto out;
+
+	npages = err;
+	err = -EINVAL;
+	if (WARN_ON(npages == 0))
+		goto out;
+
+	err = 0;
+
+	sg_init_table(sgl->sg, npages);
+
+	for (i = 0; i < npages; i++) {
+		int plen = min_t(int, len, PAGE_SIZE - off);
+
+		sg_set_page(sgl->sg + i, sgl->pages[i], plen, off);
+
+		off = 0;
+		len -= plen;
+		err += plen;
+	}
+
+out:
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_make_sg);
+
+void af_alg_free_sg(struct af_alg_sgl *sgl)
+{
+	int i;
+
+	i = 0;
+	do {
+		put_page(sgl->pages[i]);
+	} while (!sg_is_last(sgl->sg + (i++)));
+}
+EXPORT_SYMBOL_GPL(af_alg_free_sg);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con)
+{
+	struct cmsghdr *cmsg;
+
+	for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
+		if (!CMSG_OK(msg, cmsg))
+			return -EINVAL;
+		if (cmsg->cmsg_level != SOL_ALG)
+			continue;
+
+		switch(cmsg->cmsg_type) {
+		case ALG_SET_IV:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(*con->iv)))
+				return -EINVAL;
+			con->iv = (void *)CMSG_DATA(cmsg);
+			if (cmsg->cmsg_len < CMSG_LEN(con->iv->ivlen +
+						      sizeof(*con->iv)))
+				return -EINVAL;
+			break;
+
+		case ALG_SET_OP:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))
+				return -EINVAL;
+			con->op = *(u32 *)CMSG_DATA(cmsg);
+			break;
+
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_cmsg_send);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion)
+{
+	switch (err) {
+	case -EINPROGRESS:
+	case -EBUSY:
+		wait_for_completion(&completion->completion);
+		INIT_COMPLETION(completion->completion);
+		err = completion->err;
+		break;
+	};
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_wait_for_completion);
+
+void af_alg_complete(struct crypto_async_request *req, int err)
+{
+	struct af_alg_completion *completion = req->data;
+
+	completion->err = err;
+	complete(&completion->completion);
+}
+EXPORT_SYMBOL_GPL(af_alg_complete);
+
+static int __init af_alg_init(void)
+{
+	int err = proto_register(&alg_proto, 0);
+
+	if (err)
+		goto out;
+
+	err = sock_register(&alg_family);
+	if (err != 0)
+		goto out_unregister_proto;
+
+out:
+	return err;
+
+out_unregister_proto:
+	proto_unregister(&alg_proto);
+	goto out;
+}
+
+static void __exit af_alg_exit(void)
+{
+	sock_unregister(PF_ALG);
+	proto_unregister(&alg_proto);
+}
+
+module_init(af_alg_init);
+module_exit(af_alg_exit);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_NETPROTO(AF_ALG);
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/algif_hash.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/algif_hash.c
@@ -0,0 +1,319 @@
+/*
+ * algif_hash: User-space interface for hash algorithms
+ *
+ * This file provides the user-space API for hash algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/hash.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct hash_ctx {
+	struct af_alg_sgl sgl;
+
+	u8 *result;
+
+	struct af_alg_completion completion;
+
+	unsigned int len;
+	bool more;
+
+	struct ahash_request req;
+};
+
+static int hash_sendmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t ignored)
+{
+	int limit = ALG_MAX_PAGES * PAGE_SIZE;
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned long iovlen;
+	struct iovec *iov;
+	long copied = 0;
+	int err;
+
+	if (limit > sk->sk_sndbuf)
+		limit = sk->sk_sndbuf;
+
+	lock_sock(sk);
+	if (!ctx->more) {
+		err = crypto_ahash_init(&ctx->req);
+		if (err)
+			goto unlock;
+	}
+
+	ctx->more = 0;
+
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			int len = min_t(unsigned long, seglen, limit);
+			int newlen;
+
+			newlen = af_alg_make_sg(&ctx->sgl, from, len, 0);
+			if (newlen < 0)
+				goto unlock;
+
+			ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL,
+						newlen);
+
+			err = af_alg_wait_for_completion(
+				crypto_ahash_update(&ctx->req),
+				&ctx->completion);
+
+			af_alg_free_sg(&ctx->sgl);
+
+			if (err)
+				goto unlock;
+
+			seglen -= newlen;
+			from += newlen;
+			copied += newlen;
+		}
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more) {
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err ?: copied;
+}
+
+static ssize_t hash_sendpage(struct socket *sock, struct page *page,
+			     int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	int err;
+
+	lock_sock(sk);
+	sg_init_table(ctx->sgl.sg, 1);
+	sg_set_page(ctx->sgl.sg, page, size, offset);
+
+	ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, ctx->result, size);
+
+	if (!(flags & MSG_MORE)) {
+		if (ctx->more)
+			err = crypto_ahash_finup(&ctx->req);
+		else
+			err = crypto_ahash_digest(&ctx->req);
+	} else {
+		if (!ctx->more) {
+			err = crypto_ahash_init(&ctx->req);
+			if (err)
+				goto unlock;
+		}
+
+		err = crypto_ahash_update(&ctx->req);
+	}
+
+	err = af_alg_wait_for_completion(err, &ctx->completion);
+	if (err)
+		goto unlock;
+
+	ctx->more = flags & MSG_MORE;
+
+unlock:
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t len, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
+	int err;
+
+	if (len > ds)
+		len = ds;
+	else if (len < ds)
+		msg->msg_flags |= MSG_TRUNC;
+
+	lock_sock(sk);
+	if (ctx->more) {
+		ctx->more = 0;
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+		if (err)
+			goto unlock;
+	}
+
+	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);
+
+unlock:
+	release_sock(sk);
+
+	return err ?: len;
+}
+
+static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	struct ahash_request *req = &ctx->req;
+	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];
+	struct sock *sk2;
+	struct alg_sock *ask2;
+	struct hash_ctx *ctx2;
+	int err;
+
+	err = crypto_ahash_export(req, state);
+	if (err)
+		return err;
+
+	err = af_alg_accept(ask->parent, newsock);
+	if (err)
+		return err;
+
+	sk2 = newsock->sk;
+	ask2 = alg_sk(sk2);
+	ctx2 = ask2->private;
+	ctx2->more = 1;
+
+	err = crypto_ahash_import(&ctx2->req, state);
+	if (err) {
+		sock_orphan(sk2);
+		sock_put(sk2);
+	}
+
+	return err;
+}
+
+static struct proto_ops algif_hash_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.setsockopt	=	sock_no_setsockopt,
+	.poll		=	sock_no_poll,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	hash_sendmsg,
+	.sendpage	=	hash_sendpage,
+	.recvmsg	=	hash_recvmsg,
+	.accept		=	hash_accept,
+};
+
+static void *hash_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ahash(name, type, mask);
+}
+
+static void hash_release(void *private)
+{
+	crypto_free_ahash(private);
+}
+
+static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ahash_setkey(private, key, keylen);
+}
+
+static void hash_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+
+	sock_kfree_s(sk, ctx->result,
+		     crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int hash_accept_parent(void *private, struct sock *sk)
+{
+	struct hash_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);
+	unsigned ds = crypto_ahash_digestsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);
+	if (!ctx->result) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->result, 0, ds);
+
+	ctx->len = len;
+	ctx->more = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ahash_request_set_tfm(&ctx->req, private);
+	ahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				   af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = hash_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_hash = {
+	.bind		=	hash_bind,
+	.release	=	hash_release,
+	.setkey		=	hash_setkey,
+	.accept		=	hash_accept_parent,
+	.ops		=	&algif_hash_ops,
+	.name		=	"hash",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_hash_init(void)
+{
+	return af_alg_register_type(&algif_type_hash);
+}
+
+static void __exit algif_hash_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_hash);
+	BUG_ON(err);
+}
+
+module_init(algif_hash_init);
+module_exit(algif_hash_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/algif_skcipher.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/crypto/algif_skcipher.c
@@ -0,0 +1,632 @@
+/*
+ * algif_skcipher: User-space interface for skcipher algorithms
+ *
+ * This file provides the user-space API for symmetric key ciphers.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/scatterwalk.h>
+#include <crypto/skcipher.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct skcipher_sg_list {
+	struct list_head list;
+
+	int cur;
+
+	struct scatterlist sg[0];
+};
+
+struct skcipher_ctx {
+	struct list_head tsgl;
+	struct af_alg_sgl rsgl;
+
+	void *iv;
+
+	struct af_alg_completion completion;
+
+	unsigned used;
+
+	unsigned int len;
+	bool more;
+	bool merge;
+	bool enc;
+
+	struct ablkcipher_request req;
+};
+
+#define MAX_SGL_ENTS ((PAGE_SIZE - sizeof(struct skcipher_sg_list)) / \
+		      sizeof(struct scatterlist) - 1)
+
+static inline int skcipher_sndbuf(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	return max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -
+			  ctx->used, 0);
+}
+
+static inline bool skcipher_writable(struct sock *sk)
+{
+	return PAGE_SIZE <= skcipher_sndbuf(sk);
+}
+
+static int skcipher_alloc_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg = NULL;
+
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+	if (!list_empty(&ctx->tsgl))
+		sg = sgl->sg;
+
+	if (!sg || sgl->cur >= MAX_SGL_ENTS) {
+		sgl = sock_kmalloc(sk, sizeof(*sgl) +
+				       sizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),
+				   GFP_KERNEL);
+		if (!sgl)
+			return -ENOMEM;
+
+		sg_init_table(sgl->sg, MAX_SGL_ENTS + 1);
+		sgl->cur = 0;
+
+		if (sg)
+			scatterwalk_sg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);
+
+		list_add_tail(&sgl->list, &ctx->tsgl);
+	}
+
+	return 0;
+}
+
+static void skcipher_pull_sgl(struct sock *sk, int used)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	int i;
+
+	while (!list_empty(&ctx->tsgl)) {
+		sgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,
+				       list);
+		sg = sgl->sg;
+
+		for (i = 0; i < sgl->cur; i++) {
+			int plen = min_t(int, used, sg[i].length);
+
+			if (!sg_page(sg + i))
+				continue;
+
+			sg[i].length -= plen;
+			sg[i].offset += plen;
+
+			used -= plen;
+			ctx->used -= plen;
+
+			if (sg[i].length)
+				return;
+
+			put_page(sg_page(sg + i));
+			sg_assign_page(sg + i, NULL);
+		}
+
+		list_del(&sgl->list);
+		sock_kfree_s(sk, sgl,
+			     sizeof(*sgl) + sizeof(sgl->sg[0]) *
+					    (MAX_SGL_ENTS + 1));
+	}
+
+	if (!ctx->used)
+		ctx->merge = 0;
+}
+
+static void skcipher_free_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	skcipher_pull_sgl(sk, ctx->used);
+}
+
+static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)
+{
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT)
+		return -EAGAIN;
+
+	set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	return err;
+}
+
+static void skcipher_wmem_wakeup(struct sock *sk)
+{
+	struct socket_wq *wq;
+
+	if (!skcipher_writable(sk))
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLIN |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
+	rcu_read_unlock();
+}
+
+static int skcipher_wait_for_data(struct sock *sk, unsigned flags)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT) {
+		return -EAGAIN;
+	}
+
+	set_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, ctx->used)) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	return err;
+}
+
+static void skcipher_data_wakeup(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct socket_wq *wq;
+
+	if (!ctx->used)
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLOUT |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);
+	rcu_read_unlock();
+}
+
+static int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+	unsigned ivsize = crypto_ablkcipher_ivsize(tfm);
+	struct skcipher_sg_list *sgl;
+	struct af_alg_control con = {};
+	long copied = 0;
+	bool enc = 0;
+	int err;
+	int i;
+
+	if (msg->msg_controllen) {
+		err = af_alg_cmsg_send(msg, &con);
+		if (err)
+			return err;
+
+		switch (con.op) {
+		case ALG_OP_ENCRYPT:
+			enc = 1;
+			break;
+		case ALG_OP_DECRYPT:
+			enc = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (con.iv && con.iv->ivlen != ivsize)
+			return -EINVAL;
+	}
+
+	err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!ctx->used) {
+		ctx->enc = enc;
+		if (con.iv)
+			memcpy(ctx->iv, con.iv->iv, ivsize);
+	}
+
+	while (size) {
+		struct scatterlist *sg;
+		unsigned long len = size;
+		int plen;
+
+		if (ctx->merge) {
+			sgl = list_entry(ctx->tsgl.prev,
+					 struct skcipher_sg_list, list);
+			sg = sgl->sg + sgl->cur - 1;
+			len = min_t(unsigned long, len,
+				    PAGE_SIZE - sg->offset - sg->length);
+
+			err = memcpy_fromiovec(page_address(sg_page(sg)) +
+					       sg->offset + sg->length,
+					       msg->msg_iov, len);
+			if (err)
+				goto unlock;
+
+			sg->length += len;
+			ctx->merge = (sg->offset + sg->length) &
+				     (PAGE_SIZE - 1);
+
+			ctx->used += len;
+			copied += len;
+			size -= len;
+			continue;
+		}
+
+		if (!skcipher_writable(sk)) {
+			err = skcipher_wait_for_wmem(sk, msg->msg_flags);
+			if (err)
+				goto unlock;
+		}
+
+		len = min_t(unsigned long, len, skcipher_sndbuf(sk));
+
+		err = skcipher_alloc_sgl(sk);
+		if (err)
+			goto unlock;
+
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+		sg = sgl->sg;
+		do {
+			i = sgl->cur;
+			plen = min_t(int, len, PAGE_SIZE);
+
+			sg_assign_page(sg + i, alloc_page(GFP_KERNEL));
+			err = -ENOMEM;
+			if (!sg_page(sg + i))
+				goto unlock;
+
+			err = memcpy_fromiovec(page_address(sg_page(sg + i)),
+					       msg->msg_iov, plen);
+			if (err) {
+				__free_page(sg_page(sg + i));
+				sg_assign_page(sg + i, NULL);
+				goto unlock;
+			}
+
+			sg[i].length = plen;
+			len -= plen;
+			ctx->used += plen;
+			copied += plen;
+			size -= plen;
+			sgl->cur++;
+		} while (len && sgl->cur < MAX_SGL_ENTS);
+
+		ctx->merge = plen & (PAGE_SIZE - 1);
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+static ssize_t skcipher_sendpage(struct socket *sock, struct page *page,
+				 int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	int err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!size)
+		goto done;
+
+	if (!skcipher_writable(sk)) {
+		err = skcipher_wait_for_wmem(sk, flags);
+		if (err)
+			goto unlock;
+	}
+
+	err = skcipher_alloc_sgl(sk);
+	if (err)
+		goto unlock;
+
+	ctx->merge = 0;
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+	get_page(page);
+	sg_set_page(sgl->sg + sgl->cur, page, size, offset);
+	sgl->cur++;
+	ctx->used += size;
+
+done:
+	ctx->more = flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t ignored, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(
+		&ctx->req));
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	unsigned long iovlen;
+	struct iovec *iov;
+	int err = -EAGAIN;
+	int used;
+	long copied = 0;
+
+	lock_sock(sk);
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			sgl = list_first_entry(&ctx->tsgl,
+					       struct skcipher_sg_list, list);
+			sg = sgl->sg;
+
+			while (!sg->length)
+				sg++;
+
+			used = ctx->used;
+			if (!used) {
+				err = skcipher_wait_for_data(sk, flags);
+				if (err)
+					goto unlock;
+			}
+
+			used = min_t(unsigned long, used, seglen);
+
+			used = af_alg_make_sg(&ctx->rsgl, from, used, 1);
+			err = used;
+			if (err < 0)
+				goto unlock;
+
+			if (ctx->more || used < ctx->used)
+				used -= used % bs;
+
+			err = -EINVAL;
+			if (!used)
+				goto free;
+
+			ablkcipher_request_set_crypt(&ctx->req, sg,
+						     ctx->rsgl.sg, used,
+						     ctx->iv);
+
+			err = af_alg_wait_for_completion(
+				ctx->enc ?
+					crypto_ablkcipher_encrypt(&ctx->req) :
+					crypto_ablkcipher_decrypt(&ctx->req),
+				&ctx->completion);
+
+free:
+			af_alg_free_sg(&ctx->rsgl);
+
+			if (err)
+				goto unlock;
+
+			copied += used;
+			from += used;
+			seglen -= used;
+			skcipher_pull_sgl(sk, used);
+		}
+	}
+
+	err = 0;
+
+unlock:
+	skcipher_wmem_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+
+static unsigned int skcipher_poll(struct file *file, struct socket *sock,
+				  poll_table *wait)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned int mask;
+
+	sock_poll_wait(file, sk_sleep(sk), wait);
+	mask = 0;
+
+	if (ctx->used)
+		mask |= POLLIN | POLLRDNORM;
+
+	if (skcipher_writable(sk))
+		mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
+
+	return mask;
+}
+
+static struct proto_ops algif_skcipher_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.accept		=	sock_no_accept,
+	.setsockopt	=	sock_no_setsockopt,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	skcipher_sendmsg,
+	.sendpage	=	skcipher_sendpage,
+	.recvmsg	=	skcipher_recvmsg,
+	.poll		=	skcipher_poll,
+};
+
+static void *skcipher_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ablkcipher(name, type, mask);
+}
+
+static void skcipher_release(void *private)
+{
+	crypto_free_ablkcipher(private);
+}
+
+static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ablkcipher_setkey(private, key, keylen);
+}
+
+static void skcipher_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+
+	skcipher_free_sgl(sk);
+	sock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int skcipher_accept_parent(void *private, struct sock *sk)
+{
+	struct skcipher_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),
+			       GFP_KERNEL);
+	if (!ctx->iv) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));
+
+	INIT_LIST_HEAD(&ctx->tsgl);
+	ctx->len = len;
+	ctx->used = 0;
+	ctx->more = 0;
+	ctx->merge = 0;
+	ctx->enc = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ablkcipher_request_set_tfm(&ctx->req, private);
+	ablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = skcipher_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_skcipher = {
+	.bind		=	skcipher_bind,
+	.release	=	skcipher_release,
+	.setkey		=	skcipher_setkey,
+	.accept		=	skcipher_accept_parent,
+	.ops		=	&algif_skcipher_ops,
+	.name		=	"skcipher",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_skcipher_init(void)
+{
+	return af_alg_register_type(&algif_type_skcipher);
+}
+
+static void __exit algif_skcipher_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_skcipher);
+	BUG_ON(err);
+}
+
+module_init(algif_skcipher_init);
+module_exit(algif_skcipher_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/net/core/sock.c
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/net/core/sock.c
@@ -157,7 +157,7 @@
   "sk_lock-27"       , "sk_lock-28"          , "sk_lock-AF_CAN"      ,
   "sk_lock-AF_TIPC"  , "sk_lock-AF_BLUETOOTH", "sk_lock-IUCV"        ,
   "sk_lock-AF_RXRPC" , "sk_lock-AF_ISDN"     , "sk_lock-AF_PHONET"   ,
-  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" ,
+  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" , "sk_lock-AF_ALG"      ,
   "sk_lock-AF_MAX"
 };
 static const char *const af_family_slock_key_strings[AF_MAX+1] = {
@@ -173,7 +173,7 @@
   "slock-27"       , "slock-28"          , "slock-AF_CAN"      ,
   "slock-AF_TIPC"  , "slock-AF_BLUETOOTH", "slock-AF_IUCV"     ,
   "slock-AF_RXRPC" , "slock-AF_ISDN"     , "slock-AF_PHONET"   ,
-  "slock-AF_IEEE802154", "slock-AF_CAIF" ,
+  "slock-AF_IEEE802154", "slock-AF_CAIF" , "slock-AF_ALG"      ,
   "slock-AF_MAX"
 };
 static const char *const af_family_clock_key_strings[AF_MAX+1] = {
@@ -189,7 +189,7 @@
   "clock-27"       , "clock-28"          , "clock-AF_CAN"      ,
   "clock-AF_TIPC"  , "clock-AF_BLUETOOTH", "clock-AF_IUCV"     ,
   "clock-AF_RXRPC" , "clock-AF_ISDN"     , "clock-AF_PHONET"   ,
-  "clock-AF_IEEE802154", "clock-AF_CAIF" ,
+  "clock-AF_IEEE802154", "clock-AF_CAIF" , "clock-AF_ALG"      ,
   "clock-AF_MAX"
 };
 
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/crypto/if_alg.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/crypto/if_alg.h
@@ -0,0 +1,92 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _CRYPTO_IF_ALG_H
+#define _CRYPTO_IF_ALG_H
+
+#include <linux/compiler.h>
+#include <linux/completion.h>
+#include <linux/if_alg.h>
+#include <linux/types.h>
+#include <net/sock.h>
+
+#define ALG_MAX_PAGES			16
+
+struct crypto_async_request;
+
+struct alg_sock {
+	/* struct sock must be the first member of struct alg_sock */
+	struct sock sk;
+
+	struct sock *parent;
+
+	const struct af_alg_type *type;
+	void *private;
+};
+
+struct af_alg_completion {
+	struct completion completion;
+	int err;
+};
+
+struct af_alg_control {
+	struct af_alg_iv *iv;
+	int op;
+};
+
+struct af_alg_type {
+	void *(*bind)(const char *name, u32 type, u32 mask);
+	void (*release)(void *private);
+	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
+	int (*accept)(void *private, struct sock *sk);
+
+	struct proto_ops *ops;
+	struct module *owner;
+	char name[14];
+};
+
+struct af_alg_sgl {
+	struct scatterlist sg[ALG_MAX_PAGES];
+	struct page *pages[ALG_MAX_PAGES];
+};
+
+int af_alg_register_type(const struct af_alg_type *type);
+int af_alg_unregister_type(const struct af_alg_type *type);
+
+int af_alg_release(struct socket *sock);
+int af_alg_accept(struct sock *sk, struct socket *newsock);
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write);
+void af_alg_free_sg(struct af_alg_sgl *sgl);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion);
+void af_alg_complete(struct crypto_async_request *req, int err);
+
+static inline struct alg_sock *alg_sk(struct sock *sk)
+{
+	return (struct alg_sock *)sk;
+}
+
+static inline void af_alg_release_parent(struct sock *sk)
+{
+	sock_put(alg_sk(sk)->parent);
+}
+
+static inline void af_alg_init_completion(struct af_alg_completion *completion)
+{
+	init_completion(&completion->completion);
+}
+
+#endif	/* _CRYPTO_IF_ALG_H */
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/crypto/scatterwalk.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/crypto/scatterwalk.h
@@ -68,6 +68,21 @@
 	return (++sg)->length ? sg : (void *)sg_page(sg);
 }
 
+static inline void scatterwalk_crypto_chain(struct scatterlist *head,
+					    struct scatterlist *sg,
+					    int chain, int num)
+{
+	if (chain) {
+		head->length += sg->length;
+		sg = scatterwalk_sg_next(sg);
+	}
+
+	if (sg)
+		scatterwalk_sg_chain(head, num, sg);
+	else
+		sg_mark_end(head);
+}
+
 static inline unsigned long scatterwalk_samebuf(struct scatter_walk *walk_in,
 						struct scatter_walk *walk_out)
 {
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/if_alg.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/if_alg.h
@@ -0,0 +1,40 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _LINUX_IF_ALG_H
+#define _LINUX_IF_ALG_H
+
+#include <linux/types.h>
+
+struct sockaddr_alg {
+	__u16	salg_family;
+	__u8	salg_type[14];
+	__u32	salg_feat;
+	__u32	salg_mask;
+	__u8	salg_name[64];
+};
+
+struct af_alg_iv {
+	__u32	ivlen;
+	__u8	iv[0];
+};
+
+/* Socket options */
+#define ALG_SET_KEY			1
+#define ALG_SET_IV			2
+#define ALG_SET_OP			3
+
+/* Operations */
+#define ALG_OP_DECRYPT			0
+#define ALG_OP_ENCRYPT			1
+
+#endif	/* _LINUX_IF_ALG_H */
--- a/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/socket.h
+++ b/release/src-rt-6.x.4708/linux/linux-2.6.36/include/linux/socket.h
@@ -193,7 +193,8 @@
 #define AF_PHONET	35	/* Phonet sockets		*/
 #define AF_IEEE802154	36	/* IEEE802154 sockets		*/
 #define AF_CAIF		37	/* CAIF sockets			*/
-#define AF_MAX		38	/* For now.. */
+#define AF_ALG		38	/* Algorithm sockets		*/
+#define AF_MAX		39	/* For now.. */
 
 /* Protocol families, same as address families. */
 #define PF_UNSPEC	AF_UNSPEC
@@ -234,6 +235,7 @@
 #define PF_PHONET	AF_PHONET
 #define PF_IEEE802154	AF_IEEE802154
 #define PF_CAIF		AF_CAIF
+#define PF_ALG		AF_ALG
 #define PF_MAX		AF_MAX
 
 /* Maximum queue length specifiable by listen.  */
@@ -310,6 +312,7 @@
 #define SOL_RDS		276
 #define SOL_IUCV	277
 #define SOL_CAIF	278
+#define SOL_ALG		279
 
 /* IPX options */
 #define IPX_TYPE	1
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/config_base.6a
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/config_base.6a
@@ -500,7 +500,7 @@
 CONFIG_NETFILTER_NETLINK_LOG=y
 CONFIG_NF_CONNTRACK=y
 CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
+CONFIG_NF_CONNTRACK_EVENTS=y
 # CONFIG_NF_CT_PROTO_DCCP is not set
 CONFIG_NF_CT_PROTO_GRE=m
 # CONFIG_NF_CT_PROTO_SCTP is not set
@@ -544,8 +544,17 @@
 # CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
 # CONFIG_NETFILTER_XT_TARGET_TEE is not set
 # CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETFILTER_XT_TARGET_ACCOUNT is not set
+CONFIG_NETFILTER_XT_TARGET_CHAOS=m
+CONFIG_NETFILTER_XT_TARGET_DELUDE=m
+# CONFIG_NETFILTER_XT_TARGET_ECHO is not set
+CONFIG_NETFILTER_XT_TARGET_RAWNAT=m
+CONFIG_NETFILTER_XT_TARGET_STEAL=m
+CONFIG_NETFILTER_XT_TARGET_TARPIT=m
 CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
 # CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7 is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG is not set
 
 #
 # Xtables matches
@@ -580,7 +589,7 @@
 # CONFIG_NETFILTER_XT_MATCH_SCTP is not set
 # CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
 CONFIG_NETFILTER_XT_MATCH_STATE=y
-# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
 CONFIG_NETFILTER_XT_MATCH_STRING=y
 CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
 CONFIG_NETFILTER_XT_MATCH_TIME=y
@@ -588,6 +597,13 @@
 CONFIG_NETFILTER_XT_MATCH_WEBSTR=y
 CONFIG_NETFILTER_XT_MATCH_CONDITION=m
 CONFIG_NETFILTER_XT_MATCH_GEOIP=m
+CONFIG_NETFILTER_XT_MATCH_FUZZY=m
+CONFIG_NETFILTER_XT_MATCH_IFACE=m
+CONFIG_NETFILTER_XT_MATCH_IPV4OPTIONS=m
+CONFIG_NETFILTER_XT_MATCH_LSCAN=m
+CONFIG_NETFILTER_XT_MATCH_PKNOCK=m
+CONFIG_NETFILTER_XT_MATCH_PSD=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=m
 CONFIG_IP_SET=m
 CONFIG_IP_SET_MAX=256
 CONFIG_IP_SET_BITMAP_IP=m
@@ -1059,7 +1075,28 @@
 # CONFIG_SATA_INIC162X is not set
 # CONFIG_SATA_SIL24 is not set
 # CONFIG_ATA_SFF is not set
-# CONFIG_MD is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MULTICORE_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=m
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_MULTIPATH_QL is not set
+# CONFIG_DM_MULTIPATH_ST is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
 # CONFIG_FUSION is not set
 
 #
@@ -1276,7 +1313,10 @@
 #
 # PPS support
 #
-# CONFIG_PPS is not set
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_LDISC=m
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -1309,14 +1349,14 @@
 # CONFIG_SOUND is not set
 CONFIG_HID_SUPPORT=y
 CONFIG_HID=m
-# CONFIG_HIDRAW is not set
+CONFIG_HIDRAW=y
 
 #
 # USB Input Devices
 #
 CONFIG_USB_HID=m
 # CONFIG_HID_PID is not set
-# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_HIDDEV=y
 
 #
 # USB HID Boot Protocol drivers
@@ -1463,13 +1503,13 @@
 # CONFIG_USB_SERIAL_AIRCABLE is not set
 # CONFIG_USB_SERIAL_ARK3116 is not set
 # CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
+CONFIG_USB_SERIAL_CH341=m
 # CONFIG_USB_SERIAL_WHITEHEAT is not set
 # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_CP210X is not set
+CONFIG_USB_SERIAL_CP210X=m
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
 # CONFIG_USB_SERIAL_FUNSOFT is not set
 # CONFIG_USB_SERIAL_VISOR is not set
 # CONFIG_USB_SERIAL_IPAQ is not set
@@ -1488,7 +1528,7 @@
 # CONFIG_USB_SERIAL_MOS7840 is not set
 # CONFIG_USB_SERIAL_MOTOROLA is not set
 # CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
+CONFIG_USB_SERIAL_PL2303=m
 # CONFIG_USB_SERIAL_OTI6858 is not set
 # CONFIG_USB_SERIAL_QCAUX is not set
 # CONFIG_USB_SERIAL_QUALCOMM is not set
@@ -1613,8 +1653,11 @@
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
@@ -1663,11 +1706,12 @@
 # CONFIG_JFFS2_CMODE_SIZE is not set
 # CONFIG_JFFS2_CMODE_FAVOURLZO is not set
 # CONFIG_LOGFS is not set
-# CONFIG_CRAMFS is not set
+CONFIG_CRAMFS=m
 CONFIG_SQUASHFS=y
 # CONFIG_SQUASHFS_XATTR is not set
 # CONFIG_SQUASHFS_LZO is not set
 CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
 CONFIG_SQUASHFS_EMBEDDED=y
 CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
 # CONFIG_VXFS_FS is not set
@@ -1860,7 +1904,7 @@
 CONFIG_CRYPTO_ECB=y
 # CONFIG_CRYPTO_LRW is not set
 # CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
+CONFIG_CRYPTO_XTS=m
 
 #
 # Hash modes
@@ -1877,41 +1921,42 @@
 # CONFIG_CRYPTO_MD4 is not set
 CONFIG_CRYPTO_MD5=y
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
 CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
 
 #
 # Ciphers
 #
 CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ANUBIS=m
 CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_DES=m
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
 
 #
 # Compression
 #
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=m
 
 #
 # Random Number Generation
@@ -1919,9 +1964,17 @@
 CONFIG_CRYPTO_ANSI_CPRNG=y
 CONFIG_CRYPTO_HW=y
 # CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X_RNG is not set
 # CONFIG_BINARY_PRINTF is not set
 
 #
+# User-space algorithms
+#
+CONFIG_CRYPTO_USER_API=m
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+
+#
 # Library routines
 #
 CONFIG_BITREVERSE=y
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
@@ -1868,8 +1868,20 @@
 	   are only processed once.  */
 	status = packet[0] & FTDI_STATUS_B0_MASK;
 	if (status != priv->prev_status) {
-		priv->diff_status |= status ^ priv->prev_status;
-		wake_up_interruptible(&priv->delta_msr_wait);
+                char diff_status = status ^ priv->prev_status;
+                priv->diff_status |= diff_status;
+        
+                if (diff_status & FTDI_RS0_RLSD) {
+                        struct tty_struct *tty;
+ 
+                        tty = tty_port_tty_get(&port->port);
+                        if (tty)
+                                usb_serial_handle_dcd_change(port, tty,
+                                                status & FTDI_RS0_RLSD);
+                        tty_kref_put(tty);
+                }
+
+                wake_up_interruptible(&priv->delta_msr_wait);
 		priv->prev_status = status;
 	}
 
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/serial/generic.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/drivers/usb/serial/generic.c
@@ -491,6 +491,15 @@
 	struct tty_port *port = &usb_port->port;
 
 	dbg("%s - port %d, status %d", __func__, usb_port->number, status);
+        if (tty) {
+               struct tty_ldisc *ld = tty_ldisc_ref(tty);
+
+               if (ld) {
+                       if (ld->ops->dcd_change)
+                               ld->ops->dcd_change(tty, status, NULL);
+                       tty_ldisc_deref(ld);
+               }
+        }
 
 	if (status)
 		wake_up_interruptible(&port->open_wait);

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/compat_nfinetaddr.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/compat_nfinetaddr.h
@@ -0,0 +1,14 @@
+#ifndef _COMPAT_NFINETADDR_H
+#define _COMPAT_NFINETADDR_H 1
+
+#include <linux/in.h>
+#include <linux/in6.h>
+
+union nf_inet_addr {
+	__be32 ip;
+	__be32 ip6[4];
+	struct in_addr in;
+	struct in6_addr in6;
+};
+
+#endif /* _COMPAT_NFINETADDR_H */

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/compat_rawpost.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/compat_rawpost.h
@@ -0,0 +1,87 @@
+#ifndef XTA_COMPAT_RAWPOST_H
+#define XTA_COMPAT_RAWPOST_H 1
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+typedef struct sk_buff sk_buff_t;
+#else
+typedef struct sk_buff *sk_buff_t;
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 21)
+#define XT_TARGET_INIT(__name, __size)					       \
+{									       \
+	.target.u.user = {						       \
+		.target_size	= XT_ALIGN(__size),			       \
+		.name		= __name,				       \
+	},								       \
+}
+
+#define IPT_ENTRY_INIT(__size)						       \
+{									       \
+	.target_offset	= sizeof(struct ipt_entry),			       \
+	.next_offset	= (__size),					       \
+}
+
+#define IPT_STANDARD_INIT(__verdict)					       \
+{									       \
+	.entry		= IPT_ENTRY_INIT(sizeof(struct ipt_standard)),	       \
+	.target		= XT_TARGET_INIT(IPT_STANDARD_TARGET,		       \
+					 sizeof(struct xt_standard_target)),   \
+	.target.verdict	= -(__verdict) - 1,				       \
+}
+
+#define IPT_ERROR_INIT							       \
+{									       \
+	.entry		= IPT_ENTRY_INIT(sizeof(struct ipt_error)),	       \
+	.target		= XT_TARGET_INIT(IPT_ERROR_TARGET,		       \
+					 sizeof(struct ipt_error_target)),     \
+	.target.errorname = "ERROR",					       \
+}
+
+#define IP6T_ENTRY_INIT(__size)						       \
+{									       \
+	.target_offset	= sizeof(struct ip6t_entry),			       \
+	.next_offset	= (__size),					       \
+}
+
+#define IP6T_STANDARD_INIT(__verdict)					       \
+{									       \
+	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_standard)),       \
+	.target		= XT_TARGET_INIT(IP6T_STANDARD_TARGET,		       \
+					 sizeof(struct ip6t_standard_target)), \
+	.target.verdict	= -(__verdict) - 1,				       \
+}
+
+#define IP6T_ERROR_INIT							       \
+{									       \
+	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_error)),	       \
+	.target		= XT_TARGET_INIT(IP6T_ERROR_TARGET,		       \
+					 sizeof(struct ip6t_error_target)),    \
+	.target.errorname = "ERROR",					       \
+}
+
+#endif /* 2.6.21 */
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
+#	include <linux/netfilter_ipv6/ip6_tables.h>
+/* Standard entry */
+struct ip6t_standard
+{
+	struct ip6t_entry entry;
+	struct ip6t_standard_target target;
+};
+
+struct ip6t_error_target
+{
+	struct ip6t_entry_target target;
+	char errorname[IP6T_FUNCTION_MAXNAMELEN];
+};
+
+struct ip6t_error
+{
+	struct ip6t_entry entry;
+	struct ip6t_error_target target;
+};
+#endif /* 2.6.20 */
+
+#endif /* XTA_COMPAT_RAWPOST_H */

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/compat_skbuff.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/compat_skbuff.h
@@ -0,0 +1,62 @@
+#ifndef COMPAT_SKBUFF_H
+#define COMPAT_SKBUFF_H 1
+
+struct tcphdr;
+struct udphdr;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 30)
+static inline void skb_dst_set(struct sk_buff *skb, struct dst_entry *dst)
+{
+	skb->dst = dst;
+}
+
+static inline struct dst_entry *skb_dst(const struct sk_buff *skb)
+{
+	return skb->dst;
+}
+
+static inline struct rtable *skb_rtable(const struct sk_buff *skb)
+{
+	return (void *)skb->dst;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+#	define skb_ifindex(skb) \
+		(((skb)->input_dev != NULL) ? (skb)->input_dev->ifindex : 0)
+#	define skb_nfmark(skb) (((struct sk_buff *)(skb))->nfmark)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 32)
+#	define skb_ifindex(skb) (skb)->iif
+#	define skb_nfmark(skb) (((struct sk_buff *)(skb))->mark)
+#else
+#	define skb_ifindex(skb) (skb)->skb_iif
+#	define skb_nfmark(skb) (((struct sk_buff *)(skb))->mark)
+#endif
+
+#ifdef CONFIG_NETWORK_SECMARK
+#	define skb_secmark(skb) ((skb)->secmark)
+#else
+#	define skb_secmark(skb) 0
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 21)
+#	define ip_hdr(skb) ((skb)->nh.iph)
+#	define ip_hdrlen(skb) (ip_hdr(skb)->ihl * 4)
+#	define ipv6_hdr(skb) ((skb)->nh.ipv6h)
+#	define skb_network_header(skb) ((skb)->nh.raw)
+#	define skb_transport_header(skb) ((skb)->h.raw)
+static inline void skb_reset_network_header(struct sk_buff *skb)
+{
+	skb->nh.raw = skb->data;
+}
+static inline struct tcphdr *tcp_hdr(const struct sk_buff *skb)
+{
+	return (void *)skb_transport_header(skb);
+}
+static inline struct udphdr *udp_hdr(const struct sk_buff *skb)
+{
+	return (void *)skb_transport_header(skb);
+}
+#endif
+
+#endif /* COMPAT_SKBUFF_H */

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/compat_xtables.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/compat_xtables.c
@@ -0,0 +1,638 @@
+/*
+ *	API compat layer
+ *	written by Jan Engelhardt <jengelh [at] medozas de>, 2008 - 2010
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License, either
+ *	version 2 of the License, or any later version.
+ */
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/kmod.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_arp.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <net/route.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+#	include <linux/export.h>
+#endif
+#include "compat_skbuff.h"
+#include "compat_xtnu.h"
+#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
+#	define WITH_IPV6 1
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 22)
+static int xtnu_match_run(const struct sk_buff *skb,
+    const struct net_device *in, const struct net_device *out,
+    const struct xt_match *cm, const void *matchinfo, int offset,
+    unsigned int protoff, int *hotdrop)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static bool xtnu_match_run(const struct sk_buff *skb,
+    const struct net_device *in, const struct net_device *out,
+    const struct xt_match *cm, const void *matchinfo, int offset,
+    unsigned int protoff, bool *hotdrop)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_match *nm = xtcompat_numatch(cm);
+	bool lo_ret;
+	struct xt_action_param local_par;
+	local_par.in        = in;
+	local_par.out       = out;
+	local_par.match     = cm;
+	local_par.matchinfo = matchinfo;
+	local_par.fragoff   = offset;
+	local_par.thoff     = protoff;
+	local_par.hotdrop   = false;
+	local_par.family    = NFPROTO_UNSPEC; /* don't have that info */
+
+	if (nm == NULL || nm->match == NULL)
+		return false;
+	lo_ret = nm->match(skb, &local_par);
+	*hotdrop = local_par.hotdrop;
+	return lo_ret;
+}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28) && \
+    LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+static bool xtnu_match_run(const struct sk_buff *skb,
+    const struct xt_match_param *par)
+{
+	struct xtnu_match *nm = xtcompat_numatch(par->match);
+	struct xt_action_param local_par;
+	bool ret;
+
+	local_par.in        = par->in;
+	local_par.out       = par->out;
+	local_par.match     = par->match;
+	local_par.matchinfo = par->matchinfo;
+	local_par.fragoff   = par->fragoff;
+	local_par.thoff     = par->thoff;
+	local_par.hotdrop   = false;
+	local_par.family    = par->family;
+
+	if (nm == NULL || nm->match == NULL)
+		return false;
+	ret = nm->match(skb, &local_par);
+	*par->hotdrop = local_par.hotdrop;
+	return ret;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static int xtnu_match_check(const char *table, const void *entry,
+    const struct xt_match *cm, void *matchinfo, unsigned int matchinfosize,
+    unsigned int hook_mask)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 22)
+static int xtnu_match_check(const char *table, const void *entry,
+    const struct xt_match *cm, void *matchinfo, unsigned int hook_mask)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static bool xtnu_match_check(const char *table, const void *entry,
+    const struct xt_match *cm, void *matchinfo, unsigned int hook_mask)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_match *nm = xtcompat_numatch(cm);
+	struct xt_mtchk_param local_par = {
+		.table     = table,
+		.entryinfo = entry,
+		.match     = cm,
+		.matchinfo = matchinfo,
+		.hook_mask = hook_mask,
+		.family    = NFPROTO_UNSPEC,
+	};
+
+	if (nm == NULL)
+		return false;
+	if (nm->checkentry == NULL)
+		return true;
+	return nm->checkentry(&local_par) == 0;
+}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28) && \
+    LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+static bool xtnu_match_check(const struct xt_mtchk_param *par)
+{
+	struct xtnu_match *nm = xtcompat_numatch(par->match);
+
+	if (nm == NULL)
+		return false;
+	if (nm->checkentry == NULL)
+		return true;
+	return nm->checkentry(par) == 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static void xtnu_match_destroy(const struct xt_match *cm, void *matchinfo,
+    unsigned int matchinfosize)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static void xtnu_match_destroy(const struct xt_match *cm, void *matchinfo)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_match *nm = xtcompat_numatch(cm);
+	struct xt_mtdtor_param local_par = {
+		.match     = cm,
+		.matchinfo = matchinfo,
+		.family    = NFPROTO_UNSPEC,
+	};
+
+	if (nm != NULL && nm->destroy != NULL)
+		nm->destroy(&local_par);
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+int xtnu_register_match(struct xtnu_match *nt)
+{
+	struct xt_match *ct;
+	char *tmp;
+	int ret;
+
+	ct = kzalloc(sizeof(struct xt_match), GFP_KERNEL);
+	if (ct == NULL)
+		return -ENOMEM;
+
+	tmp = (char *)ct->name;
+	memcpy(tmp, nt->name, sizeof(nt->name));
+	tmp = (char *)(ct->name + sizeof(ct->name) - sizeof(void *));
+	*(tmp-1) = '\0';
+	memcpy(tmp, &nt, sizeof(void *));
+
+	ct->revision   = nt->revision;
+	ct->family     = nt->family;
+	ct->table      = (char *)nt->table;
+	ct->hooks      = nt->hooks;
+	ct->proto      = nt->proto;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+	ct->match      = xtnu_match_run;
+	ct->checkentry = xtnu_match_check;
+	ct->destroy    = xtnu_match_destroy;
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+	ct->match      = xtnu_match_run;
+	ct->checkentry = xtnu_match_check;
+	ct->destroy    = nt->destroy;
+#else
+	ct->match      = nt->match;
+	ct->checkentry = xtnu_match_check;
+	ct->destroy    = nt->destroy;
+#endif
+	ct->matchsize  = nt->matchsize;
+	ct->me         = nt->me;
+
+	nt->__compat_match = ct;
+	ret = xt_register_match(ct);
+	if (ret != 0)
+		kfree(ct);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(xtnu_register_match);
+
+int xtnu_register_matches(struct xtnu_match *nt, unsigned int num)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < num; ++i) {
+		ret = xtnu_register_match(&nt[i]);
+		if (ret < 0) {
+			if (i > 0)
+				xtnu_unregister_matches(nt, i);
+			return ret;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xtnu_register_matches);
+
+void xtnu_unregister_match(struct xtnu_match *nt)
+{
+	xt_unregister_match(nt->__compat_match);
+	kfree(nt->__compat_match);
+}
+EXPORT_SYMBOL_GPL(xtnu_unregister_match);
+
+void xtnu_unregister_matches(struct xtnu_match *nt, unsigned int num)
+{
+	unsigned int i;
+
+	for (i = 0; i < num; ++i)
+		xtnu_unregister_match(&nt[i]);
+}
+EXPORT_SYMBOL_GPL(xtnu_unregister_matches);
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static unsigned int xtnu_target_run(struct sk_buff **pskb,
+    const struct net_device *in, const struct net_device *out,
+    unsigned int hooknum, const struct xt_target *ct, const void *targinfo,
+    void *userdata)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+static unsigned int xtnu_target_run(struct sk_buff **pskb,
+    const struct net_device *in, const struct net_device *out,
+    unsigned int hooknum, const struct xt_target *ct, const void *targinfo)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static unsigned int xtnu_target_run(struct sk_buff *skb,
+    const struct net_device *in, const struct net_device *out,
+    unsigned int hooknum, const struct xt_target *ct, const void *targinfo)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(ct);
+	struct xt_action_param local_par;
+
+	local_par.in       = in;
+	local_par.out      = out;
+	local_par.hooknum  = hooknum;
+	local_par.target   = ct;
+	local_par.targinfo = targinfo;
+	local_par.family   = NFPROTO_UNSPEC;
+
+	if (nt != NULL && nt->target != NULL)
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+		return nt->target(pskb, &local_par);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+		return nt->target(&skb, &local_par);
+#endif
+	return XT_CONTINUE;
+}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28) && \
+    LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+static unsigned int
+xtnu_target_run(struct sk_buff *skb, const struct xt_target_param *par)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(par->target);
+	struct xt_action_param local_par;
+
+	local_par.in       = par->in;
+	local_par.out      = par->out;
+	local_par.hooknum  = par->hooknum;
+	local_par.target   = par->target;
+	local_par.targinfo = par->targinfo;
+	local_par.family   = par->family;
+
+	return nt->target(&skb, &local_par);
+}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+static unsigned int
+xtnu_target_run(struct sk_buff *skb, const struct xt_action_param *par)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(par->target);
+
+	return nt->target(&skb, par);
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static int xtnu_target_check(const char *table, const void *entry,
+    const struct xt_target *ct, void *targinfo,
+    unsigned int targinfosize, unsigned int hook_mask)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 22)
+static int xtnu_target_check(const char *table, const void *entry,
+    const struct xt_target *ct, void *targinfo, unsigned int hook_mask)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static bool xtnu_target_check(const char *table, const void *entry,
+    const struct xt_target *ct, void *targinfo, unsigned int hook_mask)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(ct);
+	struct xt_tgchk_param local_par = {
+		.table     = table,
+		.entryinfo = entry,
+		.target    = ct,
+		.targinfo  = targinfo,
+		.hook_mask = hook_mask,
+		.family    = NFPROTO_UNSPEC,
+	};
+
+	if (nt == NULL)
+		return false;
+	if (nt->checkentry == NULL)
+		/* this is valid, just like if there was no function */
+		return true;
+	return nt->checkentry(&local_par) == 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28) && \
+    LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+static bool xtnu_target_check(const struct xt_tgchk_param *par)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(par->target);
+
+	if (nt == NULL)
+		return false;
+	if (nt->checkentry == NULL)
+		return true;
+	return nt->checkentry(par) == 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static void xtnu_target_destroy(const struct xt_target *ct, void *targinfo,
+    unsigned int targinfosize)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static void xtnu_target_destroy(const struct xt_target *ct, void *targinfo)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(ct);
+	struct xt_tgdtor_param local_par = {
+		.target   = ct,
+		.targinfo = targinfo,
+		.family   = NFPROTO_UNSPEC,
+	};
+
+	if (nt != NULL && nt->destroy != NULL)
+		nt->destroy(&local_par);
+}
+#endif
+
+int xtnu_register_target(struct xtnu_target *nt)
+{
+	struct xt_target *ct;
+	char *tmp;
+	int ret;
+
+	ct = kzalloc(sizeof(struct xt_target), GFP_KERNEL);
+	if (ct == NULL)
+		return -ENOMEM;
+
+	tmp = (char *)ct->name;
+	memcpy(tmp, nt->name, sizeof(nt->name));
+	tmp = (char *)(ct->name + sizeof(ct->name) - sizeof(void *));
+	*(tmp-1) = '\0';
+	memcpy(tmp, &nt, sizeof(void *));
+
+	ct->revision   = nt->revision;
+	ct->family     = nt->family;
+	ct->table      = (char *)nt->table;
+	ct->hooks      = nt->hooks;
+	ct->proto      = nt->proto;
+	ct->target     = xtnu_target_run;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+	ct->checkentry = xtnu_target_check;
+	ct->destroy    = xtnu_target_destroy;
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+	ct->checkentry = xtnu_target_check;
+	ct->destroy    = nt->destroy;
+#else
+	ct->checkentry = nt->checkentry;
+	ct->destroy    = nt->destroy;
+#endif
+	ct->targetsize = nt->targetsize;
+	ct->me         = nt->me;
+
+	nt->__compat_target = ct;
+	ret = xt_register_target(ct);
+	if (ret != 0)
+		kfree(ct);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(xtnu_register_target);
+
+int xtnu_register_targets(struct xtnu_target *nt, unsigned int num)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < num; ++i) {
+		ret = xtnu_register_target(&nt[i]);
+		if (ret < 0) {
+			if (i > 0)
+				xtnu_unregister_targets(nt, i);
+			return ret;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xtnu_register_targets);
+
+void xtnu_unregister_target(struct xtnu_target *nt)
+{
+	xt_unregister_target(nt->__compat_target);
+	kfree(nt->__compat_target);
+}
+EXPORT_SYMBOL_GPL(xtnu_unregister_target);
+
+void xtnu_unregister_targets(struct xtnu_target *nt, unsigned int num)
+{
+	unsigned int i;
+
+	for (i = 0; i < num; ++i)
+		xtnu_unregister_target(&nt[i]);
+}
+EXPORT_SYMBOL_GPL(xtnu_unregister_targets);
+
+struct xt_match *xtnu_request_find_match(unsigned int af, const char *name,
+    uint8_t revision)
+{
+	static const char *const xt_prefix[] = {
+		[AF_UNSPEC] = "x",
+		[AF_INET]   = "ip",
+		[AF_INET6]  = "ip6",
+#ifdef AF_ARP
+		[AF_ARP]    = "arp",
+#elif defined(NF_ARP) && NF_ARP != AF_UNSPEC
+		[NF_ARP]    = "arp",
+#endif
+	};
+	struct xt_match *match;
+
+	match = try_then_request_module(xt_find_match(af, name, revision),
+		"%st_%s", xt_prefix[af], name);
+	if (IS_ERR(match) || match == NULL)
+		return NULL;
+
+	return match;
+}
+EXPORT_SYMBOL_GPL(xtnu_request_find_match);
+
+int xtnu_ip_route_me_harder(struct sk_buff **pskb, unsigned int addr_type)
+{
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 17)
+	/* Actually this one is valid up to 2.6.18.4, but changed in 2.6.18.5 */
+	return ip_route_me_harder(pskb);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+	return ip_route_me_harder(pskb, addr_type);
+#else
+	return ip_route_me_harder(*pskb, addr_type);
+#endif
+}
+EXPORT_SYMBOL_GPL(xtnu_ip_route_me_harder);
+
+int xtnu_skb_make_writable(struct sk_buff **pskb, unsigned int len)
+{
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+	return skb_make_writable(pskb, len);
+#else
+	return skb_make_writable(*pskb, len);
+#endif
+}
+EXPORT_SYMBOL_GPL(xtnu_skb_make_writable);
+
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 24)
+static int __xtnu_ip_local_out(struct sk_buff *skb)
+{
+	struct iphdr *iph = ip_hdr(skb);
+
+	iph->tot_len = htons(skb->len);
+	ip_send_check(iph);
+	return nf_hook(PF_INET, NF_IP_LOCAL_OUT, skb, NULL,
+	               skb->dst->dev, dst_output);
+}
+
+int xtnu_ip_local_out(struct sk_buff *skb)
+{
+	int err;
+
+	err = __xtnu_ip_local_out(skb);
+	if (likely(err == 1))
+		err = dst_output(skb);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(xtnu_ip_local_out);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+static int __xtnu_ip_local_out(struct sk_buff **pskb)
+{
+	struct iphdr *iph = ip_hdr(*pskb);
+
+	iph->tot_len = htons((*pskb)->len);
+	ip_send_check(iph);
+	return nf_hook(PF_INET, NF_IP_LOCAL_OUT, pskb, NULL,
+	               (*pskb)->dst->dev, dst_output);
+}
+
+int xtnu_ip_local_out(struct sk_buff *skb)
+{
+	int err;
+
+	err = __xtnu_ip_local_out(&skb);
+	if (likely(err == 1))
+		err = dst_output(skb);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(xtnu_ip_local_out);
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 24)
+int xtnu_ip_route_output_key(void *net, struct rtable **rp, struct flowi *flp)
+{
+	return ip_route_output_flow(rp, flp, NULL, 0);
+}
+EXPORT_SYMBOL_GPL(xtnu_ip_route_output_key);
+
+void xtnu_proto_csum_replace4(__sum16 *sum, struct sk_buff *skb,
+    __be32 from, __be32 to, bool pseudohdr)
+{
+	__be32 diff[] = {~from, to};
+	const void *dv = diff; /* kludge for < v2.6.19-555-g72685fc */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+	if (skb->ip_summed != CHECKSUM_PARTIAL) {
+		*sum = csum_fold(csum_partial(dv, sizeof(diff),
+		       ~csum_unfold(*sum)));
+		if (skb->ip_summed == CHECKSUM_COMPLETE && pseudohdr)
+			skb->csum = ~csum_partial(dv, sizeof(diff),
+			            ~skb->csum);
+	} else if (pseudohdr) {
+		*sum = ~csum_fold(csum_partial(dv, sizeof(diff),
+		       csum_unfold(*sum)));
+	}
+#else
+	*sum = csum_fold(csum_partial(dv, sizeof(diff),
+	       ~csum_unfold(*sum)));
+#endif
+}
+EXPORT_SYMBOL_GPL(xtnu_proto_csum_replace4);
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+int xtnu_neigh_hh_output(struct hh_cache *hh, struct sk_buff *skb)
+{
+	unsigned int hh_alen;
+
+	read_lock_bh(&hh->hh_lock);
+	hh_alen = HH_DATA_ALIGN(hh->hh_len);
+	memcpy(skb->data - hh_alen, hh->hh_data, hh_alen);
+	read_unlock_bh(&hh->hh_lock);
+	skb_push(skb, hh->hh_len);
+	return hh->hh_output(skb);
+}
+EXPORT_SYMBOL_GPL(xtnu_neigh_hh_output);
+
+static inline __wsum xtnu_csum_unfold(__sum16 n)
+{
+	return (__force __wsum)n;
+}
+
+void xtnu_csum_replace4(__sum16 *sum, __be32 from, __be32 to)
+{
+	__be32 diff[] = {~from, to};
+	*sum = csum_fold(csum_partial((char *)diff, sizeof(diff),
+	       ~xtnu_csum_unfold(*sum)));
+}
+
+void xtnu_csum_replace2(__sum16 *sum, __be16 from, __be16 to)
+{
+	xtnu_csum_replace4(sum, (__force __be32)from, (__force __be32)to);
+}
+EXPORT_SYMBOL_GPL(xtnu_csum_replace2);
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 17)
+int xtnu_skb_linearize(struct sk_buff *skb)
+{
+	return skb_linearize(skb, GFP_ATOMIC);
+}
+EXPORT_SYMBOL_GPL(xtnu_skb_linearize);
+#endif
+
+void *HX_memmem(const void *space, size_t spacesize,
+    const void *point, size_t pointsize)
+{
+	size_t i;
+
+	if (pointsize > spacesize)
+		return NULL;
+	for (i = 0; i <= spacesize - pointsize; ++i)
+		if (memcmp(space + i, point, pointsize) == 0)
+			return (void *)space + i;
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(HX_memmem);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0) && defined(WITH_IPV6)
+int xtnu_ipv6_skip_exthdr(const struct sk_buff *skb, int start,
+    uint8_t *nexthdrp, __be16 *fragoffp)
+{
+	return ipv6_skip_exthdr(skb, start, nexthdrp);
+}
+EXPORT_SYMBOL_GPL(xtnu_ipv6_skip_exthdr);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0) && defined(WITH_IPV6)
+int xtnu_ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,
+    int target, unsigned short *fragoff, int *fragflg)
+{
+	return ipv6_find_hdr(skb, offset, target, fragoff);
+}
+EXPORT_SYMBOL_GPL(xtnu_ipv6_find_hdr);
+#endif
+
+MODULE_LICENSE("GPL");

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/compat_xtables.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/compat_xtables.h
@@ -0,0 +1,137 @@
+#ifndef _XTABLES_COMPAT_H
+#define _XTABLES_COMPAT_H 1
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include "compat_skbuff.h"
+#include "compat_xtnu.h"
+
+#define DEBUGP Use__pr_debug__instead
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 17)
+#	warning Kernels below 2.6.17 not supported.
+#endif
+
+#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
+#	if !defined(CONFIG_NF_CONNTRACK_MARK)
+#		warning You have CONFIG_NF_CONNTRACK enabled, but CONFIG_NF_CONNTRACK_MARK is not (please enable).
+#	endif
+#	include <net/netfilter/nf_conntrack.h>
+#elif defined(CONFIG_IP_NF_CONNTRACK) || defined(CONFIG_IP_NF_CONNTRACK_MODULE)
+#	if !defined(CONFIG_IP_NF_CONNTRACK_MARK)
+#		warning You have CONFIG_IP_NF_CONNTRACK enabled, but CONFIG_IP_NF_CONNTRACK_MARK is not (please enable).
+#	endif
+#	include <linux/netfilter_ipv4/ip_conntrack.h>
+#	define nf_conn ip_conntrack
+#	define nf_ct_get ip_conntrack_get
+#	define nf_conntrack_untracked ip_conntrack_untracked
+#else
+#	warning You need either CONFIG_NF_CONNTRACK or CONFIG_IP_NF_CONNTRACK.
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 17)
+#	define skb_init_secmark(skb)
+#	define skb_linearize	xtnu_skb_linearize
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+#	define neigh_hh_output xtnu_neigh_hh_output
+#	define IPPROTO_UDPLITE 136
+#	define CSUM_MANGLED_0 ((__force __sum16)0xffff)
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 24)
+#	define NF_INET_PRE_ROUTING  NF_IP_PRE_ROUTING
+#	define NF_INET_LOCAL_IN     NF_IP_LOCAL_IN
+#	define NF_INET_FORWARD      NF_IP_FORWARD
+#	define NF_INET_LOCAL_OUT    NF_IP_LOCAL_OUT
+#	define NF_INET_POST_ROUTING NF_IP_POST_ROUTING
+#	define ip_local_out         xtnu_ip_local_out
+#	define ip_route_output_key  xtnu_ip_route_output_key
+#	include "compat_nfinetaddr.h"
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+#	define init_net               xtnu_ip_route_output_key /* yes */
+#	define init_net__loopback_dev (&loopback_dev)
+#	define init_net__proc_net     proc_net
+#else
+#	define init_net__loopback_dev init_net.loopback_dev
+#	define init_net__proc_net     init_net.proc_net
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+#	define xt_match              xtnu_match
+#	define xt_register_match     xtnu_register_match
+#	define xt_unregister_match   xtnu_unregister_match
+#	define xt_register_matches   xtnu_register_matches
+#	define xt_unregister_matches xtnu_unregister_matches
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+#	define csum_replace2 xtnu_csum_replace2
+#	define csum_replace4 xtnu_csum_replace4
+#	define inet_proto_csum_replace4 xtnu_proto_csum_replace4
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 24)
+#	define csum_replace2 nf_csum_replace2
+#	define csum_replace4 nf_csum_replace4
+#	define inet_proto_csum_replace4 xtnu_proto_csum_replace4
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+#	define ipt_unregister_table(tbl) ipt_unregister_table(&init_net, (tbl))
+#	define ip6t_unregister_table(tbl) ip6t_unregister_table(&init_net, (tbl))
+#else
+#	define ipt_unregister_table(tbl) ipt_unregister_table(tbl)
+#	define ip6t_unregister_table(tbl) ip6t_unregister_table(tbl)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+#	define rt_dst(rt)	(&(rt)->dst)
+#else
+#	define rt_dst(rt)	(&(rt)->u.dst)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0)
+#	define nf_nat_ipv4_multi_range_compat nf_nat_multi_range_compat
+#	define nf_nat_ipv4_range nf_nat_range
+#	define NF_NAT_RANGE_MAP_IPS IP_NAT_RANGE_MAP_IPS
+#	define ipv6_skip_exthdr xtnu_ipv6_skip_exthdr
+#endif
+
+#if !defined(NIP6) && !defined(NIP6_FMT)
+#	define NIP6(addr) \
+		ntohs((addr).s6_addr16[0]), \
+		ntohs((addr).s6_addr16[1]), \
+		ntohs((addr).s6_addr16[2]), \
+		ntohs((addr).s6_addr16[3]), \
+		ntohs((addr).s6_addr16[4]), \
+		ntohs((addr).s6_addr16[5]), \
+		ntohs((addr).s6_addr16[6]), \
+		ntohs((addr).s6_addr16[7])
+#	define NIP6_FMT "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x"
+#endif
+#if !defined(NIPQUAD) && !defined(NIPQUAD_FMT)
+#	define NIPQUAD(addr) \
+		((const unsigned char *)&addr)[0], \
+		((const unsigned char *)&addr)[1], \
+		((const unsigned char *)&addr)[2], \
+		((const unsigned char *)&addr)[3]
+#	define NIPQUAD_FMT "%u.%u.%u.%u"
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
+#	define ipv6_find_hdr xtnu_ipv6_find_hdr
+#endif
+
+#define ip_route_me_harder    xtnu_ip_route_me_harder
+#define skb_make_writable     xtnu_skb_make_writable
+#define xt_target             xtnu_target
+#define xt_register_target    xtnu_register_target
+#define xt_unregister_target  xtnu_unregister_target
+#define xt_register_targets   xtnu_register_targets
+#define xt_unregister_targets xtnu_unregister_targets
+
+#define xt_request_find_match xtnu_request_find_match
+
+#endif /* _XTABLES_COMPAT_H */

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/compat_xtnu.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/compat_xtnu.h
@@ -0,0 +1,172 @@
+#ifndef _COMPAT_XTNU_H
+#define _COMPAT_XTNU_H 1
+
+#include <linux/list.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/spinlock.h>
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+typedef _Bool bool;
+enum { false = 0, true = 1, };
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+typedef __u16 __bitwise __sum16;
+typedef __u32 __bitwise __wsum;
+#endif
+
+struct flowi;
+struct hh_cache;
+struct module;
+struct net_device;
+struct rtable;
+struct sk_buff;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+enum {
+	NFPROTO_UNSPEC =  0,
+	NFPROTO_IPV4   =  2,
+	NFPROTO_ARP    =  3,
+	NFPROTO_BRIDGE =  7,
+	NFPROTO_IPV6   = 10,
+	NFPROTO_DECNET = 12,
+	NFPROTO_NUMPROTO,
+};
+
+struct xt_mtchk_param {
+	const char *table;
+	const void *entryinfo;
+	const struct xt_match *match;
+	void *matchinfo;
+	unsigned int hook_mask;
+	u_int8_t family;
+};
+
+struct xt_mtdtor_param {
+	const struct xt_match *match;
+	void *matchinfo;
+	u_int8_t family;
+};
+
+struct xt_target_param {
+	const struct net_device *in, *out;
+	unsigned int hooknum;
+	const struct xt_target *target;
+	const void *targinfo;
+	u_int8_t family;
+};
+
+struct xt_tgchk_param {
+	const char *table;
+	const void *entryinfo;
+	const struct xt_target *target;
+	void *targinfo;
+	unsigned int hook_mask;
+	u_int8_t family;
+};
+
+struct xt_tgdtor_param {
+	const struct xt_target *target;
+	void *targinfo;
+	u_int8_t family;
+};
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+struct xt_action_param {
+	union {
+		const struct xt_match *match;
+		const struct xt_target *target;
+	};
+	union {
+		const void *matchinfo, *targinfo;
+	};
+	const struct net_device *in, *out;
+	int fragoff;
+	unsigned int thoff, hooknum;
+	u_int8_t family;
+	bool hotdrop;
+};
+#endif
+
+struct xtnu_match {
+	/*
+	 * Making it smaller by sizeof(void *) on purpose to catch
+	 * lossy translation, if any.
+	 */
+	char name[sizeof(((struct xt_match *)NULL)->name) - 1 - sizeof(void *)];
+	uint8_t revision;
+	bool (*match)(const struct sk_buff *, struct xt_action_param *);
+	int (*checkentry)(const struct xt_mtchk_param *);
+	void (*destroy)(const struct xt_mtdtor_param *);
+	struct module *me;
+	const char *table;
+	unsigned int matchsize, hooks;
+	unsigned short proto, family;
+
+	void *__compat_match;
+};
+
+struct xtnu_target {
+	char name[sizeof(((struct xt_target *)NULL)->name) - 1 - sizeof(void *)];
+	uint8_t revision;
+	unsigned int (*target)(struct sk_buff **,
+		const struct xt_action_param *);
+	int (*checkentry)(const struct xt_tgchk_param *);
+	void (*destroy)(const struct xt_tgdtor_param *);
+	struct module *me;
+	const char *table;
+	unsigned int targetsize, hooks;
+	unsigned short proto, family;
+
+	void *__compat_target;
+};
+
+static inline struct xtnu_match *xtcompat_numatch(const struct xt_match *m)
+{
+	void *q;
+	memcpy(&q, m->name + sizeof(m->name) - sizeof(void *), sizeof(void *));
+	return q;
+}
+
+static inline struct xtnu_target *xtcompat_nutarget(const struct xt_target *t)
+{
+	void *q;
+	memcpy(&q, t->name + sizeof(t->name) - sizeof(void *), sizeof(void *));
+	return q;
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+static inline __wsum csum_unfold(__sum16 n)
+{
+	return (__force __wsum)n;
+}
+#endif
+
+extern int xtnu_ip_local_out(struct sk_buff *);
+extern int xtnu_ip_route_me_harder(struct sk_buff **, unsigned int);
+extern int xtnu_skb_make_writable(struct sk_buff **, unsigned int);
+extern int xtnu_register_match(struct xtnu_match *);
+extern int xtnu_ip_route_output_key(void *, struct rtable **, struct flowi *);
+extern void xtnu_unregister_match(struct xtnu_match *);
+extern int xtnu_register_matches(struct xtnu_match *, unsigned int);
+extern void xtnu_unregister_matches(struct xtnu_match *, unsigned int);
+extern int xtnu_register_target(struct xtnu_target *);
+extern void xtnu_unregister_target(struct xtnu_target *);
+extern int xtnu_register_targets(struct xtnu_target *, unsigned int);
+extern void xtnu_unregister_targets(struct xtnu_target *, unsigned int);
+extern struct xt_match *xtnu_request_find_match(unsigned int,
+	const char *, uint8_t);
+extern int xtnu_neigh_hh_output(struct hh_cache *, struct sk_buff *);
+extern void xtnu_csum_replace2(__u16 __bitwise *, __be16, __be16);
+extern void xtnu_csum_replace4(__u16 __bitwise *, __be32, __be32);
+extern void xtnu_proto_csum_replace4(__u16 __bitwise *, struct sk_buff *,
+	__be32, __be32, bool);
+extern int xtnu_skb_linearize(struct sk_buff *);
+extern int xtnu_ipv6_skip_exthdr(const struct sk_buff *, int,
+	uint8_t *, __be16 *);
+extern int xtnu_ipv6_find_hdr(const struct sk_buff *, unsigned int *,
+	int, unsigned short *, int *);
+
+extern void *HX_memmem(const void *, size_t, const void *, size_t);
+
+#endif /* _COMPAT_XTNU_H */

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/ip6table_rawpost.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/ip6table_rawpost.c
@@ -0,0 +1,107 @@
+/*
+ *	rawpost table for ip6_tables
+ *	written by Jan Engelhardt <jengelh [at] medozas de>, 2008 - 2009
+ *	placed in the Public Domain
+ */
+#include <linux/module.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <net/ip.h>
+#include "compat_xtables.h"
+#include "compat_rawpost.h"
+
+enum {
+	RAWPOST_VALID_HOOKS = 1 << NF_INET_POST_ROUTING,
+};
+
+static struct {
+	struct ip6t_replace repl;
+	struct ip6t_standard entries[1];
+	struct ip6t_error term;
+} rawpost6_initial __initdata = {
+	.repl = {
+		.name        = "rawpost",
+		.valid_hooks = RAWPOST_VALID_HOOKS,
+		.num_entries = 2,
+		.size        = sizeof(struct ip6t_standard) +
+		               sizeof(struct ip6t_error),
+		.hook_entry  = {
+			[NF_INET_POST_ROUTING] = 0,
+		},
+		.underflow = {
+			[NF_INET_POST_ROUTING] = 0,
+		},
+	},
+	.entries = {
+		IP6T_STANDARD_INIT(NF_ACCEPT),	/* POST_ROUTING */
+	},
+	.term = IP6T_ERROR_INIT,		/* ERROR */
+};
+
+static struct xt_table *rawpost6_ptable;
+
+static struct xt_table rawpost6_itable = {
+	.name        = "rawpost",
+	.af          = NFPROTO_IPV6,
+	.valid_hooks = RAWPOST_VALID_HOOKS,
+	.me          = THIS_MODULE,
+};
+
+static unsigned int rawpost6_hook_fn(unsigned int hook, sk_buff_t *skb,
+    const struct net_device *in, const struct net_device *out,
+    int (*okfn)(struct sk_buff *))
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+	return ip6t_do_table(skb, hook, in, out, rawpost6_ptable);
+#else
+	return ip6t_do_table(skb, hook, in, out, rawpost6_ptable, NULL);
+#endif
+}
+
+static struct nf_hook_ops rawpost6_hook_ops __read_mostly = {
+	.hook     = rawpost6_hook_fn,
+	.pf       = NFPROTO_IPV6,
+	.hooknum  = NF_INET_POST_ROUTING,
+	.priority = NF_IP6_PRI_LAST,
+	.owner    = THIS_MODULE,
+};
+
+static int __init rawpost6_table_init(void)
+{
+	int ret;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 29)
+	rwlock_init(&rawpost6_itable.lock);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	rawpost6_ptable = ip6t_register_table(&init_net, &rawpost6_itable,
+	                  &rawpost6_initial.repl);
+	if (IS_ERR(rawpost6_ptable))
+		return PTR_ERR(rawpost6_ptable);
+#else
+	ret = ip6t_register_table(&rawpost6_itable, &rawpost6_initial.repl);
+	if (ret < 0)
+		return ret;
+	rawpost6_ptable = &rawpost6_itable;
+#endif
+
+	ret = nf_register_hook(&rawpost6_hook_ops);
+	if (ret < 0)
+		goto out;
+
+	return ret;
+
+ out:
+	ip6t_unregister_table(rawpost6_ptable);
+	return ret;
+}
+
+static void __exit rawpost6_table_exit(void)
+{
+	nf_unregister_hook(&rawpost6_hook_ops);
+	ip6t_unregister_table(rawpost6_ptable);
+}
+
+module_init(rawpost6_table_init);
+module_exit(rawpost6_table_exit);
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/iptable_rawpost.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/iptable_rawpost.c
@@ -0,0 +1,109 @@
+/*
+ *	rawpost table for ip_tables
+ *	written by Jan Engelhardt <jengelh [at] medozas de>, 2008 - 2009
+ *	placed in the Public Domain
+ */
+#include <linux/module.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/version.h>
+#include <net/ip.h>
+#include "compat_xtables.h"
+#include "compat_rawpost.h"
+
+enum {
+	RAWPOST_VALID_HOOKS = 1 << NF_INET_POST_ROUTING,
+};
+
+static struct {
+	struct ipt_replace repl;
+	struct ipt_standard entries[1];
+	struct ipt_error term;
+} rawpost4_initial __initdata = {
+	.repl = {
+		.name        = "rawpost",
+		.valid_hooks = RAWPOST_VALID_HOOKS,
+		.num_entries = 2,
+		.size        = sizeof(struct ipt_standard) +
+		               sizeof(struct ipt_error),
+		.hook_entry  = {
+			[NF_INET_POST_ROUTING] = 0,
+		},
+		.underflow = {
+			[NF_INET_POST_ROUTING] = 0,
+		},
+	},
+	.entries = {
+		IPT_STANDARD_INIT(NF_ACCEPT),	/* POST_ROUTING */
+	},
+	.term = IPT_ERROR_INIT,			/* ERROR */
+};
+
+static struct xt_table *rawpost4_ptable;
+
+static struct xt_table rawpost4_itable = {
+	.name        = "rawpost",
+	.af          = NFPROTO_IPV4,
+	.valid_hooks = RAWPOST_VALID_HOOKS,
+	.me          = THIS_MODULE,
+};
+
+static unsigned int rawpost4_hook_fn(unsigned int hook, sk_buff_t *skb,
+    const struct net_device *in, const struct net_device *out,
+    int (*okfn)(struct sk_buff *))
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+	return ipt_do_table(skb, hook, in, out, rawpost4_ptable);
+#else
+	return ipt_do_table(skb, hook, in, out, rawpost4_ptable, NULL);
+#endif
+}
+
+static struct nf_hook_ops rawpost4_hook_ops __read_mostly = {
+	.hook     = rawpost4_hook_fn,
+	.pf       = NFPROTO_IPV4,
+	.hooknum  = NF_INET_POST_ROUTING,
+	.priority = NF_IP_PRI_LAST,
+	.owner    = THIS_MODULE,
+};
+
+static int __init rawpost4_table_init(void)
+{
+	int ret;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 29)
+	rwlock_init(&rawpost4_itable.lock);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	rawpost4_ptable = ipt_register_table(&init_net, &rawpost4_itable,
+	                  &rawpost4_initial.repl);
+	if (IS_ERR(rawpost4_ptable))
+		return PTR_ERR(rawpost4_ptable);
+#else
+	ret = ipt_register_table(&rawpost4_itable, &rawpost4_initial.repl);
+	if (ret < 0)
+		return ret;
+	rawpost4_ptable = &rawpost4_itable;
+#endif
+
+	ret = nf_register_hook(&rawpost4_hook_ops);
+	if (ret < 0)
+		goto out;
+
+	return ret;
+
+ out:
+	ipt_unregister_table(rawpost4_ptable);
+	return ret;
+}
+
+static void __exit rawpost4_table_exit(void)
+{
+	nf_unregister_hook(&rawpost4_hook_ops);
+	ipt_unregister_table(rawpost4_ptable);
+}
+
+module_init(rawpost4_table_init);
+module_exit(rawpost4_table_exit);
+MODULE_DESCRIPTION("Xtables: rawpost table for use with RAWNAT");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/Kconfig
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/Kconfig
@@ -589,7 +589,204 @@
 	  packets, for use with security subsystems.
 
 	  To compile it as a module, choose M here.  If unsure, say N.
+	  
+config NETFILTER_XT_TARGET_ACCOUNT
+	tristate '"ACCOUNT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The ACCOUNT target is a high performance accounting system for large
+	  local networks. It allows per-IP accounting in whole prefixes of IPv4
+	  addresses with size of up to /8 without the need to add individual
+	  accouting rule for each IP address.
+
+	  The ACCOUNT is designed to be queried for data every second or at
+	  least every ten seconds. It is written as kernel module to handle high
+	  bandwidths without packet loss.
+
+	  The largest possible subnet size is 24 bit, meaning for example 10.0.0.0/8
+	  network. ACCOUNT uses fixed internal data structures
+	  which speeds up the processing of each packet. Furthermore,
+	  accounting data for one complete 192.168.1.X/24 network takes 4 KB of
+	  memory. Memory for 16 or 24 bit networks is only allocated when
+	  needed.
+
+	  To optimize the kernel<->userspace data transfer a bit more, the
+	  kernel module only transfers information about IPs, where the src/dst
+	  packet counter is not 0. This saves precious kernel time.
+
+	  There is no /proc interface as it would be too slow for continuous access.
+	  The read-and-flush query operation is the fastest, as no internal data
+	  snapshot needs to be created&copied for all data. Use the "read"
+	  operation without flush only for debugging purposes!
+
+	  Usage:
+
+	  ACCOUNT takes two mandatory parameters:
+
+	  --addr network/netmask
+	  where network/netmask is the subnet to account for, in CIDR syntax
+
+	  --tname NAME
+	  where NAME is the name of the table where the accounting information
+	  should be stored
+
+	  The subnet 0.0.0.0/0 is a special case: all data are then stored in the src_bytes
+	  and src_packets structure of slot "0". This is useful if you want
+	  to account the overall traffic to/from your internet provider.
+
+	  The data can be queried using the userspace libxt_ACCOUNT_cl library,
+	  and by the reference implementation to show usage of this library,
+	  the iptaccount(8) tool.
+
+	  Here is an example of use:
+
+	  iptables -A FORWARD -j ACCOUNT --addr 0.0.0.0/0 --tname all_outgoing;
+	  iptables -A FORWARD -j ACCOUNT --addr 192.168.1.0/24 --tname sales;
+
+	  This creates two tables called "all_outgoing" and "sales" which can be
+	  queried using the userspace library/iptaccount tool.
+
+	  Note that this target is non-terminating, the packet destined to it
+	  will continue traversing the chain in which it has been used.
+
+	  Also note that once a table has been defined for specific CIDR address/netmask
+	  block, it can be referenced multiple times using -j ACCOUNT, provided
+	  that both the original table name and address/netmask block are specified.
+
+	  For more information go to http://www.intra2net.com/en/developer/ipt_ACCOUNT/
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_TARGET_CHAOS
+	tristate '"CHAOS" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Causes confusion on the other end by doing odd things with incoming packets.
+	  CHAOS will randomly reply (or not) with one of its configurable subtargets:
+
+	  --delude
+	  Use the REJECT and DELUDE targets as a base to do a sudden or deferred
+	  connection reset, fooling some network scanners to return non-deterministic
+	  (randomly open/closed) results, and in case it is deemed open, it is actually
+	  closed/filtered.
+
+	  --tarpit
+	  Use the REJECT and TARPIT target as a base to hold the connection until it
+	  times out. This consumes conntrack entries when connection tracking is loaded
+	  (which usually is on most machines), and routers inbetween you and the Internet
+	  may fail to do their connection tracking if they have to handle more
+	  connections than they can.
+
+	  The randomness factor of not replying vs. replying can be set during load-time
+	  of the xt_CHAOS module or during runtime in /sys/modules/xt_CHAOS/parameters.
+
+	  See http://jengelh.medozas.de/projects/chaostables/ for more information
+	  about CHAOS, DELUDE and lscan.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_TARGET_DELUDE
+	tristate '"DELUDE" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The DELUDE target will reply to a SYN packet with SYN-ACK, and to all other
+	  packets with an RST. This will terminate the connection much like REJECT, but
+	  network scanners doing TCP half-open discovery can be spoofed to make them
+	  belive the port is open rather than closed/filtered.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_ECHO
+	tristate '"ECHO" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The ECHO target will send back all packets it received. It serves as an
+	  examples for an Xtables target.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_RAWNAT
+	tristate '"RAWNAT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The RAWSNAT and RAWDNAT targets provide stateless network address
+	  translation.
+
+	  The RAWDNAT target will rewrite the destination address in the IP header,
+	  much like the NETMAP target.
+
+	  --to-destination addr[/mask]
+	  Network address to map to. The resulting address will be constructed the
+	  following way: All 'one' bits in the mask are filled in from the new
+	  address. All bits that are zero in the mask are filled in from the
+	  original address.
+
+	  The RAWSNAT target will rewrite the source address in the IP header, much
+	  like the NETMAP target. RAWSNAT (and RAWDNAT) may only be
+	  used in the raw or rawpost tables, but can be used in all chains,
+	  which makes it possible to change the source address either when the packet
+	  enters the machine or when it leaves it. The reason for this table constraint
+	  is that RAWNAT must happen outside of connection tracking.
+
+	  --to-source addr[/mask]
+	  Network address to map to. The resulting address will be constructed the
+	  following way: All 'one' bits in the mask are filled in from the new
+	  address. All bits that are zero in the mask are filled in from the
+	  original address.
+
+	  As an example, changing the destination for packets forwarded from an internal
+	  LAN to the internet:
+
+	  -t raw -A PREROUTING -i lan0 -d 212.201.100.135 -j RAWDNAT --to-destination 199.181.132.250;
+	  -t rawpost -A POSTROUTING -o lan0 -s 199.181.132.250 -j RAWSNAT --to-source 212.201.100.135;
+
+	  Note that changing addresses may influence the route selection! Specifically,
+	  it statically NATs packets, not connections, like the normal DNAT/SNAT targets
+	  would do. Also note that it can transform already-NATed connections, as
+	  said, it is completely external to Netfilter's connection tracking/NAT.
+
+	  If the machine itself generates packets that are to be rawnat'ed, you need a
+	  rule in the OUTPUT chain instead, just like you would with the stateful NAT
+	  targets.
+
+	  It may be necessary that in doing so, you also need an extra RAWSNAT rule, to
+	  override the automatic source address selection that the routing code does
+	  before passing packets to iptables. If the connecting socket has not been
+	  explicitly bound to an address, as is the common mode of operation, the address
+	  that will be chosen is the primary address of the device through which the
+	  packet would be routed with its initial destination address - the address as
+	  seen before any RAWNAT takes place.
 
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_STEAL
+	tristate '"STEAL" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Like the DROP target, but does not throw an error like DROP when used in the
+	  OUTPUT chain.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+	  
+config NETFILTER_XT_TARGET_TARPIT
+	tristate '"TARPIT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Adds a TARPIT target to iptables, which captures and holds
+	  incoming TCP connections using no local per-connection resources.
+	  Connections are accepted, but immediately switched to the persist
+	  state (0 byte window), in which the remote side stops sending data
+	  and asks to continue every 60-240 seconds. Attempts to close the
+	  connection are ignored, forcing the remote side to time out the
+	  connection in 12-24 minutes.
+
+	  This offers similar functionality to LaBrea
+	  <http://www.hackbusters.net/LaBrea/>, but does not require dedicated
+	  hardware or IPs. Any TCP port that you would normally DROP or REJECT
+	  can instead become a tarpit.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+	  
 config NETFILTER_XT_TARGET_TCPMSS
 	tristate '"TCPMSS" target support'
 	depends on (IPV6 || IPV6=n)
@@ -1117,6 +1314,350 @@
           <file:Documentation/modules.txt>.  The module will be
           called `ipt_geoip'.  If unsure, say `N'.
 
+config NETFILTER_XT_MATCH_FUZZY
+	tristate '"MATCH" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  This module matches a rate limit based on a fuzzy logic controller (FLC).
+
+	  --lower-limit number
+	  Specifies the lower limit, in packets per second.
+
+	  --upper-limit number
+	  Specifies the upper limit, also in packets per second.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_IFACE
+	tristate '"IFACE" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Allows you to check interface states. First, an interface needs to be selected
+	  for comparison. Exactly one option of the following three must be specified:
+
+	  --iface name
+	  Check the states on the given interface.
+
+	  --dev-in
+	  Check the states on the interface on which the packet came in. If the input
+	  device is not set, because for example you are using -m iface in the OUTPUT
+	  chain, this submatch returns false.
+
+	  --dev-out
+	  Check the states on the interface on which the packet will go out. If the
+	  output device is not set, because for example you are using -m iface in the
+	  INPUT chain, this submatch returns false.
+
+	  Following that, one can select the interface properties to check for:
+
+	  [!] --up, [!] --down
+	  Check the UP flag.
+
+	  [!] --broadcast
+	  Check the BROADCAST flag.
+
+	  [!] --loopback
+	  Check the LOOPBACK flag.
+
+	  [!] --pointtopoint
+	  Check the POINTTOPOINT flag.
+
+	  [!] --running
+	  Check the RUNNING flag. Do NOT rely on it!
+
+	  [!] --noarp, [!] --arp
+	  Check the NOARP flag.
+
+	  [!] --promisc
+	  Check the PROMISC flag.
+
+	  [!] --multicast
+	  Check the MULTICAST flag.
+
+	  [!] --dynamic
+	  Check the DYNAMIC flag.
+
+	  [!] --lower-up
+	  Check the LOWER_UP flag.
+
+	  [!] --dormant
+	  Check the DORMANT flag.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_IPV4OPTIONS
+	tristate '"IPV4OPTIONS" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The "ipv4options" module allows to match against a set of IPv4 header options.
+
+	  --flags [!]symbol[,[!]symbol...]
+	  Specify the options that shall appear or not appear in the header. Each
+	  symbol specification is delimited by a comma, and a '!' can be prefixed to
+	  a symbol to negate its presence. Symbols are either the name of an IPv4 option
+	  or its number. See examples below.
+
+	  --any
+	  By default, all of the flags specified must be present/absent, that is, they
+	  form an AND condition. Use the --any flag instead to use an OR condition
+	  where only at least one symbol spec must be true.
+
+	  Known symbol names (and their number):
+
+	  1 nop
+	  2 security RFC 1108
+	  3 lsrr Loose Source Routing, RFC 791
+	  4 timestamp RFC 781, 791
+	  7 record-route RFC 791
+	  9 ssrr Strict Source Routing, RFC 791
+	  11 mtu-probe RFC 1063
+	  12 mtu-reply RFC 1063
+	  18 traceroute RFC 1393
+	  20 router-alert RFC 2113
+
+	  Examples:
+
+	  Match packets that have both Timestamp and NOP:
+	  -m ipv4options --flags nop,timestamp
+
+	  ~ that have either of Timestamp or NOP, or both:
+	  --flags nop,timestamp --any
+
+	  ~ that have Timestamp and no NOP: --flags '!nop,timestamp'
+
+	  ~ that have either no NOP or a timestamp (or both conditions):
+	  --flags '!nop,timestamp' --any
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_LSCAN
+	tristate '"LSCAN" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Detects simple low-level scan attemps based upon the packet's contents.
+	  (This is different from other implementations, which also try to match the rate of new
+	  connections.) Note that an attempt is only discovered after it has been carried
+	  out, but this information can be used in conjunction with other rules to block
+	  the remote host's future connections. So this match module will match on the
+	  (probably) last packet the remote side will send to your machine.
+
+	  --stealth
+	  Match if the packet did not belong to any known TCP connection
+	  (Stealth/FIN/XMAS/NULL scan).
+
+	  --synscan
+	  Match if the connection was a TCP half-open discovery (SYN scan), i.e. the
+	  connection was torn down after the 2nd packet in the 3-way handshake.
+
+	  --cnscan
+	  Match if the connection was a TCP full open discovery (connect scan), i.e. the
+	  connection was torn down after completion of the 3-way handshake.
+
+	  --grscan
+	  Match if data in the connection only flew in the direction of the remote side,
+	  e.g. if the connection was terminated after a locally running daemon sent its
+	  identification. (E.g. openssh, smtp, ftpd.) This may falsely trigger on
+	  warranted single-direction data flows, usually bulk data transfers such as
+	  FTP DATA connections or IRC DCC. Grab Scan Detection should only be used on
+	  ports where a protocol runs that is guaranteed to do a bidirectional exchange
+	  of bytes.
+
+	  NOTE: Some clients (Windows XP for example) may do what looks like a SYN scan,
+	  so be advised to carefully use xt_lscan in conjunction with blocking rules,
+	  as it may lock out your very own internal network.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+	  
+config NETFILTER_XT_MATCH_PKNOCK
+	tristate '"PKNOCK" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Pknock match implements so-called "port knocking", a stealthy system
+	  for network authentication: a client sends packets to selected
+	  ports in a specific sequence (= simple mode, see example 1 below), or a HMAC
+	  payload to a single port (= complex mode, see example 2 below),
+	  to a target machine that has pknock rule(s) installed. The target machine
+	  then decides whether to unblock or block (again) the pknock-protected port(s).
+	  This can be used, for instance, to avoid brute force
+	  attacks on ssh or ftp services.
+
+	  Example prerequisites:
+
+	  modprobe cn
+
+	  modprobe xt_pknock
+
+	  Example 1 (TCP mode, manual closing of opened port not possible):
+
+	  iptables -P INPUT DROP
+
+	  iptables -A INPUT -p tcp -m pknock --knockports 4002,4001,4004 --strict
+	  --name SSH --time 10 --autoclose 60 --dport 22 -j ACCEPT
+
+	  The rule will allow tcp port 22 for the attempting IP address after the successful reception of TCP SYN packets
+	  to ports 4002, 4001 and 4004, in this order (a.k.a. port-knocking).
+	  Port numbers in the connect sequence must follow the exact specification, no
+	  other ports may be "knocked" inbetween. The rule is named 'SSH', a file of
+	  the same name for tracking port knocking states will be created in
+	  /proc/net/xt_pknock .
+	  Successive port knocks must occur with delay of at most 10 seconds. Port 22 (from the example) will
+	  be automatiaclly dropped after 60 minutes after it was previously allowed.
+
+	  Example 2 (UDP mode, non-replayable and non-spoofable, manual closing
+	  of opened port possible, secure, also called "SPA" = Secure Port
+	  Authorization):
+
+	  iptables -A INPUT -p udp -m pknock --knockports 4000 --name FTP
+	  --opensecret foo --closesecret bar --autoclose 240 -j DROP
+
+	  iptables -A INPUT -p tcp -m pknock --checkip --name FTP --dport 21 -j ACCEPT
+
+	  The first rule will create an "ALLOWED" record in /proc/net/xt_pknock/FTP after
+	  the successful reception of an UDP packet to port 4000. The packet payload must be
+	  constructed as a HMAC256 using "foo" as a key. The HMAC content is the particular 
+	  client's IP address as a 32-bit network byteorder quantity,
+	  plus the number of minutes since the Unix epoch, also as a 32-bit value.
+	  (This is known as Simple Packet Authorization, also called "SPA".)
+	  In such case, any subsequent attempt to connect to port 21 from the client's IP
+	  address will cause such packets to be accepted in the second rule.
+
+	  Similarly, upon reception of an UDP packet constructed the same way, but with
+	  the key "bar", the first rule will remove a previously installed "ALLOWED" state
+	  record from /proc/net/xt_pknock/FTP, which means that the second rule will
+	  stop matching for subsequent connection attempts to port 21.
+	  In case no close-secret packet is received within 4 hours, the first rule
+	  will remove "ALLOWED" record from /proc/net/xt_pknock/FTP itself.
+
+	  Things worth noting:
+
+	  General:
+
+	  Specifying --autoclose 0 means that no automatic close will be performed at all.
+
+	  xt_pknock is capable of sending information about successful matches
+	  via a netlink socket to userspace, should you need to implement your own
+	  way of receiving and handling portknock notifications.
+	  Be sure to read the documentation in the doc/pknock/ directory,
+	  or visit the original site, http://portknocko.berlios.de/ .
+
+	  TCP mode:
+
+	  This mode is not immune against eavesdropping, spoofing and
+	  replaying of the port knock sequence by someone else (but its use may still
+	  be sufficient for scenarios where these factors are not necessarily
+	  this important, such as bare shielding of the SSH port from brute-force attacks).
+	  However, if you need these features, you should use UDP mode.
+
+	  It is always wise to specify three or more ports that are not monotonically
+	  increasing or decreasing with a small stepsize (e.g. 1024,1025,1026)
+	  to avoid accidentally triggering
+	  the rule by a portscan.
+
+	  Specifying the inter-knock timeout with --time is mandatory in TCP mode,
+	  to avoid permanent denial of services by clogging up the peer knock-state tracking table
+	  that xt_pknock internally keeps, should there be a DDoS on the
+	  first-in-row knock port from more hostile IP addresses than what the actual size
+	  of this table is (defaults to 16, can be changed via the "peer_hasht_ents" module parameter).
+	  It is also wise to use as short a time as possible (1 second) for --time
+	  for this very reason. You may also consider increasing the size
+	  of the peer knock-state tracking table. Using --strict also helps,
+	  as it requires the knock sequence to be exact. This means that if the
+	  hostile client sends more knocks to the same port, xt_pknock will
+	  mark such attempt as failed knock sequence and will forget it immediately.
+	  To completely thwart this kind of DDoS, knock-ports would need to have
+	  an additional rate-limit protection. Or you may consider using UDP mode.
+
+	  UDP mode:
+
+	  This mode is immune against eavesdropping, replaying and spoofing attacks.
+	  It is also immune against DDoS attack on the knockport.
+
+	  For this mode to work, the clock difference on the client and on the server
+	  must be below 1 minute. Synchronizing time on both ends by means
+	  of NTP or rdate is strongly suggested.
+
+	  There is a rate limiter built into xt_pknock which blocks any subsequent
+	  open attempt in UDP mode should the request arrive within less than one
+	  minute since the first successful open. This is intentional;
+	  it thwarts eventual spoofing attacks.
+
+	  Because the payload value of an UDP knock packet is influenced by client's IP address,
+	  UDP mode cannot be used across NAT.
+
+	  For sending UDP "SPA" packets, you may use either knock.sh or
+	  knock-orig.sh. These may be found in doc/pknock/util.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_PSD
+	tristate '"PSD" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Attempt to detect TCP and UDP port scans. This match was derived from
+	  Solar Designer's scanlogd.
+
+	  --psd-weight-threshold threshold
+	  Total weight of the latest TCP/UDP packets with different
+	  destination ports coming from the same host to be treated as port
+	  scan sequence.
+
+	  --psd-delay-threshold delay
+	  Delay (in hundredths of second) for the packets with different
+	  destination ports coming from the same host to be treated as
+	  possible port scan subsequence.
+
+	  --psd-lo-ports-weight weight
+	  Weight of the packet with privileged (<=1024) destination port.
+
+	  --psd-hi-ports-weight weight
+	  Weight of the packet with non-priviliged destination port.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_QUOTA2
+	tristate '"QUOTA2" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The "quota2" implements a named counter which can be increased or decreased
+	  on a per-match basis. Available modes are packet counting or byte counting.
+	  The value of the counter can be read and reset through procfs, thereby making
+	  this match a minimalist accounting tool.
+
+	  When counting down from the initial quota, the counter will stop at 0 and
+	  the match will return false, just like the original "quota" match. In growing
+	  (upcounting) mode, it will always return true.
+
+	  --grow
+	  Count upwards instead of downwards.
+
+	  --no-change
+	  Makes it so the counter or quota amount is never changed by packets matching
+	  this rule. This is only really useful in "quota" mode, as it will allow you to
+	  use complex prerouting rules in association with the quota system, without
+	  counting a packet twice.
+
+	  --name name
+	  Assign the counter a specific name. This option must be present, as an empty
+	  name is not allowed. Names starting with a dot or names containing a slash are
+	  prohibited.
+
+	  [!] --quota iq
+	  Specify the initial quota for this counter. If the counter already exists,
+	  it is not reset. An "!" may be used to invert the result of the match. The
+	  negation has no effect when --grow is used.
+
+	  --packets
+	  Count packets instead of bytes that passed the quota2 match.
+
+	  Because counters in quota2 can be shared, you can combine them for various
+	  purposes, for example, a bytebucket filter that only lets as much traffic go
+	  out as has come in:
+
+	  -A INPUT -p tcp --dport 6881 -m quota --name bt --grow;
+	  -A OUTPUT -p tcp --sport 6881 -m quota --name bt;
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
 endif # NETFILTER_XTABLES
 
 endmenu

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/Makefile
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/Makefile
@@ -40,6 +40,7 @@
 
 # generic X tables 
 obj-$(CONFIG_NETFILTER_XTABLES) += x_tables.o xt_tcpudp.o
+obj-y += compat_xtables.o
 
 # combos
 obj-$(CONFIG_NETFILTER_XT_MARK) += xt_mark.o
@@ -61,6 +62,14 @@
 obj-$(CONFIG_NETFILTER_XT_TARGET_RATEEST) += xt_RATEEST.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_SECMARK) += xt_SECMARK.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TPROXY) += xt_TPROXY.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_CHAOS) += xt_CHAOS.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_DELUDE) += xt_DELUDE.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_RAWNAT) += xt_RAWNAT.o iptable_rawpost.o
+ifneq (${CONFIG_IP6_NF_IPTABLES},)
+obj-${CONFIG_NETFILTER_XT_TARGET_RAWNAT} += ip6table_rawpost.o
+endif
+obj-$(CONFIG_NETFILTER_XT_TARGET_STEAL) += xt_STEAL.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_TARPIT) += xt_TARPIT.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TCPMSS) += xt_TCPMSS.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP) += xt_TCPOPTSTRIP.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TEE) += xt_TEE.o
@@ -108,6 +117,13 @@
 obj-$(CONFIG_NETFILTER_XT_MATCH_CONDITION) += xt_condition.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_GEOIP) += xt_geoip.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_ETHPORT) += xt_ethport.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_FUZZY) += xt_fuzzy.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_IFACE) += xt_iface.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_IPV4OPTIONS) += xt_ipv4options.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_LSCAN) += xt_lscan.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PKNOCK) += xt_pknock.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PSD) += xt_psd.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_QUOTA2) += xt_quota2.o
 
 # ipset
 obj-$(CONFIG_IP_SET) += ipset/

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_CHAOS.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_CHAOS.c
@@ -0,0 +1,279 @@
+/*
+ *	"CHAOS" target extension for Xtables
+ *	Copyright © Jan Engelhardt <jengelh [at] medozas de>, 2006 - 2008
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <linux/icmp.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/version.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_tcpudp.h>
+#include <linux/netfilter_ipv4/ipt_REJECT.h>
+#include <net/ip.h>
+#include "xt_CHAOS.h"
+static struct xt_match *xm_tcp;
+static struct xt_target *xt_delude, *xt_reject, *xt_tarpit;
+#include "compat_xtables.h"
+#define PFX KBUILD_MODNAME ": "
+
+/* Module parameters */
+static unsigned int reject_percentage = ~0U * .01;
+static unsigned int delude_percentage = ~0U * .0101;
+module_param(reject_percentage, uint, S_IRUGO | S_IWUSR);
+module_param(delude_percentage, uint, S_IRUGO | S_IWUSR);
+
+/* References to other matches/targets */
+
+static int have_delude, have_tarpit;
+
+/* Static data for other matches/targets */
+static const struct ipt_reject_info reject_params = {
+	.with = ICMP_HOST_UNREACH,
+};
+
+static const struct xt_tcp tcp_params = {
+	.spts = {0, ~0},
+	.dpts = {0, ~0},
+};
+
+/* CHAOS functions */
+static void
+xt_chaos_total(struct sk_buff *skb, const struct xt_action_param *par)
+{
+	const struct xt_chaos_tginfo *info = par->targinfo;
+	const struct iphdr *iph = ip_hdr(skb);
+	const int thoff         = 4 * iph->ihl;
+	const int fragoff       = ntohs(iph->frag_off) & IP_OFFSET;
+	typeof(xt_tarpit) destiny;
+	bool ret;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 22)
+	int hotdrop = false;
+#else
+	bool hotdrop = false;
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+	ret = xm_tcp->match(skb, par->in, par->out, xm_tcp, &tcp_params,
+	                    fragoff, thoff, &hotdrop);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+	{
+		struct xt_match_param local_par = {
+			.in        = par->in,
+			.out       = par->out,
+			.match     = xm_tcp,
+			.matchinfo = &tcp_params,
+			.fragoff   = fragoff,
+			.thoff     = thoff,
+			.hotdrop   = &hotdrop,
+		};
+		ret = xm_tcp->match(skb, &local_par);
+	}
+#else
+	{
+		struct xt_action_param local_par;
+		local_par.in        = par->in,
+		local_par.out       = par->out,
+		local_par.match     = xm_tcp;
+		local_par.matchinfo = &tcp_params;
+		local_par.fragoff   = fragoff;
+		local_par.thoff     = thoff;
+		local_par.hotdrop   = false;
+		ret = xm_tcp->match(skb, &local_par);
+		hotdrop = local_par.hotdrop;
+	}
+#endif
+	if (!ret || hotdrop || (unsigned int)net_random() > delude_percentage)
+		return;
+
+	destiny = (info->variant == XTCHAOS_TARPIT) ? xt_tarpit : xt_delude;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+	destiny->target(&skb, par->in, par->out, par->hooknum, destiny, NULL, NULL);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+	destiny->target(&skb, par->in, par->out, par->hooknum, destiny, NULL);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+	destiny->target(skb, par->in, par->out, par->hooknum, destiny, NULL);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+	{
+		struct xt_target_param local_par = {
+			.in       = par->in,
+			.out      = par->out,
+			.hooknum  = par->hooknum,
+			.target   = destiny,
+			.targinfo = par->targinfo,
+			.family   = par->family,
+		};
+		destiny->target(skb, &local_par);
+	}
+#else
+	{
+		struct xt_action_param local_par;
+		local_par.in       = par->in;
+		local_par.out      = par->out;
+		local_par.hooknum  = par->hooknum;
+		local_par.target   = destiny;
+		local_par.targinfo = par->targinfo;
+		local_par.family   = par->family;
+		destiny->target(skb, &local_par);
+	}
+#endif
+}
+
+static unsigned int
+chaos_tg(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	/*
+	 * Equivalent to:
+	 * -A chaos -m statistic --mode random --probability \
+	 *         $reject_percentage -j REJECT --reject-with host-unreach;
+	 * -A chaos -p tcp -m statistic --mode random --probability \
+	 *         $delude_percentage -j DELUDE;
+	 * -A chaos -j DROP;
+	 */
+	const struct xt_chaos_tginfo *info = par->targinfo;
+	struct sk_buff *skb = *pskb;
+	const struct iphdr *iph = ip_hdr(skb);
+
+	if ((unsigned int)net_random() <= reject_percentage) {
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+		return xt_reject->target(pskb, par->in, par->out, par->hooknum,
+		       xt_reject, &reject_params, NULL);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+		return xt_reject->target(pskb, par->in, par->out, par->hooknum,
+		       xt_reject, &reject_params);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+		return xt_reject->target(skb, par->in, par->out, par->hooknum,
+		       xt_reject, &reject_params);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+		struct xt_target_param local_par = {
+			.in       = par->in,
+			.out      = par->out,
+			.hooknum  = par->hooknum,
+			.target   = xt_reject,
+			.targinfo = &reject_params,
+		};
+		return xt_reject->target(skb, &local_par);
+#else
+		struct xt_action_param local_par;
+		local_par.in       = par->in;
+		local_par.out      = par->out;
+		local_par.hooknum  = par->hooknum;
+		local_par.target   = xt_reject;
+		local_par.targinfo = &reject_params;
+		return xt_reject->target(skb, &local_par);
+#endif
+	}
+
+	/* TARPIT/DELUDE may not be called from the OUTPUT chain */
+	if (iph->protocol == IPPROTO_TCP &&
+	    info->variant != XTCHAOS_NORMAL &&
+	    par->hooknum != NF_INET_LOCAL_OUT)
+		xt_chaos_total(skb, par);
+
+	return NF_DROP;
+}
+
+static int chaos_tg_check(const struct xt_tgchk_param *par)
+{
+	const struct xt_chaos_tginfo *info = par->targinfo;
+
+	if (info->variant == XTCHAOS_DELUDE && !have_delude) {
+		printk(KERN_WARNING PFX "Error: Cannot use --delude when "
+		       "DELUDE module not available\n");
+		return -EINVAL;
+	}
+	if (info->variant == XTCHAOS_TARPIT && !have_tarpit) {
+		printk(KERN_WARNING PFX "Error: Cannot use --tarpit when "
+		       "TARPIT module not available\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct xt_target chaos_tg_reg = {
+	.name       = "CHAOS",
+	.revision   = 0,
+	.family     = NFPROTO_IPV4,
+	.table      = "filter",
+	.hooks      = (1 << NF_INET_LOCAL_IN) | (1 << NF_INET_FORWARD) |
+	              (1 << NF_INET_LOCAL_OUT),
+	.target     = chaos_tg,
+	.checkentry = chaos_tg_check,
+	.targetsize = sizeof(struct xt_chaos_tginfo),
+	.me         = THIS_MODULE,
+};
+
+static int __init chaos_tg_init(void)
+{
+	int ret = -EINVAL;
+
+	xm_tcp = xt_request_find_match(NFPROTO_IPV4, "tcp", 0);
+	if (xm_tcp == NULL) {
+		printk(KERN_WARNING PFX "Error: Could not find or load "
+		       "\"tcp\" match\n");
+		return -EINVAL;
+	}
+
+	xt_reject = xt_request_find_target(NFPROTO_IPV4, "REJECT", 0);
+	if (xt_reject == NULL) {
+		printk(KERN_WARNING PFX "Error: Could not find or load "
+		       "\"REJECT\" target\n");
+		goto out2;
+	}
+
+	xt_tarpit   = xt_request_find_target(NFPROTO_IPV4, "TARPIT", 0);
+	have_tarpit = xt_tarpit != NULL;
+	if (!have_tarpit)
+		printk(KERN_WARNING PFX "Warning: Could not find or load "
+		       "\"TARPIT\" target\n");
+
+	xt_delude   = xt_request_find_target(NFPROTO_IPV4, "DELUDE", 0);
+	have_delude = xt_delude != NULL;
+	if (!have_delude)
+		printk(KERN_WARNING PFX "Warning: Could not find or load "
+		       "\"DELUDE\" target\n");
+
+	if ((ret = xt_register_target(&chaos_tg_reg)) != 0) {
+		printk(KERN_WARNING PFX "xt_register_target returned "
+		       "error %d\n", ret);
+		goto out3;
+	}
+
+	return 0;
+
+ out3:
+ 	if (have_delude)
+ 		module_put(xt_delude->me);
+	if (have_tarpit)
+		module_put(xt_tarpit->me);
+	module_put(xt_reject->me);
+ out2:
+	module_put(xm_tcp->me);
+	return ret;
+}
+
+static void __exit chaos_tg_exit(void)
+{
+	xt_unregister_target(&chaos_tg_reg);
+	module_put(xm_tcp->me);
+	module_put(xt_reject->me);
+	if (have_delude)
+		module_put(xt_delude->me);
+	if (have_tarpit)
+		module_put(xt_tarpit->me);
+}
+
+module_init(chaos_tg_init);
+module_exit(chaos_tg_exit);
+MODULE_DESCRIPTION("Xtables: Network scan slowdown with non-deterministic results");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_CHAOS");

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_CHAOS.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_CHAOS.h
@@ -0,0 +1,14 @@
+#ifndef _LINUX_NETFILTER_XT_CHAOS_H
+#define _LINUX_NETFILTER_XT_CHAOS_H 1
+
+enum xt_chaos_target_variant {
+	XTCHAOS_NORMAL,
+	XTCHAOS_TARPIT,
+	XTCHAOS_DELUDE,
+};
+
+struct xt_chaos_tginfo {
+	uint8_t variant;
+};
+
+#endif /* _LINUX_NETFILTER_XT_CHAOS_H */

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_DELUDE.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_DELUDE.c
@@ -0,0 +1,182 @@
+/*
+ *	"DELUDE" target extension for Xtables
+ *	Copyright © Jan Engelhardt <jengelh [at] medozas de>, 2007 - 2008
+ *
+ *	Based upon linux-2.6.18.5/net/ipv4/netfilter/ipt_REJECT.c:
+ *	(C) 1999-2001 Paul `Rusty' Russell
+ *	(C) 2002-2004 Netfilter Core Team <coreteam@netfilter.org>
+ *
+ *	xt_DELUDE acts like REJECT, but does reply with SYN-ACK on SYN.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License version 2 as
+ *	published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/version.h>
+#include <linux/netfilter/x_tables.h>
+#ifdef CONFIG_BRIDGE_NETFILTER
+#	include <linux/netfilter_bridge.h>
+#endif
+#include <net/tcp.h>
+#include "compat_xtables.h"
+#define PFX KBUILD_MODNAME ": "
+
+static void delude_send_reset(struct sk_buff *oldskb, unsigned int hook)
+{
+	struct tcphdr _otcph, *tcph;
+	const struct tcphdr *oth;
+	const struct iphdr *oiph;
+	unsigned int addr_type;
+	struct sk_buff *nskb;
+	struct iphdr *niph;
+
+	oiph = ip_hdr(oldskb);
+
+	/* IP header checks: fragment. */
+	if (oiph->frag_off & htons(IP_OFFSET))
+		return;
+
+	oth = skb_header_pointer(oldskb, ip_hdrlen(oldskb),
+				 sizeof(_otcph), &_otcph);
+	if (oth == NULL)
+		return;
+
+	/* No RST for RST. */
+	if (oth->rst)
+		return;
+
+	/* Check checksum */
+	if (nf_ip_checksum(oldskb, hook, ip_hdrlen(oldskb), IPPROTO_TCP))
+		return;
+
+	nskb = alloc_skb(sizeof(struct iphdr) + sizeof(struct tcphdr) +
+	                 LL_MAX_HEADER, GFP_ATOMIC);
+	if (nskb == NULL)
+		return;
+
+	skb_reserve(nskb, LL_MAX_HEADER);
+	skb_reset_network_header(nskb);
+	niph = (struct iphdr *)skb_put(nskb, sizeof(struct iphdr));
+	niph->version  = 4;
+	niph->ihl      = sizeof(struct iphdr) / 4;
+	niph->tos      = 0;
+	niph->id       = 0;
+	niph->frag_off = htons(IP_DF);
+	niph->protocol = IPPROTO_TCP;
+	niph->check    = 0;
+	niph->saddr    = oiph->daddr;
+	niph->daddr    = oiph->saddr;
+
+	tcph = (struct tcphdr *)skb_put(nskb, sizeof(struct tcphdr));
+	memset(tcph, 0, sizeof(*tcph));
+	tcph->source = oth->dest;
+	tcph->dest   = oth->source;
+	tcph->doff   = sizeof(struct tcphdr) / 4;
+
+	/* DELUDE essential part */
+	if (oth->syn && !oth->ack && !oth->rst && !oth->fin) {
+		tcph->syn     = true;
+		tcph->seq     = 0;
+		tcph->ack     = true;
+		tcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn + oth->fin +
+		                oldskb->len - ip_hdrlen(oldskb) -
+		                (oth->doff << 2));
+	} else {
+		tcph->rst = true;
+		if (!oth->ack) {
+			tcph->seq     = 0;
+			tcph->ack     = true;
+			tcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn +
+			                oth->fin + oldskb->len -
+			                ip_hdrlen(oldskb) - (oth->doff << 2));
+		} else {
+			tcph->seq     = oth->ack_seq;
+			tcph->ack     = false;
+			tcph->ack_seq = 0;
+		}
+	}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
+	tcph->check = tcp_v4_check(tcph, sizeof(struct tcphdr), niph->saddr,
+	              niph->daddr, csum_partial((char *)tcph,
+	              sizeof(struct tcphdr), 0));
+#else
+	tcph->check = tcp_v4_check(sizeof(struct tcphdr), niph->saddr,
+	              niph->daddr, csum_partial((char *)tcph,
+	              sizeof(struct tcphdr), 0));
+#endif
+
+	addr_type = RTN_UNSPEC;
+#ifdef CONFIG_BRIDGE_NETFILTER
+	if (hook != NF_INET_FORWARD || (nskb->nf_bridge != NULL &&
+	    nskb->nf_bridge->mask & BRNF_BRIDGED))
+#else
+	if (hook != NF_INET_FORWARD)
+#endif
+		addr_type = RTN_LOCAL;
+
+	/* ip_route_me_harder expects skb->dst to be set */
+	skb_dst_set(nskb, dst_clone(skb_dst(oldskb)));
+
+	if (ip_route_me_harder(&nskb, addr_type))
+		goto free_nskb;
+	else
+		niph = ip_hdr(nskb);
+
+	niph->ttl       = dst_metric(skb_dst(nskb), RTAX_HOPLIMIT);
+	nskb->ip_summed = CHECKSUM_NONE;
+
+	/* "Never happens" */
+	if (nskb->len > dst_mtu(skb_dst(nskb)))
+		goto free_nskb;
+
+	nf_ct_attach(nskb, oldskb);
+
+	ip_local_out(nskb);
+	return;
+
+ free_nskb:
+	kfree_skb(nskb);
+}
+
+static unsigned int
+delude_tg(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	/* WARNING: This code causes reentry within iptables.
+	   This means that the iptables jump stack is now crap.  We
+	   must return an absolute verdict. --RR */
+	delude_send_reset(*pskb, par->hooknum);
+	return NF_DROP;
+}
+
+static struct xt_target delude_tg_reg __read_mostly = {
+	.name     = "DELUDE",
+	.revision = 0,
+	.family   = NFPROTO_IPV4,
+	.table    = "filter",
+	.hooks    = (1 << NF_INET_LOCAL_IN) | (1 << NF_INET_FORWARD),
+	.proto    = IPPROTO_TCP,
+	.target   = delude_tg,
+	.me       = THIS_MODULE,
+};
+
+static int __init delude_tg_init(void)
+{
+	return xt_register_target(&delude_tg_reg);
+}
+
+static void __exit delude_tg_exit(void)
+{
+	xt_unregister_target(&delude_tg_reg);
+}
+
+module_init(delude_tg_init);
+module_exit(delude_tg_exit);
+MODULE_DESCRIPTION("Xtables: Close TCP connections after handshake");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_DELUDE");

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_fuzzy.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_fuzzy.c
@@ -0,0 +1,174 @@
+/*
+ *	This module implements a simple TSK FLC (Takagi-Sugeno-Kang Fuzzy Logic
+ *	Controller) that aims to limit, in an adaptive and flexible way, the
+ *	packet rate crossing a given stream. It serves as an initial and very
+ *	simple (but effective) example of how Fuzzy Logic techniques can be
+ *	applied to defeat DoS attacks.
+ *
+ *	As a matter of fact, Fuzzy Logic can help us to insert any "behavior"
+ *	into our code in a precise, adaptive and efficient manner.
+ *
+ *	The goal is very similar to that of "limit" match, but using techniques
+ *	of Fuzzy Control, that allow us to shape the transfer functions
+ *	precisely, avoiding over and undershoots - and stuff like that.
+ *
+ * 2002-08-10  Hime Aguiar e Oliveira Jr. <hime@engineer.com> : Initial version.
+ * 2002-08-17  : Changed to eliminate floating point operations .
+ * 2002-08-23  : Coding style changes .
+ * 2003-04-08  Maciej Soltysiak <solt@dns.toxicilms.tv> : IPv6 Port
+ */
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/random.h>
+#include <net/tcp.h>
+#include <linux/netfilter/x_tables.h>
+#include "xt_fuzzy.h"
+#include "compat_xtables.h"
+
+/*
+ * Packet Acceptance Rate - LOW and Packet Acceptance Rate - HIGH
+ * Expressed in percentage.
+ */
+
+#define PAR_LOW		1/100
+#define PAR_HIGH	1
+
+MODULE_AUTHOR("Hime Aguiar e Oliveira Junior <hime@engineer.com>");
+MODULE_DESCRIPTION("Xtables: Fuzzy Logic Controller match");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_fuzzy");
+MODULE_ALIAS("ip6t_fuzzy");
+
+static uint8_t mf_high(uint32_t tx, uint32_t mini, uint32_t maxi)
+{
+	if (tx >= maxi)
+		return 100;
+	if (tx <= mini)
+		return 0;
+	return 100 * (tx - mini) / (maxi - mini);
+}
+
+static uint8_t mf_low(uint32_t tx, uint32_t mini, uint32_t maxi)
+{
+	if (tx <= mini)
+		return 100;
+	if (tx >= maxi)
+		return 0;
+	return 100 * (maxi - tx) / (maxi - mini);
+
+}
+
+static bool
+fuzzy_mt(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	struct xt_fuzzy_mtinfo *info = (void *)par->matchinfo;
+	unsigned long amount;
+	uint8_t howhigh, howlow, random_number;
+
+	info->bytes_total += skb->len;
+	++info->packets_total;
+	info->present_time = jiffies;
+
+	if (info->present_time >= info->previous_time) {
+		amount = info->present_time - info->previous_time;
+	} else {
+		/*
+		 * There was a transition: I choose to re-sample
+		 * and keep the old acceptance rate...
+	         */
+		amount = 0;
+		info->previous_time = info->present_time;
+		info->bytes_total = info->packets_total = 0;
+	}
+
+	if (amount > HZ / 10) {
+		/* More than 100 ms elapsed ... */
+
+		info->mean_rate     = HZ * info->packets_total / amount;
+		info->previous_time = info->present_time;
+		info->bytes_total   = info->packets_total = 0;
+
+		howhigh = mf_high(info->mean_rate, info->minimum_rate,
+		          info->maximum_rate);
+		howlow  = mf_low(info->mean_rate, info->minimum_rate,
+		          info->maximum_rate);
+
+		info->acceptance_rate = howhigh * PAR_LOW + PAR_HIGH * howlow;
+
+		/*
+		 * In fact, the above defuzzification would require a
+		 * denominator proportional to (howhigh+howlow) but, in this
+		 * particular case, that expression is constant.
+		 *
+		 * An imediate consequence is that it is not necessary to call
+		 * both mf_high and mf_low - but to keep things understandable,
+		 * I did so.
+		 */
+	}
+
+	if (info->acceptance_rate < 100) {
+		get_random_bytes(&random_number, sizeof(random_number));
+
+		if (random_number <= 255 * info->acceptance_rate / 100)
+			/*
+			 * If within the acceptance, it can pass
+			 * => do not match.
+			 */
+			return false;
+		else
+			/* It cannot pass (it matches) */
+			return true;
+	};
+
+	/* acceptance_rate == 100 % => Everything passes ... */
+	return false;
+}
+
+static int fuzzy_mt_check(const struct xt_mtchk_param *par)
+{
+	const struct xt_fuzzy_mtinfo *info = par->matchinfo;
+
+	if (info->minimum_rate < FUZZY_MIN_RATE ||
+	    info->maximum_rate > FUZZY_MAX_RATE ||
+	    info->minimum_rate >= info->maximum_rate) {
+		printk(KERN_INFO KBUILD_MODNAME ": bad values, please check.\n");
+		return -EDOM;
+	}
+
+	return 0;
+}
+
+static struct xt_match fuzzy_mt_reg[] __read_mostly = {
+	{
+		.name       = "fuzzy",
+		.revision   = 1,
+		.family     = NFPROTO_IPV4,
+		.match      = fuzzy_mt,
+		.checkentry = fuzzy_mt_check,
+		.matchsize  = sizeof(struct xt_fuzzy_mtinfo),
+		.me         = THIS_MODULE,
+	},
+	{
+		.name       = "fuzzy",
+		.revision   = 1,
+		.family     = NFPROTO_IPV6,
+		.match      = fuzzy_mt,
+		.checkentry = fuzzy_mt_check,
+		.matchsize  = sizeof(struct xt_fuzzy_mtinfo),
+		.me         = THIS_MODULE,
+	},
+};
+
+static int __init fuzzy_mt_init(void)
+{
+	return xt_register_matches(fuzzy_mt_reg, ARRAY_SIZE(fuzzy_mt_reg));
+}
+
+static void __exit fuzzy_mt_exit(void)
+{
+	xt_unregister_matches(fuzzy_mt_reg, ARRAY_SIZE(fuzzy_mt_reg));
+}
+
+module_init(fuzzy_mt_init);
+module_exit(fuzzy_mt_exit);

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_fuzzy.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_fuzzy.h
@@ -0,0 +1,20 @@
+#ifndef _LINUX_NETFILTER_XT_FUZZY_H
+#define _LINUX_NETFILTER_XT_FUZZY_H 1
+
+enum {
+	FUZZY_MIN_RATE = 3,
+	FUZZY_MAX_RATE = 10000000,
+};
+
+struct xt_fuzzy_mtinfo {
+	uint32_t minimum_rate;
+	uint32_t maximum_rate;
+	uint32_t packets_total;
+	uint32_t bytes_total;
+	uint32_t previous_time;
+	uint32_t present_time;
+	uint32_t mean_rate;
+	uint8_t acceptance_rate;
+};
+
+#endif /* _LINUX_NETFILTER_XT_FUZZY_H */

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_iface.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_iface.c
@@ -0,0 +1,118 @@
+/*
+ *	xt_iface - kernel module to match interface state flags
+ *
+ *	Original author: Gáspár Lajos <gaspar.lajos@glsys.eu>
+ */
+
+#include <linux/if.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <linux/netfilter/x_tables.h>
+#include "xt_iface.h"
+#include "compat_xtables.h"
+
+struct xt_iface_flag_pairs {
+	uint16_t iface_flag;
+	uint32_t iff_flag;
+};
+
+MODULE_AUTHOR("Gáspár Lajos <gaspar.lajos@glsys.eu>");
+MODULE_DESCRIPTION("Xtables: iface match module");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_iface");
+MODULE_ALIAS("ip6t_iface");
+//MODULE_ALIAS("arpt_iface");
+
+static const struct xt_iface_flag_pairs xt_iface_lookup[] =
+{
+	{.iface_flag = XT_IFACE_UP,		.iff_flag = IFF_UP},
+	{.iface_flag = XT_IFACE_BROADCAST,	.iff_flag = IFF_BROADCAST},
+	{.iface_flag = XT_IFACE_LOOPBACK,	.iff_flag = IFF_LOOPBACK},
+	{.iface_flag = XT_IFACE_POINTOPOINT,	.iff_flag = IFF_POINTOPOINT},
+	{.iface_flag = XT_IFACE_RUNNING,	.iff_flag = IFF_RUNNING},
+	{.iface_flag = XT_IFACE_NOARP,		.iff_flag = IFF_NOARP},
+	{.iface_flag = XT_IFACE_PROMISC,	.iff_flag = IFF_PROMISC},
+	{.iface_flag = XT_IFACE_MULTICAST,	.iff_flag = IFF_MULTICAST},
+	{.iface_flag = XT_IFACE_DYNAMIC,	.iff_flag = IFF_DYNAMIC},
+	{.iface_flag = XT_IFACE_LOWER_UP,	.iff_flag = IFF_LOWER_UP},
+	{.iface_flag = XT_IFACE_DORMANT,	.iff_flag = IFF_DORMANT},
+};
+
+static const struct net_device *iface_get(const struct xt_iface_mtinfo *info,
+    const struct xt_action_param *par, struct net_device **put)
+{
+	if (info->flags & XT_IFACE_DEV_IN)
+		return par->in;
+	else if (info->flags & XT_IFACE_DEV_OUT)
+		return par->out;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+	return *put = dev_get_by_name(&init_net, info->ifname);
+#else
+	return *put = dev_get_by_name(info->ifname);
+#endif
+}
+
+static bool iface_flagtest(unsigned int devflags, unsigned int flags,
+    unsigned int invflags)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(xt_iface_lookup); ++i)
+		if ((flags & xt_iface_lookup[i].iface_flag) &&
+		    !!(devflags & xt_iface_lookup[i].iff_flag) ^
+		    !(invflags & xt_iface_lookup[i].iface_flag))
+			return false;
+	return true;
+}
+
+static bool xt_iface_mt(const struct sk_buff *skb,
+    struct xt_action_param *par)
+{
+	const struct xt_iface_mtinfo *info = par->matchinfo;
+	struct net_device *put = NULL;
+	const struct net_device *dev = iface_get(info, par, &put);
+	bool retval;
+
+	if (dev == NULL)
+		return false;
+	retval = iface_flagtest(dev->flags, info->flags, info->invflags);
+	if (put != NULL)
+		dev_put(put);
+	return retval;
+}
+
+static struct xt_match xt_iface_mt_reg[] __read_mostly = {
+	{
+		.name       = "iface",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.matchsize  = sizeof(struct xt_iface_mtinfo),
+		.match      = xt_iface_mt,
+		.me         = THIS_MODULE,
+	},
+	{
+		.name       = "iface",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.matchsize  = sizeof(struct xt_iface_mtinfo),
+		.match      = xt_iface_mt,
+		.me         = THIS_MODULE,
+	},
+};
+
+static int __init xt_iface_match_init(void)
+{
+	return xt_register_matches(xt_iface_mt_reg,
+		ARRAY_SIZE(xt_iface_mt_reg));
+}
+
+static void __exit xt_iface_match_exit(void)
+{
+	xt_unregister_matches(xt_iface_mt_reg, ARRAY_SIZE(xt_iface_mt_reg));
+}
+
+module_init(xt_iface_match_init);
+module_exit(xt_iface_match_exit);

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_iface.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_iface.h
@@ -0,0 +1,26 @@
+#ifndef _LINUX_NETFILTER_XT_IFACE_H
+#define _LINUX_NETFILTER_XT_IFACE_H 1
+
+enum {
+	XT_IFACE_UP          = 1 << 0,
+	XT_IFACE_BROADCAST   = 1 << 1,
+	XT_IFACE_LOOPBACK    = 1 << 2,
+	XT_IFACE_POINTOPOINT = 1 << 3,
+	XT_IFACE_RUNNING     = 1 << 4,
+	XT_IFACE_NOARP       = 1 << 5,
+	XT_IFACE_PROMISC     = 1 << 6,
+	XT_IFACE_MULTICAST   = 1 << 7,
+	XT_IFACE_DYNAMIC     = 1 << 8,
+	XT_IFACE_LOWER_UP    = 1 << 9,
+	XT_IFACE_DORMANT     = 1 << 10,
+	XT_IFACE_DEV_IN      = 1 << 11,
+	XT_IFACE_DEV_OUT     = 1 << 12,
+};
+
+struct xt_iface_mtinfo {
+	char ifname[IFNAMSIZ];
+	__u16 flags;
+	__u16 invflags;
+};
+
+#endif

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_ipv4options.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_ipv4options.c
@@ -0,0 +1,83 @@
+/*
+ *	xt_ipv4opts - Xtables module to match IPv4 options
+ *	Copyright © Jan Engelhardt, 2009
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <linux/ip.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/netfilter/x_tables.h>
+#include <net/ip.h>
+#include "xt_ipv4options.h"
+#include "compat_xtables.h"
+
+static uint32_t ipv4options_rd(const uint8_t *data, int len)
+{
+	uint32_t opts = 0;
+
+	while (len >= 2) {
+		switch (data[0]) {
+		case IPOPT_END:
+			return opts;
+		case IPOPT_NOOP:
+			--len;
+			++data;
+			continue;
+		}
+
+		if (data[1] < 2 || data[1] > len)
+			return opts;
+		opts |= 1 << (data[0] & 0x1F);
+		len  -= data[1];
+		data += data[1];
+	}
+
+	return opts;
+}
+
+static bool ipv4options_mt(const struct sk_buff *skb,
+    struct xt_action_param *par)
+{
+	const struct xt_ipv4options_mtinfo1 *info = par->matchinfo;
+	const struct iphdr *iph = ip_hdr(skb);
+	uint32_t opts = 0;
+	uint16_t len  = ip_hdrlen(skb) - sizeof(struct iphdr);
+
+	if (len > 0)
+		opts = ipv4options_rd((const void *)iph +
+		       sizeof(struct iphdr), len);
+
+	opts ^= info->invert;
+	opts &= info->map;
+	return (info->flags & XT_V4OPTS_ANY) ? opts : opts == info->map;
+}
+
+static struct xt_match ipv4options_mt_reg __read_mostly = {
+	.name      = "ipv4options",
+	.revision  = 1,
+	.family    = NFPROTO_IPV4,
+	.match     = ipv4options_mt,
+	.matchsize = sizeof(struct xt_ipv4options_mtinfo1),
+	.me        = THIS_MODULE,
+};
+
+static int __init ipv4options_mt_init(void)
+{
+	return xt_register_match(&ipv4options_mt_reg);
+}
+
+static void __exit ipv4options_mt_exit(void)
+{
+	xt_unregister_match(&ipv4options_mt_reg);
+}
+
+MODULE_DESCRIPTION("Xatblse: IPv4 option match");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_ipv4options");
+module_init(ipv4options_mt_init);
+module_exit(ipv4options_mt_exit);

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_ipv4options.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_ipv4options.h
@@ -0,0 +1,26 @@
+#ifndef _LINUX_NETFILTER_XT_IPV4OPTIONS_H
+#define _LINUX_NETFILTER_XT_IPV4OPTIONS_H 1
+
+/* IPv4 allows for a 5-bit option number - 32 options */
+
+/**
+ * %XT_V4OPTS_ALL:	all options in @map must be present (respecting @invert)
+ * %XT_V4OPTS_ANY:	any of the option in @map
+ */
+enum xt_ipv4options_flags {
+	XT_V4OPTS_ALL = 1 << 0,
+	XT_V4OPTS_ANY = 1 << 1,
+};
+
+/**
+ * @map:	bitmask of options that should appear
+ * @invert:	inversion map
+ * @flags:	see above
+ */
+struct xt_ipv4options_mtinfo1 {
+	__u32 map;
+	__u32 invert;
+	__u8 flags;
+};
+
+#endif /* _LINUX_NETFILTER_XT_IPV4OPTIONS_H */

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_lscan.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_lscan.c
@@ -0,0 +1,271 @@
+/*
+ *	LSCAN match for Xtables
+ *	Copyright © Jan Engelhardt, 2006 - 2009
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License; either version
+ *	2 or 3 as published by the Free Software Foundation.
+ */
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_tcpudp.h>
+#include "xt_lscan.h"
+#include "compat_xtables.h"
+#define PFX KBUILD_MODNAME ": "
+
+enum {
+	TCP_FLAGS_ALL3 = TCP_FLAG_FIN | TCP_FLAG_RST | TCP_FLAG_SYN,
+	TCP_FLAGS_ALL4 = TCP_FLAGS_ALL3 | TCP_FLAG_ACK,
+	TCP_FLAGS_ALL6 = TCP_FLAGS_ALL4 | TCP_FLAG_PSH | TCP_FLAG_URG,
+};
+
+/* Module parameters */
+static unsigned int
+	connmark_mask = ~0,
+	packet_mask   = ~0,
+	mark_seen     = 0x9,
+	mark_synrcv   = 0x1,
+	mark_closed   = 0x2,
+	mark_synscan  = 0x3,
+	mark_estab1   = 0x4,
+	mark_estab2   = 0x5,
+	mark_cnscan   = 0x6,
+	mark_grscan   = 0x7,
+	mark_valid    = 0x8;
+
+module_param(connmark_mask, uint, S_IRUGO | S_IWUSR);
+module_param(packet_mask,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_seen,     uint, S_IRUGO | S_IWUSR);
+module_param(mark_synrcv,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_closed,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_synscan,  uint, S_IRUGO | S_IWUSR);
+module_param(mark_estab1,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_estab2,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_cnscan,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_grscan,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_valid,    uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(connmark_mask, "only set specified bits in connection mark");
+MODULE_PARM_DESC(packet_mask,   "only set specified bits in packet mark");
+MODULE_PARM_DESC(mark_seen,     "nfmark value for packet-seen state");
+MODULE_PARM_DESC(mark_synrcv,   "connmark value for SYN Received state");
+MODULE_PARM_DESC(mark_closed,   "connmark value for closed state");
+MODULE_PARM_DESC(mark_synscan,  "connmark value for SYN Scan state");
+MODULE_PARM_DESC(mark_estab1,   "connmark value for Established-1 state");
+MODULE_PARM_DESC(mark_estab2,   "connmark value for Established-2 state");
+MODULE_PARM_DESC(mark_cnscan,   "connmark value for Connect Scan state");
+MODULE_PARM_DESC(mark_grscan,   "connmark value for Grab Scan state");
+MODULE_PARM_DESC(mark_valid,    "connmark value for Valid state");
+
+/* TCP flag functions */
+static inline bool tflg_ack4(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL4) == TCP_FLAG_ACK;
+}
+
+static inline bool tflg_ack6(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL6) == TCP_FLAG_ACK;
+}
+
+static inline bool tflg_fin(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL3) == TCP_FLAG_FIN;
+}
+
+static inline bool tflg_rst(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL3) == TCP_FLAG_RST;
+}
+
+static inline bool tflg_rstack(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL4) ==
+	       (TCP_FLAG_ACK | TCP_FLAG_RST);
+}
+
+static inline bool tflg_syn(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL4) == TCP_FLAG_SYN;
+}
+
+static inline bool tflg_synack(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL4) ==
+	       (TCP_FLAG_SYN | TCP_FLAG_ACK);
+}
+
+/* lscan functions */
+static inline bool lscan_mt_stealth(const struct tcphdr *th)
+{
+	/*
+	 * "Connection refused" replies to our own probes must not be matched.
+	 */
+	if (tflg_rstack(th))
+		return false;
+
+	if (tflg_rst(th) && printk_ratelimit()) {
+		printk(KERN_WARNING PFX "Warning: Pure RST received\n");
+		return false;
+	}
+
+	/*
+	 * -p tcp ! --syn -m conntrack --ctstate INVALID: Looking for non-start
+	 * packets that are not associated with any connection -- this will
+	 * match most scan types (NULL, XMAS, FIN) and ridiculous flag
+	 * combinations (SYN-RST, SYN-FIN, SYN-FIN-RST, FIN-RST, etc.).
+	 */
+	return !tflg_syn(th);
+}
+
+static inline unsigned int lscan_mt_full(int mark,
+    enum ip_conntrack_info ctstate, bool loopback, const struct tcphdr *tcph,
+    unsigned int payload_len)
+{
+	if (mark == mark_estab2) {
+		/*
+		 * -m connmark --mark $ESTAB2
+		 */
+		if (tflg_ack4(tcph) && payload_len == 0)
+			return mark; /* keep mark */
+		else if (tflg_rst(tcph) || tflg_fin(tcph))
+			return mark_grscan;
+		else
+			return mark_valid;
+	} else if (mark == mark_estab1) {
+		/*
+		 * -m connmark --mark $ESTAB1
+		 */
+		if (tflg_rst(tcph) || tflg_fin(tcph))
+			return mark_cnscan;
+		else if (!loopback && tflg_ack4(tcph) && payload_len == 0)
+			return mark_estab2;
+		else
+			return mark_valid;
+	} else if (mark == mark_synrcv) {
+		/*
+		 * -m connmark --mark $SYN
+		 */
+		if (loopback && tflg_synack(tcph))
+			return mark; /* keep mark */
+		else if (loopback && tflg_rstack(tcph))
+			return mark_closed;
+		else if (tflg_ack6(tcph))
+			return mark_estab1;
+		else
+			return mark_synscan;
+	} else if (ctstate == IP_CT_NEW && tflg_syn(tcph)) {
+		/*
+		 * -p tcp --syn --ctstate NEW
+		 */
+		return mark_synrcv;
+	}
+	return mark;
+}
+
+static bool
+lscan_mt(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	const struct xt_lscan_mtinfo *info = par->matchinfo;
+	enum ip_conntrack_info ctstate;
+	const struct tcphdr *tcph;
+	struct nf_conn *ctdata;
+	struct tcphdr tcph_buf;
+
+	tcph = skb_header_pointer(skb, par->thoff, sizeof(tcph_buf), &tcph_buf);
+	if (tcph == NULL)
+		return false;
+
+	/* Check for invalid packets: -m conntrack --ctstate INVALID */
+	if ((ctdata = nf_ct_get(skb, &ctstate)) == NULL) {
+		if (info->match_stealth)
+			return lscan_mt_stealth(tcph);
+		/*
+		 * If @ctdata is NULL, we cannot match the other scan
+		 * types, return.
+		 */
+		return false;
+	}
+
+	/*
+	 * If -m lscan was previously applied to this packet, the rules we
+	 * simulate must not be run through again. And for speedup, do not call
+	 * it either when the connection is already VALID.
+	 */
+	if ((ctdata->mark & connmark_mask) == mark_valid ||
+	     (skb_nfmark(skb) & packet_mask) != mark_seen) {
+		unsigned int n;
+
+		n = lscan_mt_full(ctdata->mark & connmark_mask, ctstate,
+		    par->in == init_net__loopback_dev, tcph,
+		    skb->len - par->thoff - 4 * tcph->doff);
+
+		ctdata->mark = (ctdata->mark & ~connmark_mask) | n;
+		skb_nfmark(skb) = (skb_nfmark(skb) & ~packet_mask) ^ mark_seen;
+	}
+
+	return (info->match_syn && ctdata->mark == mark_synscan) ||
+	       (info->match_cn && ctdata->mark == mark_cnscan) ||
+	       (info->match_gr && ctdata->mark == mark_grscan);
+}
+
+static int lscan_mt_check(const struct xt_mtchk_param *par)
+{
+	const struct xt_lscan_mtinfo *info = par->matchinfo;
+
+	if ((info->match_stealth & ~1) || (info->match_syn & ~1) ||
+	    (info->match_cn & ~1) || (info->match_gr & ~1)) {
+		printk(KERN_WARNING PFX "Invalid flags\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct xt_match lscan_mt_reg[] __read_mostly = {
+	{
+		.name       = "lscan",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.match      = lscan_mt,
+		.checkentry = lscan_mt_check,
+		.matchsize  = sizeof(struct xt_lscan_mtinfo),
+		.proto      = IPPROTO_TCP,
+		.me         = THIS_MODULE,
+	},
+	{
+		.name       = "lscan",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.match      = lscan_mt,
+		.checkentry = lscan_mt_check,
+		.matchsize  = sizeof(struct xt_lscan_mtinfo),
+		.proto      = IPPROTO_TCP,
+		.me         = THIS_MODULE,
+	},
+};
+
+static int __init lscan_mt_init(void)
+{
+	return xt_register_matches(lscan_mt_reg,
+	       ARRAY_SIZE(lscan_mt_reg));
+}
+
+static void __exit lscan_mt_exit(void)
+{
+	xt_unregister_matches(lscan_mt_reg, ARRAY_SIZE(lscan_mt_reg));
+}
+
+module_init(lscan_mt_init);
+module_exit(lscan_mt_exit);
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_DESCRIPTION("Xtables: Low-level scan (e.g. nmap) match");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_lscan");
+MODULE_ALIAS("ip6t_lscan");

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_lscan.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_lscan.h
@@ -0,0 +1,8 @@
+#ifndef _LINUX_NETFILTER_XT_LSCAN_H
+#define _LINUX_NETFILTER_XT_LSCAN_H 1
+
+struct xt_lscan_mtinfo {
+	uint8_t match_stealth, match_syn, match_cn, match_gr;
+};
+
+#endif /* _LINUX_NETFILTER_XT_LSCAN_H */

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_pknock.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_pknock.c
@@ -0,0 +1,1199 @@
+/*
+ * Kernel module to implement Port Knocking and SPA matching support.
+ *
+ * (C) 2006-2009 J. Federico Hernandez Scarso <fede.hernandez@gmail.com>
+ * (C) 2006 Luis A. Floreani <luis.floreani@gmail.com>
+ *
+ * This program is released under the terms of GNU GPL version 2.
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/in.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/jhash.h>
+#include <linux/random.h>
+#include <linux/crypto.h>
+#include <linux/proc_fs.h>
+#include <linux/scatterlist.h>
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+#include <linux/timer.h>
+#include <linux/seq_file.h>
+#include <linux/connector.h>
+
+#include <linux/netfilter/x_tables.h>
+#include "xt_pknock.h"
+#include "compat_xtables.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+#	define PK_CRYPTO 1
+#endif
+
+enum status {
+	ST_INIT = 1,
+	ST_MATCHING,
+	ST_ALLOWED,
+};
+
+/**
+ * @timestamp:	seconds, but not since epoch (uses jiffies/HZ)
+ * @login_sec: seconds at login since the epoch
+ */
+struct peer {
+	struct list_head head;
+	__be32 ip;
+	uint32_t accepted_knock_count;
+	unsigned long timestamp;
+	unsigned long login_sec;
+	enum status status;
+	uint8_t proto;
+};
+
+/**
+ * @timer:	garbage collector timer
+ * @max_time:	max matching time between ports
+ */
+struct xt_pknock_rule {
+	struct list_head head;
+	char rule_name[XT_PKNOCK_MAX_BUF_LEN+1];
+	int rule_name_len;
+	unsigned int ref_count;
+	struct timer_list timer;
+	struct list_head *peer_head;
+	struct proc_dir_entry *status_proc;
+	unsigned long max_time;
+	unsigned long autoclose_time;
+};
+
+/**
+ * @port:	destination port
+ */
+struct transport_data {
+	uint8_t proto;
+	uint16_t port;
+	int payload_len;
+	const unsigned char *payload;
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("J. Federico Hernandez Scarso, Luis A. Floreani");
+MODULE_DESCRIPTION("netfilter match for Port Knocking and SPA");
+MODULE_ALIAS("ipt_pknock");
+
+enum {
+	DEFAULT_GC_EXPIRATION_TIME = 65000, /* in msecs */
+	DEFAULT_RULE_HASH_SIZE  = 8,
+	DEFAULT_PEER_HASH_SIZE  = 16,
+};
+
+#define hashtable_for_each_safe(pos, n, head, size, i)	\
+	for ((i) = 0; (i) < (size); ++(i)) \
+		list_for_each_safe((pos), (n), (&head[(i)]))
+
+#define pk_debug(msg, peer) pr_debug( \
+			"(S) peer: " NIPQUAD_FMT " - %s.\n", \
+			NIPQUAD((peer)->ip), msg)
+
+static uint32_t ipt_pknock_hash_rnd;
+
+static unsigned int rule_hashsize	= DEFAULT_RULE_HASH_SIZE;
+static unsigned int peer_hashsize	= DEFAULT_PEER_HASH_SIZE;
+static unsigned int gc_expir_time = DEFAULT_GC_EXPIRATION_TIME;
+static int nl_multicast_group		= -1;
+
+static struct list_head *rule_hashtable;
+static struct proc_dir_entry *pde;
+
+static DEFINE_SPINLOCK(list_lock);
+
+#ifdef PK_CRYPTO
+static struct {
+	const char *algo;
+	struct crypto_hash	*tfm;
+	unsigned int size;
+	struct hash_desc	desc;
+} crypto = {
+	.algo	= "hmac(sha256)",
+	.tfm	= NULL,
+	.size	= 0
+};
+#endif
+
+module_param(rule_hashsize, int, S_IRUGO);
+MODULE_PARM_DESC(rule_hashsize, "Buckets in rule hash table (default: 8)");
+module_param(peer_hashsize, int, S_IRUGO);
+MODULE_PARM_DESC(peer_hashsize, "Buckets in peer hash table (default: 16)");
+module_param(gc_expir_time, int, S_IRUGO);
+MODULE_PARM_DESC(gc_expir_time, "Time until garbage collection after valid knock packet (default: 65000 msec)");
+module_param(nl_multicast_group, int, S_IRUGO);
+MODULE_PARM_DESC(nl_multicast_group, "Netlink multicast group number for pknock messages");
+
+/**
+ * Calculates a value from 0 to max from a hash of the arguments.
+ *
+ * @key
+ * @len: length
+ * @initval
+ * @max
+ * @return: a 32 bits index
+ */
+static inline uint32_t
+pknock_hash(const void *key, uint32_t len, uint32_t initval, uint32_t max)
+{
+	return jhash(key, len, initval) % max;
+}
+
+/**
+ * Alloc a hashtable with n buckets.
+ *
+ * @size
+ * @return: hashtable
+ */
+static struct list_head *
+alloc_hashtable(unsigned int size)
+{
+	struct list_head *hash;
+	unsigned int i;
+
+	hash = kmalloc(sizeof(*hash) * size, GFP_KERNEL);
+	if (hash == NULL)
+		return NULL;
+	for (i = 0; i < size; ++i)
+		INIT_LIST_HEAD(&hash[i]);
+
+	return hash;
+}
+
+/**
+ * This function converts the status from integer to string.
+ *
+ * @status
+ * @return: status
+ */
+static inline const char *
+status_itoa(enum status status)
+{
+	switch (status) {
+		case ST_INIT: 	  	return "INIT";
+		case ST_MATCHING: 	return "MATCHING";
+		case ST_ALLOWED:  	return "ALLOWED";
+		default: 			return "UNKNOWN";
+	}
+}
+
+/**
+ * @s
+ * @pos
+ * @return: private value used by the iterator
+ */
+static void *
+pknock_seq_start(struct seq_file *s, loff_t *pos)
+{
+	const struct proc_dir_entry *pde = s->private;
+	const struct xt_pknock_rule *rule = pde->data;
+
+	spin_lock_bh(&list_lock);
+
+	if (*pos >= peer_hashsize)
+		return NULL;
+
+	return rule->peer_head + *pos;
+}
+
+/**
+ * @s
+ * @v
+ * @pos
+ * @return: next value for the iterator
+ */
+static void *
+pknock_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	const struct proc_dir_entry *pde = s->private;
+	const struct xt_pknock_rule *rule = pde->data;
+
+	++*pos;
+	if (*pos >= peer_hashsize)
+		return NULL;
+
+	return rule->peer_head + *pos;
+}
+
+/**
+ * @s
+ * @v
+ */
+static void
+pknock_seq_stop(struct seq_file *s, void *v)
+{
+	spin_unlock_bh(&list_lock);
+}
+
+/**
+ * @s
+ * @v
+ * @return: 0 if OK
+ */
+static int
+pknock_seq_show(struct seq_file *s, void *v)
+{
+	const struct list_head *pos, *n;
+	const struct peer *peer;
+	unsigned long time;
+	const struct list_head *peer_head = v;
+
+	const struct proc_dir_entry *pde = s->private;
+	const struct xt_pknock_rule *rule = pde->data;
+
+	list_for_each_safe(pos, n, peer_head) {
+		peer = list_entry(pos, struct peer, head);
+
+		seq_printf(s, "src=" NIPQUAD_FMT " ", NIPQUAD(peer->ip));
+		seq_printf(s, "proto=%s ", (peer->proto == IPPROTO_TCP) ?
+                                                "TCP" : "UDP");
+		seq_printf(s, "status=%s ", status_itoa(peer->status));
+		seq_printf(s, "accepted_knock_count=%lu ",
+			(unsigned long)peer->accepted_knock_count);
+		if (peer->status == ST_MATCHING) {
+			time = 0;
+			if (time_before(jiffies / HZ, peer->timestamp +
+			    rule->max_time))
+				time = peer->timestamp + rule->max_time -
+				       jiffies / HZ;
+			seq_printf(s, "expir_time=%lu [secs] ", time);
+		}
+		if (peer->status == ST_ALLOWED && rule->autoclose_time != 0) {
+			time = 0;
+			if (time_before(get_seconds(), peer->login_sec +
+			    rule->autoclose_time * 60))
+				time = peer->login_sec +
+				       rule->autoclose_time * 60 -
+				       get_seconds();
+			seq_printf(s, "autoclose_time=%lu [secs] ", time);
+		}
+		seq_printf(s, "\n");
+	}
+
+	return 0;
+}
+
+static const struct seq_operations pknock_seq_ops = {
+	.start = pknock_seq_start,
+	.next = pknock_seq_next,
+	.stop = pknock_seq_stop,
+	.show = pknock_seq_show
+};
+
+/**
+ * @inode
+ * @file
+ */
+static int
+pknock_proc_open(struct inode *inode, struct file *file)
+{
+	int ret = seq_open(file, &pknock_seq_ops);
+	if (ret == 0) {
+		struct seq_file *sf = file->private_data;
+		sf->private = PDE(inode);
+	}
+	return ret;
+}
+
+static const struct file_operations pknock_proc_ops = {
+	.owner = THIS_MODULE,
+	.open = pknock_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release
+};
+
+/**
+ * It updates the rule timer to execute garbage collector.
+ *
+ * @rule
+ */
+static void update_rule_gc_timer(struct xt_pknock_rule *rule)
+{
+	if (timer_pending(&rule->timer))
+		del_timer(&rule->timer);
+
+	rule->timer.expires = jiffies + msecs_to_jiffies(gc_expir_time);
+	add_timer(&rule->timer);
+}
+
+/**
+ * @peer
+ * @autoclose_time
+ *
+ * Returns true if autoclose due, or false if still valid.
+ */
+static inline bool
+autoclose_time_passed(const struct peer *peer, unsigned int autoclose_time)
+{
+	return peer != NULL && autoclose_time != 0 && time_after(get_seconds(),
+	       peer->login_sec + autoclose_time * 60);
+}
+
+/**
+ * @peer
+ * @max_time
+ * @return: 1 time exceeded, 0 still valid
+ */
+static inline bool
+is_interknock_time_exceeded(const struct peer *peer, unsigned int max_time)
+{
+	return peer != NULL && time_after(jiffies / HZ,
+	       peer->timestamp + max_time);
+}
+
+/**
+ * @peer
+ * @return: 1 has logged, 0 otherwise
+ */
+static inline bool
+has_logged_during_this_minute(const struct peer *peer)
+{
+	return peer != NULL && peer->login_sec / 60 == get_seconds() / 60;
+}
+
+/**
+ * Garbage collector. It removes the old entries after tis timers have expired.
+ *
+ * @r: rule
+ */
+static void
+peer_gc(unsigned long r)
+{
+	unsigned int i;
+	struct xt_pknock_rule *rule = (struct xt_pknock_rule *)r;
+	struct peer *peer;
+	struct list_head *pos, *n;
+
+	pr_debug("(S) running %s\n", __func__);
+	hashtable_for_each_safe(pos, n, rule->peer_head, peer_hashsize, i) {
+		peer = list_entry(pos, struct peer, head);
+
+		/*
+		 * Remove any peer whose (inter-knock) max_time
+		 * or autoclose_time passed.
+		 */
+		if ((peer->status != ST_ALLOWED &&
+		    is_interknock_time_exceeded(peer, rule->max_time)) ||
+		    (peer->status == ST_ALLOWED &&
+		    autoclose_time_passed(peer, rule->autoclose_time)))
+		{
+			pk_debug("GC-DELETED", peer);
+			list_del(pos);
+			kfree(peer);
+		}
+	}
+}
+
+/**
+ * Compares length and name equality for the rules.
+ */
+static inline bool
+rulecmp(const struct xt_pknock_mtinfo *info, const struct xt_pknock_rule *rule)
+{
+	if (info->rule_name_len != rule->rule_name_len)
+		return false;
+	if (strncmp(info->rule_name, rule->rule_name, info->rule_name_len) != 0)
+		return false;
+	return true;
+}
+
+/**
+ * Search the rule and returns a pointer if it exists.
+ *
+ * @info
+ * @return: rule or NULL
+ */
+static struct xt_pknock_rule *search_rule(const struct xt_pknock_mtinfo *info)
+{
+	struct xt_pknock_rule *rule;
+	struct list_head *pos, *n;
+	unsigned int hash = pknock_hash(info->rule_name, info->rule_name_len,
+					ipt_pknock_hash_rnd, rule_hashsize);
+
+	list_for_each_safe(pos, n, &rule_hashtable[hash]) {
+		rule = list_entry(pos, struct xt_pknock_rule, head);
+		if (rulecmp(info, rule))
+			return rule;
+	}
+	return NULL;
+}
+
+/**
+ * It adds a rule to list only if it doesn't exist.
+ *
+ * @info
+ * @return: 1 success, 0 failure
+ */
+static bool
+add_rule(struct xt_pknock_mtinfo *info)
+{
+	struct xt_pknock_rule *rule;
+	struct list_head *pos, *n;
+	unsigned int hash = pknock_hash(info->rule_name, info->rule_name_len,
+                                ipt_pknock_hash_rnd, rule_hashsize);
+
+	list_for_each_safe(pos, n, &rule_hashtable[hash]) {
+		rule = list_entry(pos, struct xt_pknock_rule, head);
+
+		if (!rulecmp(info, rule))
+			continue;
+		++rule->ref_count;
+
+		if (info->option & XT_PKNOCK_OPENSECRET) {
+			rule->max_time       = info->max_time;
+			rule->autoclose_time = info->autoclose_time;
+		}
+
+		if (info->option & XT_PKNOCK_CHECKIP)
+			pr_debug("add_rule() (AC) rule found: %s - "
+				"ref_count: %d\n",
+				rule->rule_name, rule->ref_count);
+		return true;
+	}
+
+	rule = kmalloc(sizeof(*rule), GFP_KERNEL);
+	if (rule == NULL)
+		return false;
+
+	INIT_LIST_HEAD(&rule->head);
+
+	memset(rule->rule_name, 0, sizeof(rule->rule_name));
+	strncpy(rule->rule_name, info->rule_name, info->rule_name_len);
+	rule->rule_name_len = info->rule_name_len;
+
+	rule->ref_count      = 1;
+	rule->max_time       = info->max_time;
+	rule->autoclose_time = info->autoclose_time;
+	rule->peer_head      = alloc_hashtable(peer_hashsize);
+	if (rule->peer_head == NULL)
+		goto out;
+
+	init_timer(&rule->timer);
+	rule->timer.function	= peer_gc;
+	rule->timer.data	= (unsigned long)rule;
+
+	rule->status_proc = create_proc_entry(info->rule_name, 0, pde);
+	if (rule->status_proc == NULL)
+		goto out;
+
+	rule->status_proc->proc_fops = &pknock_proc_ops;
+	rule->status_proc->data = rule;
+
+	list_add(&rule->head, &rule_hashtable[hash]);
+	pr_debug("(A) rule_name: %s - created.\n", rule->rule_name);
+	return true;
+ out:
+	kfree(rule->peer_head);
+	kfree(rule);
+	return false;
+}
+
+/**
+ * It removes a rule only if it exists.
+ *
+ * @info
+ */
+static void
+remove_rule(struct xt_pknock_mtinfo *info)
+{
+	struct xt_pknock_rule *rule = NULL;
+	struct list_head *pos, *n;
+	struct peer *peer;
+	unsigned int i;
+	int found = 0;
+	unsigned int hash = pknock_hash(info->rule_name, info->rule_name_len,
+                                ipt_pknock_hash_rnd, rule_hashsize);
+
+	if (list_empty(&rule_hashtable[hash]))
+		return;
+
+	list_for_each_safe(pos, n, &rule_hashtable[hash]) {
+		rule = list_entry(pos, struct xt_pknock_rule, head);
+
+		if (rulecmp(info, rule)) {
+			found = 1;
+			rule->ref_count--;
+			break;
+		}
+	}
+	if (!found) {
+		pr_debug("(N) rule not found: %s.\n", info->rule_name);
+		return;
+	}
+	if (rule == NULL || rule->ref_count != 0)
+		return;
+
+	hashtable_for_each_safe(pos, n, rule->peer_head, peer_hashsize, i) {
+		peer = list_entry(pos, struct peer, head);
+		pk_debug("DELETED", peer);
+		list_del(pos);
+		kfree(peer);
+	}
+
+	if (rule->status_proc != NULL)
+		remove_proc_entry(info->rule_name, pde);
+	pr_debug("(D) rule deleted: %s.\n", rule->rule_name);
+	if (timer_pending(&rule->timer))
+		del_timer(&rule->timer);
+
+	list_del(&rule->head);
+	kfree(rule->peer_head);
+	kfree(rule);
+}
+
+/**
+ * If peer status exist in the list it returns peer status, if not it returns NULL.
+ *
+ * @rule
+ * @ip
+ * @return: peer or NULL
+ */
+static struct peer *get_peer(struct xt_pknock_rule *rule, __be32 ip)
+{
+	struct peer *peer;
+	struct list_head *pos, *n;
+	unsigned int hash;
+
+	hash = pknock_hash(&ip, sizeof(ip), ipt_pknock_hash_rnd, peer_hashsize);
+
+	list_for_each_safe(pos, n, &rule->peer_head[hash]) {
+		peer = list_entry(pos, struct peer, head);
+		if (peer->ip == ip)
+			return peer;
+	}
+	return NULL;
+}
+
+/**
+ * Reset the knock sequence status of the peer.
+ *
+ * @peer
+ */
+static void reset_knock_status(struct peer *peer)
+{
+	peer->accepted_knock_count = 0;
+	peer->status = ST_INIT;
+}
+
+/**
+ * It creates a new peer matching status.
+ *
+ * @rule
+ * @ip
+ * @proto
+ * @return: peer or NULL
+ */
+static struct peer *new_peer(__be32 ip, uint8_t proto)
+{
+	struct peer *peer = kmalloc(sizeof(*peer), GFP_ATOMIC);
+
+	if (peer == NULL)
+		return NULL;
+
+	INIT_LIST_HEAD(&peer->head);
+	peer->ip	= ip;
+	peer->proto	= proto;
+	peer->timestamp = jiffies/HZ;
+	peer->login_sec = 0;
+	reset_knock_status(peer);
+
+	return peer;
+}
+
+/**
+ * It adds a new peer matching status to the list.
+ *
+ * @peer
+ * @rule
+ */
+static void add_peer(struct peer *peer, struct xt_pknock_rule *rule)
+{
+	unsigned int hash = pknock_hash(&peer->ip, sizeof(peer->ip),
+                                ipt_pknock_hash_rnd, peer_hashsize);
+	list_add(&peer->head, &rule->peer_head[hash]);
+}
+
+/**
+ * It removes a peer matching status.
+ *
+ * @peer
+ */
+static void remove_peer(struct peer *peer)
+{
+	list_del(&peer->head);
+	if (peer != NULL)
+		kfree(peer);
+}
+
+/**
+ * @peer
+ * @info
+ * @port
+ * @return: 1 success, 0 failure
+ */
+static inline bool
+is_first_knock(const struct peer *peer, const struct xt_pknock_mtinfo *info,
+                uint16_t port)
+{
+	return peer == NULL && info->port[0] == port;
+}
+
+/**
+ * @peer
+ * @info
+ * @port
+ * @return: 1 success, 0 failure
+ */
+static inline bool
+is_wrong_knock(const struct peer *peer, const struct xt_pknock_mtinfo *info,
+		uint16_t port)
+{
+	return peer != NULL && info->port[peer->accepted_knock_count] != port;
+}
+
+/**
+ * @peer
+ * @info
+ * @return: 1 success, 0 failure
+ */
+static inline bool
+is_last_knock(const struct peer *peer, const struct xt_pknock_mtinfo *info)
+{
+	return peer != NULL && peer->accepted_knock_count == info->ports_count;
+}
+
+/**
+ * @peer
+ * @return: 1 success, 0 failure
+ */
+static inline bool
+is_allowed(const struct peer *peer)
+{
+	return peer != NULL && peer->status == ST_ALLOWED;
+}
+
+/**
+ * Sends a message to user space through netlink sockets.
+ *
+ * @info
+ * @peer
+ * @return: 1 success, 0 otherwise
+ */
+static bool
+msg_to_userspace_nl(const struct xt_pknock_mtinfo *info,
+                const struct peer *peer, int multicast_group)
+{
+#if defined(CONFIG_CONNECTOR) || defined(CONFIG_CONNECTOR_MODULE)
+	struct cn_msg *m;
+	struct xt_pknock_nl_msg msg;
+
+	m = kmalloc(sizeof(*m) + sizeof(msg), GFP_ATOMIC);
+	if (m == NULL)
+		return false;
+
+	memset(m, 0, sizeof(*m) + sizeof(msg));
+	m->seq = 0;
+	m->len = sizeof(msg);
+
+	msg.peer_ip = peer->ip;
+	scnprintf(msg.rule_name, info->rule_name_len + 1, info->rule_name);
+
+	memcpy(m + 1, &msg, m->len);
+
+	cn_netlink_send(m, multicast_group, GFP_ATOMIC);
+
+	kfree(m);
+#endif
+	return true;
+}
+
+#ifdef PK_CRYPTO
+/**
+ * Transforms a sequence of characters to hexadecimal.
+ *
+ * @out: the hexadecimal result
+ * @crypt: the original sequence
+ * @size
+ */
+static void
+crypt_to_hex(char *out, const char *crypt, unsigned int size)
+{
+	unsigned int i;
+	for (i = 0; i < size; ++i) {
+		unsigned char c = crypt[i];
+		*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);
+		*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);
+	}
+}
+
+/**
+ * Checks that the payload has the hmac(secret+ipsrc+epoch_min).
+ *
+ * @secret
+ * @secret_len
+ * @ipsrc
+ * @payload
+ * @payload_len
+ * @return: 1 success, 0 failure
+ */
+static bool
+has_secret(const unsigned char *secret, unsigned int secret_len, uint32_t ipsrc,
+    const unsigned char *payload, unsigned int payload_len)
+{
+	struct scatterlist sg[2];
+	char result[64]; // 64 bytes * 8 = 512 bits
+	char *hexresult;
+	unsigned int hexa_size;
+	int ret;
+	bool fret = false;
+	unsigned int epoch_min;
+
+	if (payload_len == 0)
+		return false;
+
+	/*
+	 * hexa:  4bits
+	 * ascii: 8bits
+	 * hexa = ascii * 2
+	 */
+	hexa_size = crypto.size * 2;
+
+	/* + 1 cause we MUST add NULL in the payload */
+	if (payload_len != hexa_size + 1)
+		return false;
+
+	hexresult = kmalloc(hexa_size, GFP_ATOMIC);
+	if (hexresult == NULL)
+		return false;
+
+	memset(result, 0, sizeof(result));
+	memset(hexresult, 0, hexa_size);
+
+	epoch_min = get_seconds() / 60;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+	sg_init_table(sg, ARRAY_SIZE(sg));
+#endif
+	sg_set_buf(&sg[0], &ipsrc, sizeof(ipsrc));
+	sg_set_buf(&sg[1], &epoch_min, sizeof(epoch_min));
+
+	ret = crypto_hash_setkey(crypto.tfm, secret, secret_len);
+	if (ret != 0) {
+		printk("crypto_hash_setkey() failed ret=%d\n", ret);
+		goto out;
+	}
+
+	/*
+	 * The third parameter is the number of bytes INSIDE the sg!
+	 * 4 bytes IP (32 bits) +
+	 * 4 bytes int epoch_min (32 bits)
+	 */
+	ret = crypto_hash_digest(&crypto.desc, sg,
+	      sizeof(ipsrc) + sizeof(epoch_min), result);
+	if (ret != 0) {
+		printk("crypto_hash_digest() failed ret=%d\n", ret);
+		goto out;
+	}
+
+	crypt_to_hex(hexresult, result, crypto.size);
+
+	if (memcmp(hexresult, payload, hexa_size) != 0)
+		pr_debug("secret match failed\n");
+	else
+		fret = true;
+
+ out:
+	kfree(hexresult);
+	return fret;
+}
+#endif /* PK_CRYPTO */
+
+/**
+ * If the peer pass the security policy.
+ *
+ * @peer
+ * @info
+ * @payload
+ * @payload_len
+ * @return: 1 if pass security, 0 otherwise
+ */
+static bool
+pass_security(struct peer *peer, const struct xt_pknock_mtinfo *info,
+        const unsigned char *payload, unsigned int payload_len)
+{
+	if (is_allowed(peer))
+		return true;
+
+	/* The peer can't log more than once during the same minute. */
+	if (has_logged_during_this_minute(peer)) {
+		pk_debug("DENIED (anti-spoof protection)", peer);
+		return false;
+	}
+#ifdef PK_CRYPTO
+	/* Check for OPEN secret */
+	if (has_secret(info->open_secret,
+					info->open_secret_len, peer->ip,
+					payload, payload_len))
+		return true;
+#endif
+
+	return false;
+}
+
+/**
+ * Validates the peer and updates the peer status for an initiating or
+ * in-sequence knock packet.
+ *
+ * @peer
+ * @info
+ * @rule
+ * @hdr
+ *
+ * Returns true if allowed, false otherwise.
+ */
+static bool
+update_peer(struct peer *peer, const struct xt_pknock_mtinfo *info,
+		struct xt_pknock_rule *rule,
+		const struct transport_data *hdr)
+{
+	unsigned long time;
+
+	if (is_wrong_knock(peer, info, hdr->port)) {
+		pk_debug("DIDN'T MATCH", peer);
+		/* Peer must start the sequence from scratch. */
+		if (info->option & XT_PKNOCK_STRICT)
+			remove_peer(peer);
+
+		return false;
+	}
+
+	/* If security is needed. */
+	if (info->option & XT_PKNOCK_OPENSECRET ) {
+		if (hdr->proto != IPPROTO_UDP && hdr->proto != IPPROTO_UDPLITE)
+			return false;
+
+		if (!pass_security(peer, info, hdr->payload, hdr->payload_len))
+			return false;
+	}
+
+	/* Update the gc timer when there is a state change. */
+	update_rule_gc_timer(rule);
+
+	++peer->accepted_knock_count;
+
+	if (is_last_knock(peer, info)) {
+		peer->status = ST_ALLOWED;
+
+		pk_debug("ALLOWED", peer);
+		peer->login_sec = get_seconds();
+
+		if (nl_multicast_group > 0)
+			msg_to_userspace_nl(info, peer, nl_multicast_group);
+
+		return true;
+	}
+
+	/* Immediate control over the maximum time between knocks. */
+	if (info->option & XT_PKNOCK_TIME) {
+		time = jiffies/HZ;
+
+		if (is_interknock_time_exceeded(peer, info->max_time)) {
+			pk_debug("ST_MATCHING knock received after interknock "
+				"time passed => destroyed", peer);
+			pr_debug("max_time: %ld - time: %ld\n",
+					peer->timestamp + info->max_time,
+					time);
+			remove_peer(peer);
+			return false;
+		}
+		peer->timestamp = time;
+	}
+	pk_debug("MATCHING", peer);
+	peer->status = ST_MATCHING;
+	return false;
+}
+
+/**
+ * Make the peer no more ALLOWED sending a payload with a special secret for
+ * closure.
+ *
+ * @peer
+ * @info
+ * @payload
+ * @payload_len
+ * @return: 1 if close knock, 0 otherwise
+ */
+static bool
+is_close_knock(const struct peer *peer, const struct xt_pknock_mtinfo *info,
+		const unsigned char *payload, unsigned int payload_len)
+{
+#ifdef PK_CRYPTO
+	/* Check for CLOSE secret. */
+	if (has_secret(info->close_secret,
+				info->close_secret_len, peer->ip,
+				payload, payload_len))
+	{
+		pk_debug("BLOCKED", peer);
+		return true;
+	}
+#endif
+	return false;
+}
+
+static bool pknock_mt(const struct sk_buff *skb,
+    struct xt_action_param *par)
+{
+	const struct xt_pknock_mtinfo *info = par->matchinfo;
+	struct xt_pknock_rule *rule;
+	struct peer *peer;
+	const struct iphdr *iph = ip_hdr(skb);
+	unsigned int hdr_len = 0;
+	__be16 _ports[2];
+	const __be16 *pptr;
+	struct transport_data hdr = {0, 0, 0, NULL};
+	bool ret = false;
+
+	pptr = skb_header_pointer(skb, par->thoff, sizeof _ports, &_ports);
+	if (pptr == NULL) {
+		/* We've been asked to examine this packet, and we
+		 * can't. Hence, no choice but to drop.
+		 */
+		par->hotdrop = true;
+		return false;
+	}
+
+	hdr.port = ntohs(pptr[1]);
+	hdr.proto = iph->protocol;
+
+	switch (hdr.proto) {
+	case IPPROTO_TCP:
+		break;
+
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+#ifdef PK_CRYPTO
+		hdr_len = (iph->ihl * 4) + sizeof(struct udphdr);
+		break;
+#else
+		pr_debug("UDP protocol not supported\n");
+		return false;
+#endif
+
+	default:
+		pr_debug("IP payload protocol is neither tcp nor udp.\n");
+		return false;
+	}
+
+	spin_lock_bh(&list_lock);
+
+	/* Searches a rule from the list depending on info structure options. */
+	rule = search_rule(info);
+	if (rule == NULL) {
+		printk(KERN_INFO PKNOCK "The rule %s doesn't exist.\n",
+						info->rule_name);
+		goto out;
+	}
+
+	/* Gives the peer matching status added to rule depending on ip src. */
+	peer = get_peer(rule, iph->saddr);
+
+	if (info->option & XT_PKNOCK_CHECKIP) {
+		ret = is_allowed(peer);
+		goto out;
+	}
+
+	if (iph->protocol == IPPROTO_UDP || iph->protocol == IPPROTO_UDPLITE) {
+		hdr.payload = (void *)iph + hdr_len;
+		hdr.payload_len = skb->len - hdr_len;
+	}
+
+	/* Sets, updates, removes or checks the peer matching status. */
+	if (info->option & XT_PKNOCK_KNOCKPORT) {
+		if ((ret = is_allowed(peer))) {
+			if (info->option & XT_PKNOCK_CLOSESECRET &&
+			    (iph->protocol == IPPROTO_UDP ||
+			    iph->protocol == IPPROTO_UDPLITE))
+			{
+				if (is_close_knock(peer, info, hdr.payload, hdr.payload_len))
+				{
+					reset_knock_status(peer);
+					ret = false;
+				}
+			}
+			goto out;
+		}
+
+		if (is_first_knock(peer, info, hdr.port)) {
+			peer = new_peer(iph->saddr, iph->protocol);
+			add_peer(peer, rule);
+		}
+
+		if (peer == NULL)
+			goto out;
+
+		update_peer(peer, info, rule, &hdr);
+	}
+
+out:
+	/* Handle cur.peer matching and deletion after autoclose_time passed */
+	if (ret && autoclose_time_passed(peer, rule->autoclose_time)) {
+		pk_debug("AUTOCLOSE TIME PASSED => BLOCKED", peer);
+		ret = false;
+		if (iph->protocol == IPPROTO_TCP ||
+		    !has_logged_during_this_minute(peer))
+			remove_peer(peer);
+	}
+
+	if (ret)
+		pk_debug("PASS OK", peer);
+	spin_unlock_bh(&list_lock);
+	return ret;
+}
+
+#define RETURN_ERR(err) do { printk(KERN_ERR PKNOCK err); return -EINVAL; } while (false)
+
+static int pknock_mt_check(const struct xt_mtchk_param *par)
+{
+	struct xt_pknock_mtinfo *info = par->matchinfo;
+
+	/* Singleton. */
+	if (rule_hashtable == NULL) {
+		rule_hashtable = alloc_hashtable(rule_hashsize);
+		if (rule_hashtable == NULL)
+			RETURN_ERR("alloc_hashtable() error in checkentry()\n");
+
+		get_random_bytes(&ipt_pknock_hash_rnd, sizeof (ipt_pknock_hash_rnd));
+	}
+
+	if (!(info->option & XT_PKNOCK_NAME))
+		RETURN_ERR("You must specify --name option.\n");
+
+#ifndef PK_CRYPTO
+	if (info->option & (XT_PKNOCK_OPENSECRET | XT_PKNOCK_CLOSESECRET))
+		RETURN_ERR("No crypto support available; "
+			"cannot use opensecret/closescret\n");
+#endif
+	if (info->option & XT_PKNOCK_OPENSECRET && info->ports_count != 1)
+		RETURN_ERR("--opensecret must have just one knock port\n");
+	if (info->option & XT_PKNOCK_KNOCKPORT) {
+		if (info->option & XT_PKNOCK_CHECKIP)
+			RETURN_ERR("Can't specify --knockports with --checkip.\n");
+		if (info->option & XT_PKNOCK_OPENSECRET &&
+				!(info->option & XT_PKNOCK_CLOSESECRET))
+			RETURN_ERR("--opensecret must go with --closesecret.\n");
+		if (info->option & XT_PKNOCK_CLOSESECRET &&
+				!(info->option & XT_PKNOCK_OPENSECRET))
+			RETURN_ERR("--closesecret must go with --opensecret.\n");
+	}
+
+	if (info->option & XT_PKNOCK_CHECKIP) {
+		if (info->option & XT_PKNOCK_KNOCKPORT)
+			RETURN_ERR("Can't specify --checkip with --knockports.\n");
+		if ((info->option & XT_PKNOCK_OPENSECRET) ||
+				(info->option & XT_PKNOCK_CLOSESECRET))
+			RETURN_ERR("Can't specify --opensecret and --closesecret"
+							" with --checkip.\n");
+		if (info->option & XT_PKNOCK_TIME)
+			RETURN_ERR("Can't specify --time with --checkip.\n");
+		if (info->option & XT_PKNOCK_AUTOCLOSE)
+			RETURN_ERR("Can't specify --autoclose with --checkip.\n");
+	} else if (!(info->option & (XT_PKNOCK_OPENSECRET | XT_PKNOCK_TIME))) {
+		RETURN_ERR("you must specify --time.\n");
+	}
+
+	if (info->option & XT_PKNOCK_OPENSECRET &&
+	    info->open_secret_len == info->close_secret_len &&
+	    memcmp(info->open_secret, info->close_secret,
+	    info->open_secret_len) == 0)
+		RETURN_ERR("opensecret & closesecret cannot be equal.\n");
+
+	if (!add_rule(info))
+		/* should ENOMEM here */
+		RETURN_ERR("add_rule() error in checkentry() function.\n");
+
+	return 0;
+}
+
+static void pknock_mt_destroy(const struct xt_mtdtor_param *par)
+{
+	struct xt_pknock_mtinfo *info = par->matchinfo;
+	/* Removes a rule only if it exits and ref_count is equal to 0. */
+	remove_rule(info);
+}
+
+static struct xt_match xt_pknock_mt_reg __read_mostly = {
+	.name		= "pknock",
+	.revision   = 1,
+	.family		= NFPROTO_IPV4,
+	.matchsize  = sizeof(struct xt_pknock_mtinfo),
+	.match      = pknock_mt,
+	.checkentry = pknock_mt_check,
+	.destroy    = pknock_mt_destroy,
+	.me			= THIS_MODULE
+};
+
+static int __init xt_pknock_mt_init(void)
+{
+#if !defined(CONFIG_CONNECTOR) && !defined(CONFIG_CONNECTOR_MODULE)
+	if (nl_multicast_group != -1)
+		pr_info("CONFIG_CONNECTOR not present; "
+		        "netlink messages disabled\n");
+#endif
+
+	if (gc_expir_time < DEFAULT_GC_EXPIRATION_TIME)
+		gc_expir_time = DEFAULT_GC_EXPIRATION_TIME;
+#ifdef PK_CRYPTO
+	if (request_module(crypto.algo) < 0) {
+		printk(KERN_ERR PKNOCK "request_module('%s') error.\n",
+                        crypto.algo);
+		return -ENXIO;
+	}
+
+	crypto.tfm = crypto_alloc_hash(crypto.algo, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(crypto.tfm)) {
+		printk(KERN_ERR PKNOCK "failed to load transform for %s\n",
+						crypto.algo);
+		return PTR_ERR(crypto.tfm);
+	}
+
+	crypto.size = crypto_hash_digestsize(crypto.tfm);
+	crypto.desc.tfm = crypto.tfm;
+	crypto.desc.flags = 0;
+#else
+	pr_info("No crypto support for < 2.6.19\n");
+#endif
+
+	pde = proc_mkdir("xt_pknock", init_net__proc_net);
+	if (pde == NULL) {
+		printk(KERN_ERR PKNOCK "proc_mkdir() error in _init().\n");
+		return -ENXIO;
+	}
+	return xt_register_match(&xt_pknock_mt_reg);
+}
+
+static void __exit xt_pknock_mt_exit(void)
+{
+	remove_proc_entry("xt_pknock", init_net__proc_net);
+	xt_unregister_match(&xt_pknock_mt_reg);
+	kfree(rule_hashtable);
+
+#ifdef PK_CRYPTO
+	if (crypto.tfm != NULL)
+		crypto_free_hash(crypto.tfm);
+#endif
+}
+
+module_init(xt_pknock_mt_init);
+module_exit(xt_pknock_mt_exit);

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_pknock.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_pknock.h
@@ -0,0 +1,53 @@
+/*
+ * Kernel module to implement Port Knocking and SPA matching support.
+ *
+ * (C) 2006-2008 J. Federico Hernandez <fede.hernandez@gmail.com>
+ * (C) 2006 Luis Floreani <luis.floreani@gmail.com>
+ *
+ * $Id$
+ *
+ * This program is released under the terms of GNU GPL version 2.
+ */
+#ifndef _XT_PKNOCK_H
+#define _XT_PKNOCK_H
+
+#define PKNOCK "xt_pknock: "
+
+enum {
+	XT_PKNOCK_KNOCKPORT   = 1 << 0,
+	XT_PKNOCK_TIME        = 1 << 1,
+	XT_PKNOCK_NAME        = 1 << 2,
+	XT_PKNOCK_STRICT      = 1 << 3,
+	XT_PKNOCK_CHECKIP     = 1 << 4,
+	XT_PKNOCK_OPENSECRET  = 1 << 5,
+	XT_PKNOCK_CLOSESECRET = 1 << 6,
+	XT_PKNOCK_AUTOCLOSE   = 1 << 7,
+
+	/* Can never change these, as they are make up the user protocol. */
+	XT_PKNOCK_MAX_PORTS      = 15,
+	XT_PKNOCK_MAX_BUF_LEN    = 31,
+	XT_PKNOCK_MAX_PASSWD_LEN = 31,
+};
+
+#define DEBUG 1
+
+struct xt_pknock_mtinfo {
+	char rule_name[XT_PKNOCK_MAX_BUF_LEN+1];
+	uint32_t			rule_name_len;
+	char open_secret[XT_PKNOCK_MAX_PASSWD_LEN+1];
+	uint32_t			open_secret_len;
+	char close_secret[XT_PKNOCK_MAX_PASSWD_LEN+1];
+	uint32_t			close_secret_len;
+	uint8_t	option;		/* --time, --knock-port, ... */
+	uint8_t	ports_count;	/* number of ports */
+	uint16_t	port[XT_PKNOCK_MAX_PORTS]; /* port[,port,port,...] */
+	uint32_t	max_time;	/* max matching time between ports */
+	uint32_t autoclose_time;
+};
+
+struct xt_pknock_nl_msg {
+	char rule_name[XT_PKNOCK_MAX_BUF_LEN+1];
+	__be32 peer_ip;
+};
+
+#endif /* _XT_PKNOCK_H */

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_psd.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_psd.c
@@ -0,0 +1,601 @@
+/*
+  This is a module which is used for PSD (portscan detection)
+  Derived from scanlogd v2.1 written by Solar Designer <solar@false.com>
+  and LOG target module.
+
+  Copyright (C) 2000,2001 astaro AG
+
+  This file is distributed under the terms of the GNU General Public
+  License (GPL). Copies of the GPL can be obtained from:
+     ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+  2000-05-04 Markus Hennig <hennig@astaro.de> : initial
+  2000-08-18 Dennis Koslowski <koslowski@astaro.de> : first release
+  2000-12-01 Dennis Koslowski <koslowski@astaro.de> : UDP scans detection added
+  2001-01-02 Dennis Koslowski <koslowski@astaro.de> : output modified
+  2001-02-04 Jan Rekorajski <baggins@pld.org.pl> : converted from target to match
+  2004-05-05 Martijn Lievaart <m@rtij.nl> : ported to 2.6
+  2007-04-05 Mohd Nawawi Mohamad Jamili <nawawi@tracenetworkcorporation.com> : ported to 2.6.18
+  2008-03-21 Mohd Nawawi Mohamad Jamili <nawawi@tracenetworkcorporation.com> : ported to 2.6.24
+  2009-08-07 Mohd Nawawi Mohamad Jamili <nawawi@tracenetworkcorporation.com> : ported to xtables-addons
+*/
+
+#define pr_fmt(x) KBUILD_MODNAME ": " x
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/types.h>
+#include <linux/tcp.h>
+#include <linux/spinlock.h>
+#include <linux/vmalloc.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include "xt_psd.h"
+#include "compat_xtables.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Dennis Koslowski <koslowski@astaro.com>");
+MODULE_AUTHOR("Martijn Lievaart <m@rtij.nl>");
+MODULE_AUTHOR("Jan Rekorajski <baggins@pld.org.pl>");
+MODULE_AUTHOR(" Mohd Nawawi Mohamad Jamili <nawawi@tracenetworkcorporation.com>");
+MODULE_DESCRIPTION("Xtables: PSD - portscan detection");
+MODULE_ALIAS("ipt_psd");
+MODULE_ALIAS("ip6t_psd");
+
+/*
+ * Keep track of up to LIST_SIZE source addresses, using a hash table of
+ * HASH_SIZE entries for faster lookups, but limiting hash collisions to
+ * HASH_MAX source addresses per the same hash value.
+ */
+#define LIST_SIZE			0x100
+#define HASH_LOG			9
+#define HASH_SIZE			(1 << HASH_LOG)
+#define HASH_MAX			0x10
+
+#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
+#	define WITH_IPV6 1
+#endif
+
+/*
+ * Information we keep per each target port
+ */
+struct port {
+	u_int16_t number;      /* port number */
+	u_int8_t proto;        /* protocol number */
+};
+
+/**
+ * Information we keep per each source address.
+ * @next:	next entry with the same hash
+ * @timestamp:	last update time
+ * @count:	number of ports in the list
+ * @weight:	total weight of ports in the list
+ */
+struct host {
+	struct host *next;
+	unsigned long timestamp;
+	__be16 src_port;
+	uint16_t count;
+	uint8_t weight;
+	struct port ports[SCAN_MAX_COUNT-1];
+};
+
+/**
+ * Information we keep per ipv4 source address.
+ */
+struct host4 {
+	struct host host;
+	__be32 saddr;
+};
+
+static struct host4 *host_to_host4(const struct host *h)
+{
+	return (struct host4 *)h;
+}
+
+struct host6 {
+	struct host host;
+	struct in6_addr saddr;
+};
+
+/**
+ * State information for IPv4 portscan detection.
+ * @list:	list of source addresses
+ * @hash:	pointers into the list
+ * @index:	oldest entry to be replaced
+ */
+static struct {
+	spinlock_t lock;
+	struct host4 list[LIST_SIZE];
+	struct host *hash[HASH_SIZE];
+	int index;
+} state;
+
+#ifdef WITH_IPV6
+/**
+ * State information for IPv6 portscan detection.
+ * @list:	list of source addresses
+ * @hash:	pointers into the list
+ * @index:	oldest entry to be replaced
+ */
+static struct {
+	spinlock_t lock;
+	struct host6 *list;
+	struct host **hash;
+	int index;
+} state6;
+
+static struct host6 *host_to_host6(const struct host *h)
+{
+	return (struct host6 *) h;
+}
+
+/**
+ * allocate state6 memory only when needed
+ */
+static bool state6_alloc_mem(void)
+{
+	if (state6.hash != NULL)
+		return true;
+
+	state6.list = vmalloc(LIST_SIZE * sizeof(struct host6));
+	if (state6.list == NULL)
+		return false;
+	memset(state6.list, 0, LIST_SIZE * sizeof(struct host6));
+
+	state6.hash = vmalloc(HASH_SIZE * sizeof(struct host*));
+	if (state6.hash == NULL) {
+		vfree(state6.list);
+		return false;
+	}
+	memset(state6.hash, 0, HASH_SIZE * sizeof(struct host *));
+	return true;
+}
+#endif
+
+/*
+ * Convert an IP address into a hash table index.
+ */
+static unsigned int hashfunc(__be32 addr)
+{
+	unsigned int value;
+	unsigned int hash;
+
+	value = addr;
+	hash = 0;
+	do {
+		hash ^= value;
+	} while ((value >>= HASH_LOG) != 0);
+
+	return hash & (HASH_SIZE - 1);
+}
+
+static inline unsigned int hashfunc6(const struct in6_addr *addr)
+{
+	__be32 h = addr->s6_addr32[0] ^ addr->s6_addr32[1];
+	return hashfunc(h ^ addr->s6_addr32[2] ^ addr->s6_addr32[3]);
+}
+
+static bool port_in_list(struct host *host, uint8_t proto, uint16_t port)
+{
+	unsigned int i;
+
+	for (i = 0; i < host->count; ++i) {
+		if (host->ports[i].proto != proto)
+			continue;
+		if (host->ports[i].number == port)
+			return true;
+	}
+	return false;
+}
+
+static uint16_t get_port_weight(const struct xt_psd_info *psd, __be16 port)
+{
+	return ntohs(port) < 1024 ? psd->lo_ports_weight : psd->hi_ports_weight;
+}
+
+static bool
+is_portscan(struct host *host, const struct xt_psd_info *psdinfo,
+            const struct tcphdr *tcph, uint8_t proto)
+{
+	if (port_in_list(host, proto, tcph->dest))
+		return false;
+
+	/*
+	 * TCP/ACK and/or TCP/RST to a new port? This could be an
+	 * outgoing connection.
+	 */
+	if (proto == IPPROTO_TCP && (tcph->ack || tcph->rst))
+		return false;
+
+	host->timestamp = jiffies;
+
+	if (host->weight >= psdinfo->weight_threshold) /* already matched */
+		return true;
+
+	/* Update the total weight */
+	host->weight += get_port_weight(psdinfo, tcph->dest);
+
+	/* Got enough destination ports to decide that this is a scan? */
+	if (host->weight >= psdinfo->weight_threshold)
+		return true;
+
+	/* Remember the new port */
+	if (host->count < ARRAY_SIZE(host->ports)) {
+		host->ports[host->count].number = tcph->dest;
+		host->ports[host->count].proto = proto;
+		host->count++;
+	}
+	return false;
+}
+
+static struct host *host_get_next(struct host *h, struct host **last)
+{
+	if (h->next != NULL)
+		*last = h;
+	return h->next;
+}
+
+static void ht_unlink(struct host **head, struct host *last)
+{
+	if (last != NULL)
+		last->next = last->next->next;
+	else if (*head != NULL)
+		*head = (*head)->next;
+}
+
+static bool
+entry_is_recent(const struct host *h, unsigned long delay_threshold,
+                unsigned long now)
+{
+	return now - h->timestamp <= (delay_threshold * HZ) / 100 &&
+	       time_after_eq(now, h->timestamp);
+}
+
+static void remove_oldest(struct host **head, struct host *curr)
+{
+	struct host *h, *last = NULL;
+
+	/*
+	 * We are going to re-use the oldest list entry, so remove it from the
+	 * hash table first, if it is really already in use.
+	 */
+	h = *head;
+	while (h != NULL) {
+		if (curr == h)
+			break;
+		last = h;
+		h = h->next;
+	}
+
+	/* Then, remove it */
+	if (h != NULL)
+		ht_unlink(head, last);
+}
+
+static void *
+get_header_pointer4(const struct sk_buff *skb, unsigned int thoff, void *mem)
+{
+	const struct iphdr *iph = ip_hdr(skb);
+	int hdrlen;
+
+	switch (iph->protocol) {
+	case IPPROTO_TCP:
+		hdrlen = sizeof(struct tcphdr);
+		break;
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+		hdrlen = sizeof(struct udphdr);
+		break;
+	default:
+		return NULL;
+	}
+
+	return skb_header_pointer(skb, thoff, hdrlen, mem);
+}
+
+static bool
+handle_packet4(const struct iphdr *iph, const struct tcphdr *tcph,
+               const struct xt_psd_info *psdinfo, unsigned int hash)
+{
+	unsigned long now;
+	struct host *curr, *last = NULL, **head;
+	struct host4 *curr4;
+	int count = 0;
+
+	now = jiffies;
+	head = &state.hash[hash];
+
+	/* Do we know this source address already? */
+	curr = *head;
+	while (curr != NULL) {
+		curr4 = host_to_host4(curr);
+		if (curr4->saddr == iph->saddr)
+			break;
+		count++;
+		curr = host_get_next(curr, &last);
+	}
+
+	if (curr != NULL) {
+		/* We know this address, and the entry isn't too old. Update it. */
+		if (entry_is_recent(curr, psdinfo->delay_threshold, now))
+			return is_portscan(curr, psdinfo, tcph, iph->protocol);
+
+		/* We know this address, but the entry is outdated. Mark it unused, and
+		 * remove from the hash table. We'll allocate a new entry instead since
+		 * this one might get re-used too soon. */
+		curr4 = host_to_host4(curr);
+		curr4->saddr = 0;
+		ht_unlink(head, last);
+		last = NULL;
+	}
+
+	/* We don't need an ACK from a new source address */
+	if (iph->protocol == IPPROTO_TCP && tcph->ack)
+		return false;
+
+	/* Got too many source addresses with the same hash value? Then remove the
+	 * oldest one from the hash table, so that they can't take too much of our
+	 * CPU time even with carefully chosen spoofed IP addresses. */
+	if (count >= HASH_MAX && last != NULL)
+		last->next = NULL;
+
+	if (state.list[state.index].saddr != 0)
+		head = &state.hash[hashfunc(state.list[state.index].saddr)];
+	else
+		head = &last;
+
+	/* Get our list entry */
+	curr4 = &state.list[state.index++];
+	curr = &curr4->host;
+	remove_oldest(head, curr);
+	if (state.index >= LIST_SIZE)
+		state.index = 0;
+
+	/* Link it into the hash table */
+	head = &state.hash[hash];
+	curr->next = *head;
+	*head = curr;
+
+	/* And fill in the fields */
+	curr4 = host_to_host4(curr);
+	curr4->saddr = iph->saddr;
+	curr->timestamp = now;
+	curr->count = 1;
+	curr->weight = get_port_weight(psdinfo, tcph->dest);
+	curr->ports[0].number = tcph->dest;
+	curr->ports[0].proto = iph->protocol;
+	return false;
+}
+
+static bool
+xt_psd_match(const struct sk_buff *pskb, struct xt_action_param *match)
+{
+	struct iphdr *iph = ip_hdr(pskb);
+	struct tcphdr _tcph;
+	struct tcphdr *tcph;
+	bool matched;
+	unsigned int hash;
+	/* Parameters from userspace */
+	const struct xt_psd_info *psdinfo = match->matchinfo;
+
+	if (iph->frag_off & htons(IP_OFFSET)) {
+		pr_debug("sanity check failed\n");
+		return false;
+	}
+
+	/*
+	 * We are using IP address 0.0.0.0 for a special purpose here, so do
+	 * not let them spoof us. [DHCP needs this feature - HW]
+	 */
+	if (iph->saddr == 0) {
+		pr_debug("spoofed source address (0.0.0.0)\n");
+		return false;
+	}
+
+	tcph = get_header_pointer4(pskb, match->thoff, &_tcph);
+	if (tcph == NULL)
+		return false;
+
+	hash = hashfunc(iph->saddr);
+
+	spin_lock(&state.lock);
+	matched = handle_packet4(iph, tcph, psdinfo, hash);
+	spin_unlock(&state.lock);
+	return matched;
+}
+
+#ifdef WITH_IPV6
+static bool
+handle_packet6(const struct ipv6hdr *ip6h, const struct tcphdr *tcph,
+	       const struct xt_psd_info *psdinfo, uint8_t proto, int hash)
+{
+	unsigned long now;
+	struct host *curr, *last = NULL, **head;
+	struct host6 *curr6;
+	int count = 0;
+
+	now = jiffies;
+	head = &state6.hash[hash];
+
+	curr = *head;
+	while (curr != NULL) {
+		curr6 = host_to_host6(curr);
+		if (ipv6_addr_equal(&curr6->saddr, &ip6h->saddr))
+			break;
+		count++;
+		curr = host_get_next(curr, &last);
+	}
+
+	if (curr != NULL) {
+		if (entry_is_recent(curr, psdinfo->delay_threshold, now))
+			return is_portscan(curr, psdinfo, tcph, proto);
+		curr6 = host_to_host6(curr);
+		memset(&curr6->saddr, 0, sizeof(curr6->saddr));
+		ht_unlink(head, last);
+		last = NULL;
+	}
+
+	if (proto == IPPROTO_TCP && tcph->ack)
+		return false;
+
+	if (count >= HASH_MAX && last != NULL)
+		last->next = NULL;
+
+	if (!ipv6_addr_any(&state6.list[state6.index].saddr))
+		head = &state6.hash[hashfunc6(&state6.list[state6.index].saddr)];
+	else
+		head = &last;
+
+	curr6 = &state6.list[state6.index++];
+	curr = &curr6->host;
+	remove_oldest(head, curr);
+	if (state6.index >= LIST_SIZE)
+		state6.index = 0;
+
+	head = &state6.hash[hash];
+	curr->next = *head;
+	*head = curr;
+
+	curr6 = host_to_host6(curr);
+	curr6->saddr = ip6h->saddr;
+	curr->timestamp = now;
+	curr->count = 1;
+	curr->weight = get_port_weight(psdinfo, tcph->dest);
+	curr->ports[0].number = tcph->dest;
+	curr->ports[0].proto = proto;
+	return false;
+}
+
+static void *
+get_header_pointer6(const struct sk_buff *skb, void *mem, uint8_t *proto)
+{
+	static const uint8_t types[] = {IPPROTO_TCP,
+				        IPPROTO_UDP, IPPROTO_UDPLITE};
+	unsigned int i, offset = 0;
+	int err;
+	size_t hdrlen;
+
+	for (i = 0; i < ARRAY_SIZE(types); ++i) {
+		err = ipv6_find_hdr(skb, &offset, types[i], NULL, NULL);
+		if (err < 0)
+			continue;
+
+		switch (types[i]) {
+		case IPPROTO_TCP:
+			hdrlen = sizeof(struct tcphdr);
+			break;
+		case IPPROTO_UDP:
+		case IPPROTO_UDPLITE:
+			hdrlen = sizeof(struct udphdr);
+			break;
+		default:
+			return NULL;
+		}
+		*proto = types[i];
+		return skb_header_pointer(skb, offset, hdrlen, mem);
+	}
+	return NULL;
+}
+
+static bool
+xt_psd_match6(const struct sk_buff *pskb, struct xt_action_param *match)
+{
+	const struct ipv6hdr *ip6h = ipv6_hdr(pskb);
+	struct tcphdr _tcph;
+	struct tcphdr *tcph;
+	uint8_t proto = 0;
+	bool matched;
+	int hash;
+	const struct xt_psd_info *psdinfo = match->matchinfo;
+
+	if (ipv6_addr_any(&ip6h->saddr))
+		return false;
+
+	tcph = get_header_pointer6(pskb, &_tcph, &proto);
+	if (tcph == NULL)
+		return false;
+
+	hash = hashfunc6(&ip6h->saddr);
+
+	spin_lock(&state6.lock);
+	matched = handle_packet6(ip6h, tcph, psdinfo, proto, hash);
+	spin_unlock(&state6.lock);
+	return matched;
+}
+#endif
+
+static int psd_mt_check(const struct xt_mtchk_param *par)
+{
+	const struct xt_psd_info *info = par->matchinfo;
+
+	if (info->weight_threshold == 0)
+		/* 0 would match on every 1st packet */
+		return -EINVAL;
+
+	if ((info->lo_ports_weight | info->hi_ports_weight) == 0)
+		/* would never match */
+		return -EINVAL;
+
+	if (info->delay_threshold > PSD_MAX_RATE ||
+	    info->weight_threshold > PSD_MAX_RATE ||
+	    info->lo_ports_weight > PSD_MAX_RATE ||
+	    info->hi_ports_weight > PSD_MAX_RATE)
+		return -EINVAL;
+
+	return 0;
+}
+
+#ifdef WITH_IPV6
+static int psd_mt_check6(const struct xt_mtchk_param *par)
+{
+	if (!state6_alloc_mem())
+		return -ENOMEM;
+	return psd_mt_check(par);
+}
+#endif
+
+static struct xt_match xt_psd_reg[] __read_mostly = {
+	{
+		.name       = "psd",
+		.family     = NFPROTO_IPV4,
+		.revision   = 1,
+		.checkentry = psd_mt_check,
+		.match      = xt_psd_match,
+		.matchsize  = sizeof(struct xt_psd_info),
+		.me         = THIS_MODULE,
+#ifdef WITH_IPV6
+	}, {
+		.name       = "psd",
+		.family     = NFPROTO_IPV6,
+		.revision   = 1,
+		.checkentry = psd_mt_check6,
+		.match      = xt_psd_match6,
+		.matchsize  = sizeof(struct xt_psd_info),
+		.me         = THIS_MODULE,
+#endif
+	}
+};
+
+static int __init xt_psd_init(void)
+{
+	spin_lock_init(&(state.lock));
+#ifdef WITH_IPV6
+	spin_lock_init(&(state6.lock));
+#endif
+	return xt_register_matches(xt_psd_reg, ARRAY_SIZE(xt_psd_reg));
+}
+
+static void __exit xt_psd_exit(void)
+{
+        xt_unregister_matches(xt_psd_reg, ARRAY_SIZE(xt_psd_reg));
+#ifdef WITH_IPV6
+	vfree(state6.list);
+	vfree(state6.hash);
+#endif
+}
+
+module_init(xt_psd_init);
+module_exit(xt_psd_exit);
+

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_psd.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_psd.h
@@ -0,0 +1,30 @@
+#ifndef _LINUX_NETFILTER_XT_PSD_H
+#define _LINUX_NETFILTER_XT_PSD_H 1
+
+#include <linux/param.h>
+#include <linux/types.h>
+
+/*
+ * High port numbers have a lower weight to reduce the frequency of false
+ * positives, such as from passive mode FTP transfers.
+ */
+#define PORT_WEIGHT_PRIV		3
+#define PORT_WEIGHT_HIGH		1
+#define	PSD_MAX_RATE			10000
+
+/*
+ * Port scan detection thresholds: at least COUNT ports need to be scanned
+ * from the same source, with no longer than DELAY ticks between ports.
+ */
+#define SCAN_MIN_COUNT			7
+#define SCAN_MAX_COUNT			(SCAN_MIN_COUNT * PORT_WEIGHT_PRIV)
+#define SCAN_WEIGHT_THRESHOLD		SCAN_MAX_COUNT
+
+struct xt_psd_info {
+	__u32 weight_threshold;
+	__u32 delay_threshold;
+	__u16 lo_ports_weight;
+	__u16 hi_ports_weight;
+};
+
+#endif /*_LINUX_NETFILTER_XT_PSD_H*/

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_quota2.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_quota2.c
@@ -0,0 +1,276 @@
+/*
+ * xt_quota2 - enhanced xt_quota that can count upwards and in packets
+ * as a minimal accounting match.
+ * by Jan Engelhardt <jengelh@medozas.de>, 2008
+ *
+ * Originally based on xt_quota.c:
+ * 	Xtables module to enforce network quotas
+ * 	Sam Johnston <samj@samj.net>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License
+ *	version 2, as published by the Free Software Foundation.
+ */
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#include <asm/atomic.h>
+
+#include <linux/netfilter/x_tables.h>
+#include "xt_quota2.h"
+#include "compat_xtables.h"
+
+/**
+ * @lock:	lock to protect quota writers from each other
+ */
+struct xt_quota_counter {
+	u_int64_t quota;
+	spinlock_t lock;
+	struct list_head list;
+	atomic_t ref;
+	char name[sizeof(((struct xt_quota_mtinfo2 *)NULL)->name)];
+	struct proc_dir_entry *procfs_entry;
+};
+
+static LIST_HEAD(counter_list);
+static DEFINE_SPINLOCK(counter_list_lock);
+
+static struct proc_dir_entry *proc_xt_quota;
+static unsigned int quota_list_perms = S_IRUGO | S_IWUSR;
+static unsigned int quota_list_uid   = 0;
+static unsigned int quota_list_gid   = 0;
+module_param_named(perms, quota_list_perms, uint, S_IRUGO | S_IWUSR);
+module_param_named(uid, quota_list_uid, uint, S_IRUGO | S_IWUSR);
+module_param_named(gid, quota_list_gid, uint, S_IRUGO | S_IWUSR);
+
+static int quota_proc_read(char *page, char **start, off_t offset,
+                           int count, int *eof, void *data)
+{
+	struct xt_quota_counter *e = data;
+	int ret;
+
+	spin_lock_bh(&e->lock);
+	ret = snprintf(page, PAGE_SIZE, "%llu\n", e->quota);
+	spin_unlock_bh(&e->lock);
+	return ret;
+}
+
+static int quota_proc_write(struct file *file, const char __user *input,
+                            unsigned long size, void *data)
+{
+	struct xt_quota_counter *e = data;
+	char buf[sizeof("18446744073709551616")];
+
+	if (size > sizeof(buf))
+		size = sizeof(buf);
+	if (copy_from_user(buf, input, size) != 0)
+		return -EFAULT;
+	buf[sizeof(buf)-1] = '\0';
+
+	spin_lock_bh(&e->lock);
+	e->quota = simple_strtoull(buf, NULL, 0);
+	spin_unlock_bh(&e->lock);
+	return size;
+}
+
+static struct xt_quota_counter *
+q2_new_counter(const struct xt_quota_mtinfo2 *q, bool anon)
+{
+	struct xt_quota_counter *e;
+	unsigned int size;
+
+	/* Do not need all the procfs things for anonymous counters. */
+	size = anon ? offsetof(typeof(*e), list) : sizeof(*e);
+	e = kmalloc(size, GFP_KERNEL);
+	if (e == NULL)
+		return NULL;
+
+	e->quota = q->quota;
+	spin_lock_init(&e->lock);
+	if (!anon) {
+		INIT_LIST_HEAD(&e->list);
+		atomic_set(&e->ref, 1);
+		strncpy(e->name, q->name, sizeof(e->name));
+	}
+	return e;
+}
+
+/**
+ * q2_get_counter - get ref to counter or create new
+ * @name:	name of counter
+ */
+static struct xt_quota_counter *
+q2_get_counter(const struct xt_quota_mtinfo2 *q)
+{
+	struct proc_dir_entry *p;
+	struct xt_quota_counter *e;
+
+	if (*q->name == '\0')
+		return q2_new_counter(q, true);
+
+	spin_lock_bh(&counter_list_lock);
+	list_for_each_entry(e, &counter_list, list)
+		if (strcmp(e->name, q->name) == 0) {
+			atomic_inc(&e->ref);
+			spin_unlock_bh(&counter_list_lock);
+			return e;
+		}
+
+	e = q2_new_counter(q, false);
+	if (e == NULL)
+		goto out;
+
+	p = e->procfs_entry = create_proc_entry(e->name, quota_list_perms,
+	                      proc_xt_quota);
+	if (p == NULL || IS_ERR(p))
+		goto out;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 29)
+	p->owner        = THIS_MODULE;
+#endif
+	p->data         = e;
+	p->read_proc    = quota_proc_read;
+	p->write_proc   = quota_proc_write;
+	p->uid          = quota_list_uid;
+	p->gid          = quota_list_gid;
+	list_add_tail(&e->list, &counter_list);
+	spin_unlock_bh(&counter_list_lock);
+	return e;
+
+ out:
+	spin_unlock_bh(&counter_list_lock);
+	kfree(e);
+	return NULL;
+}
+
+static int quota_mt2_check(const struct xt_mtchk_param *par)
+{
+	struct xt_quota_mtinfo2 *q = par->matchinfo;
+
+	if (q->flags & ~XT_QUOTA_MASK)
+		return -EINVAL;
+
+	q->name[sizeof(q->name)-1] = '\0';
+	if (*q->name == '.' || strchr(q->name, '/') != NULL) {
+		printk(KERN_ERR "xt_quota.3: illegal name\n");
+		return -EINVAL;
+	}
+
+	q->master = q2_get_counter(q);
+	if (q->master == NULL) {
+		printk(KERN_ERR "xt_quota.3: memory alloc failure\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void quota_mt2_destroy(const struct xt_mtdtor_param *par)
+{
+	struct xt_quota_mtinfo2 *q = par->matchinfo;
+	struct xt_quota_counter *e = q->master;
+
+	if (*q->name == '\0') {
+		kfree(e);
+		return;
+	}
+
+	spin_lock_bh(&counter_list_lock);
+	if (!atomic_dec_and_test(&e->ref)) {
+		spin_unlock_bh(&counter_list_lock);
+		return;
+	}
+
+	list_del(&e->list);
+	remove_proc_entry(e->name, proc_xt_quota);
+	spin_unlock_bh(&counter_list_lock);
+	kfree(e);
+}
+
+static bool
+quota_mt2(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	struct xt_quota_mtinfo2 *q = (void *)par->matchinfo;
+	struct xt_quota_counter *e = q->master;
+	bool ret = q->flags & XT_QUOTA_INVERT;
+
+	spin_lock_bh(&e->lock);
+	if (q->flags & XT_QUOTA_GROW) {
+		/*
+		 * While no_change is pointless in "grow" mode, we will
+		 * implement it here simply to have a consistent behavior.
+		 */
+		if (!(q->flags & XT_QUOTA_NO_CHANGE)) {
+			e->quota += (q->flags & XT_QUOTA_PACKET) ? 1 : skb->len;
+			q->quota = e->quota;
+		}
+		ret = true;
+	} else {
+		if (e->quota >= skb->len) {
+			if (!(q->flags & XT_QUOTA_NO_CHANGE))
+				e->quota -= (q->flags & XT_QUOTA_PACKET) ? 1 : skb->len;
+			ret = !ret;
+		} else {
+			/* we do not allow even small packets from now on */
+			e->quota = 0;
+		}
+		q->quota = e->quota;
+	}
+	spin_unlock_bh(&e->lock);
+	return ret;
+}
+
+static struct xt_match quota_mt2_reg[] __read_mostly = {
+	{
+		.name       = "quota2",
+		.revision   = 3,
+		.family     = NFPROTO_IPV4,
+		.checkentry = quota_mt2_check,
+		.match      = quota_mt2,
+		.destroy    = quota_mt2_destroy,
+		.matchsize  = sizeof(struct xt_quota_mtinfo2),
+		.me         = THIS_MODULE,
+	},
+	{
+		.name       = "quota2",
+		.revision   = 3,
+		.family     = NFPROTO_IPV6,
+		.checkentry = quota_mt2_check,
+		.match      = quota_mt2,
+		.destroy    = quota_mt2_destroy,
+		.matchsize  = sizeof(struct xt_quota_mtinfo2),
+		.me         = THIS_MODULE,
+	},
+};
+
+static int __init quota_mt2_init(void)
+{
+	int ret;
+
+	proc_xt_quota = proc_mkdir("xt_quota", init_net__proc_net);
+	if (proc_xt_quota == NULL)
+		return -EACCES;
+
+	ret = xt_register_matches(quota_mt2_reg, ARRAY_SIZE(quota_mt2_reg));
+	if (ret < 0)
+		remove_proc_entry("xt_quota", init_net__proc_net);
+	return ret;
+}
+
+static void __exit quota_mt2_exit(void)
+{
+	xt_unregister_matches(quota_mt2_reg, ARRAY_SIZE(quota_mt2_reg));
+	remove_proc_entry("xt_quota", init_net__proc_net);
+}
+
+module_init(quota_mt2_init);
+module_exit(quota_mt2_exit);
+MODULE_DESCRIPTION("Xtables: countdown quota match; up counter");
+MODULE_AUTHOR("Sam Johnston <samj@samj.net>");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_quota2");
+MODULE_ALIAS("ip6t_quota2");

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_quota2.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_quota2.h
@@ -0,0 +1,25 @@
+#ifndef _XT_QUOTA_H
+#define _XT_QUOTA_H
+
+enum xt_quota_flags {
+	XT_QUOTA_INVERT    = 1 << 0,
+	XT_QUOTA_GROW      = 1 << 1,
+	XT_QUOTA_PACKET    = 1 << 2,
+	XT_QUOTA_NO_CHANGE = 1 << 3,
+	XT_QUOTA_MASK      = 0x0F,
+};
+
+struct xt_quota_counter;
+
+struct xt_quota_mtinfo2 {
+	char name[15];
+	u_int8_t flags;
+
+	/* Comparison-invariant */
+	aligned_u64 quota;
+
+	/* Used internally by the kernel */
+	struct xt_quota_counter *master __attribute__((aligned(8)));
+};
+
+#endif /* _XT_QUOTA_H */

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_RAWNAT.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_RAWNAT.c
@@ -0,0 +1,358 @@
+/*
+ *	"RAWNAT" target extension for Xtables - untracked NAT
+ *	Copyright © Jan Engelhardt, 2008 - 2009
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/version.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter/nf_conntrack_common.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include "compat_xtables.h"
+#include "xt_RAWNAT.h"
+#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
+#	define WITH_IPV6 1
+#endif
+
+static inline __be32
+remask(__be32 addr, __be32 repl, unsigned int shift)
+{
+	uint32_t mask = (shift == 32) ? 0 : (~(uint32_t)0 >> shift);
+	return htonl((ntohl(addr) & mask) | (ntohl(repl) & ~mask));
+}
+
+#ifdef WITH_IPV6
+static void
+rawnat_ipv6_mask(__be32 *addr, const __be32 *repl, unsigned int mask)
+{
+	switch (mask) {
+	case 0:
+		break;
+	case 1 ... 31:
+		addr[0] = remask(addr[0], repl[0], mask);
+		break;
+	case 32:
+		addr[0] = repl[0];
+		break;
+	case 33 ... 63:
+		addr[0] = repl[0];
+		addr[1] = remask(addr[1], repl[1], mask - 32);
+		break;
+	case 64:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		break;
+	case 65 ... 95:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		addr[2] = remask(addr[2], repl[2], mask - 64);
+	case 96:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		addr[2] = repl[2];
+		break;
+	case 97 ... 127:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		addr[2] = repl[2];
+		addr[3] = remask(addr[3], repl[3], mask - 96);
+		break;
+	case 128:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		addr[2] = repl[2];
+		addr[3] = repl[3];
+		break;
+	}
+}
+#endif
+
+static void rawnat4_update_l4(struct sk_buff *skb, __be32 oldip, __be32 newip)
+{
+	struct iphdr *iph = ip_hdr(skb);
+	void *transport_hdr = (void *)iph + ip_hdrlen(skb);
+	struct tcphdr *tcph;
+	struct udphdr *udph;
+	bool cond;
+
+	switch (iph->protocol) {
+	case IPPROTO_TCP:
+		tcph = transport_hdr;
+		inet_proto_csum_replace4(&tcph->check, skb, oldip, newip, true);
+		break;
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+		udph = transport_hdr;
+		cond = udph->check != 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+		cond |= skb->ip_summed == CHECKSUM_PARTIAL;
+#endif
+		if (cond) {
+			inet_proto_csum_replace4(&udph->check, skb,
+				oldip, newip, true);
+			if (udph->check == 0)
+				udph->check = CSUM_MANGLED_0;
+		}
+		break;
+	}
+}
+
+static unsigned int rawnat4_writable_part(const struct iphdr *iph)
+{
+	unsigned int wlen = sizeof(*iph);
+
+	switch (iph->protocol) {
+	case IPPROTO_TCP:
+		wlen += sizeof(struct tcphdr);
+		break;
+	case IPPROTO_UDP:
+		wlen += sizeof(struct udphdr);
+		break;
+	}
+	return wlen;
+}
+
+static unsigned int
+rawsnat_tg4(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct xt_rawnat_tginfo *info = par->targinfo;
+	struct iphdr *iph;
+	__be32 new_addr;
+
+	iph = ip_hdr(*pskb);
+	new_addr = remask(iph->saddr, info->addr.ip, info->mask);
+	if (iph->saddr == new_addr)
+		return XT_CONTINUE;
+
+	if (!skb_make_writable(pskb, rawnat4_writable_part(iph)))
+		return NF_DROP;
+
+	iph = ip_hdr(*pskb);
+	csum_replace4(&iph->check, iph->saddr, new_addr);
+	rawnat4_update_l4(*pskb, iph->saddr, new_addr);
+	iph->saddr = new_addr;
+	return XT_CONTINUE;
+}
+
+static unsigned int
+rawdnat_tg4(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct xt_rawnat_tginfo *info = par->targinfo;
+	struct iphdr *iph;
+	__be32 new_addr;
+
+	iph = ip_hdr(*pskb);
+	new_addr = remask(iph->daddr, info->addr.ip, info->mask);
+	if (iph->daddr == new_addr)
+		return XT_CONTINUE;
+
+	if (!skb_make_writable(pskb, rawnat4_writable_part(iph)))
+		return NF_DROP;
+
+	iph = ip_hdr(*pskb);
+	csum_replace4(&iph->check, iph->daddr, new_addr);
+	rawnat4_update_l4(*pskb, iph->daddr, new_addr);
+	iph->daddr = new_addr;
+	return XT_CONTINUE;
+}
+
+#ifdef WITH_IPV6
+static bool rawnat6_prepare_l4(struct sk_buff **pskb, unsigned int *l4offset,
+    unsigned int *l4proto)
+{
+	static const unsigned int types[] =
+		{IPPROTO_TCP, IPPROTO_UDP, IPPROTO_UDPLITE};
+	unsigned int i;
+	int err;
+
+	*l4proto = NEXTHDR_MAX;
+
+	for (i = 0; i < ARRAY_SIZE(types); ++i) {
+		err = ipv6_find_hdr(*pskb, l4offset, types[i], NULL, NULL);
+		if (err >= 0) {
+			*l4proto = types[i];
+			break;
+		}
+		if (err != -ENOENT)
+			return false;
+	}
+
+	switch (*l4proto) {
+	case IPPROTO_TCP:
+		if (!skb_make_writable(pskb, *l4offset + sizeof(struct tcphdr)))
+			return false;
+		break;
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+		if (!skb_make_writable(pskb, *l4offset + sizeof(struct udphdr)))
+			return false;
+		break;
+	}
+
+	return true;
+}
+
+static void rawnat6_update_l4(struct sk_buff *skb, unsigned int l4proto,
+    unsigned int l4offset, const struct in6_addr *oldip,
+    const struct in6_addr *newip)
+{
+	const struct ipv6hdr *iph = ipv6_hdr(skb);
+	struct tcphdr *tcph;
+	struct udphdr *udph;
+	unsigned int i;
+	bool cond;
+
+	switch (l4proto) {
+	case IPPROTO_TCP:
+		tcph = (void *)iph + l4offset;
+		for (i = 0; i < 4; ++i)
+			inet_proto_csum_replace4(&tcph->check, skb,
+				oldip->s6_addr32[i], newip->s6_addr32[i], true);
+		break;
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+		udph = (void *)iph + l4offset;
+		cond = udph->check;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+		cond |= skb->ip_summed == CHECKSUM_PARTIAL;
+#endif
+		if (cond) {
+			for (i = 0; i < 4; ++i)
+				inet_proto_csum_replace4(&udph->check, skb,
+					oldip->s6_addr32[i],
+					newip->s6_addr32[i], true);
+			if (udph->check == 0)
+				udph->check = CSUM_MANGLED_0;
+		}
+		break;
+	}
+}
+
+static unsigned int
+rawsnat_tg6(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct xt_rawnat_tginfo *info = par->targinfo;
+	unsigned int l4offset = 0, l4proto;
+	struct ipv6hdr *iph;
+	struct in6_addr new_addr;
+
+	iph = ipv6_hdr(*pskb);
+	memcpy(&new_addr, &iph->saddr, sizeof(new_addr));
+	rawnat_ipv6_mask(new_addr.s6_addr32, info->addr.ip6, info->mask);
+	if (ipv6_addr_cmp(&iph->saddr, &new_addr) == 0)
+		return XT_CONTINUE;
+	if (!rawnat6_prepare_l4(pskb, &l4offset, &l4proto))
+		return NF_DROP;
+	iph = ipv6_hdr(*pskb);
+	rawnat6_update_l4(*pskb, l4proto, l4offset, &iph->saddr, &new_addr);
+	memcpy(&iph->saddr, &new_addr, sizeof(new_addr));
+	return XT_CONTINUE;
+}
+
+static unsigned int
+rawdnat_tg6(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct xt_rawnat_tginfo *info = par->targinfo;
+	unsigned int l4offset = 0, l4proto;
+	struct ipv6hdr *iph;
+	struct in6_addr new_addr;
+
+	iph = ipv6_hdr(*pskb);
+	memcpy(&new_addr, &iph->daddr, sizeof(new_addr));
+	rawnat_ipv6_mask(new_addr.s6_addr32, info->addr.ip6, info->mask);
+	if (ipv6_addr_cmp(&iph->daddr, &new_addr) == 0)
+		return XT_CONTINUE;
+	if (!rawnat6_prepare_l4(pskb, &l4offset, &l4proto))
+		return NF_DROP;
+	iph = ipv6_hdr(*pskb);
+	rawnat6_update_l4(*pskb, l4proto, l4offset, &iph->daddr, &new_addr);
+	memcpy(&iph->daddr, &new_addr, sizeof(new_addr));
+	return XT_CONTINUE;
+}
+#endif
+
+static int rawnat_tg_check(const struct xt_tgchk_param *par)
+{
+	if (strcmp(par->table, "raw") == 0 ||
+	    strcmp(par->table, "rawpost") == 0)
+		return 0;
+
+	printk(KERN_ERR KBUILD_MODNAME " may only be used in the \"raw\" or "
+	       "\"rawpost\" table.\n");
+	return -EINVAL;
+}
+
+static struct xt_target rawnat_tg_reg[] __read_mostly = {
+	{
+		.name       = "RAWSNAT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.target     = rawsnat_tg4,
+		.targetsize = sizeof(struct xt_rawnat_tginfo),
+		.checkentry = rawnat_tg_check,
+		.me         = THIS_MODULE,
+	},
+#ifdef WITH_IPV6
+	{
+		.name       = "RAWSNAT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.target     = rawsnat_tg6,
+		.targetsize = sizeof(struct xt_rawnat_tginfo),
+		.checkentry = rawnat_tg_check,
+		.me         = THIS_MODULE,
+	},
+#endif
+	{
+		.name       = "RAWDNAT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.target     = rawdnat_tg4,
+		.targetsize = sizeof(struct xt_rawnat_tginfo),
+		.checkentry = rawnat_tg_check,
+		.me         = THIS_MODULE,
+	},
+#ifdef WITH_IPV6
+	{
+		.name       = "RAWDNAT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.target     = rawdnat_tg6,
+		.targetsize = sizeof(struct xt_rawnat_tginfo),
+		.checkentry = rawnat_tg_check,
+		.me         = THIS_MODULE,
+	},
+#endif
+};
+
+static int __init rawnat_tg_init(void)
+{
+	return xt_register_targets(rawnat_tg_reg, ARRAY_SIZE(rawnat_tg_reg));
+}
+
+static void __exit rawnat_tg_exit(void)
+{
+	xt_unregister_targets(rawnat_tg_reg, ARRAY_SIZE(rawnat_tg_reg));
+}
+
+module_init(rawnat_tg_init);
+module_exit(rawnat_tg_exit);
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_DESCRIPTION("Xtables: conntrack-less raw NAT");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_RAWSNAT");
+MODULE_ALIAS("ipt_RAWDNAT");
+MODULE_ALIAS("ip6t_RAWSNAT");
+MODULE_ALIAS("ip6t_RAWDNAT");

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_RAWNAT.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_RAWNAT.h
@@ -0,0 +1,9 @@
+#ifndef _LINUX_NETFILTER_XT_TARGET_RAWNAT
+#define _LINUX_NETFILTER_XT_TARGET_RAWNAT 1
+
+struct xt_rawnat_tginfo {
+	union nf_inet_addr addr;
+	__u8 mask;
+};
+
+#endif /* _LINUX_NETFILTER_XT_TARGET_RAWNAT */

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_STEAL.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_STEAL.c
@@ -0,0 +1,67 @@
+/*
+ *	"STEAL" demo target extension for Xtables
+ *	written by Jan Engelhardt <jengelh [at] medozas de>, 2008 - 2009
+ *	placed in the Public Domain
+ */
+#include <linux/module.h>
+#include <linux/netfilter.h>
+#include <linux/skbuff.h>
+#include "compat_xtables.h"
+
+static unsigned int
+steal_tg(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	kfree_skb(*pskb);
+	return NF_STOLEN;
+}
+
+static struct xt_target steal_tg_reg[] __read_mostly = {
+	{
+		.name     = "STEAL",
+		.revision = 0,
+		.family   = NFPROTO_UNSPEC,
+		.target   = steal_tg,
+		.me       = THIS_MODULE,
+	},
+	{
+		.name     = "STEAL",
+		.revision = 0,
+		.family   = NFPROTO_IPV6,
+		.target   = steal_tg,
+		.me       = THIS_MODULE,
+	},
+	{
+		.name     = "STEAL",
+		.revision = 0,
+		.family   = NFPROTO_ARP,
+		.target   = steal_tg,
+		.me       = THIS_MODULE,
+	},
+	{
+		.name     = "STEAL",
+		.revision = 0,
+		.family   = NFPROTO_BRIDGE,
+		.target   = steal_tg,
+		.me       = THIS_MODULE,
+	},
+};
+
+static int __init steal_tg_init(void)
+{
+	return xt_register_targets(steal_tg_reg, ARRAY_SIZE(steal_tg_reg));
+}
+
+static void __exit steal_tg_exit(void)
+{
+	xt_unregister_targets(steal_tg_reg, ARRAY_SIZE(steal_tg_reg));
+}
+
+module_init(steal_tg_init);
+module_exit(steal_tg_exit);
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_DESCRIPTION("Xtables: Silently DROP packets on output chain");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_STEAL");
+MODULE_ALIAS("ip6t_STEAL");
+MODULE_ALIAS("arpt_STEAL");
+MODULE_ALIAS("ebt_STEAL");

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_TARPIT.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_TARPIT.c
@@ -0,0 +1,549 @@
+/*
+ *	"TARPIT" target extension to Xtables
+ *	Kernel module to capture and hold incoming TCP connections using
+ *	no local per-connection resources.
+ *
+ *	Copyright © Aaron Hopkins <tools [at] die net>, 2002
+ *
+ *	Based on ipt_REJECT.c and offering functionality similar to
+ *	LaBrea <http://www.hackbusters.net/LaBrea/>.
+ *
+ *	<<<
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *	>>>
+ *
+ * Goal:
+ * - Allow incoming TCP connections to be established.
+ * - Passing data should result in the connection being switched to the
+ *   persist state (0 byte window), in which the remote side stops sending
+ *   data and asks to continue every 60 seconds.
+ * - Attempts to shut down the connection should be ignored completely, so
+ *   the remote side ends up having to time it out.
+ *
+ * This means:
+ * - Reply to TCP SYN,!ACK,!RST,!FIN with SYN-ACK, window 5 bytes
+ * - Reply to TCP SYN,ACK,!RST,!FIN with RST to prevent spoofing
+ * - Reply to TCP !SYN,!RST,!FIN with ACK, window 0 bytes, rate-limited
+ */
+
+#include <linux/ip.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <linux/netfilter_ipv6.h>
+#include <linux/netfilter/x_tables.h>
+#ifdef CONFIG_BRIDGE_NETFILTER
+#	include <linux/netfilter_bridge.h>
+#endif
+#include <net/addrconf.h>
+#include <net/ip6_checksum.h>
+#include <net/ip6_route.h>
+#include <net/ipv6.h>
+#include <net/route.h>
+#include <net/tcp.h>
+#include "compat_xtables.h"
+#include "xt_TARPIT.h"
+#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
+#	define WITH_IPV6 1
+#endif
+
+static bool xttarpit_tarpit(struct tcphdr *tcph, const struct tcphdr *oth)
+{
+	/* No replies for RST, FIN or !SYN,!ACK */
+	if (oth->rst || oth->fin || (!oth->syn && !oth->ack))
+		return false;
+	tcph->seq = oth->ack ? oth->ack_seq : 0;
+
+	/* Our SYN-ACKs must have a >0 window */
+	tcph->window = (oth->syn && !oth->ack) ? htons(5) : 0;
+	if (oth->syn && oth->ack) {
+		tcph->rst     = true;
+		tcph->ack_seq = false;
+	} else {
+		tcph->syn     = oth->syn;
+		tcph->ack     = true;
+		tcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn);
+	}
+#if 0
+	/* Rate-limit replies to !SYN,ACKs */
+	if (!oth->syn && oth->ack)
+		if (!xrlim_allow(rt_dst(ort), HZ))
+			return false;
+#endif
+
+	return true;
+}
+
+static bool xttarpit_honeypot(struct tcphdr *tcph, const struct tcphdr *oth,
+    uint16_t payload)
+{
+	/* Do not answer any resets regardless of combination */
+	if (oth->rst || oth->seq == 0xDEADBEEF)
+		return false;
+	/* Send a reset to scanners. They like that. */
+	if (oth->syn && oth->ack) {
+		tcph->window  = 0;
+		tcph->ack     = false;
+		tcph->psh     = true;
+		tcph->ack_seq = 0xdeadbeef; /* see if they ack it */
+		tcph->seq     = oth->ack_seq;
+		tcph->rst     = true;
+	}
+
+	/* SYN > SYN-ACK */
+	if (oth->syn && !oth->ack) {
+		tcph->syn     = true;
+		tcph->ack     = true;
+		tcph->window  = oth->window &
+			((net_random() & 0x1f) - 0xf);
+		tcph->seq     = htonl(net_random() & ~oth->seq);
+		tcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn);
+	}
+
+	/* ACK > ACK */
+	if (oth->ack && (!(oth->fin || oth->syn))) {
+		tcph->syn     = false;
+		tcph->ack     = true;
+		tcph->window  = oth->window &
+			((net_random() & 0x1f) - 0xf);
+		tcph->ack_seq = payload > 100 ?
+			htonl(ntohl(oth->seq) + payload) :
+			oth->seq;
+		tcph->seq     = oth->ack_seq;
+	}
+
+	/*
+	 * FIN > RST.
+	 * We cannot terminate gracefully so just be abrupt.
+	 */
+	if (oth->fin) {
+		tcph->window  = 0;
+		tcph->seq     = oth->ack_seq;
+		tcph->ack_seq = oth->ack_seq;
+		tcph->fin     = false;
+		tcph->ack     = false;
+		tcph->rst     = true;
+	}
+
+	return true;
+}
+
+static void xttarpit_reset(struct tcphdr *tcph, const struct tcphdr *oth)
+{
+	tcph->window  = 0;
+	tcph->ack     = false;
+	tcph->syn     = false;
+	tcph->rst     = true;
+	tcph->seq     = oth->ack_seq;
+	tcph->ack_seq = oth->seq;
+}
+
+static bool tarpit_generic(struct tcphdr *tcph, const struct tcphdr *oth,
+    uint16_t payload, unsigned int mode)
+{
+	switch(mode) {
+	case XTTARPIT_TARPIT:
+		if (!xttarpit_tarpit(tcph, oth))
+			return false;
+		break;
+	case XTTARPIT_HONEYPOT:
+		if (!xttarpit_honeypot(tcph, oth, payload))
+			return false;
+		break;
+	case XTTARPIT_RESET:
+		xttarpit_reset(tcph, oth);
+		break;
+	}
+
+	return true;
+}
+
+static void tarpit_tcp4(struct sk_buff *oldskb, unsigned int hook,
+    unsigned int mode)
+{
+	struct tcphdr _otcph, *tcph;
+	const struct tcphdr *oth;
+	unsigned int addr_type = RTN_UNSPEC;
+	struct sk_buff *nskb;
+	const struct iphdr *oldhdr;
+	struct iphdr *niph;
+	uint16_t tmp, payload;
+
+	/* A truncated TCP header is not going to be useful */
+	if (oldskb->len < ip_hdrlen(oldskb) + sizeof(struct tcphdr))
+		return;
+
+	oth = skb_header_pointer(oldskb, ip_hdrlen(oldskb),
+	                         sizeof(_otcph), &_otcph);
+	if (oth == NULL)
+		return;
+
+	/* Check checksum. */
+	if (nf_ip_checksum(oldskb, hook, ip_hdrlen(oldskb), IPPROTO_TCP))
+		return;
+
+	/*
+	 * Copy skb (even if skb is about to be dropped, we cannot just
+	 * clone it because there may be other things, such as tcpdump,
+	 * interested in it)
+	 */
+	nskb = skb_copy_expand(oldskb, LL_MAX_HEADER,
+	                       skb_tailroom(oldskb), GFP_ATOMIC);
+	if (nskb == NULL)
+		return;
+
+	/* This packet will not be the same as the other: clear nf fields */
+	nf_reset(nskb);
+	skb_nfmark(nskb) = 0;
+	skb_init_secmark(nskb);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+	skb_shinfo(nskb)->gso_size = 0;
+	skb_shinfo(nskb)->gso_segs = 0;
+	skb_shinfo(nskb)->gso_type = 0;
+#endif
+
+	oldhdr = ip_hdr(oldskb);
+	tcph = (struct tcphdr *)(skb_network_header(nskb) + ip_hdrlen(nskb));
+
+	/* Swap source and dest */
+	niph         = ip_hdr(nskb);
+	niph->daddr  = xchg(&niph->saddr, niph->daddr);
+	tmp          = tcph->source;
+	tcph->source = tcph->dest;
+	tcph->dest   = tmp;
+
+	/* Calculate payload size?? */
+	payload = nskb->len - ip_hdrlen(nskb) - sizeof(struct tcphdr);
+
+	/* Truncate to length (no data) */
+	tcph->doff    = sizeof(struct tcphdr) / 4;
+	skb_trim(nskb, ip_hdrlen(nskb) + sizeof(struct tcphdr));
+	niph->tot_len = htons(nskb->len);
+	tcph->urg_ptr = 0;
+	/* Reset flags */
+	((u_int8_t *)tcph)[13] = 0;
+
+	if (!tarpit_generic(tcph, oth, payload, mode))
+		goto free_nskb;
+
+	/* Adjust TCP checksum */
+	tcph->check = 0;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
+	tcph->check = tcp_v4_check(tcph, sizeof(struct tcphdr), niph->saddr,
+	              niph->daddr, csum_partial((char *)tcph,
+	              sizeof(struct tcphdr), 0));
+#else
+	tcph->check = tcp_v4_check(sizeof(struct tcphdr), niph->saddr,
+	              niph->daddr, csum_partial((char *)tcph,
+	              sizeof(struct tcphdr), 0));
+#endif
+
+	/* Set DF, id = 0 */
+	niph->frag_off = htons(IP_DF);
+	if (mode == XTTARPIT_TARPIT || mode == XTTARPIT_RESET)
+		niph->id = 0;
+	else if (mode == XTTARPIT_HONEYPOT)
+		niph->id = ~oldhdr->id + 1;
+
+#ifdef CONFIG_BRIDGE_NETFILTER
+	if (hook != NF_INET_FORWARD || (nskb->nf_bridge != NULL &&
+	    nskb->nf_bridge->mask & BRNF_BRIDGED))
+#else
+	if (hook != NF_INET_FORWARD)
+#endif
+		addr_type = RTN_LOCAL;
+
+	if (ip_route_me_harder(&nskb, addr_type))
+		goto free_nskb;
+	else
+		niph = ip_hdr(nskb);
+
+	nskb->ip_summed = CHECKSUM_NONE;
+
+	/* Adjust IP TTL */
+	if (mode == XTTARPIT_HONEYPOT)
+		niph->ttl = 128;
+	else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+		niph->ttl = ip4_dst_hoplimit(skb_dst(nskb));
+#else
+		niph->ttl = dst_metric(skb_dst(nskb), RTAX_HOPLIMIT);
+#endif
+
+	/* Adjust IP checksum */
+	niph->check = 0;
+	niph->check = ip_fast_csum(skb_network_header(nskb), niph->ihl);
+
+	/* "Never happens" */
+	if (nskb->len > dst_mtu(skb_dst(nskb)))
+		goto free_nskb;
+
+	nf_ct_attach(nskb, oldskb);
+
+	NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_OUT, nskb, NULL,
+		skb_dst(nskb)->dev, dst_output);
+	return;
+
+ free_nskb:
+	kfree_skb(nskb);
+}
+
+#ifdef WITH_IPV6
+static void tarpit_tcp6(struct sk_buff *oldskb, unsigned int hook,
+    unsigned int mode)
+{
+	struct sk_buff *nskb;
+	struct tcphdr *tcph, oth;
+	unsigned int otcplen;
+	int tcphoff;
+	const struct ipv6hdr *oip6h = ipv6_hdr(oldskb);
+	struct ipv6hdr *ip6h;
+	const uint8_t tclass = 0;
+	uint8_t proto;
+	uint16_t payload;
+	__be16 frag_off;
+
+	proto   = oip6h->nexthdr;
+	tcphoff = ipv6_skip_exthdr(oldskb,
+	          (uint8_t *)(oip6h + 1) - oldskb->data, &proto, &frag_off);
+
+	if (tcphoff < 0 || tcphoff > oldskb->len) {
+		pr_debug("Cannot get TCP header.\n");
+		return;
+	}
+
+	otcplen = oldskb->len - tcphoff;
+
+	/* IP header checks: fragment, too short. */
+	if (proto != IPPROTO_TCP || otcplen < sizeof(struct tcphdr)) {
+		pr_debug("proto(%d) != IPPROTO_TCP, "
+		         "or too short. otcplen = %d\n",
+		         proto, otcplen);
+		return;
+	}
+
+	if (skb_copy_bits(oldskb, tcphoff, &oth, sizeof(struct tcphdr))) {
+		WARN_ON(1);
+		return;
+	}
+
+	/* Check checksum. */
+	if (csum_ipv6_magic(&oip6h->saddr, &oip6h->daddr, otcplen, IPPROTO_TCP,
+	    skb_checksum(oldskb, tcphoff, otcplen, 0))) {
+		pr_debug("TCP checksum is invalid\n");
+		return;
+	}
+
+	nskb = skb_copy_expand(oldskb, LL_MAX_HEADER,
+	       skb_tailroom(oldskb), GFP_ATOMIC);
+	if (nskb == NULL) {
+		if (net_ratelimit())
+			pr_debug("cannot alloc skb\n");
+		return;
+	}
+
+	/* This packet will not be the same as the other: clear nf fields */
+	nf_reset(nskb);
+	skb_nfmark(nskb) = 0;
+	skb_init_secmark(nskb);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+	skb_shinfo(nskb)->gso_size = 0;
+	skb_shinfo(nskb)->gso_segs = 0;
+	skb_shinfo(nskb)->gso_type = 0;
+#endif
+
+	skb_put(nskb, sizeof(struct ipv6hdr));
+	ip6h = ipv6_hdr(nskb);
+	*(__be32 *)ip6h =  htonl(0x60000000 | (tclass << 20));
+	ip6h->nexthdr = IPPROTO_TCP;
+	ip6h->saddr = oip6h->daddr;
+	ip6h->daddr = oip6h->saddr;
+
+	/* Adjust IP TTL */
+	if (mode == XTTARPIT_HONEYPOT) {
+		ip6h->hop_limit = 128;
+	} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+		ip6h->hop_limit = ip6_dst_hoplimit(skb_dst(nskb));
+#else
+		ip6h->hop_limit = dst_metric(skb_dst(nskb), RTAX_HOPLIMIT);
+#endif
+	}
+
+	tcph = (struct tcphdr *)(skb_network_header(nskb) +
+	       sizeof(struct ipv6hdr));
+
+	/* Truncate to length (no data) */
+	skb_trim(nskb, sizeof(struct ipv6hdr) + sizeof(struct tcphdr));
+	tcph->doff    = sizeof(struct tcphdr)/4;
+	tcph->source  = oth.dest;
+	tcph->dest    = oth.source;
+	tcph->urg_ptr = 0;
+	/* Reset flags */
+	((uint8_t *)tcph)[13] = 0;
+
+	payload = nskb->len - sizeof(struct ipv6hdr) - sizeof(struct tcphdr);
+	if (!tarpit_generic(&oth, tcph, payload, mode))
+		goto free_nskb;
+
+	ip6h->payload_len = htons(sizeof(struct tcphdr));
+	tcph->check = 0;
+
+	/* Adjust TCP checksum */
+	tcph->check = csum_ipv6_magic(&ipv6_hdr(nskb)->saddr,
+	              &ipv6_hdr(nskb)->daddr, sizeof(struct tcphdr),
+	              IPPROTO_TCP,
+	              csum_partial(tcph, sizeof(struct tcphdr), 0));
+
+	if (ip6_route_me_harder(nskb))
+		goto free_nskb;
+
+	nskb->ip_summed = CHECKSUM_NONE;
+
+	nf_ct_attach(nskb, oldskb);
+
+	NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, nskb, NULL,
+	        skb_dst(nskb)->dev, dst_output);
+	return;
+
+ free_nskb:
+	kfree_skb(nskb);
+}
+#endif
+
+static unsigned int
+tarpit_tg4(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct sk_buff *skb = *pskb;
+	const struct iphdr *iph = ip_hdr(skb);
+	const struct rtable *rt = skb_rtable(skb);
+	const struct xt_tarpit_tginfo *info = par->targinfo;
+
+	/* Do we have an input route cache entry? (Not in PREROUTING.) */
+	if (rt == NULL)
+		return NF_DROP;
+
+	/* No replies to physical multicast/broadcast */
+	/* skb != PACKET_OTHERHOST handled by ip_rcv() */
+	if (skb->pkt_type != PACKET_HOST)
+		return NF_DROP;
+
+	/* Now check at the protocol level */
+	if (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))
+		return NF_DROP;
+
+	/*
+	 * Our naive response construction does not deal with IP
+	 * options, and probably should not try.
+	 */
+	if (ip_hdrlen(skb) != sizeof(struct iphdr))
+		return NF_DROP;
+
+	/* We are not interested in fragments */
+	if (iph->frag_off & htons(IP_OFFSET))
+		return NF_DROP;
+
+	tarpit_tcp4(*pskb, par->hooknum, info->variant);
+	return NF_DROP;
+}
+
+#ifdef WITH_IPV6
+static unsigned int
+tarpit_tg6(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct sk_buff *skb = *pskb;
+	const struct ipv6hdr *iph = ipv6_hdr(skb);
+	const struct rt6_info *rt = (struct rt6_info *)skb_dst(skb);
+	const struct xt_tarpit_tginfo *info = par->targinfo;
+	uint8_t proto;
+	__be16 frag_off;
+
+	/* Do we have an input route cache entry? (Not in PREROUTING.) */
+	if (rt == NULL) {
+		pr_debug("Dropping no input route cache entry\n");
+		return NF_DROP;
+	}
+
+	/* No replies to physical multicast/broadcast */
+	/* skb != PACKET_OTHERHOST handled by ip_rcv() */
+	if (skb->pkt_type != PACKET_HOST) {
+		pr_debug("type != PACKET_HOST");
+		return NF_DROP;
+	}
+
+	/*
+	 * Our naive response construction does not deal with IP
+	 * options, and probably should not try.
+	 */
+	proto = iph->nexthdr;
+	if (ipv6_skip_exthdr(skb, skb_network_header_len(skb), &proto,
+	    &frag_off) != sizeof(struct ipv6hdr))
+		return NF_DROP;
+
+	if ((!(ipv6_addr_type(&iph->saddr) & IPV6_ADDR_UNICAST)) ||
+	    (!(ipv6_addr_type(&iph->daddr) & IPV6_ADDR_UNICAST))) {
+		pr_debug("addr is not unicast.\n");
+		return NF_DROP;
+	}
+
+	tarpit_tcp6(*pskb, par->hooknum, info->variant);
+	return NF_DROP;
+}
+#endif
+
+static struct xt_target tarpit_tg_reg[] __read_mostly = {
+	{
+		.name       = "TARPIT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.hooks      = (1 << NF_INET_LOCAL_IN) | (1 << NF_INET_FORWARD),
+		.proto      = IPPROTO_TCP,
+		.target     = tarpit_tg4,
+		.targetsize = sizeof(struct xt_tarpit_tginfo),
+		.me         = THIS_MODULE,
+	},
+#ifdef WITH_IPV6
+	{
+		.name       = "TARPIT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.hooks      = (1 << NF_INET_LOCAL_IN) | (1 << NF_INET_FORWARD),
+		.proto      = IPPROTO_TCP,
+		.target     = tarpit_tg6,
+		.targetsize = sizeof(struct xt_tarpit_tginfo),
+		.me         = THIS_MODULE,
+	},
+#endif
+};
+
+static int __init tarpit_tg_init(void)
+{
+	return xt_register_targets(tarpit_tg_reg, ARRAY_SIZE(tarpit_tg_reg));
+}
+
+static void __exit tarpit_tg_exit(void)
+{
+	xt_unregister_targets(tarpit_tg_reg, ARRAY_SIZE(tarpit_tg_reg));
+}
+
+module_init(tarpit_tg_init);
+module_exit(tarpit_tg_exit);
+MODULE_DESCRIPTION("Xtables: \"TARPIT\", capture and hold TCP connections");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_TARPIT");
+MODULE_ALIAS("ip6t_TARPIT");

--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_TARPIT.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/netfilter/xt_TARPIT.h
@@ -0,0 +1,14 @@
+#ifndef _LINUX_NETFILTER_XT_TARPIT_H
+#define _LINUX_NETFILTER_XT_TARPIT_H 1
+
+enum xt_tarpit_target_variant {
+	XTTARPIT_TARPIT,
+	XTTARPIT_HONEYPOT,
+	XTTARPIT_RESET,
+};
+
+struct xt_tarpit_tginfo {
+	uint8_t variant;
+};
+
+#endif /* _LINUX_NETFILTER_XT_TARPIT_H */
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/Kconfig
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/Kconfig
@@ -66,6 +66,28 @@
 
 	  If unsure, say N.
 
+config SQUASHFS_4K_DEVBLK_SIZE
+	bool "Use 4K device block size?"
+	depends on SQUASHFS
+	help
+	  By default Squashfs sets the dev block size (sb_min_blocksize)
+	  to 1K or the smallest block size supported by the block device
+	  (if larger).  This, because blocks are packed together and
+	  unaligned in Squashfs, should reduce latency.
+
+	  This, however, gives poor performance on MTD NAND devices where
+	  the optimal I/O size is 4K (even though the devices can support
+	  smaller block sizes).
+
+	  Using a 4K device block size may also improve overall I/O
+	  performance for some file access patterns (e.g. sequential
+	  accesses of files in filesystem order) on all media.
+
+	  Setting this option will force Squashfs to use a 4K device block
+	  size by default.
+
+	  If unsure, say N.
+
 config SQUASHFS_EMBEDDED
 	bool "Additional option for memory-constrained systems"
 	depends on SQUASHFS
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
@@ -37,6 +37,13 @@
 #define SQUASHFS_FILE_SIZE		131072
 #define SQUASHFS_FILE_LOG		17
 
+/* default size of block device I/O */
+#ifdef CONFIG_SQUASHFS_4K_DEVBLK_SIZE
+#define SQUASHFS_DEVBLK_SIZE 4096
+#else
+#define SQUASHFS_DEVBLK_SIZE 1024
+#endif
+
 #define SQUASHFS_FILE_MAX_SIZE		1048576
 #define SQUASHFS_FILE_MAX_LOG		20
 
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/super.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/fs/squashfs/super.c
@@ -102,7 +102,7 @@
 		goto failure;
 	}
 
-	msblk->devblksize = sb_min_blocksize(sb, BLOCK_SIZE);
+	msblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);
 	msblk->devblksize_log2 = ffz(~msblk->devblksize);
 
 	mutex_init(&msblk->read_data_mutex);
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/Makefile
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/Makefile
@@ -85,6 +85,9 @@
 obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
 obj-$(CONFIG_CRYPTO_GHASH) += ghash-generic.o
+obj-$(CONFIG_CRYPTO_USER_API) += af_alg.o
+obj-$(CONFIG_CRYPTO_USER_API_HASH) += algif_hash.o
+obj-$(CONFIG_CRYPTO_USER_API_SKCIPHER) += algif_skcipher.o
 
 #
 # generic algorithms and the async_tx api
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/Kconfig
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/Kconfig
@@ -842,6 +842,27 @@
 	  ANSI X9.31 A.2.4. Note that this option must be enabled if
 	  CRYPTO_FIPS is selected
 
+config CRYPTO_USER_API
+	tristate
+
+config CRYPTO_USER_API_HASH
+	tristate "User-space interface for hash algorithms"
+	depends on NET
+	select CRYPTO_HASH
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for hash
+	  algorithms.
+
+config CRYPTO_USER_API_SKCIPHER
+	tristate "User-space interface for symmetric key cipher algorithms"
+	depends on NET
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for symmetric
+	  key cipher algorithms.
+
 source "drivers/crypto/Kconfig"
 
 endif	# if CRYPTO
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/af_alg.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/af_alg.c
@@ -0,0 +1,483 @@
+/*
+ * af_alg: User-space algorithm interface
+ *
+ * This file provides the user-space API for algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <asm/atomic.h>
+#include <crypto/if_alg.h>
+#include <linux/crypto.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/rwsem.h>
+
+struct alg_type_list {
+	const struct af_alg_type *type;
+	struct list_head list;
+};
+
+static atomic_long_t alg_memory_allocated;
+
+static struct proto alg_proto = {
+	.name			= "ALG",
+	.owner			= THIS_MODULE,
+	.memory_allocated	= &alg_memory_allocated,
+	.obj_size		= sizeof(struct alg_sock),
+};
+
+static LIST_HEAD(alg_types);
+static DECLARE_RWSEM(alg_types_sem);
+
+static const struct af_alg_type *alg_get_type(const char *name)
+{
+	const struct af_alg_type *type = ERR_PTR(-ENOENT);
+	struct alg_type_list *node;
+
+	down_read(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, name))
+			continue;
+
+		if (try_module_get(node->type->owner))
+			type = node->type;
+		break;
+	}
+	up_read(&alg_types_sem);
+
+	return type;
+}
+
+int af_alg_register_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -EEXIST;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (!strcmp(node->type->name, type->name))
+			goto unlock;
+	}
+
+	node = kmalloc(sizeof(*node), GFP_KERNEL);
+	err = -ENOMEM;
+	if (!node)
+		goto unlock;
+
+	type->ops->owner = THIS_MODULE;
+	node->type = type;
+	list_add(&node->list, &alg_types);
+	err = 0;
+
+unlock:
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_register_type);
+
+int af_alg_unregister_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -ENOENT;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, type->name))
+			continue;
+
+		list_del(&node->list);
+		kfree(node);
+		err = 0;
+		break;
+	}
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_unregister_type);
+
+static void alg_do_release(const struct af_alg_type *type, void *private)
+{
+	if (!type)
+		return;
+
+	type->release(private);
+	module_put(type->owner);
+}
+
+int af_alg_release(struct socket *sock)
+{
+	if (sock->sk)
+		sock_put(sock->sk);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_release);
+
+static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct sockaddr_alg *sa = (void *)uaddr;
+	const struct af_alg_type *type;
+	void *private;
+
+	if (sock->state == SS_CONNECTED)
+		return -EINVAL;
+
+	if (addr_len != sizeof(*sa))
+		return -EINVAL;
+
+	sa->salg_type[sizeof(sa->salg_type) - 1] = 0;
+	sa->salg_name[sizeof(sa->salg_name) - 1] = 0;
+
+	type = alg_get_type(sa->salg_type);
+	if (IS_ERR(type) && PTR_ERR(type) == -ENOENT) {
+		request_module("algif-%s", sa->salg_type);
+		type = alg_get_type(sa->salg_type);
+	}
+
+	if (IS_ERR(type))
+		return PTR_ERR(type);
+
+	private = type->bind(sa->salg_name, sa->salg_feat, sa->salg_mask);
+	if (IS_ERR(private)) {
+		module_put(type->owner);
+		return PTR_ERR(private);
+	}
+
+	lock_sock(sk);
+
+	swap(ask->type, type);
+	swap(ask->private, private);
+
+	release_sock(sk);
+
+	alg_do_release(type, private);
+
+	return 0;
+}
+
+static int alg_setkey(struct sock *sk, char __user *ukey,
+		      unsigned int keylen)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type = ask->type;
+	u8 *key;
+	int err;
+
+	key = sock_kmalloc(sk, keylen, GFP_KERNEL);
+	if (!key)
+		return -ENOMEM;
+
+	err = -EFAULT;
+	if (copy_from_user(key, ukey, keylen))
+		goto out;
+
+	err = type->setkey(ask->private, key, keylen);
+
+out:
+	sock_kfree_s(sk, key, keylen);
+
+	return err;
+}
+
+static int alg_setsockopt(struct socket *sock, int level, int optname,
+			  char __user *optval, unsigned int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	int err = -ENOPROTOOPT;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	if (level != SOL_ALG || !type)
+		goto unlock;
+
+	switch (optname) {
+	case ALG_SET_KEY:
+		if (sock->state == SS_CONNECTED)
+			goto unlock;
+		if (!type->setkey)
+			goto unlock;
+
+		err = alg_setkey(sk, optval, optlen);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+
+int af_alg_accept(struct sock *sk, struct socket *newsock)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	struct sock *sk2;
+	int err;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	err = -EINVAL;
+	if (!type)
+		goto unlock;
+
+	sk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto);
+	err = -ENOMEM;
+	if (!sk2)
+		goto unlock;
+
+	sock_init_data(newsock, sk2);
+	sock_graft(sk2, newsock);
+
+	err = type->accept(ask->private, sk2);
+	if (err) {
+		sk_free(sk2);
+		goto unlock;
+	}
+
+	sk2->sk_family = PF_ALG;
+
+	sock_hold(sk);
+	alg_sk(sk2)->parent = sk;
+	alg_sk(sk2)->type = type;
+
+	newsock->ops = type->ops;
+	newsock->state = SS_CONNECTED;
+
+	err = 0;
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_accept);
+
+static int alg_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	return af_alg_accept(sock->sk, newsock);
+}
+
+static const struct proto_ops alg_proto_ops = {
+	.family		=	PF_ALG,
+	.owner		=	THIS_MODULE,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.sendpage	=	sock_no_sendpage,
+	.sendmsg	=	sock_no_sendmsg,
+	.recvmsg	=	sock_no_recvmsg,
+	.poll		=	sock_no_poll,
+
+	.bind		=	alg_bind,
+	.release	=	af_alg_release,
+	.setsockopt	=	alg_setsockopt,
+	.accept		=	alg_accept,
+};
+
+static void alg_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+
+	alg_do_release(ask->type, ask->private);
+}
+
+static int alg_create(struct net *net, struct socket *sock, int protocol,
+		      int kern)
+{
+	struct sock *sk;
+	int err;
+
+	if (sock->type != SOCK_SEQPACKET)
+		return -ESOCKTNOSUPPORT;
+	if (protocol != 0)
+		return -EPROTONOSUPPORT;
+
+	err = -ENOMEM;
+	sk = sk_alloc(net, PF_ALG, GFP_KERNEL, &alg_proto);
+	if (!sk)
+		goto out;
+
+	sock->ops = &alg_proto_ops;
+	sock_init_data(sock, sk);
+
+	sk->sk_family = PF_ALG;
+	sk->sk_destruct = alg_sock_destruct;
+
+	return 0;
+out:
+	return err;
+}
+
+static const struct net_proto_family alg_family = {
+	.family	=	PF_ALG,
+	.create	=	alg_create,
+	.owner	=	THIS_MODULE,
+};
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write)
+{
+	unsigned long from = (unsigned long)addr;
+	unsigned long npages;
+	unsigned off;
+	int err;
+	int i;
+
+	err = -EFAULT;
+	if (!access_ok(write ? VERIFY_READ : VERIFY_WRITE, addr, len))
+		goto out;
+
+	off = from & ~PAGE_MASK;
+	npages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	if (npages > ALG_MAX_PAGES)
+		npages = ALG_MAX_PAGES;
+
+	err = get_user_pages_fast(from, npages, write, sgl->pages);
+	if (err < 0)
+		goto out;
+
+	npages = err;
+	err = -EINVAL;
+	if (WARN_ON(npages == 0))
+		goto out;
+
+	err = 0;
+
+	sg_init_table(sgl->sg, npages);
+
+	for (i = 0; i < npages; i++) {
+		int plen = min_t(int, len, PAGE_SIZE - off);
+
+		sg_set_page(sgl->sg + i, sgl->pages[i], plen, off);
+
+		off = 0;
+		len -= plen;
+		err += plen;
+	}
+
+out:
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_make_sg);
+
+void af_alg_free_sg(struct af_alg_sgl *sgl)
+{
+	int i;
+
+	i = 0;
+	do {
+		put_page(sgl->pages[i]);
+	} while (!sg_is_last(sgl->sg + (i++)));
+}
+EXPORT_SYMBOL_GPL(af_alg_free_sg);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con)
+{
+	struct cmsghdr *cmsg;
+
+	for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
+		if (!CMSG_OK(msg, cmsg))
+			return -EINVAL;
+		if (cmsg->cmsg_level != SOL_ALG)
+			continue;
+
+		switch(cmsg->cmsg_type) {
+		case ALG_SET_IV:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(*con->iv)))
+				return -EINVAL;
+			con->iv = (void *)CMSG_DATA(cmsg);
+			if (cmsg->cmsg_len < CMSG_LEN(con->iv->ivlen +
+						      sizeof(*con->iv)))
+				return -EINVAL;
+			break;
+
+		case ALG_SET_OP:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))
+				return -EINVAL;
+			con->op = *(u32 *)CMSG_DATA(cmsg);
+			break;
+
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_cmsg_send);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion)
+{
+	switch (err) {
+	case -EINPROGRESS:
+	case -EBUSY:
+		wait_for_completion(&completion->completion);
+		INIT_COMPLETION(completion->completion);
+		err = completion->err;
+		break;
+	};
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_wait_for_completion);
+
+void af_alg_complete(struct crypto_async_request *req, int err)
+{
+	struct af_alg_completion *completion = req->data;
+
+	completion->err = err;
+	complete(&completion->completion);
+}
+EXPORT_SYMBOL_GPL(af_alg_complete);
+
+static int __init af_alg_init(void)
+{
+	int err = proto_register(&alg_proto, 0);
+
+	if (err)
+		goto out;
+
+	err = sock_register(&alg_family);
+	if (err != 0)
+		goto out_unregister_proto;
+
+out:
+	return err;
+
+out_unregister_proto:
+	proto_unregister(&alg_proto);
+	goto out;
+}
+
+static void __exit af_alg_exit(void)
+{
+	sock_unregister(PF_ALG);
+	proto_unregister(&alg_proto);
+}
+
+module_init(af_alg_init);
+module_exit(af_alg_exit);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_NETPROTO(AF_ALG);
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/algif_hash.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/algif_hash.c
@@ -0,0 +1,319 @@
+/*
+ * algif_hash: User-space interface for hash algorithms
+ *
+ * This file provides the user-space API for hash algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/hash.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct hash_ctx {
+	struct af_alg_sgl sgl;
+
+	u8 *result;
+
+	struct af_alg_completion completion;
+
+	unsigned int len;
+	bool more;
+
+	struct ahash_request req;
+};
+
+static int hash_sendmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t ignored)
+{
+	int limit = ALG_MAX_PAGES * PAGE_SIZE;
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned long iovlen;
+	struct iovec *iov;
+	long copied = 0;
+	int err;
+
+	if (limit > sk->sk_sndbuf)
+		limit = sk->sk_sndbuf;
+
+	lock_sock(sk);
+	if (!ctx->more) {
+		err = crypto_ahash_init(&ctx->req);
+		if (err)
+			goto unlock;
+	}
+
+	ctx->more = 0;
+
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			int len = min_t(unsigned long, seglen, limit);
+			int newlen;
+
+			newlen = af_alg_make_sg(&ctx->sgl, from, len, 0);
+			if (newlen < 0)
+				goto unlock;
+
+			ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL,
+						newlen);
+
+			err = af_alg_wait_for_completion(
+				crypto_ahash_update(&ctx->req),
+				&ctx->completion);
+
+			af_alg_free_sg(&ctx->sgl);
+
+			if (err)
+				goto unlock;
+
+			seglen -= newlen;
+			from += newlen;
+			copied += newlen;
+		}
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more) {
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err ?: copied;
+}
+
+static ssize_t hash_sendpage(struct socket *sock, struct page *page,
+			     int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	int err;
+
+	lock_sock(sk);
+	sg_init_table(ctx->sgl.sg, 1);
+	sg_set_page(ctx->sgl.sg, page, size, offset);
+
+	ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, ctx->result, size);
+
+	if (!(flags & MSG_MORE)) {
+		if (ctx->more)
+			err = crypto_ahash_finup(&ctx->req);
+		else
+			err = crypto_ahash_digest(&ctx->req);
+	} else {
+		if (!ctx->more) {
+			err = crypto_ahash_init(&ctx->req);
+			if (err)
+				goto unlock;
+		}
+
+		err = crypto_ahash_update(&ctx->req);
+	}
+
+	err = af_alg_wait_for_completion(err, &ctx->completion);
+	if (err)
+		goto unlock;
+
+	ctx->more = flags & MSG_MORE;
+
+unlock:
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t len, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
+	int err;
+
+	if (len > ds)
+		len = ds;
+	else if (len < ds)
+		msg->msg_flags |= MSG_TRUNC;
+
+	lock_sock(sk);
+	if (ctx->more) {
+		ctx->more = 0;
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+		if (err)
+			goto unlock;
+	}
+
+	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);
+
+unlock:
+	release_sock(sk);
+
+	return err ?: len;
+}
+
+static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	struct ahash_request *req = &ctx->req;
+	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];
+	struct sock *sk2;
+	struct alg_sock *ask2;
+	struct hash_ctx *ctx2;
+	int err;
+
+	err = crypto_ahash_export(req, state);
+	if (err)
+		return err;
+
+	err = af_alg_accept(ask->parent, newsock);
+	if (err)
+		return err;
+
+	sk2 = newsock->sk;
+	ask2 = alg_sk(sk2);
+	ctx2 = ask2->private;
+	ctx2->more = 1;
+
+	err = crypto_ahash_import(&ctx2->req, state);
+	if (err) {
+		sock_orphan(sk2);
+		sock_put(sk2);
+	}
+
+	return err;
+}
+
+static struct proto_ops algif_hash_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.setsockopt	=	sock_no_setsockopt,
+	.poll		=	sock_no_poll,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	hash_sendmsg,
+	.sendpage	=	hash_sendpage,
+	.recvmsg	=	hash_recvmsg,
+	.accept		=	hash_accept,
+};
+
+static void *hash_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ahash(name, type, mask);
+}
+
+static void hash_release(void *private)
+{
+	crypto_free_ahash(private);
+}
+
+static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ahash_setkey(private, key, keylen);
+}
+
+static void hash_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+
+	sock_kfree_s(sk, ctx->result,
+		     crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int hash_accept_parent(void *private, struct sock *sk)
+{
+	struct hash_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);
+	unsigned ds = crypto_ahash_digestsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);
+	if (!ctx->result) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->result, 0, ds);
+
+	ctx->len = len;
+	ctx->more = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ahash_request_set_tfm(&ctx->req, private);
+	ahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				   af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = hash_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_hash = {
+	.bind		=	hash_bind,
+	.release	=	hash_release,
+	.setkey		=	hash_setkey,
+	.accept		=	hash_accept_parent,
+	.ops		=	&algif_hash_ops,
+	.name		=	"hash",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_hash_init(void)
+{
+	return af_alg_register_type(&algif_type_hash);
+}
+
+static void __exit algif_hash_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_hash);
+	BUG_ON(err);
+}
+
+module_init(algif_hash_init);
+module_exit(algif_hash_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/algif_skcipher.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/crypto/algif_skcipher.c
@@ -0,0 +1,632 @@
+/*
+ * algif_skcipher: User-space interface for skcipher algorithms
+ *
+ * This file provides the user-space API for symmetric key ciphers.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/scatterwalk.h>
+#include <crypto/skcipher.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct skcipher_sg_list {
+	struct list_head list;
+
+	int cur;
+
+	struct scatterlist sg[0];
+};
+
+struct skcipher_ctx {
+	struct list_head tsgl;
+	struct af_alg_sgl rsgl;
+
+	void *iv;
+
+	struct af_alg_completion completion;
+
+	unsigned used;
+
+	unsigned int len;
+	bool more;
+	bool merge;
+	bool enc;
+
+	struct ablkcipher_request req;
+};
+
+#define MAX_SGL_ENTS ((PAGE_SIZE - sizeof(struct skcipher_sg_list)) / \
+		      sizeof(struct scatterlist) - 1)
+
+static inline int skcipher_sndbuf(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	return max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -
+			  ctx->used, 0);
+}
+
+static inline bool skcipher_writable(struct sock *sk)
+{
+	return PAGE_SIZE <= skcipher_sndbuf(sk);
+}
+
+static int skcipher_alloc_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg = NULL;
+
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+	if (!list_empty(&ctx->tsgl))
+		sg = sgl->sg;
+
+	if (!sg || sgl->cur >= MAX_SGL_ENTS) {
+		sgl = sock_kmalloc(sk, sizeof(*sgl) +
+				       sizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),
+				   GFP_KERNEL);
+		if (!sgl)
+			return -ENOMEM;
+
+		sg_init_table(sgl->sg, MAX_SGL_ENTS + 1);
+		sgl->cur = 0;
+
+		if (sg)
+			scatterwalk_sg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);
+
+		list_add_tail(&sgl->list, &ctx->tsgl);
+	}
+
+	return 0;
+}
+
+static void skcipher_pull_sgl(struct sock *sk, int used)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	int i;
+
+	while (!list_empty(&ctx->tsgl)) {
+		sgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,
+				       list);
+		sg = sgl->sg;
+
+		for (i = 0; i < sgl->cur; i++) {
+			int plen = min_t(int, used, sg[i].length);
+
+			if (!sg_page(sg + i))
+				continue;
+
+			sg[i].length -= plen;
+			sg[i].offset += plen;
+
+			used -= plen;
+			ctx->used -= plen;
+
+			if (sg[i].length)
+				return;
+
+			put_page(sg_page(sg + i));
+			sg_assign_page(sg + i, NULL);
+		}
+
+		list_del(&sgl->list);
+		sock_kfree_s(sk, sgl,
+			     sizeof(*sgl) + sizeof(sgl->sg[0]) *
+					    (MAX_SGL_ENTS + 1));
+	}
+
+	if (!ctx->used)
+		ctx->merge = 0;
+}
+
+static void skcipher_free_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	skcipher_pull_sgl(sk, ctx->used);
+}
+
+static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)
+{
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT)
+		return -EAGAIN;
+
+	set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	return err;
+}
+
+static void skcipher_wmem_wakeup(struct sock *sk)
+{
+	struct socket_wq *wq;
+
+	if (!skcipher_writable(sk))
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLIN |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
+	rcu_read_unlock();
+}
+
+static int skcipher_wait_for_data(struct sock *sk, unsigned flags)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT) {
+		return -EAGAIN;
+	}
+
+	set_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, ctx->used)) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	return err;
+}
+
+static void skcipher_data_wakeup(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct socket_wq *wq;
+
+	if (!ctx->used)
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLOUT |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);
+	rcu_read_unlock();
+}
+
+static int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+	unsigned ivsize = crypto_ablkcipher_ivsize(tfm);
+	struct skcipher_sg_list *sgl;
+	struct af_alg_control con = {};
+	long copied = 0;
+	bool enc = 0;
+	int err;
+	int i;
+
+	if (msg->msg_controllen) {
+		err = af_alg_cmsg_send(msg, &con);
+		if (err)
+			return err;
+
+		switch (con.op) {
+		case ALG_OP_ENCRYPT:
+			enc = 1;
+			break;
+		case ALG_OP_DECRYPT:
+			enc = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (con.iv && con.iv->ivlen != ivsize)
+			return -EINVAL;
+	}
+
+	err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!ctx->used) {
+		ctx->enc = enc;
+		if (con.iv)
+			memcpy(ctx->iv, con.iv->iv, ivsize);
+	}
+
+	while (size) {
+		struct scatterlist *sg;
+		unsigned long len = size;
+		int plen;
+
+		if (ctx->merge) {
+			sgl = list_entry(ctx->tsgl.prev,
+					 struct skcipher_sg_list, list);
+			sg = sgl->sg + sgl->cur - 1;
+			len = min_t(unsigned long, len,
+				    PAGE_SIZE - sg->offset - sg->length);
+
+			err = memcpy_fromiovec(page_address(sg_page(sg)) +
+					       sg->offset + sg->length,
+					       msg->msg_iov, len);
+			if (err)
+				goto unlock;
+
+			sg->length += len;
+			ctx->merge = (sg->offset + sg->length) &
+				     (PAGE_SIZE - 1);
+
+			ctx->used += len;
+			copied += len;
+			size -= len;
+			continue;
+		}
+
+		if (!skcipher_writable(sk)) {
+			err = skcipher_wait_for_wmem(sk, msg->msg_flags);
+			if (err)
+				goto unlock;
+		}
+
+		len = min_t(unsigned long, len, skcipher_sndbuf(sk));
+
+		err = skcipher_alloc_sgl(sk);
+		if (err)
+			goto unlock;
+
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+		sg = sgl->sg;
+		do {
+			i = sgl->cur;
+			plen = min_t(int, len, PAGE_SIZE);
+
+			sg_assign_page(sg + i, alloc_page(GFP_KERNEL));
+			err = -ENOMEM;
+			if (!sg_page(sg + i))
+				goto unlock;
+
+			err = memcpy_fromiovec(page_address(sg_page(sg + i)),
+					       msg->msg_iov, plen);
+			if (err) {
+				__free_page(sg_page(sg + i));
+				sg_assign_page(sg + i, NULL);
+				goto unlock;
+			}
+
+			sg[i].length = plen;
+			len -= plen;
+			ctx->used += plen;
+			copied += plen;
+			size -= plen;
+			sgl->cur++;
+		} while (len && sgl->cur < MAX_SGL_ENTS);
+
+		ctx->merge = plen & (PAGE_SIZE - 1);
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+static ssize_t skcipher_sendpage(struct socket *sock, struct page *page,
+				 int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	int err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!size)
+		goto done;
+
+	if (!skcipher_writable(sk)) {
+		err = skcipher_wait_for_wmem(sk, flags);
+		if (err)
+			goto unlock;
+	}
+
+	err = skcipher_alloc_sgl(sk);
+	if (err)
+		goto unlock;
+
+	ctx->merge = 0;
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+	get_page(page);
+	sg_set_page(sgl->sg + sgl->cur, page, size, offset);
+	sgl->cur++;
+	ctx->used += size;
+
+done:
+	ctx->more = flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t ignored, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(
+		&ctx->req));
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	unsigned long iovlen;
+	struct iovec *iov;
+	int err = -EAGAIN;
+	int used;
+	long copied = 0;
+
+	lock_sock(sk);
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			sgl = list_first_entry(&ctx->tsgl,
+					       struct skcipher_sg_list, list);
+			sg = sgl->sg;
+
+			while (!sg->length)
+				sg++;
+
+			used = ctx->used;
+			if (!used) {
+				err = skcipher_wait_for_data(sk, flags);
+				if (err)
+					goto unlock;
+			}
+
+			used = min_t(unsigned long, used, seglen);
+
+			used = af_alg_make_sg(&ctx->rsgl, from, used, 1);
+			err = used;
+			if (err < 0)
+				goto unlock;
+
+			if (ctx->more || used < ctx->used)
+				used -= used % bs;
+
+			err = -EINVAL;
+			if (!used)
+				goto free;
+
+			ablkcipher_request_set_crypt(&ctx->req, sg,
+						     ctx->rsgl.sg, used,
+						     ctx->iv);
+
+			err = af_alg_wait_for_completion(
+				ctx->enc ?
+					crypto_ablkcipher_encrypt(&ctx->req) :
+					crypto_ablkcipher_decrypt(&ctx->req),
+				&ctx->completion);
+
+free:
+			af_alg_free_sg(&ctx->rsgl);
+
+			if (err)
+				goto unlock;
+
+			copied += used;
+			from += used;
+			seglen -= used;
+			skcipher_pull_sgl(sk, used);
+		}
+	}
+
+	err = 0;
+
+unlock:
+	skcipher_wmem_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+
+static unsigned int skcipher_poll(struct file *file, struct socket *sock,
+				  poll_table *wait)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned int mask;
+
+	sock_poll_wait(file, sk_sleep(sk), wait);
+	mask = 0;
+
+	if (ctx->used)
+		mask |= POLLIN | POLLRDNORM;
+
+	if (skcipher_writable(sk))
+		mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
+
+	return mask;
+}
+
+static struct proto_ops algif_skcipher_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.accept		=	sock_no_accept,
+	.setsockopt	=	sock_no_setsockopt,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	skcipher_sendmsg,
+	.sendpage	=	skcipher_sendpage,
+	.recvmsg	=	skcipher_recvmsg,
+	.poll		=	skcipher_poll,
+};
+
+static void *skcipher_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ablkcipher(name, type, mask);
+}
+
+static void skcipher_release(void *private)
+{
+	crypto_free_ablkcipher(private);
+}
+
+static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ablkcipher_setkey(private, key, keylen);
+}
+
+static void skcipher_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+
+	skcipher_free_sgl(sk);
+	sock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int skcipher_accept_parent(void *private, struct sock *sk)
+{
+	struct skcipher_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),
+			       GFP_KERNEL);
+	if (!ctx->iv) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));
+
+	INIT_LIST_HEAD(&ctx->tsgl);
+	ctx->len = len;
+	ctx->used = 0;
+	ctx->more = 0;
+	ctx->merge = 0;
+	ctx->enc = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ablkcipher_request_set_tfm(&ctx->req, private);
+	ablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = skcipher_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_skcipher = {
+	.bind		=	skcipher_bind,
+	.release	=	skcipher_release,
+	.setkey		=	skcipher_setkey,
+	.accept		=	skcipher_accept_parent,
+	.ops		=	&algif_skcipher_ops,
+	.name		=	"skcipher",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_skcipher_init(void)
+{
+	return af_alg_register_type(&algif_type_skcipher);
+}
+
+static void __exit algif_skcipher_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_skcipher);
+	BUG_ON(err);
+}
+
+module_init(algif_skcipher_init);
+module_exit(algif_skcipher_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/core/sock.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/core/sock.c
@@ -157,7 +157,7 @@
   "sk_lock-27"       , "sk_lock-28"          , "sk_lock-AF_CAN"      ,
   "sk_lock-AF_TIPC"  , "sk_lock-AF_BLUETOOTH", "sk_lock-IUCV"        ,
   "sk_lock-AF_RXRPC" , "sk_lock-AF_ISDN"     , "sk_lock-AF_PHONET"   ,
-  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" ,
+  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" , "sk_lock-AF_ALG"      ,
   "sk_lock-AF_MAX"
 };
 static const char *const af_family_slock_key_strings[AF_MAX+1] = {
@@ -173,7 +173,7 @@
   "slock-27"       , "slock-28"          , "slock-AF_CAN"      ,
   "slock-AF_TIPC"  , "slock-AF_BLUETOOTH", "slock-AF_IUCV"     ,
   "slock-AF_RXRPC" , "slock-AF_ISDN"     , "slock-AF_PHONET"   ,
-  "slock-AF_IEEE802154", "slock-AF_CAIF" ,
+  "slock-AF_IEEE802154", "slock-AF_CAIF" , "slock-AF_ALG"      ,
   "slock-AF_MAX"
 };
 static const char *const af_family_clock_key_strings[AF_MAX+1] = {
@@ -189,7 +189,7 @@
   "clock-27"       , "clock-28"          , "clock-AF_CAN"      ,
   "clock-AF_TIPC"  , "clock-AF_BLUETOOTH", "clock-AF_IUCV"     ,
   "clock-AF_RXRPC" , "clock-AF_ISDN"     , "clock-AF_PHONET"   ,
-  "clock-AF_IEEE802154", "clock-AF_CAIF" ,
+  "clock-AF_IEEE802154", "clock-AF_CAIF" , "clock-AF_ALG"      ,
   "clock-AF_MAX"
 };
 
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/crypto/if_alg.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/crypto/if_alg.h
@@ -0,0 +1,92 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _CRYPTO_IF_ALG_H
+#define _CRYPTO_IF_ALG_H
+
+#include <linux/compiler.h>
+#include <linux/completion.h>
+#include <linux/if_alg.h>
+#include <linux/types.h>
+#include <net/sock.h>
+
+#define ALG_MAX_PAGES			16
+
+struct crypto_async_request;
+
+struct alg_sock {
+	/* struct sock must be the first member of struct alg_sock */
+	struct sock sk;
+
+	struct sock *parent;
+
+	const struct af_alg_type *type;
+	void *private;
+};
+
+struct af_alg_completion {
+	struct completion completion;
+	int err;
+};
+
+struct af_alg_control {
+	struct af_alg_iv *iv;
+	int op;
+};
+
+struct af_alg_type {
+	void *(*bind)(const char *name, u32 type, u32 mask);
+	void (*release)(void *private);
+	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
+	int (*accept)(void *private, struct sock *sk);
+
+	struct proto_ops *ops;
+	struct module *owner;
+	char name[14];
+};
+
+struct af_alg_sgl {
+	struct scatterlist sg[ALG_MAX_PAGES];
+	struct page *pages[ALG_MAX_PAGES];
+};
+
+int af_alg_register_type(const struct af_alg_type *type);
+int af_alg_unregister_type(const struct af_alg_type *type);
+
+int af_alg_release(struct socket *sock);
+int af_alg_accept(struct sock *sk, struct socket *newsock);
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write);
+void af_alg_free_sg(struct af_alg_sgl *sgl);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion);
+void af_alg_complete(struct crypto_async_request *req, int err);
+
+static inline struct alg_sock *alg_sk(struct sock *sk)
+{
+	return (struct alg_sock *)sk;
+}
+
+static inline void af_alg_release_parent(struct sock *sk)
+{
+	sock_put(alg_sk(sk)->parent);
+}
+
+static inline void af_alg_init_completion(struct af_alg_completion *completion)
+{
+	init_completion(&completion->completion);
+}
+
+#endif	/* _CRYPTO_IF_ALG_H */
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/crypto/scatterwalk.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/crypto/scatterwalk.h
@@ -68,6 +68,21 @@
 	return (++sg)->length ? sg : (void *)sg_page(sg);
 }
 
+static inline void scatterwalk_crypto_chain(struct scatterlist *head,
+					    struct scatterlist *sg,
+					    int chain, int num)
+{
+	if (chain) {
+		head->length += sg->length;
+		sg = scatterwalk_sg_next(sg);
+	}
+
+	if (sg)
+		scatterwalk_sg_chain(head, num, sg);
+	else
+		sg_mark_end(head);
+}
+
 static inline unsigned long scatterwalk_samebuf(struct scatter_walk *walk_in,
 						struct scatter_walk *walk_out)
 {
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/if_alg.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/if_alg.h
@@ -0,0 +1,40 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _LINUX_IF_ALG_H
+#define _LINUX_IF_ALG_H
+
+#include <linux/types.h>
+
+struct sockaddr_alg {
+	__u16	salg_family;
+	__u8	salg_type[14];
+	__u32	salg_feat;
+	__u32	salg_mask;
+	__u8	salg_name[64];
+};
+
+struct af_alg_iv {
+	__u32	ivlen;
+	__u8	iv[0];
+};
+
+/* Socket options */
+#define ALG_SET_KEY			1
+#define ALG_SET_IV			2
+#define ALG_SET_OP			3
+
+/* Operations */
+#define ALG_OP_DECRYPT			0
+#define ALG_OP_ENCRYPT			1
+
+#endif	/* _LINUX_IF_ALG_H */
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/socket.h
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/include/linux/socket.h
@@ -193,7 +193,8 @@
 #define AF_PHONET	35	/* Phonet sockets		*/
 #define AF_IEEE802154	36	/* IEEE802154 sockets		*/
 #define AF_CAIF		37	/* CAIF sockets			*/
-#define AF_MAX		38	/* For now.. */
+#define AF_ALG		38	/* Algorithm sockets		*/
+#define AF_MAX		39	/* For now.. */
 
 /* Protocol families, same as address families. */
 #define PF_UNSPEC	AF_UNSPEC
@@ -234,6 +235,7 @@
 #define PF_PHONET	AF_PHONET
 #define PF_IEEE802154	AF_IEEE802154
 #define PF_CAIF		AF_CAIF
+#define PF_ALG		AF_ALG
 #define PF_MAX		AF_MAX
 
 /* Maximum queue length specifiable by listen.  */
@@ -310,6 +312,7 @@
 #define SOL_RDS		276
 #define SOL_IUCV	277
 #define SOL_CAIF	278
+#define SOL_ALG		279
 
 /* IPX options */
 #define IPX_TYPE	1
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/config_base.6a
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/config_base.6a
@@ -497,7 +497,7 @@
 CONFIG_NETFILTER_NETLINK_LOG=y
 CONFIG_NF_CONNTRACK=y
 CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_EVENTS is not set
+CONFIG_NF_CONNTRACK_EVENTS=y
 # CONFIG_NF_CT_PROTO_DCCP is not set
 CONFIG_NF_CT_PROTO_GRE=y
 # CONFIG_NF_CT_PROTO_SCTP is not set
@@ -541,9 +541,17 @@
 # CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
 # CONFIG_NETFILTER_XT_TARGET_TEE is not set
 # CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETFILTER_XT_TARGET_ACCOUNT is not set
+CONFIG_NETFILTER_XT_TARGET_CHAOS=m
+CONFIG_NETFILTER_XT_TARGET_DELUDE=m
+# CONFIG_NETFILTER_XT_TARGET_ECHO is not set
+CONFIG_NETFILTER_XT_TARGET_RAWNAT=m
+CONFIG_NETFILTER_XT_TARGET_STEAL=m
+CONFIG_NETFILTER_XT_TARGET_TARPIT=m
 CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
 # CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
 # CONFIG_NETFILTER_XT_MATCH_LAYER7 is not set
+# CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG is not set
 
 #
 # Xtables matches
@@ -577,7 +585,7 @@
 CONFIG_NETFILTER_XT_MATCH_RECENT=y
 # CONFIG_NETFILTER_XT_MATCH_SCTP is not set
 CONFIG_NETFILTER_XT_MATCH_STATE=y
-# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
 CONFIG_NETFILTER_XT_MATCH_STRING=y
 CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
 CONFIG_NETFILTER_XT_MATCH_TIME=y
@@ -585,6 +593,13 @@
 CONFIG_NETFILTER_XT_MATCH_WEBSTR=y
 CONFIG_NETFILTER_XT_MATCH_CONDITION=m
 CONFIG_NETFILTER_XT_MATCH_GEOIP=m
+CONFIG_NETFILTER_XT_MATCH_FUZZY=m
+CONFIG_NETFILTER_XT_MATCH_IFACE=m
+CONFIG_NETFILTER_XT_MATCH_IPV4OPTIONS=m
+CONFIG_NETFILTER_XT_MATCH_LSCAN=m
+CONFIG_NETFILTER_XT_MATCH_PKNOCK=m
+CONFIG_NETFILTER_XT_MATCH_PSD=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=m
 CONFIG_IP_SET=m
 CONFIG_IP_SET_MAX=256
 CONFIG_IP_SET_BITMAP_IP=m
@@ -1055,7 +1070,28 @@
 # CONFIG_SATA_INIC162X is not set
 # CONFIG_SATA_SIL24 is not set
 # CONFIG_ATA_SFF is not set
-# CONFIG_MD is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MULTICORE_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=m
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_MULTIPATH_QL is not set
+# CONFIG_DM_MULTIPATH_ST is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
 # CONFIG_FUSION is not set
 
 #
@@ -1217,14 +1253,14 @@
 # CONFIG_INPUT_MISC is not set
 CONFIG_HID_SUPPORT=y
 CONFIG_HID=m
-# CONFIG_HIDRAW is not set
+CONFIG_HIDRAW=y
 
 #
 # USB Input Devices
 #
 CONFIG_USB_HID=m
 # CONFIG_HID_PID is not set
-# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_HIDDEV=y
 
 #
 # USB HID Boot Protocol drivers
@@ -1328,7 +1364,10 @@
 #
 # PPS support
 #
-# CONFIG_PPS is not set
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+CONFIG_PPS_CLIENT_KTIMER=m
+CONFIG_PPS_CLIENT_LDISC=m
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -1456,13 +1495,13 @@
 # CONFIG_USB_SERIAL_AIRCABLE is not set
 # CONFIG_USB_SERIAL_ARK3116 is not set
 # CONFIG_USB_SERIAL_BELKIN is not set
-# CONFIG_USB_SERIAL_CH341 is not set
+CONFIG_USB_SERIAL_CH341=m
 # CONFIG_USB_SERIAL_WHITEHEAT is not set
 # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-# CONFIG_USB_SERIAL_CP210X is not set
+CONFIG_USB_SERIAL_CP210X=m
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
-# CONFIG_USB_SERIAL_FTDI_SIO is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
 # CONFIG_USB_SERIAL_FUNSOFT is not set
 # CONFIG_USB_SERIAL_VISOR is not set
 # CONFIG_USB_SERIAL_IPAQ is not set
@@ -1481,7 +1520,7 @@
 # CONFIG_USB_SERIAL_MOS7840 is not set
 # CONFIG_USB_SERIAL_MOTOROLA is not set
 # CONFIG_USB_SERIAL_NAVMAN is not set
-# CONFIG_USB_SERIAL_PL2303 is not set
+CONFIG_USB_SERIAL_PL2303=m
 # CONFIG_USB_SERIAL_OTI6858 is not set
 # CONFIG_USB_SERIAL_QCAUX is not set
 # CONFIG_USB_SERIAL_QUALCOMM is not set
@@ -1606,8 +1645,11 @@
 #
 # CD-ROM/DVD Filesystems
 #
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
@@ -1656,11 +1698,12 @@
 # CONFIG_JFFS2_CMODE_SIZE is not set
 # CONFIG_JFFS2_CMODE_FAVOURLZO is not set
 # CONFIG_LOGFS is not set
-# CONFIG_CRAMFS is not set
+CONFIG_CRAMFS=m
 CONFIG_SQUASHFS=y
 # CONFIG_SQUASHFS_XATTR is not set
 # CONFIG_SQUASHFS_LZO is not set
 CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
 CONFIG_SQUASHFS_EMBEDDED=y
 CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
 # CONFIG_VXFS_FS is not set
@@ -1853,7 +1896,7 @@
 CONFIG_CRYPTO_ECB=y
 # CONFIG_CRYPTO_LRW is not set
 # CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
+CONFIG_CRYPTO_XTS=m
 
 #
 # Hash modes
@@ -1870,41 +1913,42 @@
 # CONFIG_CRYPTO_MD4 is not set
 CONFIG_CRYPTO_MD5=y
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
 CONFIG_CRYPTO_SHA1=y
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
 
 #
 # Ciphers
 #
 CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ANUBIS=m
 CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_DES=m
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
 
 #
 # Compression
 #
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=m
 
 #
 # Random Number Generation
@@ -1912,9 +1956,17 @@
 CONFIG_CRYPTO_ANSI_CPRNG=y
 CONFIG_CRYPTO_HW=y
 # CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X_RNG is not set
 # CONFIG_BINARY_PRINTF is not set
 
 #
+# User-space algorithms
+#
+CONFIG_CRYPTO_USER_API=m
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+
+#
 # Library routines
 #
 CONFIG_BITREVERSE=y
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/drivers/usb/serial/ftdi_sio.c
@@ -1868,8 +1868,20 @@
 	   are only processed once.  */
 	status = packet[0] & FTDI_STATUS_B0_MASK;
 	if (status != priv->prev_status) {
-		priv->diff_status |= status ^ priv->prev_status;
-		wake_up_interruptible(&priv->delta_msr_wait);
+                char diff_status = status ^ priv->prev_status;
+                priv->diff_status |= diff_status;
+        
+                if (diff_status & FTDI_RS0_RLSD) {
+                        struct tty_struct *tty;
+ 
+                        tty = tty_port_tty_get(&port->port);
+                        if (tty)
+                                usb_serial_handle_dcd_change(port, tty,
+                                                status & FTDI_RS0_RLSD);
+                        tty_kref_put(tty);
+                }
+
+                wake_up_interruptible(&priv->delta_msr_wait);
 		priv->prev_status = status;
 	}
 
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/drivers/usb/serial/generic.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/drivers/usb/serial/generic.c
@@ -491,6 +491,15 @@
 	struct tty_port *port = &usb_port->port;
 
 	dbg("%s - port %d, status %d", __func__, usb_port->number, status);
+        if (tty) {
+               struct tty_ldisc *ld = tty_ldisc_ref(tty);
+
+               if (ld) {
+                       if (ld->ops->dcd_change)
+                               ld->ops->dcd_change(tty, status, NULL);
+                       tty_ldisc_deref(ld);
+               }
+        }
 
 	if (status)
 		wake_up_interruptible(&port->open_wait);

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/compat_nfinetaddr.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/compat_nfinetaddr.h
@@ -0,0 +1,14 @@
+#ifndef _COMPAT_NFINETADDR_H
+#define _COMPAT_NFINETADDR_H 1
+
+#include <linux/in.h>
+#include <linux/in6.h>
+
+union nf_inet_addr {
+	__be32 ip;
+	__be32 ip6[4];
+	struct in_addr in;
+	struct in6_addr in6;
+};
+
+#endif /* _COMPAT_NFINETADDR_H */

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/compat_rawpost.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/compat_rawpost.h
@@ -0,0 +1,87 @@
+#ifndef XTA_COMPAT_RAWPOST_H
+#define XTA_COMPAT_RAWPOST_H 1
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+typedef struct sk_buff sk_buff_t;
+#else
+typedef struct sk_buff *sk_buff_t;
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 21)
+#define XT_TARGET_INIT(__name, __size)					       \
+{									       \
+	.target.u.user = {						       \
+		.target_size	= XT_ALIGN(__size),			       \
+		.name		= __name,				       \
+	},								       \
+}
+
+#define IPT_ENTRY_INIT(__size)						       \
+{									       \
+	.target_offset	= sizeof(struct ipt_entry),			       \
+	.next_offset	= (__size),					       \
+}
+
+#define IPT_STANDARD_INIT(__verdict)					       \
+{									       \
+	.entry		= IPT_ENTRY_INIT(sizeof(struct ipt_standard)),	       \
+	.target		= XT_TARGET_INIT(IPT_STANDARD_TARGET,		       \
+					 sizeof(struct xt_standard_target)),   \
+	.target.verdict	= -(__verdict) - 1,				       \
+}
+
+#define IPT_ERROR_INIT							       \
+{									       \
+	.entry		= IPT_ENTRY_INIT(sizeof(struct ipt_error)),	       \
+	.target		= XT_TARGET_INIT(IPT_ERROR_TARGET,		       \
+					 sizeof(struct ipt_error_target)),     \
+	.target.errorname = "ERROR",					       \
+}
+
+#define IP6T_ENTRY_INIT(__size)						       \
+{									       \
+	.target_offset	= sizeof(struct ip6t_entry),			       \
+	.next_offset	= (__size),					       \
+}
+
+#define IP6T_STANDARD_INIT(__verdict)					       \
+{									       \
+	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_standard)),       \
+	.target		= XT_TARGET_INIT(IP6T_STANDARD_TARGET,		       \
+					 sizeof(struct ip6t_standard_target)), \
+	.target.verdict	= -(__verdict) - 1,				       \
+}
+
+#define IP6T_ERROR_INIT							       \
+{									       \
+	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_error)),	       \
+	.target		= XT_TARGET_INIT(IP6T_ERROR_TARGET,		       \
+					 sizeof(struct ip6t_error_target)),    \
+	.target.errorname = "ERROR",					       \
+}
+
+#endif /* 2.6.21 */
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
+#	include <linux/netfilter_ipv6/ip6_tables.h>
+/* Standard entry */
+struct ip6t_standard
+{
+	struct ip6t_entry entry;
+	struct ip6t_standard_target target;
+};
+
+struct ip6t_error_target
+{
+	struct ip6t_entry_target target;
+	char errorname[IP6T_FUNCTION_MAXNAMELEN];
+};
+
+struct ip6t_error
+{
+	struct ip6t_entry entry;
+	struct ip6t_error_target target;
+};
+#endif /* 2.6.20 */
+
+#endif /* XTA_COMPAT_RAWPOST_H */

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/compat_skbuff.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/compat_skbuff.h
@@ -0,0 +1,62 @@
+#ifndef COMPAT_SKBUFF_H
+#define COMPAT_SKBUFF_H 1
+
+struct tcphdr;
+struct udphdr;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 30)
+static inline void skb_dst_set(struct sk_buff *skb, struct dst_entry *dst)
+{
+	skb->dst = dst;
+}
+
+static inline struct dst_entry *skb_dst(const struct sk_buff *skb)
+{
+	return skb->dst;
+}
+
+static inline struct rtable *skb_rtable(const struct sk_buff *skb)
+{
+	return (void *)skb->dst;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+#	define skb_ifindex(skb) \
+		(((skb)->input_dev != NULL) ? (skb)->input_dev->ifindex : 0)
+#	define skb_nfmark(skb) (((struct sk_buff *)(skb))->nfmark)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 32)
+#	define skb_ifindex(skb) (skb)->iif
+#	define skb_nfmark(skb) (((struct sk_buff *)(skb))->mark)
+#else
+#	define skb_ifindex(skb) (skb)->skb_iif
+#	define skb_nfmark(skb) (((struct sk_buff *)(skb))->mark)
+#endif
+
+#ifdef CONFIG_NETWORK_SECMARK
+#	define skb_secmark(skb) ((skb)->secmark)
+#else
+#	define skb_secmark(skb) 0
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 21)
+#	define ip_hdr(skb) ((skb)->nh.iph)
+#	define ip_hdrlen(skb) (ip_hdr(skb)->ihl * 4)
+#	define ipv6_hdr(skb) ((skb)->nh.ipv6h)
+#	define skb_network_header(skb) ((skb)->nh.raw)
+#	define skb_transport_header(skb) ((skb)->h.raw)
+static inline void skb_reset_network_header(struct sk_buff *skb)
+{
+	skb->nh.raw = skb->data;
+}
+static inline struct tcphdr *tcp_hdr(const struct sk_buff *skb)
+{
+	return (void *)skb_transport_header(skb);
+}
+static inline struct udphdr *udp_hdr(const struct sk_buff *skb)
+{
+	return (void *)skb_transport_header(skb);
+}
+#endif
+
+#endif /* COMPAT_SKBUFF_H */

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/compat_xtables.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/compat_xtables.c
@@ -0,0 +1,638 @@
+/*
+ *	API compat layer
+ *	written by Jan Engelhardt <jengelh [at] medozas de>, 2008 - 2010
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License, either
+ *	version 2 of the License, or any later version.
+ */
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/kmod.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_arp.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <net/route.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+#	include <linux/export.h>
+#endif
+#include "compat_skbuff.h"
+#include "compat_xtnu.h"
+#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
+#	define WITH_IPV6 1
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 22)
+static int xtnu_match_run(const struct sk_buff *skb,
+    const struct net_device *in, const struct net_device *out,
+    const struct xt_match *cm, const void *matchinfo, int offset,
+    unsigned int protoff, int *hotdrop)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static bool xtnu_match_run(const struct sk_buff *skb,
+    const struct net_device *in, const struct net_device *out,
+    const struct xt_match *cm, const void *matchinfo, int offset,
+    unsigned int protoff, bool *hotdrop)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_match *nm = xtcompat_numatch(cm);
+	bool lo_ret;
+	struct xt_action_param local_par;
+	local_par.in        = in;
+	local_par.out       = out;
+	local_par.match     = cm;
+	local_par.matchinfo = matchinfo;
+	local_par.fragoff   = offset;
+	local_par.thoff     = protoff;
+	local_par.hotdrop   = false;
+	local_par.family    = NFPROTO_UNSPEC; /* don't have that info */
+
+	if (nm == NULL || nm->match == NULL)
+		return false;
+	lo_ret = nm->match(skb, &local_par);
+	*hotdrop = local_par.hotdrop;
+	return lo_ret;
+}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28) && \
+    LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+static bool xtnu_match_run(const struct sk_buff *skb,
+    const struct xt_match_param *par)
+{
+	struct xtnu_match *nm = xtcompat_numatch(par->match);
+	struct xt_action_param local_par;
+	bool ret;
+
+	local_par.in        = par->in;
+	local_par.out       = par->out;
+	local_par.match     = par->match;
+	local_par.matchinfo = par->matchinfo;
+	local_par.fragoff   = par->fragoff;
+	local_par.thoff     = par->thoff;
+	local_par.hotdrop   = false;
+	local_par.family    = par->family;
+
+	if (nm == NULL || nm->match == NULL)
+		return false;
+	ret = nm->match(skb, &local_par);
+	*par->hotdrop = local_par.hotdrop;
+	return ret;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static int xtnu_match_check(const char *table, const void *entry,
+    const struct xt_match *cm, void *matchinfo, unsigned int matchinfosize,
+    unsigned int hook_mask)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 22)
+static int xtnu_match_check(const char *table, const void *entry,
+    const struct xt_match *cm, void *matchinfo, unsigned int hook_mask)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static bool xtnu_match_check(const char *table, const void *entry,
+    const struct xt_match *cm, void *matchinfo, unsigned int hook_mask)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_match *nm = xtcompat_numatch(cm);
+	struct xt_mtchk_param local_par = {
+		.table     = table,
+		.entryinfo = entry,
+		.match     = cm,
+		.matchinfo = matchinfo,
+		.hook_mask = hook_mask,
+		.family    = NFPROTO_UNSPEC,
+	};
+
+	if (nm == NULL)
+		return false;
+	if (nm->checkentry == NULL)
+		return true;
+	return nm->checkentry(&local_par) == 0;
+}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28) && \
+    LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+static bool xtnu_match_check(const struct xt_mtchk_param *par)
+{
+	struct xtnu_match *nm = xtcompat_numatch(par->match);
+
+	if (nm == NULL)
+		return false;
+	if (nm->checkentry == NULL)
+		return true;
+	return nm->checkentry(par) == 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static void xtnu_match_destroy(const struct xt_match *cm, void *matchinfo,
+    unsigned int matchinfosize)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static void xtnu_match_destroy(const struct xt_match *cm, void *matchinfo)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_match *nm = xtcompat_numatch(cm);
+	struct xt_mtdtor_param local_par = {
+		.match     = cm,
+		.matchinfo = matchinfo,
+		.family    = NFPROTO_UNSPEC,
+	};
+
+	if (nm != NULL && nm->destroy != NULL)
+		nm->destroy(&local_par);
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+int xtnu_register_match(struct xtnu_match *nt)
+{
+	struct xt_match *ct;
+	char *tmp;
+	int ret;
+
+	ct = kzalloc(sizeof(struct xt_match), GFP_KERNEL);
+	if (ct == NULL)
+		return -ENOMEM;
+
+	tmp = (char *)ct->name;
+	memcpy(tmp, nt->name, sizeof(nt->name));
+	tmp = (char *)(ct->name + sizeof(ct->name) - sizeof(void *));
+	*(tmp-1) = '\0';
+	memcpy(tmp, &nt, sizeof(void *));
+
+	ct->revision   = nt->revision;
+	ct->family     = nt->family;
+	ct->table      = (char *)nt->table;
+	ct->hooks      = nt->hooks;
+	ct->proto      = nt->proto;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+	ct->match      = xtnu_match_run;
+	ct->checkentry = xtnu_match_check;
+	ct->destroy    = xtnu_match_destroy;
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+	ct->match      = xtnu_match_run;
+	ct->checkentry = xtnu_match_check;
+	ct->destroy    = nt->destroy;
+#else
+	ct->match      = nt->match;
+	ct->checkentry = xtnu_match_check;
+	ct->destroy    = nt->destroy;
+#endif
+	ct->matchsize  = nt->matchsize;
+	ct->me         = nt->me;
+
+	nt->__compat_match = ct;
+	ret = xt_register_match(ct);
+	if (ret != 0)
+		kfree(ct);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(xtnu_register_match);
+
+int xtnu_register_matches(struct xtnu_match *nt, unsigned int num)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < num; ++i) {
+		ret = xtnu_register_match(&nt[i]);
+		if (ret < 0) {
+			if (i > 0)
+				xtnu_unregister_matches(nt, i);
+			return ret;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xtnu_register_matches);
+
+void xtnu_unregister_match(struct xtnu_match *nt)
+{
+	xt_unregister_match(nt->__compat_match);
+	kfree(nt->__compat_match);
+}
+EXPORT_SYMBOL_GPL(xtnu_unregister_match);
+
+void xtnu_unregister_matches(struct xtnu_match *nt, unsigned int num)
+{
+	unsigned int i;
+
+	for (i = 0; i < num; ++i)
+		xtnu_unregister_match(&nt[i]);
+}
+EXPORT_SYMBOL_GPL(xtnu_unregister_matches);
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static unsigned int xtnu_target_run(struct sk_buff **pskb,
+    const struct net_device *in, const struct net_device *out,
+    unsigned int hooknum, const struct xt_target *ct, const void *targinfo,
+    void *userdata)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+static unsigned int xtnu_target_run(struct sk_buff **pskb,
+    const struct net_device *in, const struct net_device *out,
+    unsigned int hooknum, const struct xt_target *ct, const void *targinfo)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static unsigned int xtnu_target_run(struct sk_buff *skb,
+    const struct net_device *in, const struct net_device *out,
+    unsigned int hooknum, const struct xt_target *ct, const void *targinfo)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(ct);
+	struct xt_action_param local_par;
+
+	local_par.in       = in;
+	local_par.out      = out;
+	local_par.hooknum  = hooknum;
+	local_par.target   = ct;
+	local_par.targinfo = targinfo;
+	local_par.family   = NFPROTO_UNSPEC;
+
+	if (nt != NULL && nt->target != NULL)
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+		return nt->target(pskb, &local_par);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+		return nt->target(&skb, &local_par);
+#endif
+	return XT_CONTINUE;
+}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28) && \
+    LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+static unsigned int
+xtnu_target_run(struct sk_buff *skb, const struct xt_target_param *par)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(par->target);
+	struct xt_action_param local_par;
+
+	local_par.in       = par->in;
+	local_par.out      = par->out;
+	local_par.hooknum  = par->hooknum;
+	local_par.target   = par->target;
+	local_par.targinfo = par->targinfo;
+	local_par.family   = par->family;
+
+	return nt->target(&skb, &local_par);
+}
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+static unsigned int
+xtnu_target_run(struct sk_buff *skb, const struct xt_action_param *par)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(par->target);
+
+	return nt->target(&skb, par);
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static int xtnu_target_check(const char *table, const void *entry,
+    const struct xt_target *ct, void *targinfo,
+    unsigned int targinfosize, unsigned int hook_mask)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 22)
+static int xtnu_target_check(const char *table, const void *entry,
+    const struct xt_target *ct, void *targinfo, unsigned int hook_mask)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static bool xtnu_target_check(const char *table, const void *entry,
+    const struct xt_target *ct, void *targinfo, unsigned int hook_mask)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(ct);
+	struct xt_tgchk_param local_par = {
+		.table     = table,
+		.entryinfo = entry,
+		.target    = ct,
+		.targinfo  = targinfo,
+		.hook_mask = hook_mask,
+		.family    = NFPROTO_UNSPEC,
+	};
+
+	if (nt == NULL)
+		return false;
+	if (nt->checkentry == NULL)
+		/* this is valid, just like if there was no function */
+		return true;
+	return nt->checkentry(&local_par) == 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28) && \
+    LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+static bool xtnu_target_check(const struct xt_tgchk_param *par)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(par->target);
+
+	if (nt == NULL)
+		return false;
+	if (nt->checkentry == NULL)
+		return true;
+	return nt->checkentry(par) == 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+static void xtnu_target_destroy(const struct xt_target *ct, void *targinfo,
+    unsigned int targinfosize)
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+static void xtnu_target_destroy(const struct xt_target *ct, void *targinfo)
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+{
+	struct xtnu_target *nt = xtcompat_nutarget(ct);
+	struct xt_tgdtor_param local_par = {
+		.target   = ct,
+		.targinfo = targinfo,
+		.family   = NFPROTO_UNSPEC,
+	};
+
+	if (nt != NULL && nt->destroy != NULL)
+		nt->destroy(&local_par);
+}
+#endif
+
+int xtnu_register_target(struct xtnu_target *nt)
+{
+	struct xt_target *ct;
+	char *tmp;
+	int ret;
+
+	ct = kzalloc(sizeof(struct xt_target), GFP_KERNEL);
+	if (ct == NULL)
+		return -ENOMEM;
+
+	tmp = (char *)ct->name;
+	memcpy(tmp, nt->name, sizeof(nt->name));
+	tmp = (char *)(ct->name + sizeof(ct->name) - sizeof(void *));
+	*(tmp-1) = '\0';
+	memcpy(tmp, &nt, sizeof(void *));
+
+	ct->revision   = nt->revision;
+	ct->family     = nt->family;
+	ct->table      = (char *)nt->table;
+	ct->hooks      = nt->hooks;
+	ct->proto      = nt->proto;
+	ct->target     = xtnu_target_run;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+	ct->checkentry = xtnu_target_check;
+	ct->destroy    = xtnu_target_destroy;
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+	ct->checkentry = xtnu_target_check;
+	ct->destroy    = nt->destroy;
+#else
+	ct->checkentry = nt->checkentry;
+	ct->destroy    = nt->destroy;
+#endif
+	ct->targetsize = nt->targetsize;
+	ct->me         = nt->me;
+
+	nt->__compat_target = ct;
+	ret = xt_register_target(ct);
+	if (ret != 0)
+		kfree(ct);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(xtnu_register_target);
+
+int xtnu_register_targets(struct xtnu_target *nt, unsigned int num)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < num; ++i) {
+		ret = xtnu_register_target(&nt[i]);
+		if (ret < 0) {
+			if (i > 0)
+				xtnu_unregister_targets(nt, i);
+			return ret;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xtnu_register_targets);
+
+void xtnu_unregister_target(struct xtnu_target *nt)
+{
+	xt_unregister_target(nt->__compat_target);
+	kfree(nt->__compat_target);
+}
+EXPORT_SYMBOL_GPL(xtnu_unregister_target);
+
+void xtnu_unregister_targets(struct xtnu_target *nt, unsigned int num)
+{
+	unsigned int i;
+
+	for (i = 0; i < num; ++i)
+		xtnu_unregister_target(&nt[i]);
+}
+EXPORT_SYMBOL_GPL(xtnu_unregister_targets);
+
+struct xt_match *xtnu_request_find_match(unsigned int af, const char *name,
+    uint8_t revision)
+{
+	static const char *const xt_prefix[] = {
+		[AF_UNSPEC] = "x",
+		[AF_INET]   = "ip",
+		[AF_INET6]  = "ip6",
+#ifdef AF_ARP
+		[AF_ARP]    = "arp",
+#elif defined(NF_ARP) && NF_ARP != AF_UNSPEC
+		[NF_ARP]    = "arp",
+#endif
+	};
+	struct xt_match *match;
+
+	match = try_then_request_module(xt_find_match(af, name, revision),
+		"%st_%s", xt_prefix[af], name);
+	if (IS_ERR(match) || match == NULL)
+		return NULL;
+
+	return match;
+}
+EXPORT_SYMBOL_GPL(xtnu_request_find_match);
+
+int xtnu_ip_route_me_harder(struct sk_buff **pskb, unsigned int addr_type)
+{
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 17)
+	/* Actually this one is valid up to 2.6.18.4, but changed in 2.6.18.5 */
+	return ip_route_me_harder(pskb);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+	return ip_route_me_harder(pskb, addr_type);
+#else
+	return ip_route_me_harder(*pskb, addr_type);
+#endif
+}
+EXPORT_SYMBOL_GPL(xtnu_ip_route_me_harder);
+
+int xtnu_skb_make_writable(struct sk_buff **pskb, unsigned int len)
+{
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+	return skb_make_writable(pskb, len);
+#else
+	return skb_make_writable(*pskb, len);
+#endif
+}
+EXPORT_SYMBOL_GPL(xtnu_skb_make_writable);
+
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 24)
+static int __xtnu_ip_local_out(struct sk_buff *skb)
+{
+	struct iphdr *iph = ip_hdr(skb);
+
+	iph->tot_len = htons(skb->len);
+	ip_send_check(iph);
+	return nf_hook(PF_INET, NF_IP_LOCAL_OUT, skb, NULL,
+	               skb->dst->dev, dst_output);
+}
+
+int xtnu_ip_local_out(struct sk_buff *skb)
+{
+	int err;
+
+	err = __xtnu_ip_local_out(skb);
+	if (likely(err == 1))
+		err = dst_output(skb);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(xtnu_ip_local_out);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+static int __xtnu_ip_local_out(struct sk_buff **pskb)
+{
+	struct iphdr *iph = ip_hdr(*pskb);
+
+	iph->tot_len = htons((*pskb)->len);
+	ip_send_check(iph);
+	return nf_hook(PF_INET, NF_IP_LOCAL_OUT, pskb, NULL,
+	               (*pskb)->dst->dev, dst_output);
+}
+
+int xtnu_ip_local_out(struct sk_buff *skb)
+{
+	int err;
+
+	err = __xtnu_ip_local_out(&skb);
+	if (likely(err == 1))
+		err = dst_output(skb);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(xtnu_ip_local_out);
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 24)
+int xtnu_ip_route_output_key(void *net, struct rtable **rp, struct flowi *flp)
+{
+	return ip_route_output_flow(rp, flp, NULL, 0);
+}
+EXPORT_SYMBOL_GPL(xtnu_ip_route_output_key);
+
+void xtnu_proto_csum_replace4(__sum16 *sum, struct sk_buff *skb,
+    __be32 from, __be32 to, bool pseudohdr)
+{
+	__be32 diff[] = {~from, to};
+	const void *dv = diff; /* kludge for < v2.6.19-555-g72685fc */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+	if (skb->ip_summed != CHECKSUM_PARTIAL) {
+		*sum = csum_fold(csum_partial(dv, sizeof(diff),
+		       ~csum_unfold(*sum)));
+		if (skb->ip_summed == CHECKSUM_COMPLETE && pseudohdr)
+			skb->csum = ~csum_partial(dv, sizeof(diff),
+			            ~skb->csum);
+	} else if (pseudohdr) {
+		*sum = ~csum_fold(csum_partial(dv, sizeof(diff),
+		       csum_unfold(*sum)));
+	}
+#else
+	*sum = csum_fold(csum_partial(dv, sizeof(diff),
+	       ~csum_unfold(*sum)));
+#endif
+}
+EXPORT_SYMBOL_GPL(xtnu_proto_csum_replace4);
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+int xtnu_neigh_hh_output(struct hh_cache *hh, struct sk_buff *skb)
+{
+	unsigned int hh_alen;
+
+	read_lock_bh(&hh->hh_lock);
+	hh_alen = HH_DATA_ALIGN(hh->hh_len);
+	memcpy(skb->data - hh_alen, hh->hh_data, hh_alen);
+	read_unlock_bh(&hh->hh_lock);
+	skb_push(skb, hh->hh_len);
+	return hh->hh_output(skb);
+}
+EXPORT_SYMBOL_GPL(xtnu_neigh_hh_output);
+
+static inline __wsum xtnu_csum_unfold(__sum16 n)
+{
+	return (__force __wsum)n;
+}
+
+void xtnu_csum_replace4(__sum16 *sum, __be32 from, __be32 to)
+{
+	__be32 diff[] = {~from, to};
+	*sum = csum_fold(csum_partial((char *)diff, sizeof(diff),
+	       ~xtnu_csum_unfold(*sum)));
+}
+
+void xtnu_csum_replace2(__sum16 *sum, __be16 from, __be16 to)
+{
+	xtnu_csum_replace4(sum, (__force __be32)from, (__force __be32)to);
+}
+EXPORT_SYMBOL_GPL(xtnu_csum_replace2);
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 17)
+int xtnu_skb_linearize(struct sk_buff *skb)
+{
+	return skb_linearize(skb, GFP_ATOMIC);
+}
+EXPORT_SYMBOL_GPL(xtnu_skb_linearize);
+#endif
+
+void *HX_memmem(const void *space, size_t spacesize,
+    const void *point, size_t pointsize)
+{
+	size_t i;
+
+	if (pointsize > spacesize)
+		return NULL;
+	for (i = 0; i <= spacesize - pointsize; ++i)
+		if (memcmp(space + i, point, pointsize) == 0)
+			return (void *)space + i;
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(HX_memmem);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0) && defined(WITH_IPV6)
+int xtnu_ipv6_skip_exthdr(const struct sk_buff *skb, int start,
+    uint8_t *nexthdrp, __be16 *fragoffp)
+{
+	return ipv6_skip_exthdr(skb, start, nexthdrp);
+}
+EXPORT_SYMBOL_GPL(xtnu_ipv6_skip_exthdr);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0) && defined(WITH_IPV6)
+int xtnu_ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,
+    int target, unsigned short *fragoff, int *fragflg)
+{
+	return ipv6_find_hdr(skb, offset, target, fragoff);
+}
+EXPORT_SYMBOL_GPL(xtnu_ipv6_find_hdr);
+#endif
+
+MODULE_LICENSE("GPL");

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/compat_xtables.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/compat_xtables.h
@@ -0,0 +1,137 @@
+#ifndef _XTABLES_COMPAT_H
+#define _XTABLES_COMPAT_H 1
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include "compat_skbuff.h"
+#include "compat_xtnu.h"
+
+#define DEBUGP Use__pr_debug__instead
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 17)
+#	warning Kernels below 2.6.17 not supported.
+#endif
+
+#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
+#	if !defined(CONFIG_NF_CONNTRACK_MARK)
+#		warning You have CONFIG_NF_CONNTRACK enabled, but CONFIG_NF_CONNTRACK_MARK is not (please enable).
+#	endif
+#	include <net/netfilter/nf_conntrack.h>
+#elif defined(CONFIG_IP_NF_CONNTRACK) || defined(CONFIG_IP_NF_CONNTRACK_MODULE)
+#	if !defined(CONFIG_IP_NF_CONNTRACK_MARK)
+#		warning You have CONFIG_IP_NF_CONNTRACK enabled, but CONFIG_IP_NF_CONNTRACK_MARK is not (please enable).
+#	endif
+#	include <linux/netfilter_ipv4/ip_conntrack.h>
+#	define nf_conn ip_conntrack
+#	define nf_ct_get ip_conntrack_get
+#	define nf_conntrack_untracked ip_conntrack_untracked
+#else
+#	warning You need either CONFIG_NF_CONNTRACK or CONFIG_IP_NF_CONNTRACK.
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 17)
+#	define skb_init_secmark(skb)
+#	define skb_linearize	xtnu_skb_linearize
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+#	define neigh_hh_output xtnu_neigh_hh_output
+#	define IPPROTO_UDPLITE 136
+#	define CSUM_MANGLED_0 ((__force __sum16)0xffff)
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 24)
+#	define NF_INET_PRE_ROUTING  NF_IP_PRE_ROUTING
+#	define NF_INET_LOCAL_IN     NF_IP_LOCAL_IN
+#	define NF_INET_FORWARD      NF_IP_FORWARD
+#	define NF_INET_LOCAL_OUT    NF_IP_LOCAL_OUT
+#	define NF_INET_POST_ROUTING NF_IP_POST_ROUTING
+#	define ip_local_out         xtnu_ip_local_out
+#	define ip_route_output_key  xtnu_ip_route_output_key
+#	include "compat_nfinetaddr.h"
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+#	define init_net               xtnu_ip_route_output_key /* yes */
+#	define init_net__loopback_dev (&loopback_dev)
+#	define init_net__proc_net     proc_net
+#else
+#	define init_net__loopback_dev init_net.loopback_dev
+#	define init_net__proc_net     init_net.proc_net
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+#	define xt_match              xtnu_match
+#	define xt_register_match     xtnu_register_match
+#	define xt_unregister_match   xtnu_unregister_match
+#	define xt_register_matches   xtnu_register_matches
+#	define xt_unregister_matches xtnu_unregister_matches
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+#	define csum_replace2 xtnu_csum_replace2
+#	define csum_replace4 xtnu_csum_replace4
+#	define inet_proto_csum_replace4 xtnu_proto_csum_replace4
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 24)
+#	define csum_replace2 nf_csum_replace2
+#	define csum_replace4 nf_csum_replace4
+#	define inet_proto_csum_replace4 xtnu_proto_csum_replace4
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+#	define ipt_unregister_table(tbl) ipt_unregister_table(&init_net, (tbl))
+#	define ip6t_unregister_table(tbl) ip6t_unregister_table(&init_net, (tbl))
+#else
+#	define ipt_unregister_table(tbl) ipt_unregister_table(tbl)
+#	define ip6t_unregister_table(tbl) ip6t_unregister_table(tbl)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+#	define rt_dst(rt)	(&(rt)->dst)
+#else
+#	define rt_dst(rt)	(&(rt)->u.dst)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0)
+#	define nf_nat_ipv4_multi_range_compat nf_nat_multi_range_compat
+#	define nf_nat_ipv4_range nf_nat_range
+#	define NF_NAT_RANGE_MAP_IPS IP_NAT_RANGE_MAP_IPS
+#	define ipv6_skip_exthdr xtnu_ipv6_skip_exthdr
+#endif
+
+#if !defined(NIP6) && !defined(NIP6_FMT)
+#	define NIP6(addr) \
+		ntohs((addr).s6_addr16[0]), \
+		ntohs((addr).s6_addr16[1]), \
+		ntohs((addr).s6_addr16[2]), \
+		ntohs((addr).s6_addr16[3]), \
+		ntohs((addr).s6_addr16[4]), \
+		ntohs((addr).s6_addr16[5]), \
+		ntohs((addr).s6_addr16[6]), \
+		ntohs((addr).s6_addr16[7])
+#	define NIP6_FMT "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x"
+#endif
+#if !defined(NIPQUAD) && !defined(NIPQUAD_FMT)
+#	define NIPQUAD(addr) \
+		((const unsigned char *)&addr)[0], \
+		((const unsigned char *)&addr)[1], \
+		((const unsigned char *)&addr)[2], \
+		((const unsigned char *)&addr)[3]
+#	define NIPQUAD_FMT "%u.%u.%u.%u"
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
+#	define ipv6_find_hdr xtnu_ipv6_find_hdr
+#endif
+
+#define ip_route_me_harder    xtnu_ip_route_me_harder
+#define skb_make_writable     xtnu_skb_make_writable
+#define xt_target             xtnu_target
+#define xt_register_target    xtnu_register_target
+#define xt_unregister_target  xtnu_unregister_target
+#define xt_register_targets   xtnu_register_targets
+#define xt_unregister_targets xtnu_unregister_targets
+
+#define xt_request_find_match xtnu_request_find_match
+
+#endif /* _XTABLES_COMPAT_H */

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/compat_xtnu.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/compat_xtnu.h
@@ -0,0 +1,172 @@
+#ifndef _COMPAT_XTNU_H
+#define _COMPAT_XTNU_H 1
+
+#include <linux/list.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/spinlock.h>
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+typedef _Bool bool;
+enum { false = 0, true = 1, };
+#endif
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+typedef __u16 __bitwise __sum16;
+typedef __u32 __bitwise __wsum;
+#endif
+
+struct flowi;
+struct hh_cache;
+struct module;
+struct net_device;
+struct rtable;
+struct sk_buff;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+enum {
+	NFPROTO_UNSPEC =  0,
+	NFPROTO_IPV4   =  2,
+	NFPROTO_ARP    =  3,
+	NFPROTO_BRIDGE =  7,
+	NFPROTO_IPV6   = 10,
+	NFPROTO_DECNET = 12,
+	NFPROTO_NUMPROTO,
+};
+
+struct xt_mtchk_param {
+	const char *table;
+	const void *entryinfo;
+	const struct xt_match *match;
+	void *matchinfo;
+	unsigned int hook_mask;
+	u_int8_t family;
+};
+
+struct xt_mtdtor_param {
+	const struct xt_match *match;
+	void *matchinfo;
+	u_int8_t family;
+};
+
+struct xt_target_param {
+	const struct net_device *in, *out;
+	unsigned int hooknum;
+	const struct xt_target *target;
+	const void *targinfo;
+	u_int8_t family;
+};
+
+struct xt_tgchk_param {
+	const char *table;
+	const void *entryinfo;
+	const struct xt_target *target;
+	void *targinfo;
+	unsigned int hook_mask;
+	u_int8_t family;
+};
+
+struct xt_tgdtor_param {
+	const struct xt_target *target;
+	void *targinfo;
+	u_int8_t family;
+};
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+struct xt_action_param {
+	union {
+		const struct xt_match *match;
+		const struct xt_target *target;
+	};
+	union {
+		const void *matchinfo, *targinfo;
+	};
+	const struct net_device *in, *out;
+	int fragoff;
+	unsigned int thoff, hooknum;
+	u_int8_t family;
+	bool hotdrop;
+};
+#endif
+
+struct xtnu_match {
+	/*
+	 * Making it smaller by sizeof(void *) on purpose to catch
+	 * lossy translation, if any.
+	 */
+	char name[sizeof(((struct xt_match *)NULL)->name) - 1 - sizeof(void *)];
+	uint8_t revision;
+	bool (*match)(const struct sk_buff *, struct xt_action_param *);
+	int (*checkentry)(const struct xt_mtchk_param *);
+	void (*destroy)(const struct xt_mtdtor_param *);
+	struct module *me;
+	const char *table;
+	unsigned int matchsize, hooks;
+	unsigned short proto, family;
+
+	void *__compat_match;
+};
+
+struct xtnu_target {
+	char name[sizeof(((struct xt_target *)NULL)->name) - 1 - sizeof(void *)];
+	uint8_t revision;
+	unsigned int (*target)(struct sk_buff **,
+		const struct xt_action_param *);
+	int (*checkentry)(const struct xt_tgchk_param *);
+	void (*destroy)(const struct xt_tgdtor_param *);
+	struct module *me;
+	const char *table;
+	unsigned int targetsize, hooks;
+	unsigned short proto, family;
+
+	void *__compat_target;
+};
+
+static inline struct xtnu_match *xtcompat_numatch(const struct xt_match *m)
+{
+	void *q;
+	memcpy(&q, m->name + sizeof(m->name) - sizeof(void *), sizeof(void *));
+	return q;
+}
+
+static inline struct xtnu_target *xtcompat_nutarget(const struct xt_target *t)
+{
+	void *q;
+	memcpy(&q, t->name + sizeof(t->name) - sizeof(void *), sizeof(void *));
+	return q;
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 19)
+static inline __wsum csum_unfold(__sum16 n)
+{
+	return (__force __wsum)n;
+}
+#endif
+
+extern int xtnu_ip_local_out(struct sk_buff *);
+extern int xtnu_ip_route_me_harder(struct sk_buff **, unsigned int);
+extern int xtnu_skb_make_writable(struct sk_buff **, unsigned int);
+extern int xtnu_register_match(struct xtnu_match *);
+extern int xtnu_ip_route_output_key(void *, struct rtable **, struct flowi *);
+extern void xtnu_unregister_match(struct xtnu_match *);
+extern int xtnu_register_matches(struct xtnu_match *, unsigned int);
+extern void xtnu_unregister_matches(struct xtnu_match *, unsigned int);
+extern int xtnu_register_target(struct xtnu_target *);
+extern void xtnu_unregister_target(struct xtnu_target *);
+extern int xtnu_register_targets(struct xtnu_target *, unsigned int);
+extern void xtnu_unregister_targets(struct xtnu_target *, unsigned int);
+extern struct xt_match *xtnu_request_find_match(unsigned int,
+	const char *, uint8_t);
+extern int xtnu_neigh_hh_output(struct hh_cache *, struct sk_buff *);
+extern void xtnu_csum_replace2(__u16 __bitwise *, __be16, __be16);
+extern void xtnu_csum_replace4(__u16 __bitwise *, __be32, __be32);
+extern void xtnu_proto_csum_replace4(__u16 __bitwise *, struct sk_buff *,
+	__be32, __be32, bool);
+extern int xtnu_skb_linearize(struct sk_buff *);
+extern int xtnu_ipv6_skip_exthdr(const struct sk_buff *, int,
+	uint8_t *, __be16 *);
+extern int xtnu_ipv6_find_hdr(const struct sk_buff *, unsigned int *,
+	int, unsigned short *, int *);
+
+extern void *HX_memmem(const void *, size_t, const void *, size_t);
+
+#endif /* _COMPAT_XTNU_H */

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/ip6table_rawpost.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/ip6table_rawpost.c
@@ -0,0 +1,107 @@
+/*
+ *	rawpost table for ip6_tables
+ *	written by Jan Engelhardt <jengelh [at] medozas de>, 2008 - 2009
+ *	placed in the Public Domain
+ */
+#include <linux/module.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <net/ip.h>
+#include "compat_xtables.h"
+#include "compat_rawpost.h"
+
+enum {
+	RAWPOST_VALID_HOOKS = 1 << NF_INET_POST_ROUTING,
+};
+
+static struct {
+	struct ip6t_replace repl;
+	struct ip6t_standard entries[1];
+	struct ip6t_error term;
+} rawpost6_initial __initdata = {
+	.repl = {
+		.name        = "rawpost",
+		.valid_hooks = RAWPOST_VALID_HOOKS,
+		.num_entries = 2,
+		.size        = sizeof(struct ip6t_standard) +
+		               sizeof(struct ip6t_error),
+		.hook_entry  = {
+			[NF_INET_POST_ROUTING] = 0,
+		},
+		.underflow = {
+			[NF_INET_POST_ROUTING] = 0,
+		},
+	},
+	.entries = {
+		IP6T_STANDARD_INIT(NF_ACCEPT),	/* POST_ROUTING */
+	},
+	.term = IP6T_ERROR_INIT,		/* ERROR */
+};
+
+static struct xt_table *rawpost6_ptable;
+
+static struct xt_table rawpost6_itable = {
+	.name        = "rawpost",
+	.af          = NFPROTO_IPV6,
+	.valid_hooks = RAWPOST_VALID_HOOKS,
+	.me          = THIS_MODULE,
+};
+
+static unsigned int rawpost6_hook_fn(unsigned int hook, sk_buff_t *skb,
+    const struct net_device *in, const struct net_device *out,
+    int (*okfn)(struct sk_buff *))
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+	return ip6t_do_table(skb, hook, in, out, rawpost6_ptable);
+#else
+	return ip6t_do_table(skb, hook, in, out, rawpost6_ptable, NULL);
+#endif
+}
+
+static struct nf_hook_ops rawpost6_hook_ops __read_mostly = {
+	.hook     = rawpost6_hook_fn,
+	.pf       = NFPROTO_IPV6,
+	.hooknum  = NF_INET_POST_ROUTING,
+	.priority = NF_IP6_PRI_LAST,
+	.owner    = THIS_MODULE,
+};
+
+static int __init rawpost6_table_init(void)
+{
+	int ret;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 29)
+	rwlock_init(&rawpost6_itable.lock);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	rawpost6_ptable = ip6t_register_table(&init_net, &rawpost6_itable,
+	                  &rawpost6_initial.repl);
+	if (IS_ERR(rawpost6_ptable))
+		return PTR_ERR(rawpost6_ptable);
+#else
+	ret = ip6t_register_table(&rawpost6_itable, &rawpost6_initial.repl);
+	if (ret < 0)
+		return ret;
+	rawpost6_ptable = &rawpost6_itable;
+#endif
+
+	ret = nf_register_hook(&rawpost6_hook_ops);
+	if (ret < 0)
+		goto out;
+
+	return ret;
+
+ out:
+	ip6t_unregister_table(rawpost6_ptable);
+	return ret;
+}
+
+static void __exit rawpost6_table_exit(void)
+{
+	nf_unregister_hook(&rawpost6_hook_ops);
+	ip6t_unregister_table(rawpost6_ptable);
+}
+
+module_init(rawpost6_table_init);
+module_exit(rawpost6_table_exit);
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/iptable_rawpost.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/iptable_rawpost.c
@@ -0,0 +1,109 @@
+/*
+ *	rawpost table for ip_tables
+ *	written by Jan Engelhardt <jengelh [at] medozas de>, 2008 - 2009
+ *	placed in the Public Domain
+ */
+#include <linux/module.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/version.h>
+#include <net/ip.h>
+#include "compat_xtables.h"
+#include "compat_rawpost.h"
+
+enum {
+	RAWPOST_VALID_HOOKS = 1 << NF_INET_POST_ROUTING,
+};
+
+static struct {
+	struct ipt_replace repl;
+	struct ipt_standard entries[1];
+	struct ipt_error term;
+} rawpost4_initial __initdata = {
+	.repl = {
+		.name        = "rawpost",
+		.valid_hooks = RAWPOST_VALID_HOOKS,
+		.num_entries = 2,
+		.size        = sizeof(struct ipt_standard) +
+		               sizeof(struct ipt_error),
+		.hook_entry  = {
+			[NF_INET_POST_ROUTING] = 0,
+		},
+		.underflow = {
+			[NF_INET_POST_ROUTING] = 0,
+		},
+	},
+	.entries = {
+		IPT_STANDARD_INIT(NF_ACCEPT),	/* POST_ROUTING */
+	},
+	.term = IPT_ERROR_INIT,			/* ERROR */
+};
+
+static struct xt_table *rawpost4_ptable;
+
+static struct xt_table rawpost4_itable = {
+	.name        = "rawpost",
+	.af          = NFPROTO_IPV4,
+	.valid_hooks = RAWPOST_VALID_HOOKS,
+	.me          = THIS_MODULE,
+};
+
+static unsigned int rawpost4_hook_fn(unsigned int hook, sk_buff_t *skb,
+    const struct net_device *in, const struct net_device *out,
+    int (*okfn)(struct sk_buff *))
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+	return ipt_do_table(skb, hook, in, out, rawpost4_ptable);
+#else
+	return ipt_do_table(skb, hook, in, out, rawpost4_ptable, NULL);
+#endif
+}
+
+static struct nf_hook_ops rawpost4_hook_ops __read_mostly = {
+	.hook     = rawpost4_hook_fn,
+	.pf       = NFPROTO_IPV4,
+	.hooknum  = NF_INET_POST_ROUTING,
+	.priority = NF_IP_PRI_LAST,
+	.owner    = THIS_MODULE,
+};
+
+static int __init rawpost4_table_init(void)
+{
+	int ret;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 29)
+	rwlock_init(&rawpost4_itable.lock);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	rawpost4_ptable = ipt_register_table(&init_net, &rawpost4_itable,
+	                  &rawpost4_initial.repl);
+	if (IS_ERR(rawpost4_ptable))
+		return PTR_ERR(rawpost4_ptable);
+#else
+	ret = ipt_register_table(&rawpost4_itable, &rawpost4_initial.repl);
+	if (ret < 0)
+		return ret;
+	rawpost4_ptable = &rawpost4_itable;
+#endif
+
+	ret = nf_register_hook(&rawpost4_hook_ops);
+	if (ret < 0)
+		goto out;
+
+	return ret;
+
+ out:
+	ipt_unregister_table(rawpost4_ptable);
+	return ret;
+}
+
+static void __exit rawpost4_table_exit(void)
+{
+	nf_unregister_hook(&rawpost4_hook_ops);
+	ipt_unregister_table(rawpost4_ptable);
+}
+
+module_init(rawpost4_table_init);
+module_exit(rawpost4_table_exit);
+MODULE_DESCRIPTION("Xtables: rawpost table for use with RAWNAT");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/Kconfig
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/Kconfig
@@ -589,6 +589,203 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_TARGET_ACCOUNT
+	tristate '"ACCOUNT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The ACCOUNT target is a high performance accounting system for large
+	  local networks. It allows per-IP accounting in whole prefixes of IPv4
+	  addresses with size of up to /8 without the need to add individual
+	  accouting rule for each IP address.
+
+	  The ACCOUNT is designed to be queried for data every second or at
+	  least every ten seconds. It is written as kernel module to handle high
+	  bandwidths without packet loss.
+
+	  The largest possible subnet size is 24 bit, meaning for example 10.0.0.0/8
+	  network. ACCOUNT uses fixed internal data structures
+	  which speeds up the processing of each packet. Furthermore,
+	  accounting data for one complete 192.168.1.X/24 network takes 4 KB of
+	  memory. Memory for 16 or 24 bit networks is only allocated when
+	  needed.
+
+	  To optimize the kernel<->userspace data transfer a bit more, the
+	  kernel module only transfers information about IPs, where the src/dst
+	  packet counter is not 0. This saves precious kernel time.
+
+	  There is no /proc interface as it would be too slow for continuous access.
+	  The read-and-flush query operation is the fastest, as no internal data
+	  snapshot needs to be created&copied for all data. Use the "read"
+	  operation without flush only for debugging purposes!
+
+	  Usage:
+
+	  ACCOUNT takes two mandatory parameters:
+
+	  --addr network/netmask
+	  where network/netmask is the subnet to account for, in CIDR syntax
+
+	  --tname NAME
+	  where NAME is the name of the table where the accounting information
+	  should be stored
+
+	  The subnet 0.0.0.0/0 is a special case: all data are then stored in the src_bytes
+	  and src_packets structure of slot "0". This is useful if you want
+	  to account the overall traffic to/from your internet provider.
+
+	  The data can be queried using the userspace libxt_ACCOUNT_cl library,
+	  and by the reference implementation to show usage of this library,
+	  the iptaccount(8) tool.
+
+	  Here is an example of use:
+
+	  iptables -A FORWARD -j ACCOUNT --addr 0.0.0.0/0 --tname all_outgoing;
+	  iptables -A FORWARD -j ACCOUNT --addr 192.168.1.0/24 --tname sales;
+
+	  This creates two tables called "all_outgoing" and "sales" which can be
+	  queried using the userspace library/iptaccount tool.
+
+	  Note that this target is non-terminating, the packet destined to it
+	  will continue traversing the chain in which it has been used.
+
+	  Also note that once a table has been defined for specific CIDR address/netmask
+	  block, it can be referenced multiple times using -j ACCOUNT, provided
+	  that both the original table name and address/netmask block are specified.
+
+	  For more information go to http://www.intra2net.com/en/developer/ipt_ACCOUNT/
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_TARGET_CHAOS
+	tristate '"CHAOS" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Causes confusion on the other end by doing odd things with incoming packets.
+	  CHAOS will randomly reply (or not) with one of its configurable subtargets:
+
+	  --delude
+	  Use the REJECT and DELUDE targets as a base to do a sudden or deferred
+	  connection reset, fooling some network scanners to return non-deterministic
+	  (randomly open/closed) results, and in case it is deemed open, it is actually
+	  closed/filtered.
+
+	  --tarpit
+	  Use the REJECT and TARPIT target as a base to hold the connection until it
+	  times out. This consumes conntrack entries when connection tracking is loaded
+	  (which usually is on most machines), and routers inbetween you and the Internet
+	  may fail to do their connection tracking if they have to handle more
+	  connections than they can.
+
+	  The randomness factor of not replying vs. replying can be set during load-time
+	  of the xt_CHAOS module or during runtime in /sys/modules/xt_CHAOS/parameters.
+
+	  See http://jengelh.medozas.de/projects/chaostables/ for more information
+	  about CHAOS, DELUDE and lscan.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_TARGET_DELUDE
+	tristate '"DELUDE" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The DELUDE target will reply to a SYN packet with SYN-ACK, and to all other
+	  packets with an RST. This will terminate the connection much like REJECT, but
+	  network scanners doing TCP half-open discovery can be spoofed to make them
+	  belive the port is open rather than closed/filtered.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_ECHO
+	tristate '"ECHO" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The ECHO target will send back all packets it received. It serves as an
+	  examples for an Xtables target.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_RAWNAT
+	tristate '"RAWNAT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The RAWSNAT and RAWDNAT targets provide stateless network address
+	  translation.
+
+	  The RAWDNAT target will rewrite the destination address in the IP header,
+	  much like the NETMAP target.
+
+	  --to-destination addr[/mask]
+	  Network address to map to. The resulting address will be constructed the
+	  following way: All 'one' bits in the mask are filled in from the new
+	  address. All bits that are zero in the mask are filled in from the
+	  original address.
+
+	  The RAWSNAT target will rewrite the source address in the IP header, much
+	  like the NETMAP target. RAWSNAT (and RAWDNAT) may only be
+	  used in the raw or rawpost tables, but can be used in all chains,
+	  which makes it possible to change the source address either when the packet
+	  enters the machine or when it leaves it. The reason for this table constraint
+	  is that RAWNAT must happen outside of connection tracking.
+
+	  --to-source addr[/mask]
+	  Network address to map to. The resulting address will be constructed the
+	  following way: All 'one' bits in the mask are filled in from the new
+	  address. All bits that are zero in the mask are filled in from the
+	  original address.
+
+	  As an example, changing the destination for packets forwarded from an internal
+	  LAN to the internet:
+
+	  -t raw -A PREROUTING -i lan0 -d 212.201.100.135 -j RAWDNAT --to-destination 199.181.132.250;
+	  -t rawpost -A POSTROUTING -o lan0 -s 199.181.132.250 -j RAWSNAT --to-source 212.201.100.135;
+
+	  Note that changing addresses may influence the route selection! Specifically,
+	  it statically NATs packets, not connections, like the normal DNAT/SNAT targets
+	  would do. Also note that it can transform already-NATed connections, as
+	  said, it is completely external to Netfilter's connection tracking/NAT.
+
+	  If the machine itself generates packets that are to be rawnat'ed, you need a
+	  rule in the OUTPUT chain instead, just like you would with the stateful NAT
+	  targets.
+
+	  It may be necessary that in doing so, you also need an extra RAWSNAT rule, to
+	  override the automatic source address selection that the routing code does
+	  before passing packets to iptables. If the connecting socket has not been
+	  explicitly bound to an address, as is the common mode of operation, the address
+	  that will be chosen is the primary address of the device through which the
+	  packet would be routed with its initial destination address - the address as
+	  seen before any RAWNAT takes place.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_TARGET_STEAL
+	tristate '"STEAL" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Like the DROP target, but does not throw an error like DROP when used in the
+	  OUTPUT chain.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+	  
+config NETFILTER_XT_TARGET_TARPIT
+	tristate '"TARPIT" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Adds a TARPIT target to iptables, which captures and holds
+	  incoming TCP connections using no local per-connection resources.
+	  Connections are accepted, but immediately switched to the persist
+	  state (0 byte window), in which the remote side stops sending data
+	  and asks to continue every 60-240 seconds. Attempts to close the
+	  connection are ignored, forcing the remote side to time out the
+	  connection in 12-24 minutes.
+
+	  This offers similar functionality to LaBrea
+	  <http://www.hackbusters.net/LaBrea/>, but does not require dedicated
+	  hardware or IPs. Any TCP port that you would normally DROP or REJECT
+	  can instead become a tarpit.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+	  
 config NETFILTER_XT_TARGET_TCPMSS
 	tristate '"TCPMSS" target support'
 	depends on (IPV6 || IPV6=n)
@@ -1115,6 +1312,350 @@
           <file:Documentation/modules.txt>.  The module will be
           called `ipt_geoip'.  If unsure, say `N'.
 
+config NETFILTER_XT_MATCH_FUZZY
+	tristate '"MATCH" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  This module matches a rate limit based on a fuzzy logic controller (FLC).
+
+	  --lower-limit number
+	  Specifies the lower limit, in packets per second.
+
+	  --upper-limit number
+	  Specifies the upper limit, also in packets per second.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_IFACE
+	tristate '"IFACE" target support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Allows you to check interface states. First, an interface needs to be selected
+	  for comparison. Exactly one option of the following three must be specified:
+
+	  --iface name
+	  Check the states on the given interface.
+
+	  --dev-in
+	  Check the states on the interface on which the packet came in. If the input
+	  device is not set, because for example you are using -m iface in the OUTPUT
+	  chain, this submatch returns false.
+
+	  --dev-out
+	  Check the states on the interface on which the packet will go out. If the
+	  output device is not set, because for example you are using -m iface in the
+	  INPUT chain, this submatch returns false.
+
+	  Following that, one can select the interface properties to check for:
+
+	  [!] --up, [!] --down
+	  Check the UP flag.
+
+	  [!] --broadcast
+	  Check the BROADCAST flag.
+
+	  [!] --loopback
+	  Check the LOOPBACK flag.
+
+	  [!] --pointtopoint
+	  Check the POINTTOPOINT flag.
+
+	  [!] --running
+	  Check the RUNNING flag. Do NOT rely on it!
+
+	  [!] --noarp, [!] --arp
+	  Check the NOARP flag.
+
+	  [!] --promisc
+	  Check the PROMISC flag.
+
+	  [!] --multicast
+	  Check the MULTICAST flag.
+
+	  [!] --dynamic
+	  Check the DYNAMIC flag.
+
+	  [!] --lower-up
+	  Check the LOWER_UP flag.
+
+	  [!] --dormant
+	  Check the DORMANT flag.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_IPV4OPTIONS
+	tristate '"IPV4OPTIONS" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The "ipv4options" module allows to match against a set of IPv4 header options.
+
+	  --flags [!]symbol[,[!]symbol...]
+	  Specify the options that shall appear or not appear in the header. Each
+	  symbol specification is delimited by a comma, and a '!' can be prefixed to
+	  a symbol to negate its presence. Symbols are either the name of an IPv4 option
+	  or its number. See examples below.
+
+	  --any
+	  By default, all of the flags specified must be present/absent, that is, they
+	  form an AND condition. Use the --any flag instead to use an OR condition
+	  where only at least one symbol spec must be true.
+
+	  Known symbol names (and their number):
+
+	  1 nop
+	  2 security RFC 1108
+	  3 lsrr Loose Source Routing, RFC 791
+	  4 timestamp RFC 781, 791
+	  7 record-route RFC 791
+	  9 ssrr Strict Source Routing, RFC 791
+	  11 mtu-probe RFC 1063
+	  12 mtu-reply RFC 1063
+	  18 traceroute RFC 1393
+	  20 router-alert RFC 2113
+
+	  Examples:
+
+	  Match packets that have both Timestamp and NOP:
+	  -m ipv4options --flags nop,timestamp
+
+	  ~ that have either of Timestamp or NOP, or both:
+	  --flags nop,timestamp --any
+
+	  ~ that have Timestamp and no NOP: --flags '!nop,timestamp'
+
+	  ~ that have either no NOP or a timestamp (or both conditions):
+	  --flags '!nop,timestamp' --any
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_LSCAN
+	tristate '"LSCAN" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Detects simple low-level scan attemps based upon the packet's contents.
+	  (This is different from other implementations, which also try to match the rate of new
+	  connections.) Note that an attempt is only discovered after it has been carried
+	  out, but this information can be used in conjunction with other rules to block
+	  the remote host's future connections. So this match module will match on the
+	  (probably) last packet the remote side will send to your machine.
+
+	  --stealth
+	  Match if the packet did not belong to any known TCP connection
+	  (Stealth/FIN/XMAS/NULL scan).
+
+	  --synscan
+	  Match if the connection was a TCP half-open discovery (SYN scan), i.e. the
+	  connection was torn down after the 2nd packet in the 3-way handshake.
+
+	  --cnscan
+	  Match if the connection was a TCP full open discovery (connect scan), i.e. the
+	  connection was torn down after completion of the 3-way handshake.
+
+	  --grscan
+	  Match if data in the connection only flew in the direction of the remote side,
+	  e.g. if the connection was terminated after a locally running daemon sent its
+	  identification. (E.g. openssh, smtp, ftpd.) This may falsely trigger on
+	  warranted single-direction data flows, usually bulk data transfers such as
+	  FTP DATA connections or IRC DCC. Grab Scan Detection should only be used on
+	  ports where a protocol runs that is guaranteed to do a bidirectional exchange
+	  of bytes.
+
+	  NOTE: Some clients (Windows XP for example) may do what looks like a SYN scan,
+	  so be advised to carefully use xt_lscan in conjunction with blocking rules,
+	  as it may lock out your very own internal network.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+	  
+config NETFILTER_XT_MATCH_PKNOCK
+	tristate '"PKNOCK" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Pknock match implements so-called "port knocking", a stealthy system
+	  for network authentication: a client sends packets to selected
+	  ports in a specific sequence (= simple mode, see example 1 below), or a HMAC
+	  payload to a single port (= complex mode, see example 2 below),
+	  to a target machine that has pknock rule(s) installed. The target machine
+	  then decides whether to unblock or block (again) the pknock-protected port(s).
+	  This can be used, for instance, to avoid brute force
+	  attacks on ssh or ftp services.
+
+	  Example prerequisites:
+
+	  modprobe cn
+
+	  modprobe xt_pknock
+
+	  Example 1 (TCP mode, manual closing of opened port not possible):
+
+	  iptables -P INPUT DROP
+
+	  iptables -A INPUT -p tcp -m pknock --knockports 4002,4001,4004 --strict
+	  --name SSH --time 10 --autoclose 60 --dport 22 -j ACCEPT
+
+	  The rule will allow tcp port 22 for the attempting IP address after the successful reception of TCP SYN packets
+	  to ports 4002, 4001 and 4004, in this order (a.k.a. port-knocking).
+	  Port numbers in the connect sequence must follow the exact specification, no
+	  other ports may be "knocked" inbetween. The rule is named 'SSH', a file of
+	  the same name for tracking port knocking states will be created in
+	  /proc/net/xt_pknock .
+	  Successive port knocks must occur with delay of at most 10 seconds. Port 22 (from the example) will
+	  be automatiaclly dropped after 60 minutes after it was previously allowed.
+
+	  Example 2 (UDP mode, non-replayable and non-spoofable, manual closing
+	  of opened port possible, secure, also called "SPA" = Secure Port
+	  Authorization):
+
+	  iptables -A INPUT -p udp -m pknock --knockports 4000 --name FTP
+	  --opensecret foo --closesecret bar --autoclose 240 -j DROP
+
+	  iptables -A INPUT -p tcp -m pknock --checkip --name FTP --dport 21 -j ACCEPT
+
+	  The first rule will create an "ALLOWED" record in /proc/net/xt_pknock/FTP after
+	  the successful reception of an UDP packet to port 4000. The packet payload must be
+	  constructed as a HMAC256 using "foo" as a key. The HMAC content is the particular 
+	  client's IP address as a 32-bit network byteorder quantity,
+	  plus the number of minutes since the Unix epoch, also as a 32-bit value.
+	  (This is known as Simple Packet Authorization, also called "SPA".)
+	  In such case, any subsequent attempt to connect to port 21 from the client's IP
+	  address will cause such packets to be accepted in the second rule.
+
+	  Similarly, upon reception of an UDP packet constructed the same way, but with
+	  the key "bar", the first rule will remove a previously installed "ALLOWED" state
+	  record from /proc/net/xt_pknock/FTP, which means that the second rule will
+	  stop matching for subsequent connection attempts to port 21.
+	  In case no close-secret packet is received within 4 hours, the first rule
+	  will remove "ALLOWED" record from /proc/net/xt_pknock/FTP itself.
+
+	  Things worth noting:
+
+	  General:
+
+	  Specifying --autoclose 0 means that no automatic close will be performed at all.
+
+	  xt_pknock is capable of sending information about successful matches
+	  via a netlink socket to userspace, should you need to implement your own
+	  way of receiving and handling portknock notifications.
+	  Be sure to read the documentation in the doc/pknock/ directory,
+	  or visit the original site, http://portknocko.berlios.de/ .
+
+	  TCP mode:
+
+	  This mode is not immune against eavesdropping, spoofing and
+	  replaying of the port knock sequence by someone else (but its use may still
+	  be sufficient for scenarios where these factors are not necessarily
+	  this important, such as bare shielding of the SSH port from brute-force attacks).
+	  However, if you need these features, you should use UDP mode.
+
+	  It is always wise to specify three or more ports that are not monotonically
+	  increasing or decreasing with a small stepsize (e.g. 1024,1025,1026)
+	  to avoid accidentally triggering
+	  the rule by a portscan.
+
+	  Specifying the inter-knock timeout with --time is mandatory in TCP mode,
+	  to avoid permanent denial of services by clogging up the peer knock-state tracking table
+	  that xt_pknock internally keeps, should there be a DDoS on the
+	  first-in-row knock port from more hostile IP addresses than what the actual size
+	  of this table is (defaults to 16, can be changed via the "peer_hasht_ents" module parameter).
+	  It is also wise to use as short a time as possible (1 second) for --time
+	  for this very reason. You may also consider increasing the size
+	  of the peer knock-state tracking table. Using --strict also helps,
+	  as it requires the knock sequence to be exact. This means that if the
+	  hostile client sends more knocks to the same port, xt_pknock will
+	  mark such attempt as failed knock sequence and will forget it immediately.
+	  To completely thwart this kind of DDoS, knock-ports would need to have
+	  an additional rate-limit protection. Or you may consider using UDP mode.
+
+	  UDP mode:
+
+	  This mode is immune against eavesdropping, replaying and spoofing attacks.
+	  It is also immune against DDoS attack on the knockport.
+
+	  For this mode to work, the clock difference on the client and on the server
+	  must be below 1 minute. Synchronizing time on both ends by means
+	  of NTP or rdate is strongly suggested.
+
+	  There is a rate limiter built into xt_pknock which blocks any subsequent
+	  open attempt in UDP mode should the request arrive within less than one
+	  minute since the first successful open. This is intentional;
+	  it thwarts eventual spoofing attacks.
+
+	  Because the payload value of an UDP knock packet is influenced by client's IP address,
+	  UDP mode cannot be used across NAT.
+
+	  For sending UDP "SPA" packets, you may use either knock.sh or
+	  knock-orig.sh. These may be found in doc/pknock/util.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_PSD
+	tristate '"PSD" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  Attempt to detect TCP and UDP port scans. This match was derived from
+	  Solar Designer's scanlogd.
+
+	  --psd-weight-threshold threshold
+	  Total weight of the latest TCP/UDP packets with different
+	  destination ports coming from the same host to be treated as port
+	  scan sequence.
+
+	  --psd-delay-threshold delay
+	  Delay (in hundredths of second) for the packets with different
+	  destination ports coming from the same host to be treated as
+	  possible port scan subsequence.
+
+	  --psd-lo-ports-weight weight
+	  Weight of the packet with privileged (<=1024) destination port.
+
+	  --psd-hi-ports-weight weight
+	  Weight of the packet with non-priviliged destination port.
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
+config NETFILTER_XT_MATCH_QUOTA2
+	tristate '"QUOTA2" match support'
+	depends on NETFILTER_XTABLES
+	---help---
+	  The "quota2" implements a named counter which can be increased or decreased
+	  on a per-match basis. Available modes are packet counting or byte counting.
+	  The value of the counter can be read and reset through procfs, thereby making
+	  this match a minimalist accounting tool.
+
+	  When counting down from the initial quota, the counter will stop at 0 and
+	  the match will return false, just like the original "quota" match. In growing
+	  (upcounting) mode, it will always return true.
+
+	  --grow
+	  Count upwards instead of downwards.
+
+	  --no-change
+	  Makes it so the counter or quota amount is never changed by packets matching
+	  this rule. This is only really useful in "quota" mode, as it will allow you to
+	  use complex prerouting rules in association with the quota system, without
+	  counting a packet twice.
+
+	  --name name
+	  Assign the counter a specific name. This option must be present, as an empty
+	  name is not allowed. Names starting with a dot or names containing a slash are
+	  prohibited.
+
+	  [!] --quota iq
+	  Specify the initial quota for this counter. If the counter already exists,
+	  it is not reset. An "!" may be used to invert the result of the match. The
+	  negation has no effect when --grow is used.
+
+	  --packets
+	  Count packets instead of bytes that passed the quota2 match.
+
+	  Because counters in quota2 can be shared, you can combine them for various
+	  purposes, for example, a bytebucket filter that only lets as much traffic go
+	  out as has come in:
+
+	  -A INPUT -p tcp --dport 6881 -m quota --name bt --grow;
+	  -A OUTPUT -p tcp --sport 6881 -m quota --name bt;
+
+	  To compile it as a module, choose M here.  If unsure, say N.  
+
 endif # NETFILTER_XTABLES
 
 endmenu

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/Makefile
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/Makefile
@@ -40,6 +40,7 @@
 
 # generic X tables 
 obj-$(CONFIG_NETFILTER_XTABLES) += x_tables.o xt_tcpudp.o
+obj-y += compat_xtables.o
 
 # combos
 obj-$(CONFIG_NETFILTER_XT_MARK) += xt_mark.o
@@ -61,6 +62,14 @@
 obj-$(CONFIG_NETFILTER_XT_TARGET_RATEEST) += xt_RATEEST.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_SECMARK) += xt_SECMARK.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TPROXY) += xt_TPROXY.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_CHAOS) += xt_CHAOS.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_DELUDE) += xt_DELUDE.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_RAWNAT) += xt_RAWNAT.o iptable_rawpost.o
+ifneq (${CONFIG_IP6_NF_IPTABLES},)
+obj-${CONFIG_NETFILTER_XT_TARGET_RAWNAT} += ip6table_rawpost.o
+endif
+obj-$(CONFIG_NETFILTER_XT_TARGET_STEAL) += xt_STEAL.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_TARPIT) += xt_TARPIT.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TCPMSS) += xt_TCPMSS.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP) += xt_TCPOPTSTRIP.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TEE) += xt_TEE.o
@@ -109,6 +118,13 @@
 obj-$(CONFIG_NETFILTER_XT_MATCH_CONDITION) += xt_condition.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_GEOIP) += xt_geoip.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_ETHPORT) += xt_ethport.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_FUZZY) += xt_fuzzy.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_IFACE) += xt_iface.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_IPV4OPTIONS) += xt_ipv4options.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_LSCAN) += xt_lscan.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PKNOCK) += xt_pknock.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PSD) += xt_psd.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_QUOTA2) += xt_quota2.o
 
 # ipset
 obj-$(CONFIG_IP_SET) += ipset/

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_CHAOS.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_CHAOS.c
@@ -0,0 +1,279 @@
+/*
+ *	"CHAOS" target extension for Xtables
+ *	Copyright © Jan Engelhardt <jengelh [at] medozas de>, 2006 - 2008
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <linux/icmp.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/version.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_tcpudp.h>
+#include <linux/netfilter_ipv4/ipt_REJECT.h>
+#include <net/ip.h>
+#include "xt_CHAOS.h"
+static struct xt_match *xm_tcp;
+static struct xt_target *xt_delude, *xt_reject, *xt_tarpit;
+#include "compat_xtables.h"
+#define PFX KBUILD_MODNAME ": "
+
+/* Module parameters */
+static unsigned int reject_percentage = ~0U * .01;
+static unsigned int delude_percentage = ~0U * .0101;
+module_param(reject_percentage, uint, S_IRUGO | S_IWUSR);
+module_param(delude_percentage, uint, S_IRUGO | S_IWUSR);
+
+/* References to other matches/targets */
+
+static int have_delude, have_tarpit;
+
+/* Static data for other matches/targets */
+static const struct ipt_reject_info reject_params = {
+	.with = ICMP_HOST_UNREACH,
+};
+
+static const struct xt_tcp tcp_params = {
+	.spts = {0, ~0},
+	.dpts = {0, ~0},
+};
+
+/* CHAOS functions */
+static void
+xt_chaos_total(struct sk_buff *skb, const struct xt_action_param *par)
+{
+	const struct xt_chaos_tginfo *info = par->targinfo;
+	const struct iphdr *iph = ip_hdr(skb);
+	const int thoff         = 4 * iph->ihl;
+	const int fragoff       = ntohs(iph->frag_off) & IP_OFFSET;
+	typeof(xt_tarpit) destiny;
+	bool ret;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 22)
+	int hotdrop = false;
+#else
+	bool hotdrop = false;
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+	ret = xm_tcp->match(skb, par->in, par->out, xm_tcp, &tcp_params,
+	                    fragoff, thoff, &hotdrop);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+	{
+		struct xt_match_param local_par = {
+			.in        = par->in,
+			.out       = par->out,
+			.match     = xm_tcp,
+			.matchinfo = &tcp_params,
+			.fragoff   = fragoff,
+			.thoff     = thoff,
+			.hotdrop   = &hotdrop,
+		};
+		ret = xm_tcp->match(skb, &local_par);
+	}
+#else
+	{
+		struct xt_action_param local_par;
+		local_par.in        = par->in,
+		local_par.out       = par->out,
+		local_par.match     = xm_tcp;
+		local_par.matchinfo = &tcp_params;
+		local_par.fragoff   = fragoff;
+		local_par.thoff     = thoff;
+		local_par.hotdrop   = false;
+		ret = xm_tcp->match(skb, &local_par);
+		hotdrop = local_par.hotdrop;
+	}
+#endif
+	if (!ret || hotdrop || (unsigned int)net_random() > delude_percentage)
+		return;
+
+	destiny = (info->variant == XTCHAOS_TARPIT) ? xt_tarpit : xt_delude;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+	destiny->target(&skb, par->in, par->out, par->hooknum, destiny, NULL, NULL);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+	destiny->target(&skb, par->in, par->out, par->hooknum, destiny, NULL);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+	destiny->target(skb, par->in, par->out, par->hooknum, destiny, NULL);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+	{
+		struct xt_target_param local_par = {
+			.in       = par->in,
+			.out      = par->out,
+			.hooknum  = par->hooknum,
+			.target   = destiny,
+			.targinfo = par->targinfo,
+			.family   = par->family,
+		};
+		destiny->target(skb, &local_par);
+	}
+#else
+	{
+		struct xt_action_param local_par;
+		local_par.in       = par->in;
+		local_par.out      = par->out;
+		local_par.hooknum  = par->hooknum;
+		local_par.target   = destiny;
+		local_par.targinfo = par->targinfo;
+		local_par.family   = par->family;
+		destiny->target(skb, &local_par);
+	}
+#endif
+}
+
+static unsigned int
+chaos_tg(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	/*
+	 * Equivalent to:
+	 * -A chaos -m statistic --mode random --probability \
+	 *         $reject_percentage -j REJECT --reject-with host-unreach;
+	 * -A chaos -p tcp -m statistic --mode random --probability \
+	 *         $delude_percentage -j DELUDE;
+	 * -A chaos -j DROP;
+	 */
+	const struct xt_chaos_tginfo *info = par->targinfo;
+	struct sk_buff *skb = *pskb;
+	const struct iphdr *iph = ip_hdr(skb);
+
+	if ((unsigned int)net_random() <= reject_percentage) {
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18)
+		return xt_reject->target(pskb, par->in, par->out, par->hooknum,
+		       xt_reject, &reject_params, NULL);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 23)
+		return xt_reject->target(pskb, par->in, par->out, par->hooknum,
+		       xt_reject, &reject_params);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 27)
+		return xt_reject->target(skb, par->in, par->out, par->hooknum,
+		       xt_reject, &reject_params);
+#elif LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34)
+		struct xt_target_param local_par = {
+			.in       = par->in,
+			.out      = par->out,
+			.hooknum  = par->hooknum,
+			.target   = xt_reject,
+			.targinfo = &reject_params,
+		};
+		return xt_reject->target(skb, &local_par);
+#else
+		struct xt_action_param local_par;
+		local_par.in       = par->in;
+		local_par.out      = par->out;
+		local_par.hooknum  = par->hooknum;
+		local_par.target   = xt_reject;
+		local_par.targinfo = &reject_params;
+		return xt_reject->target(skb, &local_par);
+#endif
+	}
+
+	/* TARPIT/DELUDE may not be called from the OUTPUT chain */
+	if (iph->protocol == IPPROTO_TCP &&
+	    info->variant != XTCHAOS_NORMAL &&
+	    par->hooknum != NF_INET_LOCAL_OUT)
+		xt_chaos_total(skb, par);
+
+	return NF_DROP;
+}
+
+static int chaos_tg_check(const struct xt_tgchk_param *par)
+{
+	const struct xt_chaos_tginfo *info = par->targinfo;
+
+	if (info->variant == XTCHAOS_DELUDE && !have_delude) {
+		printk(KERN_WARNING PFX "Error: Cannot use --delude when "
+		       "DELUDE module not available\n");
+		return -EINVAL;
+	}
+	if (info->variant == XTCHAOS_TARPIT && !have_tarpit) {
+		printk(KERN_WARNING PFX "Error: Cannot use --tarpit when "
+		       "TARPIT module not available\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct xt_target chaos_tg_reg = {
+	.name       = "CHAOS",
+	.revision   = 0,
+	.family     = NFPROTO_IPV4,
+	.table      = "filter",
+	.hooks      = (1 << NF_INET_LOCAL_IN) | (1 << NF_INET_FORWARD) |
+	              (1 << NF_INET_LOCAL_OUT),
+	.target     = chaos_tg,
+	.checkentry = chaos_tg_check,
+	.targetsize = sizeof(struct xt_chaos_tginfo),
+	.me         = THIS_MODULE,
+};
+
+static int __init chaos_tg_init(void)
+{
+	int ret = -EINVAL;
+
+	xm_tcp = xt_request_find_match(NFPROTO_IPV4, "tcp", 0);
+	if (xm_tcp == NULL) {
+		printk(KERN_WARNING PFX "Error: Could not find or load "
+		       "\"tcp\" match\n");
+		return -EINVAL;
+	}
+
+	xt_reject = xt_request_find_target(NFPROTO_IPV4, "REJECT", 0);
+	if (xt_reject == NULL) {
+		printk(KERN_WARNING PFX "Error: Could not find or load "
+		       "\"REJECT\" target\n");
+		goto out2;
+	}
+
+	xt_tarpit   = xt_request_find_target(NFPROTO_IPV4, "TARPIT", 0);
+	have_tarpit = xt_tarpit != NULL;
+	if (!have_tarpit)
+		printk(KERN_WARNING PFX "Warning: Could not find or load "
+		       "\"TARPIT\" target\n");
+
+	xt_delude   = xt_request_find_target(NFPROTO_IPV4, "DELUDE", 0);
+	have_delude = xt_delude != NULL;
+	if (!have_delude)
+		printk(KERN_WARNING PFX "Warning: Could not find or load "
+		       "\"DELUDE\" target\n");
+
+	if ((ret = xt_register_target(&chaos_tg_reg)) != 0) {
+		printk(KERN_WARNING PFX "xt_register_target returned "
+		       "error %d\n", ret);
+		goto out3;
+	}
+
+	return 0;
+
+ out3:
+ 	if (have_delude)
+ 		module_put(xt_delude->me);
+	if (have_tarpit)
+		module_put(xt_tarpit->me);
+	module_put(xt_reject->me);
+ out2:
+	module_put(xm_tcp->me);
+	return ret;
+}
+
+static void __exit chaos_tg_exit(void)
+{
+	xt_unregister_target(&chaos_tg_reg);
+	module_put(xm_tcp->me);
+	module_put(xt_reject->me);
+	if (have_delude)
+		module_put(xt_delude->me);
+	if (have_tarpit)
+		module_put(xt_tarpit->me);
+}
+
+module_init(chaos_tg_init);
+module_exit(chaos_tg_exit);
+MODULE_DESCRIPTION("Xtables: Network scan slowdown with non-deterministic results");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_CHAOS");

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_CHAOS.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_CHAOS.h
@@ -0,0 +1,14 @@
+#ifndef _LINUX_NETFILTER_XT_CHAOS_H
+#define _LINUX_NETFILTER_XT_CHAOS_H 1
+
+enum xt_chaos_target_variant {
+	XTCHAOS_NORMAL,
+	XTCHAOS_TARPIT,
+	XTCHAOS_DELUDE,
+};
+
+struct xt_chaos_tginfo {
+	uint8_t variant;
+};
+
+#endif /* _LINUX_NETFILTER_XT_CHAOS_H */

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_DELUDE.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_DELUDE.c
@@ -0,0 +1,182 @@
+/*
+ *	"DELUDE" target extension for Xtables
+ *	Copyright © Jan Engelhardt <jengelh [at] medozas de>, 2007 - 2008
+ *
+ *	Based upon linux-2.6.18.5/net/ipv4/netfilter/ipt_REJECT.c:
+ *	(C) 1999-2001 Paul `Rusty' Russell
+ *	(C) 2002-2004 Netfilter Core Team <coreteam@netfilter.org>
+ *
+ *	xt_DELUDE acts like REJECT, but does reply with SYN-ACK on SYN.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License version 2 as
+ *	published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/version.h>
+#include <linux/netfilter/x_tables.h>
+#ifdef CONFIG_BRIDGE_NETFILTER
+#	include <linux/netfilter_bridge.h>
+#endif
+#include <net/tcp.h>
+#include "compat_xtables.h"
+#define PFX KBUILD_MODNAME ": "
+
+static void delude_send_reset(struct sk_buff *oldskb, unsigned int hook)
+{
+	struct tcphdr _otcph, *tcph;
+	const struct tcphdr *oth;
+	const struct iphdr *oiph;
+	unsigned int addr_type;
+	struct sk_buff *nskb;
+	struct iphdr *niph;
+
+	oiph = ip_hdr(oldskb);
+
+	/* IP header checks: fragment. */
+	if (oiph->frag_off & htons(IP_OFFSET))
+		return;
+
+	oth = skb_header_pointer(oldskb, ip_hdrlen(oldskb),
+				 sizeof(_otcph), &_otcph);
+	if (oth == NULL)
+		return;
+
+	/* No RST for RST. */
+	if (oth->rst)
+		return;
+
+	/* Check checksum */
+	if (nf_ip_checksum(oldskb, hook, ip_hdrlen(oldskb), IPPROTO_TCP))
+		return;
+
+	nskb = alloc_skb(sizeof(struct iphdr) + sizeof(struct tcphdr) +
+	                 LL_MAX_HEADER, GFP_ATOMIC);
+	if (nskb == NULL)
+		return;
+
+	skb_reserve(nskb, LL_MAX_HEADER);
+	skb_reset_network_header(nskb);
+	niph = (struct iphdr *)skb_put(nskb, sizeof(struct iphdr));
+	niph->version  = 4;
+	niph->ihl      = sizeof(struct iphdr) / 4;
+	niph->tos      = 0;
+	niph->id       = 0;
+	niph->frag_off = htons(IP_DF);
+	niph->protocol = IPPROTO_TCP;
+	niph->check    = 0;
+	niph->saddr    = oiph->daddr;
+	niph->daddr    = oiph->saddr;
+
+	tcph = (struct tcphdr *)skb_put(nskb, sizeof(struct tcphdr));
+	memset(tcph, 0, sizeof(*tcph));
+	tcph->source = oth->dest;
+	tcph->dest   = oth->source;
+	tcph->doff   = sizeof(struct tcphdr) / 4;
+
+	/* DELUDE essential part */
+	if (oth->syn && !oth->ack && !oth->rst && !oth->fin) {
+		tcph->syn     = true;
+		tcph->seq     = 0;
+		tcph->ack     = true;
+		tcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn + oth->fin +
+		                oldskb->len - ip_hdrlen(oldskb) -
+		                (oth->doff << 2));
+	} else {
+		tcph->rst = true;
+		if (!oth->ack) {
+			tcph->seq     = 0;
+			tcph->ack     = true;
+			tcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn +
+			                oth->fin + oldskb->len -
+			                ip_hdrlen(oldskb) - (oth->doff << 2));
+		} else {
+			tcph->seq     = oth->ack_seq;
+			tcph->ack     = false;
+			tcph->ack_seq = 0;
+		}
+	}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
+	tcph->check = tcp_v4_check(tcph, sizeof(struct tcphdr), niph->saddr,
+	              niph->daddr, csum_partial((char *)tcph,
+	              sizeof(struct tcphdr), 0));
+#else
+	tcph->check = tcp_v4_check(sizeof(struct tcphdr), niph->saddr,
+	              niph->daddr, csum_partial((char *)tcph,
+	              sizeof(struct tcphdr), 0));
+#endif
+
+	addr_type = RTN_UNSPEC;
+#ifdef CONFIG_BRIDGE_NETFILTER
+	if (hook != NF_INET_FORWARD || (nskb->nf_bridge != NULL &&
+	    nskb->nf_bridge->mask & BRNF_BRIDGED))
+#else
+	if (hook != NF_INET_FORWARD)
+#endif
+		addr_type = RTN_LOCAL;
+
+	/* ip_route_me_harder expects skb->dst to be set */
+	skb_dst_set(nskb, dst_clone(skb_dst(oldskb)));
+
+	if (ip_route_me_harder(&nskb, addr_type))
+		goto free_nskb;
+	else
+		niph = ip_hdr(nskb);
+
+	niph->ttl       = dst_metric(skb_dst(nskb), RTAX_HOPLIMIT);
+	nskb->ip_summed = CHECKSUM_NONE;
+
+	/* "Never happens" */
+	if (nskb->len > dst_mtu(skb_dst(nskb)))
+		goto free_nskb;
+
+	nf_ct_attach(nskb, oldskb);
+
+	ip_local_out(nskb);
+	return;
+
+ free_nskb:
+	kfree_skb(nskb);
+}
+
+static unsigned int
+delude_tg(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	/* WARNING: This code causes reentry within iptables.
+	   This means that the iptables jump stack is now crap.  We
+	   must return an absolute verdict. --RR */
+	delude_send_reset(*pskb, par->hooknum);
+	return NF_DROP;
+}
+
+static struct xt_target delude_tg_reg __read_mostly = {
+	.name     = "DELUDE",
+	.revision = 0,
+	.family   = NFPROTO_IPV4,
+	.table    = "filter",
+	.hooks    = (1 << NF_INET_LOCAL_IN) | (1 << NF_INET_FORWARD),
+	.proto    = IPPROTO_TCP,
+	.target   = delude_tg,
+	.me       = THIS_MODULE,
+};
+
+static int __init delude_tg_init(void)
+{
+	return xt_register_target(&delude_tg_reg);
+}
+
+static void __exit delude_tg_exit(void)
+{
+	xt_unregister_target(&delude_tg_reg);
+}
+
+module_init(delude_tg_init);
+module_exit(delude_tg_exit);
+MODULE_DESCRIPTION("Xtables: Close TCP connections after handshake");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_DELUDE");

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_fuzzy.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_fuzzy.c
@@ -0,0 +1,174 @@
+/*
+ *	This module implements a simple TSK FLC (Takagi-Sugeno-Kang Fuzzy Logic
+ *	Controller) that aims to limit, in an adaptive and flexible way, the
+ *	packet rate crossing a given stream. It serves as an initial and very
+ *	simple (but effective) example of how Fuzzy Logic techniques can be
+ *	applied to defeat DoS attacks.
+ *
+ *	As a matter of fact, Fuzzy Logic can help us to insert any "behavior"
+ *	into our code in a precise, adaptive and efficient manner.
+ *
+ *	The goal is very similar to that of "limit" match, but using techniques
+ *	of Fuzzy Control, that allow us to shape the transfer functions
+ *	precisely, avoiding over and undershoots - and stuff like that.
+ *
+ * 2002-08-10  Hime Aguiar e Oliveira Jr. <hime@engineer.com> : Initial version.
+ * 2002-08-17  : Changed to eliminate floating point operations .
+ * 2002-08-23  : Coding style changes .
+ * 2003-04-08  Maciej Soltysiak <solt@dns.toxicilms.tv> : IPv6 Port
+ */
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/random.h>
+#include <net/tcp.h>
+#include <linux/netfilter/x_tables.h>
+#include "xt_fuzzy.h"
+#include "compat_xtables.h"
+
+/*
+ * Packet Acceptance Rate - LOW and Packet Acceptance Rate - HIGH
+ * Expressed in percentage.
+ */
+
+#define PAR_LOW		1/100
+#define PAR_HIGH	1
+
+MODULE_AUTHOR("Hime Aguiar e Oliveira Junior <hime@engineer.com>");
+MODULE_DESCRIPTION("Xtables: Fuzzy Logic Controller match");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_fuzzy");
+MODULE_ALIAS("ip6t_fuzzy");
+
+static uint8_t mf_high(uint32_t tx, uint32_t mini, uint32_t maxi)
+{
+	if (tx >= maxi)
+		return 100;
+	if (tx <= mini)
+		return 0;
+	return 100 * (tx - mini) / (maxi - mini);
+}
+
+static uint8_t mf_low(uint32_t tx, uint32_t mini, uint32_t maxi)
+{
+	if (tx <= mini)
+		return 100;
+	if (tx >= maxi)
+		return 0;
+	return 100 * (maxi - tx) / (maxi - mini);
+
+}
+
+static bool
+fuzzy_mt(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	struct xt_fuzzy_mtinfo *info = (void *)par->matchinfo;
+	unsigned long amount;
+	uint8_t howhigh, howlow, random_number;
+
+	info->bytes_total += skb->len;
+	++info->packets_total;
+	info->present_time = jiffies;
+
+	if (info->present_time >= info->previous_time) {
+		amount = info->present_time - info->previous_time;
+	} else {
+		/*
+		 * There was a transition: I choose to re-sample
+		 * and keep the old acceptance rate...
+	         */
+		amount = 0;
+		info->previous_time = info->present_time;
+		info->bytes_total = info->packets_total = 0;
+	}
+
+	if (amount > HZ / 10) {
+		/* More than 100 ms elapsed ... */
+
+		info->mean_rate     = HZ * info->packets_total / amount;
+		info->previous_time = info->present_time;
+		info->bytes_total   = info->packets_total = 0;
+
+		howhigh = mf_high(info->mean_rate, info->minimum_rate,
+		          info->maximum_rate);
+		howlow  = mf_low(info->mean_rate, info->minimum_rate,
+		          info->maximum_rate);
+
+		info->acceptance_rate = howhigh * PAR_LOW + PAR_HIGH * howlow;
+
+		/*
+		 * In fact, the above defuzzification would require a
+		 * denominator proportional to (howhigh+howlow) but, in this
+		 * particular case, that expression is constant.
+		 *
+		 * An imediate consequence is that it is not necessary to call
+		 * both mf_high and mf_low - but to keep things understandable,
+		 * I did so.
+		 */
+	}
+
+	if (info->acceptance_rate < 100) {
+		get_random_bytes(&random_number, sizeof(random_number));
+
+		if (random_number <= 255 * info->acceptance_rate / 100)
+			/*
+			 * If within the acceptance, it can pass
+			 * => do not match.
+			 */
+			return false;
+		else
+			/* It cannot pass (it matches) */
+			return true;
+	};
+
+	/* acceptance_rate == 100 % => Everything passes ... */
+	return false;
+}
+
+static int fuzzy_mt_check(const struct xt_mtchk_param *par)
+{
+	const struct xt_fuzzy_mtinfo *info = par->matchinfo;
+
+	if (info->minimum_rate < FUZZY_MIN_RATE ||
+	    info->maximum_rate > FUZZY_MAX_RATE ||
+	    info->minimum_rate >= info->maximum_rate) {
+		printk(KERN_INFO KBUILD_MODNAME ": bad values, please check.\n");
+		return -EDOM;
+	}
+
+	return 0;
+}
+
+static struct xt_match fuzzy_mt_reg[] __read_mostly = {
+	{
+		.name       = "fuzzy",
+		.revision   = 1,
+		.family     = NFPROTO_IPV4,
+		.match      = fuzzy_mt,
+		.checkentry = fuzzy_mt_check,
+		.matchsize  = sizeof(struct xt_fuzzy_mtinfo),
+		.me         = THIS_MODULE,
+	},
+	{
+		.name       = "fuzzy",
+		.revision   = 1,
+		.family     = NFPROTO_IPV6,
+		.match      = fuzzy_mt,
+		.checkentry = fuzzy_mt_check,
+		.matchsize  = sizeof(struct xt_fuzzy_mtinfo),
+		.me         = THIS_MODULE,
+	},
+};
+
+static int __init fuzzy_mt_init(void)
+{
+	return xt_register_matches(fuzzy_mt_reg, ARRAY_SIZE(fuzzy_mt_reg));
+}
+
+static void __exit fuzzy_mt_exit(void)
+{
+	xt_unregister_matches(fuzzy_mt_reg, ARRAY_SIZE(fuzzy_mt_reg));
+}
+
+module_init(fuzzy_mt_init);
+module_exit(fuzzy_mt_exit);

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_fuzzy.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_fuzzy.h
@@ -0,0 +1,20 @@
+#ifndef _LINUX_NETFILTER_XT_FUZZY_H
+#define _LINUX_NETFILTER_XT_FUZZY_H 1
+
+enum {
+	FUZZY_MIN_RATE = 3,
+	FUZZY_MAX_RATE = 10000000,
+};
+
+struct xt_fuzzy_mtinfo {
+	uint32_t minimum_rate;
+	uint32_t maximum_rate;
+	uint32_t packets_total;
+	uint32_t bytes_total;
+	uint32_t previous_time;
+	uint32_t present_time;
+	uint32_t mean_rate;
+	uint8_t acceptance_rate;
+};
+
+#endif /* _LINUX_NETFILTER_XT_FUZZY_H */

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_iface.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_iface.c
@@ -0,0 +1,118 @@
+/*
+ *	xt_iface - kernel module to match interface state flags
+ *
+ *	Original author: Gáspár Lajos <gaspar.lajos@glsys.eu>
+ */
+
+#include <linux/if.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <linux/netfilter/x_tables.h>
+#include "xt_iface.h"
+#include "compat_xtables.h"
+
+struct xt_iface_flag_pairs {
+	uint16_t iface_flag;
+	uint32_t iff_flag;
+};
+
+MODULE_AUTHOR("Gáspár Lajos <gaspar.lajos@glsys.eu>");
+MODULE_DESCRIPTION("Xtables: iface match module");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_iface");
+MODULE_ALIAS("ip6t_iface");
+//MODULE_ALIAS("arpt_iface");
+
+static const struct xt_iface_flag_pairs xt_iface_lookup[] =
+{
+	{.iface_flag = XT_IFACE_UP,		.iff_flag = IFF_UP},
+	{.iface_flag = XT_IFACE_BROADCAST,	.iff_flag = IFF_BROADCAST},
+	{.iface_flag = XT_IFACE_LOOPBACK,	.iff_flag = IFF_LOOPBACK},
+	{.iface_flag = XT_IFACE_POINTOPOINT,	.iff_flag = IFF_POINTOPOINT},
+	{.iface_flag = XT_IFACE_RUNNING,	.iff_flag = IFF_RUNNING},
+	{.iface_flag = XT_IFACE_NOARP,		.iff_flag = IFF_NOARP},
+	{.iface_flag = XT_IFACE_PROMISC,	.iff_flag = IFF_PROMISC},
+	{.iface_flag = XT_IFACE_MULTICAST,	.iff_flag = IFF_MULTICAST},
+	{.iface_flag = XT_IFACE_DYNAMIC,	.iff_flag = IFF_DYNAMIC},
+	{.iface_flag = XT_IFACE_LOWER_UP,	.iff_flag = IFF_LOWER_UP},
+	{.iface_flag = XT_IFACE_DORMANT,	.iff_flag = IFF_DORMANT},
+};
+
+static const struct net_device *iface_get(const struct xt_iface_mtinfo *info,
+    const struct xt_action_param *par, struct net_device **put)
+{
+	if (info->flags & XT_IFACE_DEV_IN)
+		return par->in;
+	else if (info->flags & XT_IFACE_DEV_OUT)
+		return par->out;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+	return *put = dev_get_by_name(&init_net, info->ifname);
+#else
+	return *put = dev_get_by_name(info->ifname);
+#endif
+}
+
+static bool iface_flagtest(unsigned int devflags, unsigned int flags,
+    unsigned int invflags)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(xt_iface_lookup); ++i)
+		if ((flags & xt_iface_lookup[i].iface_flag) &&
+		    !!(devflags & xt_iface_lookup[i].iff_flag) ^
+		    !(invflags & xt_iface_lookup[i].iface_flag))
+			return false;
+	return true;
+}
+
+static bool xt_iface_mt(const struct sk_buff *skb,
+    struct xt_action_param *par)
+{
+	const struct xt_iface_mtinfo *info = par->matchinfo;
+	struct net_device *put = NULL;
+	const struct net_device *dev = iface_get(info, par, &put);
+	bool retval;
+
+	if (dev == NULL)
+		return false;
+	retval = iface_flagtest(dev->flags, info->flags, info->invflags);
+	if (put != NULL)
+		dev_put(put);
+	return retval;
+}
+
+static struct xt_match xt_iface_mt_reg[] __read_mostly = {
+	{
+		.name       = "iface",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.matchsize  = sizeof(struct xt_iface_mtinfo),
+		.match      = xt_iface_mt,
+		.me         = THIS_MODULE,
+	},
+	{
+		.name       = "iface",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.matchsize  = sizeof(struct xt_iface_mtinfo),
+		.match      = xt_iface_mt,
+		.me         = THIS_MODULE,
+	},
+};
+
+static int __init xt_iface_match_init(void)
+{
+	return xt_register_matches(xt_iface_mt_reg,
+		ARRAY_SIZE(xt_iface_mt_reg));
+}
+
+static void __exit xt_iface_match_exit(void)
+{
+	xt_unregister_matches(xt_iface_mt_reg, ARRAY_SIZE(xt_iface_mt_reg));
+}
+
+module_init(xt_iface_match_init);
+module_exit(xt_iface_match_exit);

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_iface.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_iface.h
@@ -0,0 +1,26 @@
+#ifndef _LINUX_NETFILTER_XT_IFACE_H
+#define _LINUX_NETFILTER_XT_IFACE_H 1
+
+enum {
+	XT_IFACE_UP          = 1 << 0,
+	XT_IFACE_BROADCAST   = 1 << 1,
+	XT_IFACE_LOOPBACK    = 1 << 2,
+	XT_IFACE_POINTOPOINT = 1 << 3,
+	XT_IFACE_RUNNING     = 1 << 4,
+	XT_IFACE_NOARP       = 1 << 5,
+	XT_IFACE_PROMISC     = 1 << 6,
+	XT_IFACE_MULTICAST   = 1 << 7,
+	XT_IFACE_DYNAMIC     = 1 << 8,
+	XT_IFACE_LOWER_UP    = 1 << 9,
+	XT_IFACE_DORMANT     = 1 << 10,
+	XT_IFACE_DEV_IN      = 1 << 11,
+	XT_IFACE_DEV_OUT     = 1 << 12,
+};
+
+struct xt_iface_mtinfo {
+	char ifname[IFNAMSIZ];
+	__u16 flags;
+	__u16 invflags;
+};
+
+#endif

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_ipv4options.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_ipv4options.c
@@ -0,0 +1,83 @@
+/*
+ *	xt_ipv4opts - Xtables module to match IPv4 options
+ *	Copyright © Jan Engelhardt, 2009
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <linux/ip.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/netfilter/x_tables.h>
+#include <net/ip.h>
+#include "xt_ipv4options.h"
+#include "compat_xtables.h"
+
+static uint32_t ipv4options_rd(const uint8_t *data, int len)
+{
+	uint32_t opts = 0;
+
+	while (len >= 2) {
+		switch (data[0]) {
+		case IPOPT_END:
+			return opts;
+		case IPOPT_NOOP:
+			--len;
+			++data;
+			continue;
+		}
+
+		if (data[1] < 2 || data[1] > len)
+			return opts;
+		opts |= 1 << (data[0] & 0x1F);
+		len  -= data[1];
+		data += data[1];
+	}
+
+	return opts;
+}
+
+static bool ipv4options_mt(const struct sk_buff *skb,
+    struct xt_action_param *par)
+{
+	const struct xt_ipv4options_mtinfo1 *info = par->matchinfo;
+	const struct iphdr *iph = ip_hdr(skb);
+	uint32_t opts = 0;
+	uint16_t len  = ip_hdrlen(skb) - sizeof(struct iphdr);
+
+	if (len > 0)
+		opts = ipv4options_rd((const void *)iph +
+		       sizeof(struct iphdr), len);
+
+	opts ^= info->invert;
+	opts &= info->map;
+	return (info->flags & XT_V4OPTS_ANY) ? opts : opts == info->map;
+}
+
+static struct xt_match ipv4options_mt_reg __read_mostly = {
+	.name      = "ipv4options",
+	.revision  = 1,
+	.family    = NFPROTO_IPV4,
+	.match     = ipv4options_mt,
+	.matchsize = sizeof(struct xt_ipv4options_mtinfo1),
+	.me        = THIS_MODULE,
+};
+
+static int __init ipv4options_mt_init(void)
+{
+	return xt_register_match(&ipv4options_mt_reg);
+}
+
+static void __exit ipv4options_mt_exit(void)
+{
+	xt_unregister_match(&ipv4options_mt_reg);
+}
+
+MODULE_DESCRIPTION("Xatblse: IPv4 option match");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_ipv4options");
+module_init(ipv4options_mt_init);
+module_exit(ipv4options_mt_exit);

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_ipv4options.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_ipv4options.h
@@ -0,0 +1,26 @@
+#ifndef _LINUX_NETFILTER_XT_IPV4OPTIONS_H
+#define _LINUX_NETFILTER_XT_IPV4OPTIONS_H 1
+
+/* IPv4 allows for a 5-bit option number - 32 options */
+
+/**
+ * %XT_V4OPTS_ALL:	all options in @map must be present (respecting @invert)
+ * %XT_V4OPTS_ANY:	any of the option in @map
+ */
+enum xt_ipv4options_flags {
+	XT_V4OPTS_ALL = 1 << 0,
+	XT_V4OPTS_ANY = 1 << 1,
+};
+
+/**
+ * @map:	bitmask of options that should appear
+ * @invert:	inversion map
+ * @flags:	see above
+ */
+struct xt_ipv4options_mtinfo1 {
+	__u32 map;
+	__u32 invert;
+	__u8 flags;
+};
+
+#endif /* _LINUX_NETFILTER_XT_IPV4OPTIONS_H */

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_lscan.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_lscan.c
@@ -0,0 +1,271 @@
+/*
+ *	LSCAN match for Xtables
+ *	Copyright © Jan Engelhardt, 2006 - 2009
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License; either version
+ *	2 or 3 as published by the Free Software Foundation.
+ */
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_tcpudp.h>
+#include "xt_lscan.h"
+#include "compat_xtables.h"
+#define PFX KBUILD_MODNAME ": "
+
+enum {
+	TCP_FLAGS_ALL3 = TCP_FLAG_FIN | TCP_FLAG_RST | TCP_FLAG_SYN,
+	TCP_FLAGS_ALL4 = TCP_FLAGS_ALL3 | TCP_FLAG_ACK,
+	TCP_FLAGS_ALL6 = TCP_FLAGS_ALL4 | TCP_FLAG_PSH | TCP_FLAG_URG,
+};
+
+/* Module parameters */
+static unsigned int
+	connmark_mask = ~0,
+	packet_mask   = ~0,
+	mark_seen     = 0x9,
+	mark_synrcv   = 0x1,
+	mark_closed   = 0x2,
+	mark_synscan  = 0x3,
+	mark_estab1   = 0x4,
+	mark_estab2   = 0x5,
+	mark_cnscan   = 0x6,
+	mark_grscan   = 0x7,
+	mark_valid    = 0x8;
+
+module_param(connmark_mask, uint, S_IRUGO | S_IWUSR);
+module_param(packet_mask,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_seen,     uint, S_IRUGO | S_IWUSR);
+module_param(mark_synrcv,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_closed,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_synscan,  uint, S_IRUGO | S_IWUSR);
+module_param(mark_estab1,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_estab2,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_cnscan,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_grscan,   uint, S_IRUGO | S_IWUSR);
+module_param(mark_valid,    uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(connmark_mask, "only set specified bits in connection mark");
+MODULE_PARM_DESC(packet_mask,   "only set specified bits in packet mark");
+MODULE_PARM_DESC(mark_seen,     "nfmark value for packet-seen state");
+MODULE_PARM_DESC(mark_synrcv,   "connmark value for SYN Received state");
+MODULE_PARM_DESC(mark_closed,   "connmark value for closed state");
+MODULE_PARM_DESC(mark_synscan,  "connmark value for SYN Scan state");
+MODULE_PARM_DESC(mark_estab1,   "connmark value for Established-1 state");
+MODULE_PARM_DESC(mark_estab2,   "connmark value for Established-2 state");
+MODULE_PARM_DESC(mark_cnscan,   "connmark value for Connect Scan state");
+MODULE_PARM_DESC(mark_grscan,   "connmark value for Grab Scan state");
+MODULE_PARM_DESC(mark_valid,    "connmark value for Valid state");
+
+/* TCP flag functions */
+static inline bool tflg_ack4(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL4) == TCP_FLAG_ACK;
+}
+
+static inline bool tflg_ack6(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL6) == TCP_FLAG_ACK;
+}
+
+static inline bool tflg_fin(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL3) == TCP_FLAG_FIN;
+}
+
+static inline bool tflg_rst(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL3) == TCP_FLAG_RST;
+}
+
+static inline bool tflg_rstack(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL4) ==
+	       (TCP_FLAG_ACK | TCP_FLAG_RST);
+}
+
+static inline bool tflg_syn(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL4) == TCP_FLAG_SYN;
+}
+
+static inline bool tflg_synack(const struct tcphdr *th)
+{
+	return (tcp_flag_word(th) & TCP_FLAGS_ALL4) ==
+	       (TCP_FLAG_SYN | TCP_FLAG_ACK);
+}
+
+/* lscan functions */
+static inline bool lscan_mt_stealth(const struct tcphdr *th)
+{
+	/*
+	 * "Connection refused" replies to our own probes must not be matched.
+	 */
+	if (tflg_rstack(th))
+		return false;
+
+	if (tflg_rst(th) && printk_ratelimit()) {
+		printk(KERN_WARNING PFX "Warning: Pure RST received\n");
+		return false;
+	}
+
+	/*
+	 * -p tcp ! --syn -m conntrack --ctstate INVALID: Looking for non-start
+	 * packets that are not associated with any connection -- this will
+	 * match most scan types (NULL, XMAS, FIN) and ridiculous flag
+	 * combinations (SYN-RST, SYN-FIN, SYN-FIN-RST, FIN-RST, etc.).
+	 */
+	return !tflg_syn(th);
+}
+
+static inline unsigned int lscan_mt_full(int mark,
+    enum ip_conntrack_info ctstate, bool loopback, const struct tcphdr *tcph,
+    unsigned int payload_len)
+{
+	if (mark == mark_estab2) {
+		/*
+		 * -m connmark --mark $ESTAB2
+		 */
+		if (tflg_ack4(tcph) && payload_len == 0)
+			return mark; /* keep mark */
+		else if (tflg_rst(tcph) || tflg_fin(tcph))
+			return mark_grscan;
+		else
+			return mark_valid;
+	} else if (mark == mark_estab1) {
+		/*
+		 * -m connmark --mark $ESTAB1
+		 */
+		if (tflg_rst(tcph) || tflg_fin(tcph))
+			return mark_cnscan;
+		else if (!loopback && tflg_ack4(tcph) && payload_len == 0)
+			return mark_estab2;
+		else
+			return mark_valid;
+	} else if (mark == mark_synrcv) {
+		/*
+		 * -m connmark --mark $SYN
+		 */
+		if (loopback && tflg_synack(tcph))
+			return mark; /* keep mark */
+		else if (loopback && tflg_rstack(tcph))
+			return mark_closed;
+		else if (tflg_ack6(tcph))
+			return mark_estab1;
+		else
+			return mark_synscan;
+	} else if (ctstate == IP_CT_NEW && tflg_syn(tcph)) {
+		/*
+		 * -p tcp --syn --ctstate NEW
+		 */
+		return mark_synrcv;
+	}
+	return mark;
+}
+
+static bool
+lscan_mt(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	const struct xt_lscan_mtinfo *info = par->matchinfo;
+	enum ip_conntrack_info ctstate;
+	const struct tcphdr *tcph;
+	struct nf_conn *ctdata;
+	struct tcphdr tcph_buf;
+
+	tcph = skb_header_pointer(skb, par->thoff, sizeof(tcph_buf), &tcph_buf);
+	if (tcph == NULL)
+		return false;
+
+	/* Check for invalid packets: -m conntrack --ctstate INVALID */
+	if ((ctdata = nf_ct_get(skb, &ctstate)) == NULL) {
+		if (info->match_stealth)
+			return lscan_mt_stealth(tcph);
+		/*
+		 * If @ctdata is NULL, we cannot match the other scan
+		 * types, return.
+		 */
+		return false;
+	}
+
+	/*
+	 * If -m lscan was previously applied to this packet, the rules we
+	 * simulate must not be run through again. And for speedup, do not call
+	 * it either when the connection is already VALID.
+	 */
+	if ((ctdata->mark & connmark_mask) == mark_valid ||
+	     (skb_nfmark(skb) & packet_mask) != mark_seen) {
+		unsigned int n;
+
+		n = lscan_mt_full(ctdata->mark & connmark_mask, ctstate,
+		    par->in == init_net__loopback_dev, tcph,
+		    skb->len - par->thoff - 4 * tcph->doff);
+
+		ctdata->mark = (ctdata->mark & ~connmark_mask) | n;
+		skb_nfmark(skb) = (skb_nfmark(skb) & ~packet_mask) ^ mark_seen;
+	}
+
+	return (info->match_syn && ctdata->mark == mark_synscan) ||
+	       (info->match_cn && ctdata->mark == mark_cnscan) ||
+	       (info->match_gr && ctdata->mark == mark_grscan);
+}
+
+static int lscan_mt_check(const struct xt_mtchk_param *par)
+{
+	const struct xt_lscan_mtinfo *info = par->matchinfo;
+
+	if ((info->match_stealth & ~1) || (info->match_syn & ~1) ||
+	    (info->match_cn & ~1) || (info->match_gr & ~1)) {
+		printk(KERN_WARNING PFX "Invalid flags\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct xt_match lscan_mt_reg[] __read_mostly = {
+	{
+		.name       = "lscan",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.match      = lscan_mt,
+		.checkentry = lscan_mt_check,
+		.matchsize  = sizeof(struct xt_lscan_mtinfo),
+		.proto      = IPPROTO_TCP,
+		.me         = THIS_MODULE,
+	},
+	{
+		.name       = "lscan",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.match      = lscan_mt,
+		.checkentry = lscan_mt_check,
+		.matchsize  = sizeof(struct xt_lscan_mtinfo),
+		.proto      = IPPROTO_TCP,
+		.me         = THIS_MODULE,
+	},
+};
+
+static int __init lscan_mt_init(void)
+{
+	return xt_register_matches(lscan_mt_reg,
+	       ARRAY_SIZE(lscan_mt_reg));
+}
+
+static void __exit lscan_mt_exit(void)
+{
+	xt_unregister_matches(lscan_mt_reg, ARRAY_SIZE(lscan_mt_reg));
+}
+
+module_init(lscan_mt_init);
+module_exit(lscan_mt_exit);
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_DESCRIPTION("Xtables: Low-level scan (e.g. nmap) match");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_lscan");
+MODULE_ALIAS("ip6t_lscan");

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_lscan.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_lscan.h
@@ -0,0 +1,8 @@
+#ifndef _LINUX_NETFILTER_XT_LSCAN_H
+#define _LINUX_NETFILTER_XT_LSCAN_H 1
+
+struct xt_lscan_mtinfo {
+	uint8_t match_stealth, match_syn, match_cn, match_gr;
+};
+
+#endif /* _LINUX_NETFILTER_XT_LSCAN_H */

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_pknock.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_pknock.c
@@ -0,0 +1,1199 @@
+/*
+ * Kernel module to implement Port Knocking and SPA matching support.
+ *
+ * (C) 2006-2009 J. Federico Hernandez Scarso <fede.hernandez@gmail.com>
+ * (C) 2006 Luis A. Floreani <luis.floreani@gmail.com>
+ *
+ * This program is released under the terms of GNU GPL version 2.
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/in.h>
+#include <linux/list.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/jhash.h>
+#include <linux/random.h>
+#include <linux/crypto.h>
+#include <linux/proc_fs.h>
+#include <linux/scatterlist.h>
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+#include <linux/timer.h>
+#include <linux/seq_file.h>
+#include <linux/connector.h>
+
+#include <linux/netfilter/x_tables.h>
+#include "xt_pknock.h"
+#include "compat_xtables.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+#	define PK_CRYPTO 1
+#endif
+
+enum status {
+	ST_INIT = 1,
+	ST_MATCHING,
+	ST_ALLOWED,
+};
+
+/**
+ * @timestamp:	seconds, but not since epoch (uses jiffies/HZ)
+ * @login_sec: seconds at login since the epoch
+ */
+struct peer {
+	struct list_head head;
+	__be32 ip;
+	uint32_t accepted_knock_count;
+	unsigned long timestamp;
+	unsigned long login_sec;
+	enum status status;
+	uint8_t proto;
+};
+
+/**
+ * @timer:	garbage collector timer
+ * @max_time:	max matching time between ports
+ */
+struct xt_pknock_rule {
+	struct list_head head;
+	char rule_name[XT_PKNOCK_MAX_BUF_LEN+1];
+	int rule_name_len;
+	unsigned int ref_count;
+	struct timer_list timer;
+	struct list_head *peer_head;
+	struct proc_dir_entry *status_proc;
+	unsigned long max_time;
+	unsigned long autoclose_time;
+};
+
+/**
+ * @port:	destination port
+ */
+struct transport_data {
+	uint8_t proto;
+	uint16_t port;
+	int payload_len;
+	const unsigned char *payload;
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("J. Federico Hernandez Scarso, Luis A. Floreani");
+MODULE_DESCRIPTION("netfilter match for Port Knocking and SPA");
+MODULE_ALIAS("ipt_pknock");
+
+enum {
+	DEFAULT_GC_EXPIRATION_TIME = 65000, /* in msecs */
+	DEFAULT_RULE_HASH_SIZE  = 8,
+	DEFAULT_PEER_HASH_SIZE  = 16,
+};
+
+#define hashtable_for_each_safe(pos, n, head, size, i)	\
+	for ((i) = 0; (i) < (size); ++(i)) \
+		list_for_each_safe((pos), (n), (&head[(i)]))
+
+#define pk_debug(msg, peer) pr_debug( \
+			"(S) peer: " NIPQUAD_FMT " - %s.\n", \
+			NIPQUAD((peer)->ip), msg)
+
+static uint32_t ipt_pknock_hash_rnd;
+
+static unsigned int rule_hashsize	= DEFAULT_RULE_HASH_SIZE;
+static unsigned int peer_hashsize	= DEFAULT_PEER_HASH_SIZE;
+static unsigned int gc_expir_time = DEFAULT_GC_EXPIRATION_TIME;
+static int nl_multicast_group		= -1;
+
+static struct list_head *rule_hashtable;
+static struct proc_dir_entry *pde;
+
+static DEFINE_SPINLOCK(list_lock);
+
+#ifdef PK_CRYPTO
+static struct {
+	const char *algo;
+	struct crypto_hash	*tfm;
+	unsigned int size;
+	struct hash_desc	desc;
+} crypto = {
+	.algo	= "hmac(sha256)",
+	.tfm	= NULL,
+	.size	= 0
+};
+#endif
+
+module_param(rule_hashsize, int, S_IRUGO);
+MODULE_PARM_DESC(rule_hashsize, "Buckets in rule hash table (default: 8)");
+module_param(peer_hashsize, int, S_IRUGO);
+MODULE_PARM_DESC(peer_hashsize, "Buckets in peer hash table (default: 16)");
+module_param(gc_expir_time, int, S_IRUGO);
+MODULE_PARM_DESC(gc_expir_time, "Time until garbage collection after valid knock packet (default: 65000 msec)");
+module_param(nl_multicast_group, int, S_IRUGO);
+MODULE_PARM_DESC(nl_multicast_group, "Netlink multicast group number for pknock messages");
+
+/**
+ * Calculates a value from 0 to max from a hash of the arguments.
+ *
+ * @key
+ * @len: length
+ * @initval
+ * @max
+ * @return: a 32 bits index
+ */
+static inline uint32_t
+pknock_hash(const void *key, uint32_t len, uint32_t initval, uint32_t max)
+{
+	return jhash(key, len, initval) % max;
+}
+
+/**
+ * Alloc a hashtable with n buckets.
+ *
+ * @size
+ * @return: hashtable
+ */
+static struct list_head *
+alloc_hashtable(unsigned int size)
+{
+	struct list_head *hash;
+	unsigned int i;
+
+	hash = kmalloc(sizeof(*hash) * size, GFP_KERNEL);
+	if (hash == NULL)
+		return NULL;
+	for (i = 0; i < size; ++i)
+		INIT_LIST_HEAD(&hash[i]);
+
+	return hash;
+}
+
+/**
+ * This function converts the status from integer to string.
+ *
+ * @status
+ * @return: status
+ */
+static inline const char *
+status_itoa(enum status status)
+{
+	switch (status) {
+		case ST_INIT: 	  	return "INIT";
+		case ST_MATCHING: 	return "MATCHING";
+		case ST_ALLOWED:  	return "ALLOWED";
+		default: 			return "UNKNOWN";
+	}
+}
+
+/**
+ * @s
+ * @pos
+ * @return: private value used by the iterator
+ */
+static void *
+pknock_seq_start(struct seq_file *s, loff_t *pos)
+{
+	const struct proc_dir_entry *pde = s->private;
+	const struct xt_pknock_rule *rule = pde->data;
+
+	spin_lock_bh(&list_lock);
+
+	if (*pos >= peer_hashsize)
+		return NULL;
+
+	return rule->peer_head + *pos;
+}
+
+/**
+ * @s
+ * @v
+ * @pos
+ * @return: next value for the iterator
+ */
+static void *
+pknock_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	const struct proc_dir_entry *pde = s->private;
+	const struct xt_pknock_rule *rule = pde->data;
+
+	++*pos;
+	if (*pos >= peer_hashsize)
+		return NULL;
+
+	return rule->peer_head + *pos;
+}
+
+/**
+ * @s
+ * @v
+ */
+static void
+pknock_seq_stop(struct seq_file *s, void *v)
+{
+	spin_unlock_bh(&list_lock);
+}
+
+/**
+ * @s
+ * @v
+ * @return: 0 if OK
+ */
+static int
+pknock_seq_show(struct seq_file *s, void *v)
+{
+	const struct list_head *pos, *n;
+	const struct peer *peer;
+	unsigned long time;
+	const struct list_head *peer_head = v;
+
+	const struct proc_dir_entry *pde = s->private;
+	const struct xt_pknock_rule *rule = pde->data;
+
+	list_for_each_safe(pos, n, peer_head) {
+		peer = list_entry(pos, struct peer, head);
+
+		seq_printf(s, "src=" NIPQUAD_FMT " ", NIPQUAD(peer->ip));
+		seq_printf(s, "proto=%s ", (peer->proto == IPPROTO_TCP) ?
+                                                "TCP" : "UDP");
+		seq_printf(s, "status=%s ", status_itoa(peer->status));
+		seq_printf(s, "accepted_knock_count=%lu ",
+			(unsigned long)peer->accepted_knock_count);
+		if (peer->status == ST_MATCHING) {
+			time = 0;
+			if (time_before(jiffies / HZ, peer->timestamp +
+			    rule->max_time))
+				time = peer->timestamp + rule->max_time -
+				       jiffies / HZ;
+			seq_printf(s, "expir_time=%lu [secs] ", time);
+		}
+		if (peer->status == ST_ALLOWED && rule->autoclose_time != 0) {
+			time = 0;
+			if (time_before(get_seconds(), peer->login_sec +
+			    rule->autoclose_time * 60))
+				time = peer->login_sec +
+				       rule->autoclose_time * 60 -
+				       get_seconds();
+			seq_printf(s, "autoclose_time=%lu [secs] ", time);
+		}
+		seq_printf(s, "\n");
+	}
+
+	return 0;
+}
+
+static const struct seq_operations pknock_seq_ops = {
+	.start = pknock_seq_start,
+	.next = pknock_seq_next,
+	.stop = pknock_seq_stop,
+	.show = pknock_seq_show
+};
+
+/**
+ * @inode
+ * @file
+ */
+static int
+pknock_proc_open(struct inode *inode, struct file *file)
+{
+	int ret = seq_open(file, &pknock_seq_ops);
+	if (ret == 0) {
+		struct seq_file *sf = file->private_data;
+		sf->private = PDE(inode);
+	}
+	return ret;
+}
+
+static const struct file_operations pknock_proc_ops = {
+	.owner = THIS_MODULE,
+	.open = pknock_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release
+};
+
+/**
+ * It updates the rule timer to execute garbage collector.
+ *
+ * @rule
+ */
+static void update_rule_gc_timer(struct xt_pknock_rule *rule)
+{
+	if (timer_pending(&rule->timer))
+		del_timer(&rule->timer);
+
+	rule->timer.expires = jiffies + msecs_to_jiffies(gc_expir_time);
+	add_timer(&rule->timer);
+}
+
+/**
+ * @peer
+ * @autoclose_time
+ *
+ * Returns true if autoclose due, or false if still valid.
+ */
+static inline bool
+autoclose_time_passed(const struct peer *peer, unsigned int autoclose_time)
+{
+	return peer != NULL && autoclose_time != 0 && time_after(get_seconds(),
+	       peer->login_sec + autoclose_time * 60);
+}
+
+/**
+ * @peer
+ * @max_time
+ * @return: 1 time exceeded, 0 still valid
+ */
+static inline bool
+is_interknock_time_exceeded(const struct peer *peer, unsigned int max_time)
+{
+	return peer != NULL && time_after(jiffies / HZ,
+	       peer->timestamp + max_time);
+}
+
+/**
+ * @peer
+ * @return: 1 has logged, 0 otherwise
+ */
+static inline bool
+has_logged_during_this_minute(const struct peer *peer)
+{
+	return peer != NULL && peer->login_sec / 60 == get_seconds() / 60;
+}
+
+/**
+ * Garbage collector. It removes the old entries after tis timers have expired.
+ *
+ * @r: rule
+ */
+static void
+peer_gc(unsigned long r)
+{
+	unsigned int i;
+	struct xt_pknock_rule *rule = (struct xt_pknock_rule *)r;
+	struct peer *peer;
+	struct list_head *pos, *n;
+
+	pr_debug("(S) running %s\n", __func__);
+	hashtable_for_each_safe(pos, n, rule->peer_head, peer_hashsize, i) {
+		peer = list_entry(pos, struct peer, head);
+
+		/*
+		 * Remove any peer whose (inter-knock) max_time
+		 * or autoclose_time passed.
+		 */
+		if ((peer->status != ST_ALLOWED &&
+		    is_interknock_time_exceeded(peer, rule->max_time)) ||
+		    (peer->status == ST_ALLOWED &&
+		    autoclose_time_passed(peer, rule->autoclose_time)))
+		{
+			pk_debug("GC-DELETED", peer);
+			list_del(pos);
+			kfree(peer);
+		}
+	}
+}
+
+/**
+ * Compares length and name equality for the rules.
+ */
+static inline bool
+rulecmp(const struct xt_pknock_mtinfo *info, const struct xt_pknock_rule *rule)
+{
+	if (info->rule_name_len != rule->rule_name_len)
+		return false;
+	if (strncmp(info->rule_name, rule->rule_name, info->rule_name_len) != 0)
+		return false;
+	return true;
+}
+
+/**
+ * Search the rule and returns a pointer if it exists.
+ *
+ * @info
+ * @return: rule or NULL
+ */
+static struct xt_pknock_rule *search_rule(const struct xt_pknock_mtinfo *info)
+{
+	struct xt_pknock_rule *rule;
+	struct list_head *pos, *n;
+	unsigned int hash = pknock_hash(info->rule_name, info->rule_name_len,
+					ipt_pknock_hash_rnd, rule_hashsize);
+
+	list_for_each_safe(pos, n, &rule_hashtable[hash]) {
+		rule = list_entry(pos, struct xt_pknock_rule, head);
+		if (rulecmp(info, rule))
+			return rule;
+	}
+	return NULL;
+}
+
+/**
+ * It adds a rule to list only if it doesn't exist.
+ *
+ * @info
+ * @return: 1 success, 0 failure
+ */
+static bool
+add_rule(struct xt_pknock_mtinfo *info)
+{
+	struct xt_pknock_rule *rule;
+	struct list_head *pos, *n;
+	unsigned int hash = pknock_hash(info->rule_name, info->rule_name_len,
+                                ipt_pknock_hash_rnd, rule_hashsize);
+
+	list_for_each_safe(pos, n, &rule_hashtable[hash]) {
+		rule = list_entry(pos, struct xt_pknock_rule, head);
+
+		if (!rulecmp(info, rule))
+			continue;
+		++rule->ref_count;
+
+		if (info->option & XT_PKNOCK_OPENSECRET) {
+			rule->max_time       = info->max_time;
+			rule->autoclose_time = info->autoclose_time;
+		}
+
+		if (info->option & XT_PKNOCK_CHECKIP)
+			pr_debug("add_rule() (AC) rule found: %s - "
+				"ref_count: %d\n",
+				rule->rule_name, rule->ref_count);
+		return true;
+	}
+
+	rule = kmalloc(sizeof(*rule), GFP_KERNEL);
+	if (rule == NULL)
+		return false;
+
+	INIT_LIST_HEAD(&rule->head);
+
+	memset(rule->rule_name, 0, sizeof(rule->rule_name));
+	strncpy(rule->rule_name, info->rule_name, info->rule_name_len);
+	rule->rule_name_len = info->rule_name_len;
+
+	rule->ref_count      = 1;
+	rule->max_time       = info->max_time;
+	rule->autoclose_time = info->autoclose_time;
+	rule->peer_head      = alloc_hashtable(peer_hashsize);
+	if (rule->peer_head == NULL)
+		goto out;
+
+	init_timer(&rule->timer);
+	rule->timer.function	= peer_gc;
+	rule->timer.data	= (unsigned long)rule;
+
+	rule->status_proc = create_proc_entry(info->rule_name, 0, pde);
+	if (rule->status_proc == NULL)
+		goto out;
+
+	rule->status_proc->proc_fops = &pknock_proc_ops;
+	rule->status_proc->data = rule;
+
+	list_add(&rule->head, &rule_hashtable[hash]);
+	pr_debug("(A) rule_name: %s - created.\n", rule->rule_name);
+	return true;
+ out:
+	kfree(rule->peer_head);
+	kfree(rule);
+	return false;
+}
+
+/**
+ * It removes a rule only if it exists.
+ *
+ * @info
+ */
+static void
+remove_rule(struct xt_pknock_mtinfo *info)
+{
+	struct xt_pknock_rule *rule = NULL;
+	struct list_head *pos, *n;
+	struct peer *peer;
+	unsigned int i;
+	int found = 0;
+	unsigned int hash = pknock_hash(info->rule_name, info->rule_name_len,
+                                ipt_pknock_hash_rnd, rule_hashsize);
+
+	if (list_empty(&rule_hashtable[hash]))
+		return;
+
+	list_for_each_safe(pos, n, &rule_hashtable[hash]) {
+		rule = list_entry(pos, struct xt_pknock_rule, head);
+
+		if (rulecmp(info, rule)) {
+			found = 1;
+			rule->ref_count--;
+			break;
+		}
+	}
+	if (!found) {
+		pr_debug("(N) rule not found: %s.\n", info->rule_name);
+		return;
+	}
+	if (rule == NULL || rule->ref_count != 0)
+		return;
+
+	hashtable_for_each_safe(pos, n, rule->peer_head, peer_hashsize, i) {
+		peer = list_entry(pos, struct peer, head);
+		pk_debug("DELETED", peer);
+		list_del(pos);
+		kfree(peer);
+	}
+
+	if (rule->status_proc != NULL)
+		remove_proc_entry(info->rule_name, pde);
+	pr_debug("(D) rule deleted: %s.\n", rule->rule_name);
+	if (timer_pending(&rule->timer))
+		del_timer(&rule->timer);
+
+	list_del(&rule->head);
+	kfree(rule->peer_head);
+	kfree(rule);
+}
+
+/**
+ * If peer status exist in the list it returns peer status, if not it returns NULL.
+ *
+ * @rule
+ * @ip
+ * @return: peer or NULL
+ */
+static struct peer *get_peer(struct xt_pknock_rule *rule, __be32 ip)
+{
+	struct peer *peer;
+	struct list_head *pos, *n;
+	unsigned int hash;
+
+	hash = pknock_hash(&ip, sizeof(ip), ipt_pknock_hash_rnd, peer_hashsize);
+
+	list_for_each_safe(pos, n, &rule->peer_head[hash]) {
+		peer = list_entry(pos, struct peer, head);
+		if (peer->ip == ip)
+			return peer;
+	}
+	return NULL;
+}
+
+/**
+ * Reset the knock sequence status of the peer.
+ *
+ * @peer
+ */
+static void reset_knock_status(struct peer *peer)
+{
+	peer->accepted_knock_count = 0;
+	peer->status = ST_INIT;
+}
+
+/**
+ * It creates a new peer matching status.
+ *
+ * @rule
+ * @ip
+ * @proto
+ * @return: peer or NULL
+ */
+static struct peer *new_peer(__be32 ip, uint8_t proto)
+{
+	struct peer *peer = kmalloc(sizeof(*peer), GFP_ATOMIC);
+
+	if (peer == NULL)
+		return NULL;
+
+	INIT_LIST_HEAD(&peer->head);
+	peer->ip	= ip;
+	peer->proto	= proto;
+	peer->timestamp = jiffies/HZ;
+	peer->login_sec = 0;
+	reset_knock_status(peer);
+
+	return peer;
+}
+
+/**
+ * It adds a new peer matching status to the list.
+ *
+ * @peer
+ * @rule
+ */
+static void add_peer(struct peer *peer, struct xt_pknock_rule *rule)
+{
+	unsigned int hash = pknock_hash(&peer->ip, sizeof(peer->ip),
+                                ipt_pknock_hash_rnd, peer_hashsize);
+	list_add(&peer->head, &rule->peer_head[hash]);
+}
+
+/**
+ * It removes a peer matching status.
+ *
+ * @peer
+ */
+static void remove_peer(struct peer *peer)
+{
+	list_del(&peer->head);
+	if (peer != NULL)
+		kfree(peer);
+}
+
+/**
+ * @peer
+ * @info
+ * @port
+ * @return: 1 success, 0 failure
+ */
+static inline bool
+is_first_knock(const struct peer *peer, const struct xt_pknock_mtinfo *info,
+                uint16_t port)
+{
+	return peer == NULL && info->port[0] == port;
+}
+
+/**
+ * @peer
+ * @info
+ * @port
+ * @return: 1 success, 0 failure
+ */
+static inline bool
+is_wrong_knock(const struct peer *peer, const struct xt_pknock_mtinfo *info,
+		uint16_t port)
+{
+	return peer != NULL && info->port[peer->accepted_knock_count] != port;
+}
+
+/**
+ * @peer
+ * @info
+ * @return: 1 success, 0 failure
+ */
+static inline bool
+is_last_knock(const struct peer *peer, const struct xt_pknock_mtinfo *info)
+{
+	return peer != NULL && peer->accepted_knock_count == info->ports_count;
+}
+
+/**
+ * @peer
+ * @return: 1 success, 0 failure
+ */
+static inline bool
+is_allowed(const struct peer *peer)
+{
+	return peer != NULL && peer->status == ST_ALLOWED;
+}
+
+/**
+ * Sends a message to user space through netlink sockets.
+ *
+ * @info
+ * @peer
+ * @return: 1 success, 0 otherwise
+ */
+static bool
+msg_to_userspace_nl(const struct xt_pknock_mtinfo *info,
+                const struct peer *peer, int multicast_group)
+{
+#if defined(CONFIG_CONNECTOR) || defined(CONFIG_CONNECTOR_MODULE)
+	struct cn_msg *m;
+	struct xt_pknock_nl_msg msg;
+
+	m = kmalloc(sizeof(*m) + sizeof(msg), GFP_ATOMIC);
+	if (m == NULL)
+		return false;
+
+	memset(m, 0, sizeof(*m) + sizeof(msg));
+	m->seq = 0;
+	m->len = sizeof(msg);
+
+	msg.peer_ip = peer->ip;
+	scnprintf(msg.rule_name, info->rule_name_len + 1, info->rule_name);
+
+	memcpy(m + 1, &msg, m->len);
+
+	cn_netlink_send(m, multicast_group, GFP_ATOMIC);
+
+	kfree(m);
+#endif
+	return true;
+}
+
+#ifdef PK_CRYPTO
+/**
+ * Transforms a sequence of characters to hexadecimal.
+ *
+ * @out: the hexadecimal result
+ * @crypt: the original sequence
+ * @size
+ */
+static void
+crypt_to_hex(char *out, const char *crypt, unsigned int size)
+{
+	unsigned int i;
+	for (i = 0; i < size; ++i) {
+		unsigned char c = crypt[i];
+		*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);
+		*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);
+	}
+}
+
+/**
+ * Checks that the payload has the hmac(secret+ipsrc+epoch_min).
+ *
+ * @secret
+ * @secret_len
+ * @ipsrc
+ * @payload
+ * @payload_len
+ * @return: 1 success, 0 failure
+ */
+static bool
+has_secret(const unsigned char *secret, unsigned int secret_len, uint32_t ipsrc,
+    const unsigned char *payload, unsigned int payload_len)
+{
+	struct scatterlist sg[2];
+	char result[64]; // 64 bytes * 8 = 512 bits
+	char *hexresult;
+	unsigned int hexa_size;
+	int ret;
+	bool fret = false;
+	unsigned int epoch_min;
+
+	if (payload_len == 0)
+		return false;
+
+	/*
+	 * hexa:  4bits
+	 * ascii: 8bits
+	 * hexa = ascii * 2
+	 */
+	hexa_size = crypto.size * 2;
+
+	/* + 1 cause we MUST add NULL in the payload */
+	if (payload_len != hexa_size + 1)
+		return false;
+
+	hexresult = kmalloc(hexa_size, GFP_ATOMIC);
+	if (hexresult == NULL)
+		return false;
+
+	memset(result, 0, sizeof(result));
+	memset(hexresult, 0, hexa_size);
+
+	epoch_min = get_seconds() / 60;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+	sg_init_table(sg, ARRAY_SIZE(sg));
+#endif
+	sg_set_buf(&sg[0], &ipsrc, sizeof(ipsrc));
+	sg_set_buf(&sg[1], &epoch_min, sizeof(epoch_min));
+
+	ret = crypto_hash_setkey(crypto.tfm, secret, secret_len);
+	if (ret != 0) {
+		printk("crypto_hash_setkey() failed ret=%d\n", ret);
+		goto out;
+	}
+
+	/*
+	 * The third parameter is the number of bytes INSIDE the sg!
+	 * 4 bytes IP (32 bits) +
+	 * 4 bytes int epoch_min (32 bits)
+	 */
+	ret = crypto_hash_digest(&crypto.desc, sg,
+	      sizeof(ipsrc) + sizeof(epoch_min), result);
+	if (ret != 0) {
+		printk("crypto_hash_digest() failed ret=%d\n", ret);
+		goto out;
+	}
+
+	crypt_to_hex(hexresult, result, crypto.size);
+
+	if (memcmp(hexresult, payload, hexa_size) != 0)
+		pr_debug("secret match failed\n");
+	else
+		fret = true;
+
+ out:
+	kfree(hexresult);
+	return fret;
+}
+#endif /* PK_CRYPTO */
+
+/**
+ * If the peer pass the security policy.
+ *
+ * @peer
+ * @info
+ * @payload
+ * @payload_len
+ * @return: 1 if pass security, 0 otherwise
+ */
+static bool
+pass_security(struct peer *peer, const struct xt_pknock_mtinfo *info,
+        const unsigned char *payload, unsigned int payload_len)
+{
+	if (is_allowed(peer))
+		return true;
+
+	/* The peer can't log more than once during the same minute. */
+	if (has_logged_during_this_minute(peer)) {
+		pk_debug("DENIED (anti-spoof protection)", peer);
+		return false;
+	}
+#ifdef PK_CRYPTO
+	/* Check for OPEN secret */
+	if (has_secret(info->open_secret,
+					info->open_secret_len, peer->ip,
+					payload, payload_len))
+		return true;
+#endif
+
+	return false;
+}
+
+/**
+ * Validates the peer and updates the peer status for an initiating or
+ * in-sequence knock packet.
+ *
+ * @peer
+ * @info
+ * @rule
+ * @hdr
+ *
+ * Returns true if allowed, false otherwise.
+ */
+static bool
+update_peer(struct peer *peer, const struct xt_pknock_mtinfo *info,
+		struct xt_pknock_rule *rule,
+		const struct transport_data *hdr)
+{
+	unsigned long time;
+
+	if (is_wrong_knock(peer, info, hdr->port)) {
+		pk_debug("DIDN'T MATCH", peer);
+		/* Peer must start the sequence from scratch. */
+		if (info->option & XT_PKNOCK_STRICT)
+			remove_peer(peer);
+
+		return false;
+	}
+
+	/* If security is needed. */
+	if (info->option & XT_PKNOCK_OPENSECRET ) {
+		if (hdr->proto != IPPROTO_UDP && hdr->proto != IPPROTO_UDPLITE)
+			return false;
+
+		if (!pass_security(peer, info, hdr->payload, hdr->payload_len))
+			return false;
+	}
+
+	/* Update the gc timer when there is a state change. */
+	update_rule_gc_timer(rule);
+
+	++peer->accepted_knock_count;
+
+	if (is_last_knock(peer, info)) {
+		peer->status = ST_ALLOWED;
+
+		pk_debug("ALLOWED", peer);
+		peer->login_sec = get_seconds();
+
+		if (nl_multicast_group > 0)
+			msg_to_userspace_nl(info, peer, nl_multicast_group);
+
+		return true;
+	}
+
+	/* Immediate control over the maximum time between knocks. */
+	if (info->option & XT_PKNOCK_TIME) {
+		time = jiffies/HZ;
+
+		if (is_interknock_time_exceeded(peer, info->max_time)) {
+			pk_debug("ST_MATCHING knock received after interknock "
+				"time passed => destroyed", peer);
+			pr_debug("max_time: %ld - time: %ld\n",
+					peer->timestamp + info->max_time,
+					time);
+			remove_peer(peer);
+			return false;
+		}
+		peer->timestamp = time;
+	}
+	pk_debug("MATCHING", peer);
+	peer->status = ST_MATCHING;
+	return false;
+}
+
+/**
+ * Make the peer no more ALLOWED sending a payload with a special secret for
+ * closure.
+ *
+ * @peer
+ * @info
+ * @payload
+ * @payload_len
+ * @return: 1 if close knock, 0 otherwise
+ */
+static bool
+is_close_knock(const struct peer *peer, const struct xt_pknock_mtinfo *info,
+		const unsigned char *payload, unsigned int payload_len)
+{
+#ifdef PK_CRYPTO
+	/* Check for CLOSE secret. */
+	if (has_secret(info->close_secret,
+				info->close_secret_len, peer->ip,
+				payload, payload_len))
+	{
+		pk_debug("BLOCKED", peer);
+		return true;
+	}
+#endif
+	return false;
+}
+
+static bool pknock_mt(const struct sk_buff *skb,
+    struct xt_action_param *par)
+{
+	const struct xt_pknock_mtinfo *info = par->matchinfo;
+	struct xt_pknock_rule *rule;
+	struct peer *peer;
+	const struct iphdr *iph = ip_hdr(skb);
+	unsigned int hdr_len = 0;
+	__be16 _ports[2];
+	const __be16 *pptr;
+	struct transport_data hdr = {0, 0, 0, NULL};
+	bool ret = false;
+
+	pptr = skb_header_pointer(skb, par->thoff, sizeof _ports, &_ports);
+	if (pptr == NULL) {
+		/* We've been asked to examine this packet, and we
+		 * can't. Hence, no choice but to drop.
+		 */
+		par->hotdrop = true;
+		return false;
+	}
+
+	hdr.port = ntohs(pptr[1]);
+	hdr.proto = iph->protocol;
+
+	switch (hdr.proto) {
+	case IPPROTO_TCP:
+		break;
+
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+#ifdef PK_CRYPTO
+		hdr_len = (iph->ihl * 4) + sizeof(struct udphdr);
+		break;
+#else
+		pr_debug("UDP protocol not supported\n");
+		return false;
+#endif
+
+	default:
+		pr_debug("IP payload protocol is neither tcp nor udp.\n");
+		return false;
+	}
+
+	spin_lock_bh(&list_lock);
+
+	/* Searches a rule from the list depending on info structure options. */
+	rule = search_rule(info);
+	if (rule == NULL) {
+		printk(KERN_INFO PKNOCK "The rule %s doesn't exist.\n",
+						info->rule_name);
+		goto out;
+	}
+
+	/* Gives the peer matching status added to rule depending on ip src. */
+	peer = get_peer(rule, iph->saddr);
+
+	if (info->option & XT_PKNOCK_CHECKIP) {
+		ret = is_allowed(peer);
+		goto out;
+	}
+
+	if (iph->protocol == IPPROTO_UDP || iph->protocol == IPPROTO_UDPLITE) {
+		hdr.payload = (void *)iph + hdr_len;
+		hdr.payload_len = skb->len - hdr_len;
+	}
+
+	/* Sets, updates, removes or checks the peer matching status. */
+	if (info->option & XT_PKNOCK_KNOCKPORT) {
+		if ((ret = is_allowed(peer))) {
+			if (info->option & XT_PKNOCK_CLOSESECRET &&
+			    (iph->protocol == IPPROTO_UDP ||
+			    iph->protocol == IPPROTO_UDPLITE))
+			{
+				if (is_close_knock(peer, info, hdr.payload, hdr.payload_len))
+				{
+					reset_knock_status(peer);
+					ret = false;
+				}
+			}
+			goto out;
+		}
+
+		if (is_first_knock(peer, info, hdr.port)) {
+			peer = new_peer(iph->saddr, iph->protocol);
+			add_peer(peer, rule);
+		}
+
+		if (peer == NULL)
+			goto out;
+
+		update_peer(peer, info, rule, &hdr);
+	}
+
+out:
+	/* Handle cur.peer matching and deletion after autoclose_time passed */
+	if (ret && autoclose_time_passed(peer, rule->autoclose_time)) {
+		pk_debug("AUTOCLOSE TIME PASSED => BLOCKED", peer);
+		ret = false;
+		if (iph->protocol == IPPROTO_TCP ||
+		    !has_logged_during_this_minute(peer))
+			remove_peer(peer);
+	}
+
+	if (ret)
+		pk_debug("PASS OK", peer);
+	spin_unlock_bh(&list_lock);
+	return ret;
+}
+
+#define RETURN_ERR(err) do { printk(KERN_ERR PKNOCK err); return -EINVAL; } while (false)
+
+static int pknock_mt_check(const struct xt_mtchk_param *par)
+{
+	struct xt_pknock_mtinfo *info = par->matchinfo;
+
+	/* Singleton. */
+	if (rule_hashtable == NULL) {
+		rule_hashtable = alloc_hashtable(rule_hashsize);
+		if (rule_hashtable == NULL)
+			RETURN_ERR("alloc_hashtable() error in checkentry()\n");
+
+		get_random_bytes(&ipt_pknock_hash_rnd, sizeof (ipt_pknock_hash_rnd));
+	}
+
+	if (!(info->option & XT_PKNOCK_NAME))
+		RETURN_ERR("You must specify --name option.\n");
+
+#ifndef PK_CRYPTO
+	if (info->option & (XT_PKNOCK_OPENSECRET | XT_PKNOCK_CLOSESECRET))
+		RETURN_ERR("No crypto support available; "
+			"cannot use opensecret/closescret\n");
+#endif
+	if (info->option & XT_PKNOCK_OPENSECRET && info->ports_count != 1)
+		RETURN_ERR("--opensecret must have just one knock port\n");
+	if (info->option & XT_PKNOCK_KNOCKPORT) {
+		if (info->option & XT_PKNOCK_CHECKIP)
+			RETURN_ERR("Can't specify --knockports with --checkip.\n");
+		if (info->option & XT_PKNOCK_OPENSECRET &&
+				!(info->option & XT_PKNOCK_CLOSESECRET))
+			RETURN_ERR("--opensecret must go with --closesecret.\n");
+		if (info->option & XT_PKNOCK_CLOSESECRET &&
+				!(info->option & XT_PKNOCK_OPENSECRET))
+			RETURN_ERR("--closesecret must go with --opensecret.\n");
+	}
+
+	if (info->option & XT_PKNOCK_CHECKIP) {
+		if (info->option & XT_PKNOCK_KNOCKPORT)
+			RETURN_ERR("Can't specify --checkip with --knockports.\n");
+		if ((info->option & XT_PKNOCK_OPENSECRET) ||
+				(info->option & XT_PKNOCK_CLOSESECRET))
+			RETURN_ERR("Can't specify --opensecret and --closesecret"
+							" with --checkip.\n");
+		if (info->option & XT_PKNOCK_TIME)
+			RETURN_ERR("Can't specify --time with --checkip.\n");
+		if (info->option & XT_PKNOCK_AUTOCLOSE)
+			RETURN_ERR("Can't specify --autoclose with --checkip.\n");
+	} else if (!(info->option & (XT_PKNOCK_OPENSECRET | XT_PKNOCK_TIME))) {
+		RETURN_ERR("you must specify --time.\n");
+	}
+
+	if (info->option & XT_PKNOCK_OPENSECRET &&
+	    info->open_secret_len == info->close_secret_len &&
+	    memcmp(info->open_secret, info->close_secret,
+	    info->open_secret_len) == 0)
+		RETURN_ERR("opensecret & closesecret cannot be equal.\n");
+
+	if (!add_rule(info))
+		/* should ENOMEM here */
+		RETURN_ERR("add_rule() error in checkentry() function.\n");
+
+	return 0;
+}
+
+static void pknock_mt_destroy(const struct xt_mtdtor_param *par)
+{
+	struct xt_pknock_mtinfo *info = par->matchinfo;
+	/* Removes a rule only if it exits and ref_count is equal to 0. */
+	remove_rule(info);
+}
+
+static struct xt_match xt_pknock_mt_reg __read_mostly = {
+	.name		= "pknock",
+	.revision   = 1,
+	.family		= NFPROTO_IPV4,
+	.matchsize  = sizeof(struct xt_pknock_mtinfo),
+	.match      = pknock_mt,
+	.checkentry = pknock_mt_check,
+	.destroy    = pknock_mt_destroy,
+	.me			= THIS_MODULE
+};
+
+static int __init xt_pknock_mt_init(void)
+{
+#if !defined(CONFIG_CONNECTOR) && !defined(CONFIG_CONNECTOR_MODULE)
+	if (nl_multicast_group != -1)
+		pr_info("CONFIG_CONNECTOR not present; "
+		        "netlink messages disabled\n");
+#endif
+
+	if (gc_expir_time < DEFAULT_GC_EXPIRATION_TIME)
+		gc_expir_time = DEFAULT_GC_EXPIRATION_TIME;
+#ifdef PK_CRYPTO
+	if (request_module(crypto.algo) < 0) {
+		printk(KERN_ERR PKNOCK "request_module('%s') error.\n",
+                        crypto.algo);
+		return -ENXIO;
+	}
+
+	crypto.tfm = crypto_alloc_hash(crypto.algo, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(crypto.tfm)) {
+		printk(KERN_ERR PKNOCK "failed to load transform for %s\n",
+						crypto.algo);
+		return PTR_ERR(crypto.tfm);
+	}
+
+	crypto.size = crypto_hash_digestsize(crypto.tfm);
+	crypto.desc.tfm = crypto.tfm;
+	crypto.desc.flags = 0;
+#else
+	pr_info("No crypto support for < 2.6.19\n");
+#endif
+
+	pde = proc_mkdir("xt_pknock", init_net__proc_net);
+	if (pde == NULL) {
+		printk(KERN_ERR PKNOCK "proc_mkdir() error in _init().\n");
+		return -ENXIO;
+	}
+	return xt_register_match(&xt_pknock_mt_reg);
+}
+
+static void __exit xt_pknock_mt_exit(void)
+{
+	remove_proc_entry("xt_pknock", init_net__proc_net);
+	xt_unregister_match(&xt_pknock_mt_reg);
+	kfree(rule_hashtable);
+
+#ifdef PK_CRYPTO
+	if (crypto.tfm != NULL)
+		crypto_free_hash(crypto.tfm);
+#endif
+}
+
+module_init(xt_pknock_mt_init);
+module_exit(xt_pknock_mt_exit);

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_pknock.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_pknock.h
@@ -0,0 +1,53 @@
+/*
+ * Kernel module to implement Port Knocking and SPA matching support.
+ *
+ * (C) 2006-2008 J. Federico Hernandez <fede.hernandez@gmail.com>
+ * (C) 2006 Luis Floreani <luis.floreani@gmail.com>
+ *
+ * $Id$
+ *
+ * This program is released under the terms of GNU GPL version 2.
+ */
+#ifndef _XT_PKNOCK_H
+#define _XT_PKNOCK_H
+
+#define PKNOCK "xt_pknock: "
+
+enum {
+	XT_PKNOCK_KNOCKPORT   = 1 << 0,
+	XT_PKNOCK_TIME        = 1 << 1,
+	XT_PKNOCK_NAME        = 1 << 2,
+	XT_PKNOCK_STRICT      = 1 << 3,
+	XT_PKNOCK_CHECKIP     = 1 << 4,
+	XT_PKNOCK_OPENSECRET  = 1 << 5,
+	XT_PKNOCK_CLOSESECRET = 1 << 6,
+	XT_PKNOCK_AUTOCLOSE   = 1 << 7,
+
+	/* Can never change these, as they are make up the user protocol. */
+	XT_PKNOCK_MAX_PORTS      = 15,
+	XT_PKNOCK_MAX_BUF_LEN    = 31,
+	XT_PKNOCK_MAX_PASSWD_LEN = 31,
+};
+
+#define DEBUG 1
+
+struct xt_pknock_mtinfo {
+	char rule_name[XT_PKNOCK_MAX_BUF_LEN+1];
+	uint32_t			rule_name_len;
+	char open_secret[XT_PKNOCK_MAX_PASSWD_LEN+1];
+	uint32_t			open_secret_len;
+	char close_secret[XT_PKNOCK_MAX_PASSWD_LEN+1];
+	uint32_t			close_secret_len;
+	uint8_t	option;		/* --time, --knock-port, ... */
+	uint8_t	ports_count;	/* number of ports */
+	uint16_t	port[XT_PKNOCK_MAX_PORTS]; /* port[,port,port,...] */
+	uint32_t	max_time;	/* max matching time between ports */
+	uint32_t autoclose_time;
+};
+
+struct xt_pknock_nl_msg {
+	char rule_name[XT_PKNOCK_MAX_BUF_LEN+1];
+	__be32 peer_ip;
+};
+
+#endif /* _XT_PKNOCK_H */

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_psd.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_psd.c
@@ -0,0 +1,601 @@
+/*
+  This is a module which is used for PSD (portscan detection)
+  Derived from scanlogd v2.1 written by Solar Designer <solar@false.com>
+  and LOG target module.
+
+  Copyright (C) 2000,2001 astaro AG
+
+  This file is distributed under the terms of the GNU General Public
+  License (GPL). Copies of the GPL can be obtained from:
+     ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+  2000-05-04 Markus Hennig <hennig@astaro.de> : initial
+  2000-08-18 Dennis Koslowski <koslowski@astaro.de> : first release
+  2000-12-01 Dennis Koslowski <koslowski@astaro.de> : UDP scans detection added
+  2001-01-02 Dennis Koslowski <koslowski@astaro.de> : output modified
+  2001-02-04 Jan Rekorajski <baggins@pld.org.pl> : converted from target to match
+  2004-05-05 Martijn Lievaart <m@rtij.nl> : ported to 2.6
+  2007-04-05 Mohd Nawawi Mohamad Jamili <nawawi@tracenetworkcorporation.com> : ported to 2.6.18
+  2008-03-21 Mohd Nawawi Mohamad Jamili <nawawi@tracenetworkcorporation.com> : ported to 2.6.24
+  2009-08-07 Mohd Nawawi Mohamad Jamili <nawawi@tracenetworkcorporation.com> : ported to xtables-addons
+*/
+
+#define pr_fmt(x) KBUILD_MODNAME ": " x
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/types.h>
+#include <linux/tcp.h>
+#include <linux/spinlock.h>
+#include <linux/vmalloc.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include "xt_psd.h"
+#include "compat_xtables.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Dennis Koslowski <koslowski@astaro.com>");
+MODULE_AUTHOR("Martijn Lievaart <m@rtij.nl>");
+MODULE_AUTHOR("Jan Rekorajski <baggins@pld.org.pl>");
+MODULE_AUTHOR(" Mohd Nawawi Mohamad Jamili <nawawi@tracenetworkcorporation.com>");
+MODULE_DESCRIPTION("Xtables: PSD - portscan detection");
+MODULE_ALIAS("ipt_psd");
+MODULE_ALIAS("ip6t_psd");
+
+/*
+ * Keep track of up to LIST_SIZE source addresses, using a hash table of
+ * HASH_SIZE entries for faster lookups, but limiting hash collisions to
+ * HASH_MAX source addresses per the same hash value.
+ */
+#define LIST_SIZE			0x100
+#define HASH_LOG			9
+#define HASH_SIZE			(1 << HASH_LOG)
+#define HASH_MAX			0x10
+
+#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
+#	define WITH_IPV6 1
+#endif
+
+/*
+ * Information we keep per each target port
+ */
+struct port {
+	u_int16_t number;      /* port number */
+	u_int8_t proto;        /* protocol number */
+};
+
+/**
+ * Information we keep per each source address.
+ * @next:	next entry with the same hash
+ * @timestamp:	last update time
+ * @count:	number of ports in the list
+ * @weight:	total weight of ports in the list
+ */
+struct host {
+	struct host *next;
+	unsigned long timestamp;
+	__be16 src_port;
+	uint16_t count;
+	uint8_t weight;
+	struct port ports[SCAN_MAX_COUNT-1];
+};
+
+/**
+ * Information we keep per ipv4 source address.
+ */
+struct host4 {
+	struct host host;
+	__be32 saddr;
+};
+
+static struct host4 *host_to_host4(const struct host *h)
+{
+	return (struct host4 *)h;
+}
+
+struct host6 {
+	struct host host;
+	struct in6_addr saddr;
+};
+
+/**
+ * State information for IPv4 portscan detection.
+ * @list:	list of source addresses
+ * @hash:	pointers into the list
+ * @index:	oldest entry to be replaced
+ */
+static struct {
+	spinlock_t lock;
+	struct host4 list[LIST_SIZE];
+	struct host *hash[HASH_SIZE];
+	int index;
+} state;
+
+#ifdef WITH_IPV6
+/**
+ * State information for IPv6 portscan detection.
+ * @list:	list of source addresses
+ * @hash:	pointers into the list
+ * @index:	oldest entry to be replaced
+ */
+static struct {
+	spinlock_t lock;
+	struct host6 *list;
+	struct host **hash;
+	int index;
+} state6;
+
+static struct host6 *host_to_host6(const struct host *h)
+{
+	return (struct host6 *) h;
+}
+
+/**
+ * allocate state6 memory only when needed
+ */
+static bool state6_alloc_mem(void)
+{
+	if (state6.hash != NULL)
+		return true;
+
+	state6.list = vmalloc(LIST_SIZE * sizeof(struct host6));
+	if (state6.list == NULL)
+		return false;
+	memset(state6.list, 0, LIST_SIZE * sizeof(struct host6));
+
+	state6.hash = vmalloc(HASH_SIZE * sizeof(struct host*));
+	if (state6.hash == NULL) {
+		vfree(state6.list);
+		return false;
+	}
+	memset(state6.hash, 0, HASH_SIZE * sizeof(struct host *));
+	return true;
+}
+#endif
+
+/*
+ * Convert an IP address into a hash table index.
+ */
+static unsigned int hashfunc(__be32 addr)
+{
+	unsigned int value;
+	unsigned int hash;
+
+	value = addr;
+	hash = 0;
+	do {
+		hash ^= value;
+	} while ((value >>= HASH_LOG) != 0);
+
+	return hash & (HASH_SIZE - 1);
+}
+
+static inline unsigned int hashfunc6(const struct in6_addr *addr)
+{
+	__be32 h = addr->s6_addr32[0] ^ addr->s6_addr32[1];
+	return hashfunc(h ^ addr->s6_addr32[2] ^ addr->s6_addr32[3]);
+}
+
+static bool port_in_list(struct host *host, uint8_t proto, uint16_t port)
+{
+	unsigned int i;
+
+	for (i = 0; i < host->count; ++i) {
+		if (host->ports[i].proto != proto)
+			continue;
+		if (host->ports[i].number == port)
+			return true;
+	}
+	return false;
+}
+
+static uint16_t get_port_weight(const struct xt_psd_info *psd, __be16 port)
+{
+	return ntohs(port) < 1024 ? psd->lo_ports_weight : psd->hi_ports_weight;
+}
+
+static bool
+is_portscan(struct host *host, const struct xt_psd_info *psdinfo,
+            const struct tcphdr *tcph, uint8_t proto)
+{
+	if (port_in_list(host, proto, tcph->dest))
+		return false;
+
+	/*
+	 * TCP/ACK and/or TCP/RST to a new port? This could be an
+	 * outgoing connection.
+	 */
+	if (proto == IPPROTO_TCP && (tcph->ack || tcph->rst))
+		return false;
+
+	host->timestamp = jiffies;
+
+	if (host->weight >= psdinfo->weight_threshold) /* already matched */
+		return true;
+
+	/* Update the total weight */
+	host->weight += get_port_weight(psdinfo, tcph->dest);
+
+	/* Got enough destination ports to decide that this is a scan? */
+	if (host->weight >= psdinfo->weight_threshold)
+		return true;
+
+	/* Remember the new port */
+	if (host->count < ARRAY_SIZE(host->ports)) {
+		host->ports[host->count].number = tcph->dest;
+		host->ports[host->count].proto = proto;
+		host->count++;
+	}
+	return false;
+}
+
+static struct host *host_get_next(struct host *h, struct host **last)
+{
+	if (h->next != NULL)
+		*last = h;
+	return h->next;
+}
+
+static void ht_unlink(struct host **head, struct host *last)
+{
+	if (last != NULL)
+		last->next = last->next->next;
+	else if (*head != NULL)
+		*head = (*head)->next;
+}
+
+static bool
+entry_is_recent(const struct host *h, unsigned long delay_threshold,
+                unsigned long now)
+{
+	return now - h->timestamp <= (delay_threshold * HZ) / 100 &&
+	       time_after_eq(now, h->timestamp);
+}
+
+static void remove_oldest(struct host **head, struct host *curr)
+{
+	struct host *h, *last = NULL;
+
+	/*
+	 * We are going to re-use the oldest list entry, so remove it from the
+	 * hash table first, if it is really already in use.
+	 */
+	h = *head;
+	while (h != NULL) {
+		if (curr == h)
+			break;
+		last = h;
+		h = h->next;
+	}
+
+	/* Then, remove it */
+	if (h != NULL)
+		ht_unlink(head, last);
+}
+
+static void *
+get_header_pointer4(const struct sk_buff *skb, unsigned int thoff, void *mem)
+{
+	const struct iphdr *iph = ip_hdr(skb);
+	int hdrlen;
+
+	switch (iph->protocol) {
+	case IPPROTO_TCP:
+		hdrlen = sizeof(struct tcphdr);
+		break;
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+		hdrlen = sizeof(struct udphdr);
+		break;
+	default:
+		return NULL;
+	}
+
+	return skb_header_pointer(skb, thoff, hdrlen, mem);
+}
+
+static bool
+handle_packet4(const struct iphdr *iph, const struct tcphdr *tcph,
+               const struct xt_psd_info *psdinfo, unsigned int hash)
+{
+	unsigned long now;
+	struct host *curr, *last = NULL, **head;
+	struct host4 *curr4;
+	int count = 0;
+
+	now = jiffies;
+	head = &state.hash[hash];
+
+	/* Do we know this source address already? */
+	curr = *head;
+	while (curr != NULL) {
+		curr4 = host_to_host4(curr);
+		if (curr4->saddr == iph->saddr)
+			break;
+		count++;
+		curr = host_get_next(curr, &last);
+	}
+
+	if (curr != NULL) {
+		/* We know this address, and the entry isn't too old. Update it. */
+		if (entry_is_recent(curr, psdinfo->delay_threshold, now))
+			return is_portscan(curr, psdinfo, tcph, iph->protocol);
+
+		/* We know this address, but the entry is outdated. Mark it unused, and
+		 * remove from the hash table. We'll allocate a new entry instead since
+		 * this one might get re-used too soon. */
+		curr4 = host_to_host4(curr);
+		curr4->saddr = 0;
+		ht_unlink(head, last);
+		last = NULL;
+	}
+
+	/* We don't need an ACK from a new source address */
+	if (iph->protocol == IPPROTO_TCP && tcph->ack)
+		return false;
+
+	/* Got too many source addresses with the same hash value? Then remove the
+	 * oldest one from the hash table, so that they can't take too much of our
+	 * CPU time even with carefully chosen spoofed IP addresses. */
+	if (count >= HASH_MAX && last != NULL)
+		last->next = NULL;
+
+	if (state.list[state.index].saddr != 0)
+		head = &state.hash[hashfunc(state.list[state.index].saddr)];
+	else
+		head = &last;
+
+	/* Get our list entry */
+	curr4 = &state.list[state.index++];
+	curr = &curr4->host;
+	remove_oldest(head, curr);
+	if (state.index >= LIST_SIZE)
+		state.index = 0;
+
+	/* Link it into the hash table */
+	head = &state.hash[hash];
+	curr->next = *head;
+	*head = curr;
+
+	/* And fill in the fields */
+	curr4 = host_to_host4(curr);
+	curr4->saddr = iph->saddr;
+	curr->timestamp = now;
+	curr->count = 1;
+	curr->weight = get_port_weight(psdinfo, tcph->dest);
+	curr->ports[0].number = tcph->dest;
+	curr->ports[0].proto = iph->protocol;
+	return false;
+}
+
+static bool
+xt_psd_match(const struct sk_buff *pskb, struct xt_action_param *match)
+{
+	struct iphdr *iph = ip_hdr(pskb);
+	struct tcphdr _tcph;
+	struct tcphdr *tcph;
+	bool matched;
+	unsigned int hash;
+	/* Parameters from userspace */
+	const struct xt_psd_info *psdinfo = match->matchinfo;
+
+	if (iph->frag_off & htons(IP_OFFSET)) {
+		pr_debug("sanity check failed\n");
+		return false;
+	}
+
+	/*
+	 * We are using IP address 0.0.0.0 for a special purpose here, so do
+	 * not let them spoof us. [DHCP needs this feature - HW]
+	 */
+	if (iph->saddr == 0) {
+		pr_debug("spoofed source address (0.0.0.0)\n");
+		return false;
+	}
+
+	tcph = get_header_pointer4(pskb, match->thoff, &_tcph);
+	if (tcph == NULL)
+		return false;
+
+	hash = hashfunc(iph->saddr);
+
+	spin_lock(&state.lock);
+	matched = handle_packet4(iph, tcph, psdinfo, hash);
+	spin_unlock(&state.lock);
+	return matched;
+}
+
+#ifdef WITH_IPV6
+static bool
+handle_packet6(const struct ipv6hdr *ip6h, const struct tcphdr *tcph,
+	       const struct xt_psd_info *psdinfo, uint8_t proto, int hash)
+{
+	unsigned long now;
+	struct host *curr, *last = NULL, **head;
+	struct host6 *curr6;
+	int count = 0;
+
+	now = jiffies;
+	head = &state6.hash[hash];
+
+	curr = *head;
+	while (curr != NULL) {
+		curr6 = host_to_host6(curr);
+		if (ipv6_addr_equal(&curr6->saddr, &ip6h->saddr))
+			break;
+		count++;
+		curr = host_get_next(curr, &last);
+	}
+
+	if (curr != NULL) {
+		if (entry_is_recent(curr, psdinfo->delay_threshold, now))
+			return is_portscan(curr, psdinfo, tcph, proto);
+		curr6 = host_to_host6(curr);
+		memset(&curr6->saddr, 0, sizeof(curr6->saddr));
+		ht_unlink(head, last);
+		last = NULL;
+	}
+
+	if (proto == IPPROTO_TCP && tcph->ack)
+		return false;
+
+	if (count >= HASH_MAX && last != NULL)
+		last->next = NULL;
+
+	if (!ipv6_addr_any(&state6.list[state6.index].saddr))
+		head = &state6.hash[hashfunc6(&state6.list[state6.index].saddr)];
+	else
+		head = &last;
+
+	curr6 = &state6.list[state6.index++];
+	curr = &curr6->host;
+	remove_oldest(head, curr);
+	if (state6.index >= LIST_SIZE)
+		state6.index = 0;
+
+	head = &state6.hash[hash];
+	curr->next = *head;
+	*head = curr;
+
+	curr6 = host_to_host6(curr);
+	curr6->saddr = ip6h->saddr;
+	curr->timestamp = now;
+	curr->count = 1;
+	curr->weight = get_port_weight(psdinfo, tcph->dest);
+	curr->ports[0].number = tcph->dest;
+	curr->ports[0].proto = proto;
+	return false;
+}
+
+static void *
+get_header_pointer6(const struct sk_buff *skb, void *mem, uint8_t *proto)
+{
+	static const uint8_t types[] = {IPPROTO_TCP,
+				        IPPROTO_UDP, IPPROTO_UDPLITE};
+	unsigned int i, offset = 0;
+	int err;
+	size_t hdrlen;
+
+	for (i = 0; i < ARRAY_SIZE(types); ++i) {
+		err = ipv6_find_hdr(skb, &offset, types[i], NULL, NULL);
+		if (err < 0)
+			continue;
+
+		switch (types[i]) {
+		case IPPROTO_TCP:
+			hdrlen = sizeof(struct tcphdr);
+			break;
+		case IPPROTO_UDP:
+		case IPPROTO_UDPLITE:
+			hdrlen = sizeof(struct udphdr);
+			break;
+		default:
+			return NULL;
+		}
+		*proto = types[i];
+		return skb_header_pointer(skb, offset, hdrlen, mem);
+	}
+	return NULL;
+}
+
+static bool
+xt_psd_match6(const struct sk_buff *pskb, struct xt_action_param *match)
+{
+	const struct ipv6hdr *ip6h = ipv6_hdr(pskb);
+	struct tcphdr _tcph;
+	struct tcphdr *tcph;
+	uint8_t proto = 0;
+	bool matched;
+	int hash;
+	const struct xt_psd_info *psdinfo = match->matchinfo;
+
+	if (ipv6_addr_any(&ip6h->saddr))
+		return false;
+
+	tcph = get_header_pointer6(pskb, &_tcph, &proto);
+	if (tcph == NULL)
+		return false;
+
+	hash = hashfunc6(&ip6h->saddr);
+
+	spin_lock(&state6.lock);
+	matched = handle_packet6(ip6h, tcph, psdinfo, proto, hash);
+	spin_unlock(&state6.lock);
+	return matched;
+}
+#endif
+
+static int psd_mt_check(const struct xt_mtchk_param *par)
+{
+	const struct xt_psd_info *info = par->matchinfo;
+
+	if (info->weight_threshold == 0)
+		/* 0 would match on every 1st packet */
+		return -EINVAL;
+
+	if ((info->lo_ports_weight | info->hi_ports_weight) == 0)
+		/* would never match */
+		return -EINVAL;
+
+	if (info->delay_threshold > PSD_MAX_RATE ||
+	    info->weight_threshold > PSD_MAX_RATE ||
+	    info->lo_ports_weight > PSD_MAX_RATE ||
+	    info->hi_ports_weight > PSD_MAX_RATE)
+		return -EINVAL;
+
+	return 0;
+}
+
+#ifdef WITH_IPV6
+static int psd_mt_check6(const struct xt_mtchk_param *par)
+{
+	if (!state6_alloc_mem())
+		return -ENOMEM;
+	return psd_mt_check(par);
+}
+#endif
+
+static struct xt_match xt_psd_reg[] __read_mostly = {
+	{
+		.name       = "psd",
+		.family     = NFPROTO_IPV4,
+		.revision   = 1,
+		.checkentry = psd_mt_check,
+		.match      = xt_psd_match,
+		.matchsize  = sizeof(struct xt_psd_info),
+		.me         = THIS_MODULE,
+#ifdef WITH_IPV6
+	}, {
+		.name       = "psd",
+		.family     = NFPROTO_IPV6,
+		.revision   = 1,
+		.checkentry = psd_mt_check6,
+		.match      = xt_psd_match6,
+		.matchsize  = sizeof(struct xt_psd_info),
+		.me         = THIS_MODULE,
+#endif
+	}
+};
+
+static int __init xt_psd_init(void)
+{
+	spin_lock_init(&(state.lock));
+#ifdef WITH_IPV6
+	spin_lock_init(&(state6.lock));
+#endif
+	return xt_register_matches(xt_psd_reg, ARRAY_SIZE(xt_psd_reg));
+}
+
+static void __exit xt_psd_exit(void)
+{
+        xt_unregister_matches(xt_psd_reg, ARRAY_SIZE(xt_psd_reg));
+#ifdef WITH_IPV6
+	vfree(state6.list);
+	vfree(state6.hash);
+#endif
+}
+
+module_init(xt_psd_init);
+module_exit(xt_psd_exit);
+

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_psd.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_psd.h
@@ -0,0 +1,30 @@
+#ifndef _LINUX_NETFILTER_XT_PSD_H
+#define _LINUX_NETFILTER_XT_PSD_H 1
+
+#include <linux/param.h>
+#include <linux/types.h>
+
+/*
+ * High port numbers have a lower weight to reduce the frequency of false
+ * positives, such as from passive mode FTP transfers.
+ */
+#define PORT_WEIGHT_PRIV		3
+#define PORT_WEIGHT_HIGH		1
+#define	PSD_MAX_RATE			10000
+
+/*
+ * Port scan detection thresholds: at least COUNT ports need to be scanned
+ * from the same source, with no longer than DELAY ticks between ports.
+ */
+#define SCAN_MIN_COUNT			7
+#define SCAN_MAX_COUNT			(SCAN_MIN_COUNT * PORT_WEIGHT_PRIV)
+#define SCAN_WEIGHT_THRESHOLD		SCAN_MAX_COUNT
+
+struct xt_psd_info {
+	__u32 weight_threshold;
+	__u32 delay_threshold;
+	__u16 lo_ports_weight;
+	__u16 hi_ports_weight;
+};
+
+#endif /*_LINUX_NETFILTER_XT_PSD_H*/

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_quota2.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_quota2.c
@@ -0,0 +1,276 @@
+/*
+ * xt_quota2 - enhanced xt_quota that can count upwards and in packets
+ * as a minimal accounting match.
+ * by Jan Engelhardt <jengelh@medozas.de>, 2008
+ *
+ * Originally based on xt_quota.c:
+ * 	Xtables module to enforce network quotas
+ * 	Sam Johnston <samj@samj.net>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License
+ *	version 2, as published by the Free Software Foundation.
+ */
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#include <asm/atomic.h>
+
+#include <linux/netfilter/x_tables.h>
+#include "xt_quota2.h"
+#include "compat_xtables.h"
+
+/**
+ * @lock:	lock to protect quota writers from each other
+ */
+struct xt_quota_counter {
+	u_int64_t quota;
+	spinlock_t lock;
+	struct list_head list;
+	atomic_t ref;
+	char name[sizeof(((struct xt_quota_mtinfo2 *)NULL)->name)];
+	struct proc_dir_entry *procfs_entry;
+};
+
+static LIST_HEAD(counter_list);
+static DEFINE_SPINLOCK(counter_list_lock);
+
+static struct proc_dir_entry *proc_xt_quota;
+static unsigned int quota_list_perms = S_IRUGO | S_IWUSR;
+static unsigned int quota_list_uid   = 0;
+static unsigned int quota_list_gid   = 0;
+module_param_named(perms, quota_list_perms, uint, S_IRUGO | S_IWUSR);
+module_param_named(uid, quota_list_uid, uint, S_IRUGO | S_IWUSR);
+module_param_named(gid, quota_list_gid, uint, S_IRUGO | S_IWUSR);
+
+static int quota_proc_read(char *page, char **start, off_t offset,
+                           int count, int *eof, void *data)
+{
+	struct xt_quota_counter *e = data;
+	int ret;
+
+	spin_lock_bh(&e->lock);
+	ret = snprintf(page, PAGE_SIZE, "%llu\n", e->quota);
+	spin_unlock_bh(&e->lock);
+	return ret;
+}
+
+static int quota_proc_write(struct file *file, const char __user *input,
+                            unsigned long size, void *data)
+{
+	struct xt_quota_counter *e = data;
+	char buf[sizeof("18446744073709551616")];
+
+	if (size > sizeof(buf))
+		size = sizeof(buf);
+	if (copy_from_user(buf, input, size) != 0)
+		return -EFAULT;
+	buf[sizeof(buf)-1] = '\0';
+
+	spin_lock_bh(&e->lock);
+	e->quota = simple_strtoull(buf, NULL, 0);
+	spin_unlock_bh(&e->lock);
+	return size;
+}
+
+static struct xt_quota_counter *
+q2_new_counter(const struct xt_quota_mtinfo2 *q, bool anon)
+{
+	struct xt_quota_counter *e;
+	unsigned int size;
+
+	/* Do not need all the procfs things for anonymous counters. */
+	size = anon ? offsetof(typeof(*e), list) : sizeof(*e);
+	e = kmalloc(size, GFP_KERNEL);
+	if (e == NULL)
+		return NULL;
+
+	e->quota = q->quota;
+	spin_lock_init(&e->lock);
+	if (!anon) {
+		INIT_LIST_HEAD(&e->list);
+		atomic_set(&e->ref, 1);
+		strncpy(e->name, q->name, sizeof(e->name));
+	}
+	return e;
+}
+
+/**
+ * q2_get_counter - get ref to counter or create new
+ * @name:	name of counter
+ */
+static struct xt_quota_counter *
+q2_get_counter(const struct xt_quota_mtinfo2 *q)
+{
+	struct proc_dir_entry *p;
+	struct xt_quota_counter *e;
+
+	if (*q->name == '\0')
+		return q2_new_counter(q, true);
+
+	spin_lock_bh(&counter_list_lock);
+	list_for_each_entry(e, &counter_list, list)
+		if (strcmp(e->name, q->name) == 0) {
+			atomic_inc(&e->ref);
+			spin_unlock_bh(&counter_list_lock);
+			return e;
+		}
+
+	e = q2_new_counter(q, false);
+	if (e == NULL)
+		goto out;
+
+	p = e->procfs_entry = create_proc_entry(e->name, quota_list_perms,
+	                      proc_xt_quota);
+	if (p == NULL || IS_ERR(p))
+		goto out;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 29)
+	p->owner        = THIS_MODULE;
+#endif
+	p->data         = e;
+	p->read_proc    = quota_proc_read;
+	p->write_proc   = quota_proc_write;
+	p->uid          = quota_list_uid;
+	p->gid          = quota_list_gid;
+	list_add_tail(&e->list, &counter_list);
+	spin_unlock_bh(&counter_list_lock);
+	return e;
+
+ out:
+	spin_unlock_bh(&counter_list_lock);
+	kfree(e);
+	return NULL;
+}
+
+static int quota_mt2_check(const struct xt_mtchk_param *par)
+{
+	struct xt_quota_mtinfo2 *q = par->matchinfo;
+
+	if (q->flags & ~XT_QUOTA_MASK)
+		return -EINVAL;
+
+	q->name[sizeof(q->name)-1] = '\0';
+	if (*q->name == '.' || strchr(q->name, '/') != NULL) {
+		printk(KERN_ERR "xt_quota.3: illegal name\n");
+		return -EINVAL;
+	}
+
+	q->master = q2_get_counter(q);
+	if (q->master == NULL) {
+		printk(KERN_ERR "xt_quota.3: memory alloc failure\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void quota_mt2_destroy(const struct xt_mtdtor_param *par)
+{
+	struct xt_quota_mtinfo2 *q = par->matchinfo;
+	struct xt_quota_counter *e = q->master;
+
+	if (*q->name == '\0') {
+		kfree(e);
+		return;
+	}
+
+	spin_lock_bh(&counter_list_lock);
+	if (!atomic_dec_and_test(&e->ref)) {
+		spin_unlock_bh(&counter_list_lock);
+		return;
+	}
+
+	list_del(&e->list);
+	remove_proc_entry(e->name, proc_xt_quota);
+	spin_unlock_bh(&counter_list_lock);
+	kfree(e);
+}
+
+static bool
+quota_mt2(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	struct xt_quota_mtinfo2 *q = (void *)par->matchinfo;
+	struct xt_quota_counter *e = q->master;
+	bool ret = q->flags & XT_QUOTA_INVERT;
+
+	spin_lock_bh(&e->lock);
+	if (q->flags & XT_QUOTA_GROW) {
+		/*
+		 * While no_change is pointless in "grow" mode, we will
+		 * implement it here simply to have a consistent behavior.
+		 */
+		if (!(q->flags & XT_QUOTA_NO_CHANGE)) {
+			e->quota += (q->flags & XT_QUOTA_PACKET) ? 1 : skb->len;
+			q->quota = e->quota;
+		}
+		ret = true;
+	} else {
+		if (e->quota >= skb->len) {
+			if (!(q->flags & XT_QUOTA_NO_CHANGE))
+				e->quota -= (q->flags & XT_QUOTA_PACKET) ? 1 : skb->len;
+			ret = !ret;
+		} else {
+			/* we do not allow even small packets from now on */
+			e->quota = 0;
+		}
+		q->quota = e->quota;
+	}
+	spin_unlock_bh(&e->lock);
+	return ret;
+}
+
+static struct xt_match quota_mt2_reg[] __read_mostly = {
+	{
+		.name       = "quota2",
+		.revision   = 3,
+		.family     = NFPROTO_IPV4,
+		.checkentry = quota_mt2_check,
+		.match      = quota_mt2,
+		.destroy    = quota_mt2_destroy,
+		.matchsize  = sizeof(struct xt_quota_mtinfo2),
+		.me         = THIS_MODULE,
+	},
+	{
+		.name       = "quota2",
+		.revision   = 3,
+		.family     = NFPROTO_IPV6,
+		.checkentry = quota_mt2_check,
+		.match      = quota_mt2,
+		.destroy    = quota_mt2_destroy,
+		.matchsize  = sizeof(struct xt_quota_mtinfo2),
+		.me         = THIS_MODULE,
+	},
+};
+
+static int __init quota_mt2_init(void)
+{
+	int ret;
+
+	proc_xt_quota = proc_mkdir("xt_quota", init_net__proc_net);
+	if (proc_xt_quota == NULL)
+		return -EACCES;
+
+	ret = xt_register_matches(quota_mt2_reg, ARRAY_SIZE(quota_mt2_reg));
+	if (ret < 0)
+		remove_proc_entry("xt_quota", init_net__proc_net);
+	return ret;
+}
+
+static void __exit quota_mt2_exit(void)
+{
+	xt_unregister_matches(quota_mt2_reg, ARRAY_SIZE(quota_mt2_reg));
+	remove_proc_entry("xt_quota", init_net__proc_net);
+}
+
+module_init(quota_mt2_init);
+module_exit(quota_mt2_exit);
+MODULE_DESCRIPTION("Xtables: countdown quota match; up counter");
+MODULE_AUTHOR("Sam Johnston <samj@samj.net>");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_quota2");
+MODULE_ALIAS("ip6t_quota2");

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_quota2.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_quota2.h
@@ -0,0 +1,25 @@
+#ifndef _XT_QUOTA_H
+#define _XT_QUOTA_H
+
+enum xt_quota_flags {
+	XT_QUOTA_INVERT    = 1 << 0,
+	XT_QUOTA_GROW      = 1 << 1,
+	XT_QUOTA_PACKET    = 1 << 2,
+	XT_QUOTA_NO_CHANGE = 1 << 3,
+	XT_QUOTA_MASK      = 0x0F,
+};
+
+struct xt_quota_counter;
+
+struct xt_quota_mtinfo2 {
+	char name[15];
+	u_int8_t flags;
+
+	/* Comparison-invariant */
+	aligned_u64 quota;
+
+	/* Used internally by the kernel */
+	struct xt_quota_counter *master __attribute__((aligned(8)));
+};
+
+#endif /* _XT_QUOTA_H */

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_RAWNAT.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_RAWNAT.c
@@ -0,0 +1,358 @@
+/*
+ *	"RAWNAT" target extension for Xtables - untracked NAT
+ *	Copyright © Jan Engelhardt, 2008 - 2009
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/version.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter/nf_conntrack_common.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include "compat_xtables.h"
+#include "xt_RAWNAT.h"
+#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
+#	define WITH_IPV6 1
+#endif
+
+static inline __be32
+remask(__be32 addr, __be32 repl, unsigned int shift)
+{
+	uint32_t mask = (shift == 32) ? 0 : (~(uint32_t)0 >> shift);
+	return htonl((ntohl(addr) & mask) | (ntohl(repl) & ~mask));
+}
+
+#ifdef WITH_IPV6
+static void
+rawnat_ipv6_mask(__be32 *addr, const __be32 *repl, unsigned int mask)
+{
+	switch (mask) {
+	case 0:
+		break;
+	case 1 ... 31:
+		addr[0] = remask(addr[0], repl[0], mask);
+		break;
+	case 32:
+		addr[0] = repl[0];
+		break;
+	case 33 ... 63:
+		addr[0] = repl[0];
+		addr[1] = remask(addr[1], repl[1], mask - 32);
+		break;
+	case 64:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		break;
+	case 65 ... 95:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		addr[2] = remask(addr[2], repl[2], mask - 64);
+	case 96:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		addr[2] = repl[2];
+		break;
+	case 97 ... 127:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		addr[2] = repl[2];
+		addr[3] = remask(addr[3], repl[3], mask - 96);
+		break;
+	case 128:
+		addr[0] = repl[0];
+		addr[1] = repl[1];
+		addr[2] = repl[2];
+		addr[3] = repl[3];
+		break;
+	}
+}
+#endif
+
+static void rawnat4_update_l4(struct sk_buff *skb, __be32 oldip, __be32 newip)
+{
+	struct iphdr *iph = ip_hdr(skb);
+	void *transport_hdr = (void *)iph + ip_hdrlen(skb);
+	struct tcphdr *tcph;
+	struct udphdr *udph;
+	bool cond;
+
+	switch (iph->protocol) {
+	case IPPROTO_TCP:
+		tcph = transport_hdr;
+		inet_proto_csum_replace4(&tcph->check, skb, oldip, newip, true);
+		break;
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+		udph = transport_hdr;
+		cond = udph->check != 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+		cond |= skb->ip_summed == CHECKSUM_PARTIAL;
+#endif
+		if (cond) {
+			inet_proto_csum_replace4(&udph->check, skb,
+				oldip, newip, true);
+			if (udph->check == 0)
+				udph->check = CSUM_MANGLED_0;
+		}
+		break;
+	}
+}
+
+static unsigned int rawnat4_writable_part(const struct iphdr *iph)
+{
+	unsigned int wlen = sizeof(*iph);
+
+	switch (iph->protocol) {
+	case IPPROTO_TCP:
+		wlen += sizeof(struct tcphdr);
+		break;
+	case IPPROTO_UDP:
+		wlen += sizeof(struct udphdr);
+		break;
+	}
+	return wlen;
+}
+
+static unsigned int
+rawsnat_tg4(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct xt_rawnat_tginfo *info = par->targinfo;
+	struct iphdr *iph;
+	__be32 new_addr;
+
+	iph = ip_hdr(*pskb);
+	new_addr = remask(iph->saddr, info->addr.ip, info->mask);
+	if (iph->saddr == new_addr)
+		return XT_CONTINUE;
+
+	if (!skb_make_writable(pskb, rawnat4_writable_part(iph)))
+		return NF_DROP;
+
+	iph = ip_hdr(*pskb);
+	csum_replace4(&iph->check, iph->saddr, new_addr);
+	rawnat4_update_l4(*pskb, iph->saddr, new_addr);
+	iph->saddr = new_addr;
+	return XT_CONTINUE;
+}
+
+static unsigned int
+rawdnat_tg4(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct xt_rawnat_tginfo *info = par->targinfo;
+	struct iphdr *iph;
+	__be32 new_addr;
+
+	iph = ip_hdr(*pskb);
+	new_addr = remask(iph->daddr, info->addr.ip, info->mask);
+	if (iph->daddr == new_addr)
+		return XT_CONTINUE;
+
+	if (!skb_make_writable(pskb, rawnat4_writable_part(iph)))
+		return NF_DROP;
+
+	iph = ip_hdr(*pskb);
+	csum_replace4(&iph->check, iph->daddr, new_addr);
+	rawnat4_update_l4(*pskb, iph->daddr, new_addr);
+	iph->daddr = new_addr;
+	return XT_CONTINUE;
+}
+
+#ifdef WITH_IPV6
+static bool rawnat6_prepare_l4(struct sk_buff **pskb, unsigned int *l4offset,
+    unsigned int *l4proto)
+{
+	static const unsigned int types[] =
+		{IPPROTO_TCP, IPPROTO_UDP, IPPROTO_UDPLITE};
+	unsigned int i;
+	int err;
+
+	*l4proto = NEXTHDR_MAX;
+
+	for (i = 0; i < ARRAY_SIZE(types); ++i) {
+		err = ipv6_find_hdr(*pskb, l4offset, types[i], NULL, NULL);
+		if (err >= 0) {
+			*l4proto = types[i];
+			break;
+		}
+		if (err != -ENOENT)
+			return false;
+	}
+
+	switch (*l4proto) {
+	case IPPROTO_TCP:
+		if (!skb_make_writable(pskb, *l4offset + sizeof(struct tcphdr)))
+			return false;
+		break;
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+		if (!skb_make_writable(pskb, *l4offset + sizeof(struct udphdr)))
+			return false;
+		break;
+	}
+
+	return true;
+}
+
+static void rawnat6_update_l4(struct sk_buff *skb, unsigned int l4proto,
+    unsigned int l4offset, const struct in6_addr *oldip,
+    const struct in6_addr *newip)
+{
+	const struct ipv6hdr *iph = ipv6_hdr(skb);
+	struct tcphdr *tcph;
+	struct udphdr *udph;
+	unsigned int i;
+	bool cond;
+
+	switch (l4proto) {
+	case IPPROTO_TCP:
+		tcph = (void *)iph + l4offset;
+		for (i = 0; i < 4; ++i)
+			inet_proto_csum_replace4(&tcph->check, skb,
+				oldip->s6_addr32[i], newip->s6_addr32[i], true);
+		break;
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+		udph = (void *)iph + l4offset;
+		cond = udph->check;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+		cond |= skb->ip_summed == CHECKSUM_PARTIAL;
+#endif
+		if (cond) {
+			for (i = 0; i < 4; ++i)
+				inet_proto_csum_replace4(&udph->check, skb,
+					oldip->s6_addr32[i],
+					newip->s6_addr32[i], true);
+			if (udph->check == 0)
+				udph->check = CSUM_MANGLED_0;
+		}
+		break;
+	}
+}
+
+static unsigned int
+rawsnat_tg6(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct xt_rawnat_tginfo *info = par->targinfo;
+	unsigned int l4offset = 0, l4proto;
+	struct ipv6hdr *iph;
+	struct in6_addr new_addr;
+
+	iph = ipv6_hdr(*pskb);
+	memcpy(&new_addr, &iph->saddr, sizeof(new_addr));
+	rawnat_ipv6_mask(new_addr.s6_addr32, info->addr.ip6, info->mask);
+	if (ipv6_addr_cmp(&iph->saddr, &new_addr) == 0)
+		return XT_CONTINUE;
+	if (!rawnat6_prepare_l4(pskb, &l4offset, &l4proto))
+		return NF_DROP;
+	iph = ipv6_hdr(*pskb);
+	rawnat6_update_l4(*pskb, l4proto, l4offset, &iph->saddr, &new_addr);
+	memcpy(&iph->saddr, &new_addr, sizeof(new_addr));
+	return XT_CONTINUE;
+}
+
+static unsigned int
+rawdnat_tg6(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct xt_rawnat_tginfo *info = par->targinfo;
+	unsigned int l4offset = 0, l4proto;
+	struct ipv6hdr *iph;
+	struct in6_addr new_addr;
+
+	iph = ipv6_hdr(*pskb);
+	memcpy(&new_addr, &iph->daddr, sizeof(new_addr));
+	rawnat_ipv6_mask(new_addr.s6_addr32, info->addr.ip6, info->mask);
+	if (ipv6_addr_cmp(&iph->daddr, &new_addr) == 0)
+		return XT_CONTINUE;
+	if (!rawnat6_prepare_l4(pskb, &l4offset, &l4proto))
+		return NF_DROP;
+	iph = ipv6_hdr(*pskb);
+	rawnat6_update_l4(*pskb, l4proto, l4offset, &iph->daddr, &new_addr);
+	memcpy(&iph->daddr, &new_addr, sizeof(new_addr));
+	return XT_CONTINUE;
+}
+#endif
+
+static int rawnat_tg_check(const struct xt_tgchk_param *par)
+{
+	if (strcmp(par->table, "raw") == 0 ||
+	    strcmp(par->table, "rawpost") == 0)
+		return 0;
+
+	printk(KERN_ERR KBUILD_MODNAME " may only be used in the \"raw\" or "
+	       "\"rawpost\" table.\n");
+	return -EINVAL;
+}
+
+static struct xt_target rawnat_tg_reg[] __read_mostly = {
+	{
+		.name       = "RAWSNAT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.target     = rawsnat_tg4,
+		.targetsize = sizeof(struct xt_rawnat_tginfo),
+		.checkentry = rawnat_tg_check,
+		.me         = THIS_MODULE,
+	},
+#ifdef WITH_IPV6
+	{
+		.name       = "RAWSNAT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.target     = rawsnat_tg6,
+		.targetsize = sizeof(struct xt_rawnat_tginfo),
+		.checkentry = rawnat_tg_check,
+		.me         = THIS_MODULE,
+	},
+#endif
+	{
+		.name       = "RAWDNAT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.target     = rawdnat_tg4,
+		.targetsize = sizeof(struct xt_rawnat_tginfo),
+		.checkentry = rawnat_tg_check,
+		.me         = THIS_MODULE,
+	},
+#ifdef WITH_IPV6
+	{
+		.name       = "RAWDNAT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.target     = rawdnat_tg6,
+		.targetsize = sizeof(struct xt_rawnat_tginfo),
+		.checkentry = rawnat_tg_check,
+		.me         = THIS_MODULE,
+	},
+#endif
+};
+
+static int __init rawnat_tg_init(void)
+{
+	return xt_register_targets(rawnat_tg_reg, ARRAY_SIZE(rawnat_tg_reg));
+}
+
+static void __exit rawnat_tg_exit(void)
+{
+	xt_unregister_targets(rawnat_tg_reg, ARRAY_SIZE(rawnat_tg_reg));
+}
+
+module_init(rawnat_tg_init);
+module_exit(rawnat_tg_exit);
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_DESCRIPTION("Xtables: conntrack-less raw NAT");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_RAWSNAT");
+MODULE_ALIAS("ipt_RAWDNAT");
+MODULE_ALIAS("ip6t_RAWSNAT");
+MODULE_ALIAS("ip6t_RAWDNAT");

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_RAWNAT.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_RAWNAT.h
@@ -0,0 +1,9 @@
+#ifndef _LINUX_NETFILTER_XT_TARGET_RAWNAT
+#define _LINUX_NETFILTER_XT_TARGET_RAWNAT 1
+
+struct xt_rawnat_tginfo {
+	union nf_inet_addr addr;
+	__u8 mask;
+};
+
+#endif /* _LINUX_NETFILTER_XT_TARGET_RAWNAT */

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_STEAL.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_STEAL.c
@@ -0,0 +1,67 @@
+/*
+ *	"STEAL" demo target extension for Xtables
+ *	written by Jan Engelhardt <jengelh [at] medozas de>, 2008 - 2009
+ *	placed in the Public Domain
+ */
+#include <linux/module.h>
+#include <linux/netfilter.h>
+#include <linux/skbuff.h>
+#include "compat_xtables.h"
+
+static unsigned int
+steal_tg(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	kfree_skb(*pskb);
+	return NF_STOLEN;
+}
+
+static struct xt_target steal_tg_reg[] __read_mostly = {
+	{
+		.name     = "STEAL",
+		.revision = 0,
+		.family   = NFPROTO_UNSPEC,
+		.target   = steal_tg,
+		.me       = THIS_MODULE,
+	},
+	{
+		.name     = "STEAL",
+		.revision = 0,
+		.family   = NFPROTO_IPV6,
+		.target   = steal_tg,
+		.me       = THIS_MODULE,
+	},
+	{
+		.name     = "STEAL",
+		.revision = 0,
+		.family   = NFPROTO_ARP,
+		.target   = steal_tg,
+		.me       = THIS_MODULE,
+	},
+	{
+		.name     = "STEAL",
+		.revision = 0,
+		.family   = NFPROTO_BRIDGE,
+		.target   = steal_tg,
+		.me       = THIS_MODULE,
+	},
+};
+
+static int __init steal_tg_init(void)
+{
+	return xt_register_targets(steal_tg_reg, ARRAY_SIZE(steal_tg_reg));
+}
+
+static void __exit steal_tg_exit(void)
+{
+	xt_unregister_targets(steal_tg_reg, ARRAY_SIZE(steal_tg_reg));
+}
+
+module_init(steal_tg_init);
+module_exit(steal_tg_exit);
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_DESCRIPTION("Xtables: Silently DROP packets on output chain");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_STEAL");
+MODULE_ALIAS("ip6t_STEAL");
+MODULE_ALIAS("arpt_STEAL");
+MODULE_ALIAS("ebt_STEAL");

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_TARPIT.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_TARPIT.c
@@ -0,0 +1,549 @@
+/*
+ *	"TARPIT" target extension to Xtables
+ *	Kernel module to capture and hold incoming TCP connections using
+ *	no local per-connection resources.
+ *
+ *	Copyright © Aaron Hopkins <tools [at] die net>, 2002
+ *
+ *	Based on ipt_REJECT.c and offering functionality similar to
+ *	LaBrea <http://www.hackbusters.net/LaBrea/>.
+ *
+ *	<<<
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *	>>>
+ *
+ * Goal:
+ * - Allow incoming TCP connections to be established.
+ * - Passing data should result in the connection being switched to the
+ *   persist state (0 byte window), in which the remote side stops sending
+ *   data and asks to continue every 60 seconds.
+ * - Attempts to shut down the connection should be ignored completely, so
+ *   the remote side ends up having to time it out.
+ *
+ * This means:
+ * - Reply to TCP SYN,!ACK,!RST,!FIN with SYN-ACK, window 5 bytes
+ * - Reply to TCP SYN,ACK,!RST,!FIN with RST to prevent spoofing
+ * - Reply to TCP !SYN,!RST,!FIN with ACK, window 0 bytes, rate-limited
+ */
+
+#include <linux/ip.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+#include <linux/netfilter_ipv6.h>
+#include <linux/netfilter/x_tables.h>
+#ifdef CONFIG_BRIDGE_NETFILTER
+#	include <linux/netfilter_bridge.h>
+#endif
+#include <net/addrconf.h>
+#include <net/ip6_checksum.h>
+#include <net/ip6_route.h>
+#include <net/ipv6.h>
+#include <net/route.h>
+#include <net/tcp.h>
+#include "compat_xtables.h"
+#include "xt_TARPIT.h"
+#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)
+#	define WITH_IPV6 1
+#endif
+
+static bool xttarpit_tarpit(struct tcphdr *tcph, const struct tcphdr *oth)
+{
+	/* No replies for RST, FIN or !SYN,!ACK */
+	if (oth->rst || oth->fin || (!oth->syn && !oth->ack))
+		return false;
+	tcph->seq = oth->ack ? oth->ack_seq : 0;
+
+	/* Our SYN-ACKs must have a >0 window */
+	tcph->window = (oth->syn && !oth->ack) ? htons(5) : 0;
+	if (oth->syn && oth->ack) {
+		tcph->rst     = true;
+		tcph->ack_seq = false;
+	} else {
+		tcph->syn     = oth->syn;
+		tcph->ack     = true;
+		tcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn);
+	}
+#if 0
+	/* Rate-limit replies to !SYN,ACKs */
+	if (!oth->syn && oth->ack)
+		if (!xrlim_allow(rt_dst(ort), HZ))
+			return false;
+#endif
+
+	return true;
+}
+
+static bool xttarpit_honeypot(struct tcphdr *tcph, const struct tcphdr *oth,
+    uint16_t payload)
+{
+	/* Do not answer any resets regardless of combination */
+	if (oth->rst || oth->seq == 0xDEADBEEF)
+		return false;
+	/* Send a reset to scanners. They like that. */
+	if (oth->syn && oth->ack) {
+		tcph->window  = 0;
+		tcph->ack     = false;
+		tcph->psh     = true;
+		tcph->ack_seq = 0xdeadbeef; /* see if they ack it */
+		tcph->seq     = oth->ack_seq;
+		tcph->rst     = true;
+	}
+
+	/* SYN > SYN-ACK */
+	if (oth->syn && !oth->ack) {
+		tcph->syn     = true;
+		tcph->ack     = true;
+		tcph->window  = oth->window &
+			((net_random() & 0x1f) - 0xf);
+		tcph->seq     = htonl(net_random() & ~oth->seq);
+		tcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn);
+	}
+
+	/* ACK > ACK */
+	if (oth->ack && (!(oth->fin || oth->syn))) {
+		tcph->syn     = false;
+		tcph->ack     = true;
+		tcph->window  = oth->window &
+			((net_random() & 0x1f) - 0xf);
+		tcph->ack_seq = payload > 100 ?
+			htonl(ntohl(oth->seq) + payload) :
+			oth->seq;
+		tcph->seq     = oth->ack_seq;
+	}
+
+	/*
+	 * FIN > RST.
+	 * We cannot terminate gracefully so just be abrupt.
+	 */
+	if (oth->fin) {
+		tcph->window  = 0;
+		tcph->seq     = oth->ack_seq;
+		tcph->ack_seq = oth->ack_seq;
+		tcph->fin     = false;
+		tcph->ack     = false;
+		tcph->rst     = true;
+	}
+
+	return true;
+}
+
+static void xttarpit_reset(struct tcphdr *tcph, const struct tcphdr *oth)
+{
+	tcph->window  = 0;
+	tcph->ack     = false;
+	tcph->syn     = false;
+	tcph->rst     = true;
+	tcph->seq     = oth->ack_seq;
+	tcph->ack_seq = oth->seq;
+}
+
+static bool tarpit_generic(struct tcphdr *tcph, const struct tcphdr *oth,
+    uint16_t payload, unsigned int mode)
+{
+	switch(mode) {
+	case XTTARPIT_TARPIT:
+		if (!xttarpit_tarpit(tcph, oth))
+			return false;
+		break;
+	case XTTARPIT_HONEYPOT:
+		if (!xttarpit_honeypot(tcph, oth, payload))
+			return false;
+		break;
+	case XTTARPIT_RESET:
+		xttarpit_reset(tcph, oth);
+		break;
+	}
+
+	return true;
+}
+
+static void tarpit_tcp4(struct sk_buff *oldskb, unsigned int hook,
+    unsigned int mode)
+{
+	struct tcphdr _otcph, *tcph;
+	const struct tcphdr *oth;
+	unsigned int addr_type = RTN_UNSPEC;
+	struct sk_buff *nskb;
+	const struct iphdr *oldhdr;
+	struct iphdr *niph;
+	uint16_t tmp, payload;
+
+	/* A truncated TCP header is not going to be useful */
+	if (oldskb->len < ip_hdrlen(oldskb) + sizeof(struct tcphdr))
+		return;
+
+	oth = skb_header_pointer(oldskb, ip_hdrlen(oldskb),
+	                         sizeof(_otcph), &_otcph);
+	if (oth == NULL)
+		return;
+
+	/* Check checksum. */
+	if (nf_ip_checksum(oldskb, hook, ip_hdrlen(oldskb), IPPROTO_TCP))
+		return;
+
+	/*
+	 * Copy skb (even if skb is about to be dropped, we cannot just
+	 * clone it because there may be other things, such as tcpdump,
+	 * interested in it)
+	 */
+	nskb = skb_copy_expand(oldskb, LL_MAX_HEADER,
+	                       skb_tailroom(oldskb), GFP_ATOMIC);
+	if (nskb == NULL)
+		return;
+
+	/* This packet will not be the same as the other: clear nf fields */
+	nf_reset(nskb);
+	skb_nfmark(nskb) = 0;
+	skb_init_secmark(nskb);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+	skb_shinfo(nskb)->gso_size = 0;
+	skb_shinfo(nskb)->gso_segs = 0;
+	skb_shinfo(nskb)->gso_type = 0;
+#endif
+
+	oldhdr = ip_hdr(oldskb);
+	tcph = (struct tcphdr *)(skb_network_header(nskb) + ip_hdrlen(nskb));
+
+	/* Swap source and dest */
+	niph         = ip_hdr(nskb);
+	niph->daddr  = xchg(&niph->saddr, niph->daddr);
+	tmp          = tcph->source;
+	tcph->source = tcph->dest;
+	tcph->dest   = tmp;
+
+	/* Calculate payload size?? */
+	payload = nskb->len - ip_hdrlen(nskb) - sizeof(struct tcphdr);
+
+	/* Truncate to length (no data) */
+	tcph->doff    = sizeof(struct tcphdr) / 4;
+	skb_trim(nskb, ip_hdrlen(nskb) + sizeof(struct tcphdr));
+	niph->tot_len = htons(nskb->len);
+	tcph->urg_ptr = 0;
+	/* Reset flags */
+	((u_int8_t *)tcph)[13] = 0;
+
+	if (!tarpit_generic(tcph, oth, payload, mode))
+		goto free_nskb;
+
+	/* Adjust TCP checksum */
+	tcph->check = 0;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 20)
+	tcph->check = tcp_v4_check(tcph, sizeof(struct tcphdr), niph->saddr,
+	              niph->daddr, csum_partial((char *)tcph,
+	              sizeof(struct tcphdr), 0));
+#else
+	tcph->check = tcp_v4_check(sizeof(struct tcphdr), niph->saddr,
+	              niph->daddr, csum_partial((char *)tcph,
+	              sizeof(struct tcphdr), 0));
+#endif
+
+	/* Set DF, id = 0 */
+	niph->frag_off = htons(IP_DF);
+	if (mode == XTTARPIT_TARPIT || mode == XTTARPIT_RESET)
+		niph->id = 0;
+	else if (mode == XTTARPIT_HONEYPOT)
+		niph->id = ~oldhdr->id + 1;
+
+#ifdef CONFIG_BRIDGE_NETFILTER
+	if (hook != NF_INET_FORWARD || (nskb->nf_bridge != NULL &&
+	    nskb->nf_bridge->mask & BRNF_BRIDGED))
+#else
+	if (hook != NF_INET_FORWARD)
+#endif
+		addr_type = RTN_LOCAL;
+
+	if (ip_route_me_harder(&nskb, addr_type))
+		goto free_nskb;
+	else
+		niph = ip_hdr(nskb);
+
+	nskb->ip_summed = CHECKSUM_NONE;
+
+	/* Adjust IP TTL */
+	if (mode == XTTARPIT_HONEYPOT)
+		niph->ttl = 128;
+	else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+		niph->ttl = ip4_dst_hoplimit(skb_dst(nskb));
+#else
+		niph->ttl = dst_metric(skb_dst(nskb), RTAX_HOPLIMIT);
+#endif
+
+	/* Adjust IP checksum */
+	niph->check = 0;
+	niph->check = ip_fast_csum(skb_network_header(nskb), niph->ihl);
+
+	/* "Never happens" */
+	if (nskb->len > dst_mtu(skb_dst(nskb)))
+		goto free_nskb;
+
+	nf_ct_attach(nskb, oldskb);
+
+	NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_OUT, nskb, NULL,
+		skb_dst(nskb)->dev, dst_output);
+	return;
+
+ free_nskb:
+	kfree_skb(nskb);
+}
+
+#ifdef WITH_IPV6
+static void tarpit_tcp6(struct sk_buff *oldskb, unsigned int hook,
+    unsigned int mode)
+{
+	struct sk_buff *nskb;
+	struct tcphdr *tcph, oth;
+	unsigned int otcplen;
+	int tcphoff;
+	const struct ipv6hdr *oip6h = ipv6_hdr(oldskb);
+	struct ipv6hdr *ip6h;
+	const uint8_t tclass = 0;
+	uint8_t proto;
+	uint16_t payload;
+	__be16 frag_off;
+
+	proto   = oip6h->nexthdr;
+	tcphoff = ipv6_skip_exthdr(oldskb,
+	          (uint8_t *)(oip6h + 1) - oldskb->data, &proto, &frag_off);
+
+	if (tcphoff < 0 || tcphoff > oldskb->len) {
+		pr_debug("Cannot get TCP header.\n");
+		return;
+	}
+
+	otcplen = oldskb->len - tcphoff;
+
+	/* IP header checks: fragment, too short. */
+	if (proto != IPPROTO_TCP || otcplen < sizeof(struct tcphdr)) {
+		pr_debug("proto(%d) != IPPROTO_TCP, "
+		         "or too short. otcplen = %d\n",
+		         proto, otcplen);
+		return;
+	}
+
+	if (skb_copy_bits(oldskb, tcphoff, &oth, sizeof(struct tcphdr))) {
+		WARN_ON(1);
+		return;
+	}
+
+	/* Check checksum. */
+	if (csum_ipv6_magic(&oip6h->saddr, &oip6h->daddr, otcplen, IPPROTO_TCP,
+	    skb_checksum(oldskb, tcphoff, otcplen, 0))) {
+		pr_debug("TCP checksum is invalid\n");
+		return;
+	}
+
+	nskb = skb_copy_expand(oldskb, LL_MAX_HEADER,
+	       skb_tailroom(oldskb), GFP_ATOMIC);
+	if (nskb == NULL) {
+		if (net_ratelimit())
+			pr_debug("cannot alloc skb\n");
+		return;
+	}
+
+	/* This packet will not be the same as the other: clear nf fields */
+	nf_reset(nskb);
+	skb_nfmark(nskb) = 0;
+	skb_init_secmark(nskb);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+	skb_shinfo(nskb)->gso_size = 0;
+	skb_shinfo(nskb)->gso_segs = 0;
+	skb_shinfo(nskb)->gso_type = 0;
+#endif
+
+	skb_put(nskb, sizeof(struct ipv6hdr));
+	ip6h = ipv6_hdr(nskb);
+	*(__be32 *)ip6h =  htonl(0x60000000 | (tclass << 20));
+	ip6h->nexthdr = IPPROTO_TCP;
+	ip6h->saddr = oip6h->daddr;
+	ip6h->daddr = oip6h->saddr;
+
+	/* Adjust IP TTL */
+	if (mode == XTTARPIT_HONEYPOT) {
+		ip6h->hop_limit = 128;
+	} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+		ip6h->hop_limit = ip6_dst_hoplimit(skb_dst(nskb));
+#else
+		ip6h->hop_limit = dst_metric(skb_dst(nskb), RTAX_HOPLIMIT);
+#endif
+	}
+
+	tcph = (struct tcphdr *)(skb_network_header(nskb) +
+	       sizeof(struct ipv6hdr));
+
+	/* Truncate to length (no data) */
+	skb_trim(nskb, sizeof(struct ipv6hdr) + sizeof(struct tcphdr));
+	tcph->doff    = sizeof(struct tcphdr)/4;
+	tcph->source  = oth.dest;
+	tcph->dest    = oth.source;
+	tcph->urg_ptr = 0;
+	/* Reset flags */
+	((uint8_t *)tcph)[13] = 0;
+
+	payload = nskb->len - sizeof(struct ipv6hdr) - sizeof(struct tcphdr);
+	if (!tarpit_generic(&oth, tcph, payload, mode))
+		goto free_nskb;
+
+	ip6h->payload_len = htons(sizeof(struct tcphdr));
+	tcph->check = 0;
+
+	/* Adjust TCP checksum */
+	tcph->check = csum_ipv6_magic(&ipv6_hdr(nskb)->saddr,
+	              &ipv6_hdr(nskb)->daddr, sizeof(struct tcphdr),
+	              IPPROTO_TCP,
+	              csum_partial(tcph, sizeof(struct tcphdr), 0));
+
+	if (ip6_route_me_harder(nskb))
+		goto free_nskb;
+
+	nskb->ip_summed = CHECKSUM_NONE;
+
+	nf_ct_attach(nskb, oldskb);
+
+	NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, nskb, NULL,
+	        skb_dst(nskb)->dev, dst_output);
+	return;
+
+ free_nskb:
+	kfree_skb(nskb);
+}
+#endif
+
+static unsigned int
+tarpit_tg4(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct sk_buff *skb = *pskb;
+	const struct iphdr *iph = ip_hdr(skb);
+	const struct rtable *rt = skb_rtable(skb);
+	const struct xt_tarpit_tginfo *info = par->targinfo;
+
+	/* Do we have an input route cache entry? (Not in PREROUTING.) */
+	if (rt == NULL)
+		return NF_DROP;
+
+	/* No replies to physical multicast/broadcast */
+	/* skb != PACKET_OTHERHOST handled by ip_rcv() */
+	if (skb->pkt_type != PACKET_HOST)
+		return NF_DROP;
+
+	/* Now check at the protocol level */
+	if (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))
+		return NF_DROP;
+
+	/*
+	 * Our naive response construction does not deal with IP
+	 * options, and probably should not try.
+	 */
+	if (ip_hdrlen(skb) != sizeof(struct iphdr))
+		return NF_DROP;
+
+	/* We are not interested in fragments */
+	if (iph->frag_off & htons(IP_OFFSET))
+		return NF_DROP;
+
+	tarpit_tcp4(*pskb, par->hooknum, info->variant);
+	return NF_DROP;
+}
+
+#ifdef WITH_IPV6
+static unsigned int
+tarpit_tg6(struct sk_buff **pskb, const struct xt_action_param *par)
+{
+	const struct sk_buff *skb = *pskb;
+	const struct ipv6hdr *iph = ipv6_hdr(skb);
+	const struct rt6_info *rt = (struct rt6_info *)skb_dst(skb);
+	const struct xt_tarpit_tginfo *info = par->targinfo;
+	uint8_t proto;
+	__be16 frag_off;
+
+	/* Do we have an input route cache entry? (Not in PREROUTING.) */
+	if (rt == NULL) {
+		pr_debug("Dropping no input route cache entry\n");
+		return NF_DROP;
+	}
+
+	/* No replies to physical multicast/broadcast */
+	/* skb != PACKET_OTHERHOST handled by ip_rcv() */
+	if (skb->pkt_type != PACKET_HOST) {
+		pr_debug("type != PACKET_HOST");
+		return NF_DROP;
+	}
+
+	/*
+	 * Our naive response construction does not deal with IP
+	 * options, and probably should not try.
+	 */
+	proto = iph->nexthdr;
+	if (ipv6_skip_exthdr(skb, skb_network_header_len(skb), &proto,
+	    &frag_off) != sizeof(struct ipv6hdr))
+		return NF_DROP;
+
+	if ((!(ipv6_addr_type(&iph->saddr) & IPV6_ADDR_UNICAST)) ||
+	    (!(ipv6_addr_type(&iph->daddr) & IPV6_ADDR_UNICAST))) {
+		pr_debug("addr is not unicast.\n");
+		return NF_DROP;
+	}
+
+	tarpit_tcp6(*pskb, par->hooknum, info->variant);
+	return NF_DROP;
+}
+#endif
+
+static struct xt_target tarpit_tg_reg[] __read_mostly = {
+	{
+		.name       = "TARPIT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV4,
+		.hooks      = (1 << NF_INET_LOCAL_IN) | (1 << NF_INET_FORWARD),
+		.proto      = IPPROTO_TCP,
+		.target     = tarpit_tg4,
+		.targetsize = sizeof(struct xt_tarpit_tginfo),
+		.me         = THIS_MODULE,
+	},
+#ifdef WITH_IPV6
+	{
+		.name       = "TARPIT",
+		.revision   = 0,
+		.family     = NFPROTO_IPV6,
+		.hooks      = (1 << NF_INET_LOCAL_IN) | (1 << NF_INET_FORWARD),
+		.proto      = IPPROTO_TCP,
+		.target     = tarpit_tg6,
+		.targetsize = sizeof(struct xt_tarpit_tginfo),
+		.me         = THIS_MODULE,
+	},
+#endif
+};
+
+static int __init tarpit_tg_init(void)
+{
+	return xt_register_targets(tarpit_tg_reg, ARRAY_SIZE(tarpit_tg_reg));
+}
+
+static void __exit tarpit_tg_exit(void)
+{
+	xt_unregister_targets(tarpit_tg_reg, ARRAY_SIZE(tarpit_tg_reg));
+}
+
+module_init(tarpit_tg_init);
+module_exit(tarpit_tg_exit);
+MODULE_DESCRIPTION("Xtables: \"TARPIT\", capture and hold TCP connections");
+MODULE_AUTHOR("Jan Engelhardt <jengelh@medozas.de>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_TARPIT");
+MODULE_ALIAS("ip6t_TARPIT");

--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_TARPIT.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/netfilter/xt_TARPIT.h
@@ -0,0 +1,14 @@
+#ifndef _LINUX_NETFILTER_XT_TARPIT_H
+#define _LINUX_NETFILTER_XT_TARPIT_H 1
+
+enum xt_tarpit_target_variant {
+	XTTARPIT_TARPIT,
+	XTTARPIT_HONEYPOT,
+	XTTARPIT_RESET,
+};
+
+struct xt_tarpit_tginfo {
+	uint8_t variant;
+};
+
+#endif /* _LINUX_NETFILTER_XT_TARPIT_H */
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/Kconfig
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/Kconfig
@@ -66,6 +66,28 @@
 
 	  If unsure, say N.
 
+config SQUASHFS_4K_DEVBLK_SIZE
+	bool "Use 4K device block size?"
+	depends on SQUASHFS
+	help
+	  By default Squashfs sets the dev block size (sb_min_blocksize)
+	  to 1K or the smallest block size supported by the block device
+	  (if larger).  This, because blocks are packed together and
+	  unaligned in Squashfs, should reduce latency.
+
+	  This, however, gives poor performance on MTD NAND devices where
+	  the optimal I/O size is 4K (even though the devices can support
+	  smaller block sizes).
+
+	  Using a 4K device block size may also improve overall I/O
+	  performance for some file access patterns (e.g. sequential
+	  accesses of files in filesystem order) on all media.
+
+	  Setting this option will force Squashfs to use a 4K device block
+	  size by default.
+
+	  If unsure, say N.
+
 config SQUASHFS_EMBEDDED
 	bool "Additional option for memory-constrained systems"
 	depends on SQUASHFS
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/squashfs_fs.h
@@ -37,6 +37,13 @@
 #define SQUASHFS_FILE_SIZE		131072
 #define SQUASHFS_FILE_LOG		17
 
+/* default size of block device I/O */
+#ifdef CONFIG_SQUASHFS_4K_DEVBLK_SIZE
+#define SQUASHFS_DEVBLK_SIZE 4096
+#else
+#define SQUASHFS_DEVBLK_SIZE 1024
+#endif
+
 #define SQUASHFS_FILE_MAX_SIZE		1048576
 #define SQUASHFS_FILE_MAX_LOG		20
 
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/super.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/fs/squashfs/super.c
@@ -102,7 +102,7 @@
 		goto failure;
 	}
 
-	msblk->devblksize = sb_min_blocksize(sb, BLOCK_SIZE);
+	msblk->devblksize = sb_min_blocksize(sb, SQUASHFS_DEVBLK_SIZE);
 	msblk->devblksize_log2 = ffz(~msblk->devblksize);
 
 	mutex_init(&msblk->read_data_mutex);
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/Makefile
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/Makefile
@@ -85,6 +85,9 @@
 obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
 obj-$(CONFIG_CRYPTO_GHASH) += ghash-generic.o
+obj-$(CONFIG_CRYPTO_USER_API) += af_alg.o
+obj-$(CONFIG_CRYPTO_USER_API_HASH) += algif_hash.o
+obj-$(CONFIG_CRYPTO_USER_API_SKCIPHER) += algif_skcipher.o
 
 #
 # generic algorithms and the async_tx api
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/Kconfig
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/Kconfig
@@ -842,6 +842,27 @@
 	  ANSI X9.31 A.2.4. Note that this option must be enabled if
 	  CRYPTO_FIPS is selected
 
+config CRYPTO_USER_API
+	tristate
+
+config CRYPTO_USER_API_HASH
+	tristate "User-space interface for hash algorithms"
+	depends on NET
+	select CRYPTO_HASH
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for hash
+	  algorithms.
+
+config CRYPTO_USER_API_SKCIPHER
+	tristate "User-space interface for symmetric key cipher algorithms"
+	depends on NET
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for symmetric
+	  key cipher algorithms.
+
 source "drivers/crypto/Kconfig"
 
 endif	# if CRYPTO
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/af_alg.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/af_alg.c
@@ -0,0 +1,483 @@
+/*
+ * af_alg: User-space algorithm interface
+ *
+ * This file provides the user-space API for algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <asm/atomic.h>
+#include <crypto/if_alg.h>
+#include <linux/crypto.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/rwsem.h>
+
+struct alg_type_list {
+	const struct af_alg_type *type;
+	struct list_head list;
+};
+
+static atomic_long_t alg_memory_allocated;
+
+static struct proto alg_proto = {
+	.name			= "ALG",
+	.owner			= THIS_MODULE,
+	.memory_allocated	= &alg_memory_allocated,
+	.obj_size		= sizeof(struct alg_sock),
+};
+
+static LIST_HEAD(alg_types);
+static DECLARE_RWSEM(alg_types_sem);
+
+static const struct af_alg_type *alg_get_type(const char *name)
+{
+	const struct af_alg_type *type = ERR_PTR(-ENOENT);
+	struct alg_type_list *node;
+
+	down_read(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, name))
+			continue;
+
+		if (try_module_get(node->type->owner))
+			type = node->type;
+		break;
+	}
+	up_read(&alg_types_sem);
+
+	return type;
+}
+
+int af_alg_register_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -EEXIST;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (!strcmp(node->type->name, type->name))
+			goto unlock;
+	}
+
+	node = kmalloc(sizeof(*node), GFP_KERNEL);
+	err = -ENOMEM;
+	if (!node)
+		goto unlock;
+
+	type->ops->owner = THIS_MODULE;
+	node->type = type;
+	list_add(&node->list, &alg_types);
+	err = 0;
+
+unlock:
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_register_type);
+
+int af_alg_unregister_type(const struct af_alg_type *type)
+{
+	struct alg_type_list *node;
+	int err = -ENOENT;
+
+	down_write(&alg_types_sem);
+	list_for_each_entry(node, &alg_types, list) {
+		if (strcmp(node->type->name, type->name))
+			continue;
+
+		list_del(&node->list);
+		kfree(node);
+		err = 0;
+		break;
+	}
+	up_write(&alg_types_sem);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_unregister_type);
+
+static void alg_do_release(const struct af_alg_type *type, void *private)
+{
+	if (!type)
+		return;
+
+	type->release(private);
+	module_put(type->owner);
+}
+
+int af_alg_release(struct socket *sock)
+{
+	if (sock->sk)
+		sock_put(sock->sk);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_release);
+
+static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct sockaddr_alg *sa = (void *)uaddr;
+	const struct af_alg_type *type;
+	void *private;
+
+	if (sock->state == SS_CONNECTED)
+		return -EINVAL;
+
+	if (addr_len != sizeof(*sa))
+		return -EINVAL;
+
+	sa->salg_type[sizeof(sa->salg_type) - 1] = 0;
+	sa->salg_name[sizeof(sa->salg_name) - 1] = 0;
+
+	type = alg_get_type(sa->salg_type);
+	if (IS_ERR(type) && PTR_ERR(type) == -ENOENT) {
+		request_module("algif-%s", sa->salg_type);
+		type = alg_get_type(sa->salg_type);
+	}
+
+	if (IS_ERR(type))
+		return PTR_ERR(type);
+
+	private = type->bind(sa->salg_name, sa->salg_feat, sa->salg_mask);
+	if (IS_ERR(private)) {
+		module_put(type->owner);
+		return PTR_ERR(private);
+	}
+
+	lock_sock(sk);
+
+	swap(ask->type, type);
+	swap(ask->private, private);
+
+	release_sock(sk);
+
+	alg_do_release(type, private);
+
+	return 0;
+}
+
+static int alg_setkey(struct sock *sk, char __user *ukey,
+		      unsigned int keylen)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type = ask->type;
+	u8 *key;
+	int err;
+
+	key = sock_kmalloc(sk, keylen, GFP_KERNEL);
+	if (!key)
+		return -ENOMEM;
+
+	err = -EFAULT;
+	if (copy_from_user(key, ukey, keylen))
+		goto out;
+
+	err = type->setkey(ask->private, key, keylen);
+
+out:
+	sock_kfree_s(sk, key, keylen);
+
+	return err;
+}
+
+static int alg_setsockopt(struct socket *sock, int level, int optname,
+			  char __user *optval, unsigned int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	int err = -ENOPROTOOPT;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	if (level != SOL_ALG || !type)
+		goto unlock;
+
+	switch (optname) {
+	case ALG_SET_KEY:
+		if (sock->state == SS_CONNECTED)
+			goto unlock;
+		if (!type->setkey)
+			goto unlock;
+
+		err = alg_setkey(sk, optval, optlen);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+
+int af_alg_accept(struct sock *sk, struct socket *newsock)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	const struct af_alg_type *type;
+	struct sock *sk2;
+	int err;
+
+	lock_sock(sk);
+	type = ask->type;
+
+	err = -EINVAL;
+	if (!type)
+		goto unlock;
+
+	sk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto);
+	err = -ENOMEM;
+	if (!sk2)
+		goto unlock;
+
+	sock_init_data(newsock, sk2);
+	sock_graft(sk2, newsock);
+
+	err = type->accept(ask->private, sk2);
+	if (err) {
+		sk_free(sk2);
+		goto unlock;
+	}
+
+	sk2->sk_family = PF_ALG;
+
+	sock_hold(sk);
+	alg_sk(sk2)->parent = sk;
+	alg_sk(sk2)->type = type;
+
+	newsock->ops = type->ops;
+	newsock->state = SS_CONNECTED;
+
+	err = 0;
+
+unlock:
+	release_sock(sk);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_accept);
+
+static int alg_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	return af_alg_accept(sock->sk, newsock);
+}
+
+static const struct proto_ops alg_proto_ops = {
+	.family		=	PF_ALG,
+	.owner		=	THIS_MODULE,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.sendpage	=	sock_no_sendpage,
+	.sendmsg	=	sock_no_sendmsg,
+	.recvmsg	=	sock_no_recvmsg,
+	.poll		=	sock_no_poll,
+
+	.bind		=	alg_bind,
+	.release	=	af_alg_release,
+	.setsockopt	=	alg_setsockopt,
+	.accept		=	alg_accept,
+};
+
+static void alg_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+
+	alg_do_release(ask->type, ask->private);
+}
+
+static int alg_create(struct net *net, struct socket *sock, int protocol,
+		      int kern)
+{
+	struct sock *sk;
+	int err;
+
+	if (sock->type != SOCK_SEQPACKET)
+		return -ESOCKTNOSUPPORT;
+	if (protocol != 0)
+		return -EPROTONOSUPPORT;
+
+	err = -ENOMEM;
+	sk = sk_alloc(net, PF_ALG, GFP_KERNEL, &alg_proto);
+	if (!sk)
+		goto out;
+
+	sock->ops = &alg_proto_ops;
+	sock_init_data(sock, sk);
+
+	sk->sk_family = PF_ALG;
+	sk->sk_destruct = alg_sock_destruct;
+
+	return 0;
+out:
+	return err;
+}
+
+static const struct net_proto_family alg_family = {
+	.family	=	PF_ALG,
+	.create	=	alg_create,
+	.owner	=	THIS_MODULE,
+};
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write)
+{
+	unsigned long from = (unsigned long)addr;
+	unsigned long npages;
+	unsigned off;
+	int err;
+	int i;
+
+	err = -EFAULT;
+	if (!access_ok(write ? VERIFY_READ : VERIFY_WRITE, addr, len))
+		goto out;
+
+	off = from & ~PAGE_MASK;
+	npages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	if (npages > ALG_MAX_PAGES)
+		npages = ALG_MAX_PAGES;
+
+	err = get_user_pages_fast(from, npages, write, sgl->pages);
+	if (err < 0)
+		goto out;
+
+	npages = err;
+	err = -EINVAL;
+	if (WARN_ON(npages == 0))
+		goto out;
+
+	err = 0;
+
+	sg_init_table(sgl->sg, npages);
+
+	for (i = 0; i < npages; i++) {
+		int plen = min_t(int, len, PAGE_SIZE - off);
+
+		sg_set_page(sgl->sg + i, sgl->pages[i], plen, off);
+
+		off = 0;
+		len -= plen;
+		err += plen;
+	}
+
+out:
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_make_sg);
+
+void af_alg_free_sg(struct af_alg_sgl *sgl)
+{
+	int i;
+
+	i = 0;
+	do {
+		put_page(sgl->pages[i]);
+	} while (!sg_is_last(sgl->sg + (i++)));
+}
+EXPORT_SYMBOL_GPL(af_alg_free_sg);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con)
+{
+	struct cmsghdr *cmsg;
+
+	for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
+		if (!CMSG_OK(msg, cmsg))
+			return -EINVAL;
+		if (cmsg->cmsg_level != SOL_ALG)
+			continue;
+
+		switch(cmsg->cmsg_type) {
+		case ALG_SET_IV:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(*con->iv)))
+				return -EINVAL;
+			con->iv = (void *)CMSG_DATA(cmsg);
+			if (cmsg->cmsg_len < CMSG_LEN(con->iv->ivlen +
+						      sizeof(*con->iv)))
+				return -EINVAL;
+			break;
+
+		case ALG_SET_OP:
+			if (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))
+				return -EINVAL;
+			con->op = *(u32 *)CMSG_DATA(cmsg);
+			break;
+
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(af_alg_cmsg_send);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion)
+{
+	switch (err) {
+	case -EINPROGRESS:
+	case -EBUSY:
+		wait_for_completion(&completion->completion);
+		INIT_COMPLETION(completion->completion);
+		err = completion->err;
+		break;
+	};
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(af_alg_wait_for_completion);
+
+void af_alg_complete(struct crypto_async_request *req, int err)
+{
+	struct af_alg_completion *completion = req->data;
+
+	completion->err = err;
+	complete(&completion->completion);
+}
+EXPORT_SYMBOL_GPL(af_alg_complete);
+
+static int __init af_alg_init(void)
+{
+	int err = proto_register(&alg_proto, 0);
+
+	if (err)
+		goto out;
+
+	err = sock_register(&alg_family);
+	if (err != 0)
+		goto out_unregister_proto;
+
+out:
+	return err;
+
+out_unregister_proto:
+	proto_unregister(&alg_proto);
+	goto out;
+}
+
+static void __exit af_alg_exit(void)
+{
+	sock_unregister(PF_ALG);
+	proto_unregister(&alg_proto);
+}
+
+module_init(af_alg_init);
+module_exit(af_alg_exit);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_NETPROTO(AF_ALG);
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/algif_hash.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/algif_hash.c
@@ -0,0 +1,319 @@
+/*
+ * algif_hash: User-space interface for hash algorithms
+ *
+ * This file provides the user-space API for hash algorithms.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/hash.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct hash_ctx {
+	struct af_alg_sgl sgl;
+
+	u8 *result;
+
+	struct af_alg_completion completion;
+
+	unsigned int len;
+	bool more;
+
+	struct ahash_request req;
+};
+
+static int hash_sendmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t ignored)
+{
+	int limit = ALG_MAX_PAGES * PAGE_SIZE;
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned long iovlen;
+	struct iovec *iov;
+	long copied = 0;
+	int err;
+
+	if (limit > sk->sk_sndbuf)
+		limit = sk->sk_sndbuf;
+
+	lock_sock(sk);
+	if (!ctx->more) {
+		err = crypto_ahash_init(&ctx->req);
+		if (err)
+			goto unlock;
+	}
+
+	ctx->more = 0;
+
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			int len = min_t(unsigned long, seglen, limit);
+			int newlen;
+
+			newlen = af_alg_make_sg(&ctx->sgl, from, len, 0);
+			if (newlen < 0)
+				goto unlock;
+
+			ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL,
+						newlen);
+
+			err = af_alg_wait_for_completion(
+				crypto_ahash_update(&ctx->req),
+				&ctx->completion);
+
+			af_alg_free_sg(&ctx->sgl);
+
+			if (err)
+				goto unlock;
+
+			seglen -= newlen;
+			from += newlen;
+			copied += newlen;
+		}
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more) {
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+	}
+
+unlock:
+	release_sock(sk);
+
+	return err ?: copied;
+}
+
+static ssize_t hash_sendpage(struct socket *sock, struct page *page,
+			     int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	int err;
+
+	lock_sock(sk);
+	sg_init_table(ctx->sgl.sg, 1);
+	sg_set_page(ctx->sgl.sg, page, size, offset);
+
+	ahash_request_set_crypt(&ctx->req, ctx->sgl.sg, ctx->result, size);
+
+	if (!(flags & MSG_MORE)) {
+		if (ctx->more)
+			err = crypto_ahash_finup(&ctx->req);
+		else
+			err = crypto_ahash_digest(&ctx->req);
+	} else {
+		if (!ctx->more) {
+			err = crypto_ahash_init(&ctx->req);
+			if (err)
+				goto unlock;
+		}
+
+		err = crypto_ahash_update(&ctx->req);
+	}
+
+	err = af_alg_wait_for_completion(err, &ctx->completion);
+	if (err)
+		goto unlock;
+
+	ctx->more = flags & MSG_MORE;
+
+unlock:
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
+			struct msghdr *msg, size_t len, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
+	int err;
+
+	if (len > ds)
+		len = ds;
+	else if (len < ds)
+		msg->msg_flags |= MSG_TRUNC;
+
+	lock_sock(sk);
+	if (ctx->more) {
+		ctx->more = 0;
+		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
+		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
+						 &ctx->completion);
+		if (err)
+			goto unlock;
+	}
+
+	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);
+
+unlock:
+	release_sock(sk);
+
+	return err ?: len;
+}
+
+static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+	struct ahash_request *req = &ctx->req;
+	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];
+	struct sock *sk2;
+	struct alg_sock *ask2;
+	struct hash_ctx *ctx2;
+	int err;
+
+	err = crypto_ahash_export(req, state);
+	if (err)
+		return err;
+
+	err = af_alg_accept(ask->parent, newsock);
+	if (err)
+		return err;
+
+	sk2 = newsock->sk;
+	ask2 = alg_sk(sk2);
+	ctx2 = ask2->private;
+	ctx2->more = 1;
+
+	err = crypto_ahash_import(&ctx2->req, state);
+	if (err) {
+		sock_orphan(sk2);
+		sock_put(sk2);
+	}
+
+	return err;
+}
+
+static struct proto_ops algif_hash_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.setsockopt	=	sock_no_setsockopt,
+	.poll		=	sock_no_poll,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	hash_sendmsg,
+	.sendpage	=	hash_sendpage,
+	.recvmsg	=	hash_recvmsg,
+	.accept		=	hash_accept,
+};
+
+static void *hash_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ahash(name, type, mask);
+}
+
+static void hash_release(void *private)
+{
+	crypto_free_ahash(private);
+}
+
+static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ahash_setkey(private, key, keylen);
+}
+
+static void hash_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct hash_ctx *ctx = ask->private;
+
+	sock_kfree_s(sk, ctx->result,
+		     crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int hash_accept_parent(void *private, struct sock *sk)
+{
+	struct hash_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);
+	unsigned ds = crypto_ahash_digestsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);
+	if (!ctx->result) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->result, 0, ds);
+
+	ctx->len = len;
+	ctx->more = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ahash_request_set_tfm(&ctx->req, private);
+	ahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				   af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = hash_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_hash = {
+	.bind		=	hash_bind,
+	.release	=	hash_release,
+	.setkey		=	hash_setkey,
+	.accept		=	hash_accept_parent,
+	.ops		=	&algif_hash_ops,
+	.name		=	"hash",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_hash_init(void)
+{
+	return af_alg_register_type(&algif_type_hash);
+}
+
+static void __exit algif_hash_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_hash);
+	BUG_ON(err);
+}
+
+module_init(algif_hash_init);
+module_exit(algif_hash_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/algif_skcipher.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/crypto/algif_skcipher.c
@@ -0,0 +1,632 @@
+/*
+ * algif_skcipher: User-space interface for skcipher algorithms
+ *
+ * This file provides the user-space API for symmetric key ciphers.
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#include <crypto/scatterwalk.h>
+#include <crypto/skcipher.h>
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+
+struct skcipher_sg_list {
+	struct list_head list;
+
+	int cur;
+
+	struct scatterlist sg[0];
+};
+
+struct skcipher_ctx {
+	struct list_head tsgl;
+	struct af_alg_sgl rsgl;
+
+	void *iv;
+
+	struct af_alg_completion completion;
+
+	unsigned used;
+
+	unsigned int len;
+	bool more;
+	bool merge;
+	bool enc;
+
+	struct ablkcipher_request req;
+};
+
+#define MAX_SGL_ENTS ((PAGE_SIZE - sizeof(struct skcipher_sg_list)) / \
+		      sizeof(struct scatterlist) - 1)
+
+static inline int skcipher_sndbuf(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	return max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -
+			  ctx->used, 0);
+}
+
+static inline bool skcipher_writable(struct sock *sk)
+{
+	return PAGE_SIZE <= skcipher_sndbuf(sk);
+}
+
+static int skcipher_alloc_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg = NULL;
+
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+	if (!list_empty(&ctx->tsgl))
+		sg = sgl->sg;
+
+	if (!sg || sgl->cur >= MAX_SGL_ENTS) {
+		sgl = sock_kmalloc(sk, sizeof(*sgl) +
+				       sizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),
+				   GFP_KERNEL);
+		if (!sgl)
+			return -ENOMEM;
+
+		sg_init_table(sgl->sg, MAX_SGL_ENTS + 1);
+		sgl->cur = 0;
+
+		if (sg)
+			scatterwalk_sg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);
+
+		list_add_tail(&sgl->list, &ctx->tsgl);
+	}
+
+	return 0;
+}
+
+static void skcipher_pull_sgl(struct sock *sk, int used)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	int i;
+
+	while (!list_empty(&ctx->tsgl)) {
+		sgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,
+				       list);
+		sg = sgl->sg;
+
+		for (i = 0; i < sgl->cur; i++) {
+			int plen = min_t(int, used, sg[i].length);
+
+			if (!sg_page(sg + i))
+				continue;
+
+			sg[i].length -= plen;
+			sg[i].offset += plen;
+
+			used -= plen;
+			ctx->used -= plen;
+
+			if (sg[i].length)
+				return;
+
+			put_page(sg_page(sg + i));
+			sg_assign_page(sg + i, NULL);
+		}
+
+		list_del(&sgl->list);
+		sock_kfree_s(sk, sgl,
+			     sizeof(*sgl) + sizeof(sgl->sg[0]) *
+					    (MAX_SGL_ENTS + 1));
+	}
+
+	if (!ctx->used)
+		ctx->merge = 0;
+}
+
+static void skcipher_free_sgl(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+
+	skcipher_pull_sgl(sk, ctx->used);
+}
+
+static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)
+{
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT)
+		return -EAGAIN;
+
+	set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	return err;
+}
+
+static void skcipher_wmem_wakeup(struct sock *sk)
+{
+	struct socket_wq *wq;
+
+	if (!skcipher_writable(sk))
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLIN |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
+	rcu_read_unlock();
+}
+
+static int skcipher_wait_for_data(struct sock *sk, unsigned flags)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	long timeout;
+	DEFINE_WAIT(wait);
+	int err = -ERESTARTSYS;
+
+	if (flags & MSG_DONTWAIT) {
+		return -EAGAIN;
+	}
+
+	set_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	for (;;) {
+		if (signal_pending(current))
+			break;
+		prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+		timeout = MAX_SCHEDULE_TIMEOUT;
+		if (sk_wait_event(sk, &timeout, ctx->used)) {
+			err = 0;
+			break;
+		}
+	}
+	finish_wait(sk_sleep(sk), &wait);
+
+	clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
+
+	return err;
+}
+
+static void skcipher_data_wakeup(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct socket_wq *wq;
+
+	if (!ctx->used)
+		return;
+
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLOUT |
+							   POLLRDNORM |
+							   POLLRDBAND);
+	sk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);
+	rcu_read_unlock();
+}
+
+static int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+	unsigned ivsize = crypto_ablkcipher_ivsize(tfm);
+	struct skcipher_sg_list *sgl;
+	struct af_alg_control con = {};
+	long copied = 0;
+	bool enc = 0;
+	int err;
+	int i;
+
+	if (msg->msg_controllen) {
+		err = af_alg_cmsg_send(msg, &con);
+		if (err)
+			return err;
+
+		switch (con.op) {
+		case ALG_OP_ENCRYPT:
+			enc = 1;
+			break;
+		case ALG_OP_DECRYPT:
+			enc = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (con.iv && con.iv->ivlen != ivsize)
+			return -EINVAL;
+	}
+
+	err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!ctx->used) {
+		ctx->enc = enc;
+		if (con.iv)
+			memcpy(ctx->iv, con.iv->iv, ivsize);
+	}
+
+	while (size) {
+		struct scatterlist *sg;
+		unsigned long len = size;
+		int plen;
+
+		if (ctx->merge) {
+			sgl = list_entry(ctx->tsgl.prev,
+					 struct skcipher_sg_list, list);
+			sg = sgl->sg + sgl->cur - 1;
+			len = min_t(unsigned long, len,
+				    PAGE_SIZE - sg->offset - sg->length);
+
+			err = memcpy_fromiovec(page_address(sg_page(sg)) +
+					       sg->offset + sg->length,
+					       msg->msg_iov, len);
+			if (err)
+				goto unlock;
+
+			sg->length += len;
+			ctx->merge = (sg->offset + sg->length) &
+				     (PAGE_SIZE - 1);
+
+			ctx->used += len;
+			copied += len;
+			size -= len;
+			continue;
+		}
+
+		if (!skcipher_writable(sk)) {
+			err = skcipher_wait_for_wmem(sk, msg->msg_flags);
+			if (err)
+				goto unlock;
+		}
+
+		len = min_t(unsigned long, len, skcipher_sndbuf(sk));
+
+		err = skcipher_alloc_sgl(sk);
+		if (err)
+			goto unlock;
+
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+		sg = sgl->sg;
+		do {
+			i = sgl->cur;
+			plen = min_t(int, len, PAGE_SIZE);
+
+			sg_assign_page(sg + i, alloc_page(GFP_KERNEL));
+			err = -ENOMEM;
+			if (!sg_page(sg + i))
+				goto unlock;
+
+			err = memcpy_fromiovec(page_address(sg_page(sg + i)),
+					       msg->msg_iov, plen);
+			if (err) {
+				__free_page(sg_page(sg + i));
+				sg_assign_page(sg + i, NULL);
+				goto unlock;
+			}
+
+			sg[i].length = plen;
+			len -= plen;
+			ctx->used += plen;
+			copied += plen;
+			size -= plen;
+			sgl->cur++;
+		} while (len && sgl->cur < MAX_SGL_ENTS);
+
+		ctx->merge = plen & (PAGE_SIZE - 1);
+	}
+
+	err = 0;
+
+	ctx->more = msg->msg_flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+static ssize_t skcipher_sendpage(struct socket *sock, struct page *page,
+				 int offset, size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct skcipher_sg_list *sgl;
+	int err = -EINVAL;
+
+	lock_sock(sk);
+	if (!ctx->more && ctx->used)
+		goto unlock;
+
+	if (!size)
+		goto done;
+
+	if (!skcipher_writable(sk)) {
+		err = skcipher_wait_for_wmem(sk, flags);
+		if (err)
+			goto unlock;
+	}
+
+	err = skcipher_alloc_sgl(sk);
+	if (err)
+		goto unlock;
+
+	ctx->merge = 0;
+	sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+	get_page(page);
+	sg_set_page(sgl->sg + sgl->cur, page, size, offset);
+	sgl->cur++;
+	ctx->used += size;
+
+done:
+	ctx->more = flags & MSG_MORE;
+	if (!ctx->more && !list_empty(&ctx->tsgl))
+		sgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);
+
+unlock:
+	skcipher_data_wakeup(sk);
+	release_sock(sk);
+
+	return err ?: size;
+}
+
+static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,
+			    struct msghdr *msg, size_t ignored, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(
+		&ctx->req));
+	struct skcipher_sg_list *sgl;
+	struct scatterlist *sg;
+	unsigned long iovlen;
+	struct iovec *iov;
+	int err = -EAGAIN;
+	int used;
+	long copied = 0;
+
+	lock_sock(sk);
+	for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;
+	     iovlen--, iov++) {
+		unsigned long seglen = iov->iov_len;
+		char __user *from = iov->iov_base;
+
+		while (seglen) {
+			sgl = list_first_entry(&ctx->tsgl,
+					       struct skcipher_sg_list, list);
+			sg = sgl->sg;
+
+			while (!sg->length)
+				sg++;
+
+			used = ctx->used;
+			if (!used) {
+				err = skcipher_wait_for_data(sk, flags);
+				if (err)
+					goto unlock;
+			}
+
+			used = min_t(unsigned long, used, seglen);
+
+			used = af_alg_make_sg(&ctx->rsgl, from, used, 1);
+			err = used;
+			if (err < 0)
+				goto unlock;
+
+			if (ctx->more || used < ctx->used)
+				used -= used % bs;
+
+			err = -EINVAL;
+			if (!used)
+				goto free;
+
+			ablkcipher_request_set_crypt(&ctx->req, sg,
+						     ctx->rsgl.sg, used,
+						     ctx->iv);
+
+			err = af_alg_wait_for_completion(
+				ctx->enc ?
+					crypto_ablkcipher_encrypt(&ctx->req) :
+					crypto_ablkcipher_decrypt(&ctx->req),
+				&ctx->completion);
+
+free:
+			af_alg_free_sg(&ctx->rsgl);
+
+			if (err)
+				goto unlock;
+
+			copied += used;
+			from += used;
+			seglen -= used;
+			skcipher_pull_sgl(sk, used);
+		}
+	}
+
+	err = 0;
+
+unlock:
+	skcipher_wmem_wakeup(sk);
+	release_sock(sk);
+
+	return copied ?: err;
+}
+
+
+static unsigned int skcipher_poll(struct file *file, struct socket *sock,
+				  poll_table *wait)
+{
+	struct sock *sk = sock->sk;
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	unsigned int mask;
+
+	sock_poll_wait(file, sk_sleep(sk), wait);
+	mask = 0;
+
+	if (ctx->used)
+		mask |= POLLIN | POLLRDNORM;
+
+	if (skcipher_writable(sk))
+		mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
+
+	return mask;
+}
+
+static struct proto_ops algif_skcipher_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_no_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.accept		=	sock_no_accept,
+	.setsockopt	=	sock_no_setsockopt,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	skcipher_sendmsg,
+	.sendpage	=	skcipher_sendpage,
+	.recvmsg	=	skcipher_recvmsg,
+	.poll		=	skcipher_poll,
+};
+
+static void *skcipher_bind(const char *name, u32 type, u32 mask)
+{
+	return crypto_alloc_ablkcipher(name, type, mask);
+}
+
+static void skcipher_release(void *private)
+{
+	crypto_free_ablkcipher(private);
+}
+
+static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
+{
+	return crypto_ablkcipher_setkey(private, key, keylen);
+}
+
+static void skcipher_sock_destruct(struct sock *sk)
+{
+	struct alg_sock *ask = alg_sk(sk);
+	struct skcipher_ctx *ctx = ask->private;
+	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
+
+	skcipher_free_sgl(sk);
+	sock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));
+	sock_kfree_s(sk, ctx, ctx->len);
+	af_alg_release_parent(sk);
+}
+
+static int skcipher_accept_parent(void *private, struct sock *sk)
+{
+	struct skcipher_ctx *ctx;
+	struct alg_sock *ask = alg_sk(sk);
+	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);
+
+	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),
+			       GFP_KERNEL);
+	if (!ctx->iv) {
+		sock_kfree_s(sk, ctx, len);
+		return -ENOMEM;
+	}
+
+	memset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));
+
+	INIT_LIST_HEAD(&ctx->tsgl);
+	ctx->len = len;
+	ctx->used = 0;
+	ctx->more = 0;
+	ctx->merge = 0;
+	ctx->enc = 0;
+	af_alg_init_completion(&ctx->completion);
+
+	ask->private = ctx;
+
+	ablkcipher_request_set_tfm(&ctx->req, private);
+	ablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					af_alg_complete, &ctx->completion);
+
+	sk->sk_destruct = skcipher_sock_destruct;
+
+	return 0;
+}
+
+static const struct af_alg_type algif_type_skcipher = {
+	.bind		=	skcipher_bind,
+	.release	=	skcipher_release,
+	.setkey		=	skcipher_setkey,
+	.accept		=	skcipher_accept_parent,
+	.ops		=	&algif_skcipher_ops,
+	.name		=	"skcipher",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_skcipher_init(void)
+{
+	return af_alg_register_type(&algif_type_skcipher);
+}
+
+static void __exit algif_skcipher_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_skcipher);
+	BUG_ON(err);
+}
+
+module_init(algif_skcipher_init);
+module_exit(algif_skcipher_exit);
+MODULE_LICENSE("GPL");
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/core/sock.c
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/net/core/sock.c
@@ -157,7 +157,7 @@
   "sk_lock-27"       , "sk_lock-28"          , "sk_lock-AF_CAN"      ,
   "sk_lock-AF_TIPC"  , "sk_lock-AF_BLUETOOTH", "sk_lock-IUCV"        ,
   "sk_lock-AF_RXRPC" , "sk_lock-AF_ISDN"     , "sk_lock-AF_PHONET"   ,
-  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" ,
+  "sk_lock-AF_IEEE802154", "sk_lock-AF_CAIF" , "sk_lock-AF_ALG"      ,
   "sk_lock-AF_MAX"
 };
 static const char *const af_family_slock_key_strings[AF_MAX+1] = {
@@ -173,7 +173,7 @@
   "slock-27"       , "slock-28"          , "slock-AF_CAN"      ,
   "slock-AF_TIPC"  , "slock-AF_BLUETOOTH", "slock-AF_IUCV"     ,
   "slock-AF_RXRPC" , "slock-AF_ISDN"     , "slock-AF_PHONET"   ,
-  "slock-AF_IEEE802154", "slock-AF_CAIF" ,
+  "slock-AF_IEEE802154", "slock-AF_CAIF" , "slock-AF_ALG"      ,
   "slock-AF_MAX"
 };
 static const char *const af_family_clock_key_strings[AF_MAX+1] = {
@@ -189,7 +189,7 @@
   "clock-27"       , "clock-28"          , "clock-AF_CAN"      ,
   "clock-AF_TIPC"  , "clock-AF_BLUETOOTH", "clock-AF_IUCV"     ,
   "clock-AF_RXRPC" , "clock-AF_ISDN"     , "clock-AF_PHONET"   ,
-  "clock-AF_IEEE802154", "clock-AF_CAIF" ,
+  "clock-AF_IEEE802154", "clock-AF_CAIF" , "clock-AF_ALG"      ,
   "clock-AF_MAX"
 };
 
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/crypto/if_alg.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/crypto/if_alg.h
@@ -0,0 +1,92 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _CRYPTO_IF_ALG_H
+#define _CRYPTO_IF_ALG_H
+
+#include <linux/compiler.h>
+#include <linux/completion.h>
+#include <linux/if_alg.h>
+#include <linux/types.h>
+#include <net/sock.h>
+
+#define ALG_MAX_PAGES			16
+
+struct crypto_async_request;
+
+struct alg_sock {
+	/* struct sock must be the first member of struct alg_sock */
+	struct sock sk;
+
+	struct sock *parent;
+
+	const struct af_alg_type *type;
+	void *private;
+};
+
+struct af_alg_completion {
+	struct completion completion;
+	int err;
+};
+
+struct af_alg_control {
+	struct af_alg_iv *iv;
+	int op;
+};
+
+struct af_alg_type {
+	void *(*bind)(const char *name, u32 type, u32 mask);
+	void (*release)(void *private);
+	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
+	int (*accept)(void *private, struct sock *sk);
+
+	struct proto_ops *ops;
+	struct module *owner;
+	char name[14];
+};
+
+struct af_alg_sgl {
+	struct scatterlist sg[ALG_MAX_PAGES];
+	struct page *pages[ALG_MAX_PAGES];
+};
+
+int af_alg_register_type(const struct af_alg_type *type);
+int af_alg_unregister_type(const struct af_alg_type *type);
+
+int af_alg_release(struct socket *sock);
+int af_alg_accept(struct sock *sk, struct socket *newsock);
+
+int af_alg_make_sg(struct af_alg_sgl *sgl, void __user *addr, int len,
+		   int write);
+void af_alg_free_sg(struct af_alg_sgl *sgl);
+
+int af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con);
+
+int af_alg_wait_for_completion(int err, struct af_alg_completion *completion);
+void af_alg_complete(struct crypto_async_request *req, int err);
+
+static inline struct alg_sock *alg_sk(struct sock *sk)
+{
+	return (struct alg_sock *)sk;
+}
+
+static inline void af_alg_release_parent(struct sock *sk)
+{
+	sock_put(alg_sk(sk)->parent);
+}
+
+static inline void af_alg_init_completion(struct af_alg_completion *completion)
+{
+	init_completion(&completion->completion);
+}
+
+#endif	/* _CRYPTO_IF_ALG_H */
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/crypto/scatterwalk.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/crypto/scatterwalk.h
@@ -68,6 +68,21 @@
 	return (++sg)->length ? sg : (void *)sg_page(sg);
 }
 
+static inline void scatterwalk_crypto_chain(struct scatterlist *head,
+					    struct scatterlist *sg,
+					    int chain, int num)
+{
+	if (chain) {
+		head->length += sg->length;
+		sg = scatterwalk_sg_next(sg);
+	}
+
+	if (sg)
+		scatterwalk_sg_chain(head, num, sg);
+	else
+		sg_mark_end(head);
+}
+
 static inline unsigned long scatterwalk_samebuf(struct scatter_walk *walk_in,
 						struct scatter_walk *walk_out)
 {
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/linux/if_alg.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/linux/if_alg.h
@@ -0,0 +1,40 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _LINUX_IF_ALG_H
+#define _LINUX_IF_ALG_H
+
+#include <linux/types.h>
+
+struct sockaddr_alg {
+	__u16	salg_family;
+	__u8	salg_type[14];
+	__u32	salg_feat;
+	__u32	salg_mask;
+	__u8	salg_name[64];
+};
+
+struct af_alg_iv {
+	__u32	ivlen;
+	__u8	iv[0];
+};
+
+/* Socket options */
+#define ALG_SET_KEY			1
+#define ALG_SET_IV			2
+#define ALG_SET_OP			3
+
+/* Operations */
+#define ALG_OP_DECRYPT			0
+#define ALG_OP_ENCRYPT			1
+
+#endif	/* _LINUX_IF_ALG_H */
--- a/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/linux/socket.h
+++ b/release/src-rt-7.x.main/src/linux/linux-2.6.36/include/linux/socket.h
@@ -193,7 +193,8 @@
 #define AF_PHONET	35	/* Phonet sockets		*/
 #define AF_IEEE802154	36	/* IEEE802154 sockets		*/
 #define AF_CAIF		37	/* CAIF sockets			*/
-#define AF_MAX		38	/* For now.. */
+#define AF_ALG		38	/* Algorithm sockets		*/
+#define AF_MAX		39	/* For now.. */
 
 /* Protocol families, same as address families. */
 #define PF_UNSPEC	AF_UNSPEC
@@ -234,6 +235,7 @@
 #define PF_PHONET	AF_PHONET
 #define PF_IEEE802154	AF_IEEE802154
 #define PF_CAIF		AF_CAIF
+#define PF_ALG		AF_ALG
 #define PF_MAX		AF_MAX
 
 /* Maximum queue length specifiable by listen.  */
@@ -310,6 +312,7 @@
 #define SOL_RDS		276
 #define SOL_IUCV	277
 #define SOL_CAIF	278
+#define SOL_ALG		279
 
 /* IPX options */
 #define IPX_TYPE	1

--- a/release/src/router/iptables-1.4.x/extensions/compat_user.h
+++ b/release/src/router/iptables-1.4.x/extensions/compat_user.h
@@ -0,0 +1,12 @@
+/*
+ *	Userspace-level compat hacks
+ */
+#ifndef _XTABLES_COMPAT_USER_H
+#define _XTABLES_COMPAT_USER_H 1
+
+/* linux-glibc-devel 2.6.34 header screwup */
+#ifndef ALIGN
+#	define ALIGN(s, n) (((s) + ((n) - 1)) & ~((n) - 1))
+#endif
+
+#endif /* _XTABLES_COMPAT_USER_H */

--- a/release/src/router/iptables-1.4.x/extensions/libxt_CHAOS.c
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_CHAOS.c
@@ -0,0 +1,113 @@
+/*
+ *	"CHAOS" target extension for iptables
+ *	Copyright © Jan Engelhardt <jengelh [at] medozas de>, 2006 - 2008
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <getopt.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <xtables.h>
+#include <linux/netfilter/x_tables.h>
+#include "xt_CHAOS.h"
+#include "compat_user.h"
+
+enum {
+	F_DELUDE = 1 << 0,
+	F_TARPIT = 1 << 1,
+};
+
+static const struct option chaos_tg_opts[] = {
+	{.name = "delude", .has_arg = false, .val = 'd'},
+	{.name = "tarpit", .has_arg = false, .val = 't'},
+	{NULL},
+};
+
+static void chaos_tg_help(void)
+{
+	printf(
+		"CHAOS target options:\n"
+		"  --delude    Enable DELUDE processing for TCP\n"
+		"  --tarpit    Enable TARPIT processing for TCP\n");
+}
+
+static int chaos_tg_parse(int c, char **argv, int invert, unsigned int *flags,
+    const void *entry, struct xt_entry_target **target)
+{
+	struct xt_chaos_tginfo *info = (void *)((*target)->data);
+
+	switch (c) {
+	case 'd':
+		info->variant = XTCHAOS_DELUDE;
+		*flags |= F_DELUDE;
+		return true;
+	case 't':
+		info->variant = XTCHAOS_TARPIT;
+		*flags |= F_TARPIT;
+		return true;
+	}
+	return false;
+}
+
+static void chaos_tg_check(unsigned int flags)
+{
+	if (flags == (F_DELUDE | F_TARPIT))
+		/* If flags == 0x03, both were specified, which should not be. */
+		xtables_error(PARAMETER_PROBLEM,
+		           "CHAOS: only one of --tarpit or --delude "
+		           "may be specified");
+}
+
+static void chaos_tg_print(const void *ip,
+    const struct xt_entry_target *target, int numeric)
+{
+	const struct xt_chaos_tginfo *info = (const void *)target->data;
+
+	switch (info->variant) {
+	case XTCHAOS_DELUDE:
+		printf(" DELUDE ");
+		break;
+	case XTCHAOS_TARPIT:
+		printf(" TARPIT ");
+		break;
+	}
+}
+
+static void chaos_tg_save(const void *ip, const struct xt_entry_target *target)
+{
+	const struct xt_chaos_tginfo *info = (const void *)target->data;
+
+	switch (info->variant) {
+	case XTCHAOS_DELUDE:
+		printf(" --delude ");
+		break;
+	case XTCHAOS_TARPIT:
+		printf(" --tarpit ");
+		break;
+	}
+}
+
+static struct xtables_target chaos_tg_reg = {
+	.version       = XTABLES_VERSION,
+	.name          = "CHAOS",
+	.family        = NFPROTO_IPV4,
+	.size          = XT_ALIGN(sizeof(struct xt_chaos_tginfo)),
+	.userspacesize = XT_ALIGN(sizeof(struct xt_chaos_tginfo)),
+	.help          = chaos_tg_help,
+	.parse         = chaos_tg_parse,
+	.final_check   = chaos_tg_check,
+	.print         = chaos_tg_print,
+	.save          = chaos_tg_save,
+	.extra_opts    = chaos_tg_opts,
+};
+
+static __attribute__((constructor)) void chaos_tg_ldr(void)
+{
+	xtables_register_target(&chaos_tg_reg);
+}

--- a/release/src/router/iptables-1.4.x/extensions/libxt_CHAOS.man
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_CHAOS.man
@@ -0,0 +1,21 @@
+Causes confusion on the other end by doing odd things with incoming packets.
+CHAOS will randomly reply (or not) with one of its configurable subtargets:
+.TP
+\fB\-\-delude\fP
+Use the REJECT and DELUDE targets as a base to do a sudden or deferred
+connection reset, fooling some network scanners to return non-deterministic
+(randomly open/closed) results, and in case it is deemed open, it is actually
+closed/filtered.
+.TP
+\fB\-\-tarpit\fP
+Use the REJECT and TARPIT target as a base to hold the connection until it
+times out. This consumes conntrack entries when connection tracking is loaded
+(which usually is on most machines), and routers inbetween you and the Internet
+may fail to do their connection tracking if they have to handle more
+connections than they can.
+.PP
+The randomness factor of not replying vs. replying can be set during load-time
+of the xt_CHAOS module or during runtime in /sys/modules/xt_CHAOS/parameters.
+.PP
+See http://jengelh.medozas.de/projects/chaostables/ for more information
+about CHAOS, DELUDE and lscan.

--- a/release/src/router/iptables-1.4.x/extensions/libxt_DELUDE.c
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_DELUDE.c
@@ -0,0 +1,46 @@
+/*
+ *	"DELUDE" target extension for iptables
+ *	Copyright © Jan Engelhardt <jengelh [at] medozas de>, 2006 - 2008
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <getopt.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <xtables.h>
+#include <linux/netfilter/x_tables.h>
+#include "compat_user.h"
+
+static void delude_tg_help(void)
+{
+	printf("DELUDE takes no options\n");
+}
+
+static int delude_tg_parse(int c, char **argv, int invert, unsigned int *flags,
+    const void *entry, struct xt_entry_target **target)
+{
+	return 0;
+}
+
+static void delude_tg_check(unsigned int flags)
+{
+}
+
+static struct xtables_target delude_tg_reg = {
+	.version       = XTABLES_VERSION,
+	.name          = "DELUDE",
+	.revision      = 0,
+	.family        = NFPROTO_IPV4,
+	.help          = delude_tg_help,
+	.parse         = delude_tg_parse,
+	.final_check   = delude_tg_check,
+};
+
+static __attribute__((constructor)) void delude_tg_ldr(void)
+{
+	xtables_register_target(&delude_tg_reg);
+}

--- a/release/src/router/iptables-1.4.x/extensions/libxt_DELUDE.man
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_DELUDE.man
@@ -0,0 +1,4 @@
+The DELUDE target will reply to a SYN packet with SYN-ACK, and to all other
+packets with an RST. This will terminate the connection much like REJECT, but
+network scanners doing TCP half-open discovery can be spoofed to make them
+belive the port is open rather than closed/filtered.

--- a/release/src/router/iptables-1.4.x/extensions/libxt_fuzzy.c
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_fuzzy.c
@@ -0,0 +1,122 @@
+/*
+ *	"fuzzy" match extension for iptables
+ *	Hime Aguiar e Oliveira Jr. <hime@engineer.com>, 2002 - 2003
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License;
+ *	either version 2 of the License, or any later version, as
+ *	published by the Free Software Foundation.
+ */
+#include <getopt.h>
+#include <netdb.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <xtables.h>
+#include "xt_fuzzy.h"
+#include "compat_user.h"
+
+static void fuzzy_mt_help(void)
+{
+	printf(
+"fuzzy match options:\n"
+"  --lower-limit number (in packets per second)\n"
+"  --upper-limit number\n");
+};
+
+static const struct option fuzzy_mt_opts[] = {
+	{.name = "lower-limit", .has_arg = true, .val = '1'},
+	{.name = "upper-limit", .has_arg = true, .val = '2'},
+	{NULL},
+};
+
+/* Initialize data structures */
+static void fuzzy_mt_init(struct xt_entry_match *m)
+{
+	struct xt_fuzzy_mtinfo *info = (void *)m->data;
+
+	/*
+	 * Default rates (I will improve this very soon with something based
+	 * on real statistics of the running machine).
+	 */
+	info->minimum_rate = 1000;
+	info->maximum_rate = 2000;
+}
+
+#define IPT_FUZZY_OPT_MINIMUM	0x01
+#define IPT_FUZZY_OPT_MAXIMUM	0x02
+
+static int fuzzy_mt_parse(int c, char **argv, int invert, unsigned int *flags,
+                          const void *entry, struct xt_entry_match **match)
+{
+	struct xt_fuzzy_mtinfo *info = (void *)(*match)->data;
+	uint32_t num;
+
+	switch (c) {
+	case '1':
+		if (invert)
+			xtables_error(PARAMETER_PROBLEM,"Can't specify ! --lower-limit");
+		if (*flags & IPT_FUZZY_OPT_MINIMUM)
+			xtables_error(PARAMETER_PROBLEM,"Can't specify --lower-limit twice");
+		if (!xtables_strtoui(optarg, NULL, &num, 1, FUZZY_MAX_RATE) || num < 1)
+			xtables_error(PARAMETER_PROBLEM,"BAD --lower-limit");
+		info->minimum_rate = num;
+		*flags |= IPT_FUZZY_OPT_MINIMUM;
+		return true;
+
+	case '2':
+		if (invert)
+			xtables_error(PARAMETER_PROBLEM,"Can't specify ! --upper-limit");
+		if (*flags & IPT_FUZZY_OPT_MAXIMUM)
+			xtables_error(PARAMETER_PROBLEM,"Can't specify --upper-limit twice");
+		if (!xtables_strtoui(optarg, NULL, &num, 1, FUZZY_MAX_RATE) || num < 1)
+			xtables_error(PARAMETER_PROBLEM,"BAD --upper-limit");
+		info->maximum_rate = num;
+		*flags |= IPT_FUZZY_OPT_MAXIMUM;
+		return true;
+	}
+	return false;
+}
+
+static void fuzzy_mt_check(unsigned int flags)
+{
+}
+
+static void fuzzy_mt_print(const void *ip, const struct xt_entry_match *match,
+                           int numeric)
+{
+	const struct xt_fuzzy_mtinfo *info = (const void *)match->data;
+
+	printf(" fuzzy: lower limit = %u pps - upper limit = %u pps ",
+	       info->minimum_rate, info->maximum_rate);
+}
+
+static void fuzzy_mt_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_fuzzy_mtinfo *info = (const void *)match->data;
+
+	printf(" --lower-limit %u ", info->minimum_rate);
+	printf(" --upper-limit %u ", info->maximum_rate);
+}
+
+static struct xtables_match fuzzy_mt_reg = {
+	.name          = "fuzzy",
+	.revision      = 1,
+	.version       = XTABLES_VERSION,
+	.family        = NFPROTO_UNSPEC,
+	.size          = XT_ALIGN(sizeof(struct xt_fuzzy_mtinfo)),
+	.userspacesize = offsetof(struct xt_fuzzy_mtinfo, packets_total),
+	.help          = fuzzy_mt_help,
+	.init          = fuzzy_mt_init,
+	.parse         = fuzzy_mt_parse,
+	.final_check   = fuzzy_mt_check,
+	.print         = fuzzy_mt_print,
+	.save          = fuzzy_mt_save,
+	.extra_opts    = fuzzy_mt_opts,
+};
+
+static __attribute__((constructor)) void fuzzy_mt_ldr(void)
+{
+	xtables_register_match(&fuzzy_mt_reg);
+}

--- a/release/src/router/iptables-1.4.x/extensions/libxt_fuzzy.man
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_fuzzy.man
@@ -0,0 +1,7 @@
+This module matches a rate limit based on a fuzzy logic controller (FLC).
+.TP
+\fB\-\-lower\-limit\fP \fInumber\fP
+Specifies the lower limit, in packets per second.
+.TP
+\fB\-\-upper\-limit\fP \fInumber\fP
+Specifies the upper limit, also in packets per second.

--- a/release/src/router/iptables-1.4.x/extensions/libxt_iface.c
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_iface.c
@@ -0,0 +1,247 @@
+/*
+ * Shared library add-on to iptables to add interface state matching
+ * support.
+ *
+ * (C) 2008 Gáspár Lajos <gaspar.lajos@glsys.eu>
+ *
+ * This program is released under the terms of GNU GPL version 2.
+ */
+
+#include <getopt.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <xtables.h>
+#include "xt_iface.h"
+#include "compat_user.h"
+
+enum {
+	XT_IFACE_IFACE = 1 << 16,
+};
+
+static const struct option iface_mt_opts[] = {
+	{.name = "iface",        .has_arg = true,  .val = 'i'},
+	{.name = "dev-in",       .has_arg = false, .val = 'I'},
+	{.name = "dev-out",      .has_arg = false, .val = 'O'},
+	{.name = "up",           .has_arg = false, .val = 'u'},
+	{.name = "down",         .has_arg = false, .val = 'U'}, /* not up */
+	{.name = "broadcast",    .has_arg = false, .val = 'b'},
+	{.name = "loopback",     .has_arg = false, .val = 'l'},
+	{.name = "pointopoint",  .has_arg = false, .val = 'p'},
+	{.name = "pointtopoint", .has_arg = false, .val = 'p'}, /* eq pointopoint */
+	{.name = "running",      .has_arg = false, .val = 'r'},
+	{.name = "noarp",        .has_arg = false, .val = 'n'},
+	{.name = "arp",          .has_arg = false, .val = 'N'}, /* not noarp */
+	{.name = "promisc",      .has_arg = false, .val = 'o'},
+	{.name = "multicast",    .has_arg = false, .val = 'm'},
+	{.name = "dynamic",      .has_arg = false, .val = 'd'},
+	{.name = "lower-up",     .has_arg = false, .val = 'w'},
+	{.name = "dormant",      .has_arg = false, .val = 'a'},
+	{NULL},
+};
+
+static void iface_print_opt(const struct xt_iface_mtinfo *info,
+    const unsigned int option, const char *command)
+{
+	if (info->flags & option)
+		printf(" %s%s", (info->invflags & option) ? "! " : "", command);
+}
+
+static void iface_setflag(struct xt_iface_mtinfo *info,
+    unsigned int *flags, int invert, u_int16_t flag, const char *command)
+{
+	if (*flags & flag)
+		xtables_error(PARAMETER_PROBLEM,
+			"iface: \"--%s\" flag already specified", command);
+	info->flags |= flag;
+	if (invert)
+		info->invflags |= flag;
+	*flags |= flag;
+}
+
+static bool iface_valid_name(const char *name)
+{
+	static const char invalid_chars[] = ".+!*";
+
+	return strlen(name) < IFNAMSIZ && strpbrk(name, invalid_chars) == NULL;
+}
+
+static void iface_mt_help(void)
+{
+	printf(
+	"iface match options:\n"
+	"    --iface interface     Name of interface\n"
+	"    --dev-in / --dev-out  Use incoming/outgoing interface instead\n"
+	"[!] --up / --down         match if UP flag (not) set\n"
+	"[!] --broadcast           match if BROADCAST flag (not) set\n"
+	"[!] --loopback            match if LOOPBACK flag (not) set\n"
+	"[!] --pointopoint\n"
+	"[!] --pointtopoint        match if POINTOPOINT flag (not) set\n"
+	"[!] --running             match if RUNNING flag (not) set\n"
+	"[!] --noarp / --arp       match if NOARP flag (not) set\n"
+	"[!] --promisc             match if PROMISC flag (not) set\n"
+	"[!] --multicast           match if MULTICAST flag (not) set\n"
+	"[!] --dynamic             match if DYNAMIC flag (not) set\n"
+	"[!] --lower-up            match if LOWER_UP flag (not) set\n"
+	"[!] --dormant             match if DORMANT flag (not) set\n");
+}
+
+static int iface_mt_parse(int c, char **argv, int invert, unsigned int *flags,
+    const void *entry, struct xt_entry_match **match)
+{
+	struct xt_iface_mtinfo *info = (void *)(*match)->data;
+
+	switch (c) {
+	case 'U':
+		c = 'u';
+		invert = !invert;
+		break;
+	case 'N':
+		c = 'n';
+		invert = !invert;
+		break;
+	}
+
+	switch (c) {
+	case 'i': /* interface name */
+		if (*flags & XT_IFACE_IFACE)
+			xtables_error(PARAMETER_PROBLEM,
+				"iface: Interface name already specified");
+		if (!iface_valid_name(optarg))
+			xtables_error(PARAMETER_PROBLEM,
+				"iface: Invalid interface name!");
+		strcpy(info->ifname, optarg);
+		*flags |= XT_IFACE_IFACE;
+		return true;
+	case 'I': /* --dev-in */
+		xtables_param_act(XTF_ONLY_ONCE, "iface", "--dev-in",
+			*flags & XT_IFACE_IFACE);
+		*flags |= XT_IFACE_IFACE;
+		iface_setflag(info, flags, invert, XT_IFACE_DEV_IN, "dev-in");
+		return true;
+	case 'O': /* --dev-out */
+		xtables_param_act(XTF_ONLY_ONCE, "iface", "--dev-out",
+			*flags & XT_IFACE_IFACE);
+		*flags |= XT_IFACE_IFACE;
+		iface_setflag(info, flags, invert, XT_IFACE_DEV_OUT, "dev-out");
+		return true;
+	case 'u': /* UP */
+		iface_setflag(info, flags, invert, XT_IFACE_UP, "up");
+		return true;
+	case 'b': /* BROADCAST */
+		iface_setflag(info, flags, invert, XT_IFACE_BROADCAST, "broadcast");
+		return true;
+	case 'l': /* LOOPBACK */
+		iface_setflag(info, flags, invert, XT_IFACE_LOOPBACK, "loopback");
+		return true;
+	case 'p': /* POINTOPOINT */
+		iface_setflag(info, flags, invert, XT_IFACE_POINTOPOINT, "pointopoint");
+		return true;
+	case 'r': /* RUNNING */
+		iface_setflag(info, flags, invert, XT_IFACE_RUNNING, "running");
+		return true;
+	case 'n': /* NOARP */
+		iface_setflag(info, flags, invert, XT_IFACE_NOARP, "noarp");
+		return true;
+	case 'o': /* PROMISC */
+		iface_setflag(info, flags, invert, XT_IFACE_PROMISC, "promisc");
+		return true;
+	case 'm': /* MULTICAST */
+		iface_setflag(info, flags, invert, XT_IFACE_MULTICAST, "multicast");
+		return true;
+	case 'd': /* DYNAMIC */
+		iface_setflag(info, flags, invert, XT_IFACE_DYNAMIC, "dynamic");
+		return true;
+	case 'w': /* LOWER_UP */
+		iface_setflag(info, flags, invert, XT_IFACE_LOWER_UP, "lower_up");
+		return true;
+	case 'a': /* DORMANT */
+		iface_setflag(info, flags, invert, XT_IFACE_DORMANT, "dormant");
+		return true;
+	}
+	return false;
+}
+
+static void iface_mt_check(unsigned int flags)
+{
+	if (!(flags & XT_IFACE_IFACE))
+		xtables_error(PARAMETER_PROBLEM,
+			"iface: You must specify an interface");
+	if ((flags & ~(XT_IFACE_IFACE | XT_IFACE_DEV_IN |
+	    XT_IFACE_DEV_OUT)) == 0)
+		xtables_error(PARAMETER_PROBLEM,
+			"iface: You must specify at least one option");
+}
+
+static void iface_mt_print(const void *ip, const struct xt_entry_match *match,
+    int numeric)
+{
+	const struct xt_iface_mtinfo *info = (const void *)match->data;
+
+	printf(" iface: ");
+	if (info->flags & XT_IFACE_DEV_IN)
+		printf("(in)");
+	else if (info->flags & XT_IFACE_DEV_OUT)
+		printf("(out)");
+	else
+		printf("%s", info->ifname);
+	printf(" [state:");
+	iface_print_opt(info, XT_IFACE_UP,          "up");
+	iface_print_opt(info, XT_IFACE_BROADCAST,   "broadcast");
+	iface_print_opt(info, XT_IFACE_LOOPBACK,    "loopback");
+	iface_print_opt(info, XT_IFACE_POINTOPOINT, "pointopoint");
+	iface_print_opt(info, XT_IFACE_RUNNING,     "running");
+	iface_print_opt(info, XT_IFACE_NOARP,       "noarp");
+	iface_print_opt(info, XT_IFACE_PROMISC,     "promisc");
+	iface_print_opt(info, XT_IFACE_MULTICAST,   "multicast");
+	iface_print_opt(info, XT_IFACE_DYNAMIC,     "dynamic");
+	iface_print_opt(info, XT_IFACE_LOWER_UP,    "lower_up");
+	iface_print_opt(info, XT_IFACE_DORMANT,     "dormant");
+	printf("] ");
+}
+
+static void iface_mt_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_iface_mtinfo *info = (const void *)match->data;
+
+	if (info->flags & XT_IFACE_DEV_IN)
+		printf(" --dev-in");
+	else if (info->flags & XT_IFACE_DEV_OUT)
+		printf(" --dev-out");
+	else
+		printf(" --iface %s", info->ifname);
+	iface_print_opt(info, XT_IFACE_UP,          "--up");
+	iface_print_opt(info, XT_IFACE_BROADCAST,   "--broadcast");
+	iface_print_opt(info, XT_IFACE_LOOPBACK,    "--loopback");
+	iface_print_opt(info, XT_IFACE_POINTOPOINT, "--pointopoint");
+	iface_print_opt(info, XT_IFACE_RUNNING,     "--running");
+	iface_print_opt(info, XT_IFACE_NOARP,       "--noarp");
+	iface_print_opt(info, XT_IFACE_PROMISC,     "--promisc");
+	iface_print_opt(info, XT_IFACE_MULTICAST,   "--multicast");
+	iface_print_opt(info, XT_IFACE_DYNAMIC,     "--dynamic");
+	iface_print_opt(info, XT_IFACE_LOWER_UP,    "--lower_up");
+	iface_print_opt(info, XT_IFACE_DORMANT,     "--dormant");
+	printf(" ");
+}
+
+static struct xtables_match iface_mt_reg = {
+	.version	= XTABLES_VERSION,
+	.name		= "iface",
+	.revision	= 0,
+	.family		= NFPROTO_UNSPEC,
+	.size		= XT_ALIGN(sizeof(struct xt_iface_mtinfo)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_iface_mtinfo)),
+	.help		= iface_mt_help,
+	.parse		= iface_mt_parse,
+	.final_check	= iface_mt_check,
+	.print		= iface_mt_print,
+	.save		= iface_mt_save,
+	.extra_opts	= iface_mt_opts,
+};
+
+static __attribute__((constructor)) void iface_mt_ldr(void)
+{
+	xtables_register_match(&iface_mt_reg);
+}

--- a/release/src/router/iptables-1.4.x/extensions/libxt_iface.man
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_iface.man
@@ -0,0 +1,50 @@
+Allows you to check interface states. First, an interface needs to be selected
+for comparison. Exactly one option of the following three must be specified:
+.TP
+\fB\-\-iface\fP \fIname\fP
+Check the states on the given interface.
+.TP
+\fB\-\-dev\-in\fP
+Check the states on the interface on which the packet came in. If the input
+device is not set, because for example you are using \-m iface in the OUTPUT
+chain, this submatch returns false.
+.TP
+\fB\-\-dev\-out\fP
+Check the states on the interface on which the packet will go out. If the
+output device is not set, because for example you are using \-m iface in the
+INPUT chain, this submatch returns false.
+.PP
+Following that, one can select the interface properties to check for:
+.TP
+[\fB!\fP] \fB\-\-up\fP, [\fB!\fP] \fB\-\-down\fP
+Check the UP flag.
+.TP
+[\fB!\fP] \fB\-\-broadcast\fP
+Check the BROADCAST flag.
+.TP
+[\fB!\fP] \fB\-\-loopback\fP
+Check the LOOPBACK flag.
+.TP
+[\fB!\fP] \fB\-\-pointtopoint\fP
+Check the POINTTOPOINT flag.
+.TP
+[\fB!\fP] \fB\-\-running\fP
+Check the RUNNING flag. Do NOT rely on it!
+.TP
+[\fB!\fP] \fB\-\-noarp\fP, [\fB!\fP] \fB\-\-arp\fP
+Check the NOARP flag.
+.TP
+[\fB!\fP] \fB\-\-promisc\fP
+Check the PROMISC flag.
+.TP
+[\fB!\fP] \fB\-\-multicast\fP
+Check the MULTICAST flag.
+.TP
+[\fB!\fP] \fB\-\-dynamic\fP
+Check the DYNAMIC flag.
+.TP
+[\fB!\fP] \fB\-\-lower\-up\fP
+Check the LOWER_UP flag.
+.TP
+[\fB!\fP] \fB\-\-dormant\fP
+Check the DORMANT flag.

--- a/release/src/router/iptables-1.4.x/extensions/libxt_ipv4options.c
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_ipv4options.c
@@ -0,0 +1,178 @@
+/*
+ *	"ipv4options" match extension for iptables
+ *	Copyright © Jan Engelhardt, 2009
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <getopt.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include <xtables.h>
+#include "xt_ipv4options.h"
+#include "compat_user.h"
+
+/*
+ * Overview from http://www.networksorcery.com/enp/protocol/ip.htm
+ * Not providing strings for options that seem to be most distant in the past.
+ */
+static const char *const v4opt_names[32] = {
+	[ 1] = "nop",
+	[ 2] = "security",     /* RFC 1108 */
+	[ 3] = "lsrr",         /* RFC 791 */
+	[ 4] = "timestamp",    /* RFC 781, 791 */
+	[ 7] = "record-route", /* RFC 791 */
+	[ 9] = "ssrr",         /* RFC 791 */
+	[11] = "mtu-probe",    /* RFC 1063 */
+	[12] = "mtu-reply",    /* RFC 1063 */
+	[18] = "traceroute",   /* RFC 1393 */
+	[20] = "router-alert", /* RFC 2113 */
+};
+
+static void ipv4options_mt_help(void)
+{
+	printf(
+"ipv4options match options:\n"
+"--flags [!]symbol[,...]    Match presence/absence (!) of option\n"
+"                           (either by name or number)\n"
+"--any                      Interpret --flags as OR-combined\n\n");
+}
+
+static const struct option ipv4options_mt_opts[] = {
+	{.name = "flags", .has_arg = true,  .val = 'f'},
+	{.name = "any",   .has_arg = false, .val = 'a'},
+	{NULL},
+};
+
+static void ipv4options_parse_flagspec(struct xt_ipv4options_mtinfo1 *info,
+    char *arg)
+{
+	unsigned int i, opt;
+	bool inv;
+	char *p;
+
+	while (true) {
+		p = strchr(arg, ',');
+		if (p != NULL)
+			*p = '\0';
+
+		inv = false;
+		opt = 0;
+		if (*arg == '!') {
+			inv = true;
+			++arg;
+		}
+
+		for (i = 1; i < 32;++i)
+			if (v4opt_names[i] != NULL &&
+			    strcmp(v4opt_names[i], arg) == 0) {
+				opt = i;
+				break;
+			}
+
+		if (opt == 0 &&
+		    !xtables_strtoui(arg, NULL, &opt, 0, UINT8_MAX))
+			xtables_error(PARAMETER_PROBLEM,
+				"ipv4options: Bad option value \"%s\"", arg);
+
+		if (opt == 0)
+			xtables_error(PARAMETER_PROBLEM,
+				"ipv4options: Option value may not be zero");
+
+		info->map |= (1 << opt);
+		if (inv)
+			info->invert |= (1 << opt);
+		if (p == NULL)
+			break;
+		arg = p + 1;
+	}
+}
+
+static int ipv4options_mt_parse(int c, char **argv, int invert,
+    unsigned int *flags, const void *entry, struct xt_entry_match **match)
+{
+	struct xt_ipv4options_mtinfo1 *info = (void *)(*match)->data;
+
+	switch (c) {
+	case 'a': /* --any */
+		xtables_param_act(XTF_NO_INVERT, "ipv4options", "--any", invert);
+		info->flags |= XT_V4OPTS_ANY;
+		return true;
+	case 'f': /* --flags */
+		xtables_param_act(XTF_NO_INVERT, "ipv4options", "--flags", invert);
+		ipv4options_parse_flagspec(info, optarg);
+		return true;
+	}
+
+	return false;
+}
+
+/* no checking of *flags - no IPv4 options is also valid */
+
+static void ipv4options_print_flags(const struct xt_ipv4options_mtinfo1 *info,
+    bool numeric)
+{
+	uint32_t tmp = info->map;
+	unsigned int i;
+
+	for (i = 1; i < 32; ++i)
+		if (tmp & (1 << i)) {
+			if (info->invert & (1 << i))
+				printf("!");
+			if (!numeric && v4opt_names[i] != NULL)
+				printf("%s", v4opt_names[i]);
+			else
+				printf("%u", i);
+			tmp &= ~(1 << i);
+			if (tmp)
+				printf(",");
+		}
+}
+
+static void ipv4options_mt_print(const void *ip,
+    const struct xt_entry_match *match, int numeric)
+{
+	const struct xt_ipv4options_mtinfo1 *info = (void *)match->data;
+
+	printf(" ipv4options %s ",
+	       (info->flags & XT_V4OPTS_ANY) ? "any-of" : "all-of");
+	ipv4options_print_flags(info, numeric);
+	printf(" ");
+}
+
+static void ipv4options_mt_save(const void *ip,
+    const struct xt_entry_match *match)
+{
+	const struct xt_ipv4options_mtinfo1 *info = (void *)match->data;
+
+	if (info->map != 0) {
+		printf(" --flags ");
+		ipv4options_print_flags(info, true);
+	}
+	if (info->flags & XT_V4OPTS_ANY)
+		printf(" --any");
+	printf(" ");
+}
+
+static struct xtables_match ipv4options_mt_reg = {
+	.version       = XTABLES_VERSION,
+	.name          = "ipv4options",
+	.revision      = 1,
+	.family        = NFPROTO_IPV4,
+	.size          = XT_ALIGN(sizeof(struct xt_ipv4options_mtinfo1)),
+	.userspacesize = XT_ALIGN(sizeof(struct xt_ipv4options_mtinfo1)),
+	.help          = ipv4options_mt_help,
+	.parse         = ipv4options_mt_parse,
+	.print         = ipv4options_mt_print,
+	.save          = ipv4options_mt_save,
+	.extra_opts    = ipv4options_mt_opts,
+};
+
+static __attribute__((constructor)) void ipv4options_mt_ldr(void)
+{
+	xtables_register_match(&ipv4options_mt_reg);
+}

--- a/release/src/router/iptables-1.4.x/extensions/libxt_ipv4options.man
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_ipv4options.man
@@ -0,0 +1,47 @@
+The "ipv4options" module allows to match against a set of IPv4 header options.
+.TP
+\fB\-\-flags\fP [\fB!\fP]\fIsymbol\fP[\fB,\fP[\fB!\fP]\fIsymbol...\fP]
+Specify the options that shall appear or not appear in the header. Each
+symbol specification is delimited by a comma, and a '!' can be prefixed to
+a symbol to negate its presence. Symbols are either the name of an IPv4 option
+or its number. See examples below.
+.TP
+\fB\-\-any\fP
+By default, all of the flags specified must be present/absent, that is, they
+form an AND condition. Use the \-\-any flag instead to use an OR condition
+where only at least one symbol spec must be true.
+.PP
+Known symbol names (and their number):
+.PP
+1 \(em \fBnop\fP
+.PP
+2 \(em \fBsecurity\fP \(em RFC 1108
+.PP
+3 \(em \fBlsrr\fP \(em Loose Source Routing, RFC 791
+.PP
+4 \(em \fBtimestamp\fP \(em RFC 781, 791
+.PP
+7 \(em \fBrecord\-route\fP \(em RFC 791
+.PP
+9 \(em \fBssrr\fP \(em Strict Source Routing, RFC 791
+.PP
+11 \(em \fBmtu\-probe\fP \(em RFC 1063
+.PP
+12 \(em \fBmtu\-reply\fP \(em RFC 1063
+.PP
+18 \(em \fBtraceroute\fP \(em RFC 1393
+.PP
+20 \(em \fBrouter-alert\fP \(em RFC 2113
+.PP
+Examples:
+.PP
+Match packets that have both Timestamp and NOP:
+\-m ipv4options \-\-flags nop,timestamp
+.PP
+~ that have either of Timestamp or NOP, or both:
+\-\-flags nop,timestamp \-\-any
+.PP
+~ that have Timestamp and no NOP: \-\-flags '!nop,timestamp'
+.PP
+~ that have either no NOP or a timestamp (or both conditions):
+\-\-flags '!nop,timestamp' \-\-any

--- a/release/src/router/iptables-1.4.x/extensions/libxt_lscan.c
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_lscan.c
@@ -0,0 +1,123 @@
+/*
+ *	LSCAN match extension for iptables
+ *	Copyright © Jan Engelhardt <jengelh [at] medozas de>, 2006 - 2009
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <xtables.h>
+#include <linux/netfilter/x_tables.h>
+#include "xt_lscan.h"
+#include "compat_user.h"
+
+static const struct option lscan_mt_opts[] = {
+	{.name = "stealth", .has_arg = false, .val = 'x'},
+	{.name = "synscan", .has_arg = false, .val = 's'},
+	{.name = "cnscan",  .has_arg = false, .val = 'c'},
+	{.name = "grscan",  .has_arg = false, .val = 'g'},
+	{NULL},
+};
+
+static void lscan_mt_help(void)
+{
+	printf(
+		"lscan match options:\n"
+		"(Combining them will make them match by OR-logic)\n"
+		"  --stealth    Match TCP Stealth packets\n"
+		"  --synscan    Match TCP SYN scans\n"
+		"  --cnscan     Match TCP Connect scans\n"
+		"  --grscan     Match Banner Grabbing scans\n");
+}
+
+static int lscan_mt_parse(int c, char **argv, int invert,
+    unsigned int *flags, const void *entry, struct xt_entry_match **match)
+{
+	struct xt_lscan_mtinfo *info = (void *)((*match)->data);
+
+	switch (c) {
+	case 'c':
+		info->match_cn = true;
+		return true;
+	case 'g':
+		info->match_gr = true;
+		return true;
+	case 's':
+		info->match_syn = true;
+		return true;
+	case 'x':
+		info->match_stealth = true;
+		return true;
+	}
+	return false;
+}
+
+static void lscan_mt_check(unsigned int flags)
+{
+}
+
+static void lscan_mt_print(const void *ip,
+    const struct xt_entry_match *match, int numeric)
+{
+	const struct xt_lscan_mtinfo *info = (const void *)(match->data);
+	const char *s = "";
+
+	printf(" lscan ");
+	if (info->match_stealth) {
+		printf("STEALTH");
+		s = ",";
+	}
+	if (info->match_syn) {
+		printf("%sSYNSCAN", s);
+		s = ",";
+	}
+	if (info->match_cn) {
+		printf("%sCNSCAN", s);
+		s = ",";
+	}
+	if (info->match_gr)
+		printf("%sGRSCAN", s);
+	printf(" ");
+}
+
+static void lscan_mt_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_lscan_mtinfo *info = (const void *)(match->data);
+
+	if (info->match_stealth)
+		printf(" --stealth ");
+	if (info->match_syn)
+		printf(" --synscan ");
+	if (info->match_cn)
+		printf(" --cnscan ");
+	if (info->match_gr)
+		printf(" --grscan ");
+}
+
+static struct xtables_match lscan_mt_reg = {
+	.version       = XTABLES_VERSION,
+	.name          = "lscan",
+	.revision      = 0,
+	.family        = NFPROTO_IPV4,
+	.size          = XT_ALIGN(sizeof(struct xt_lscan_mtinfo)),
+	.userspacesize = XT_ALIGN(sizeof(struct xt_lscan_mtinfo)),
+	.help          = lscan_mt_help,
+	.parse         = lscan_mt_parse,
+	.final_check   = lscan_mt_check,
+	.print         = lscan_mt_print,
+	.save          = lscan_mt_save,
+	.extra_opts    = lscan_mt_opts,
+};
+
+static __attribute__((constructor)) void lscan_mt_ldr(void)
+{
+	xtables_register_match(&lscan_mt_reg);
+}

--- a/release/src/router/iptables-1.4.x/extensions/libxt_lscan.man
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_lscan.man
@@ -0,0 +1,32 @@
+Detects simple low-level scan attemps based upon the packet's contents.
+(This is
+different from other implementations, which also try to match the rate of new
+connections.) Note that an attempt is only discovered after it has been carried
+out, but this information can be used in conjunction with other rules to block
+the remote host's future connections. So this match module will match on the
+(probably) last packet the remote side will send to your machine.
+.TP
+\fB\-\-stealth\fR
+Match if the packet did not belong to any known TCP connection
+(Stealth/FIN/XMAS/NULL scan).
+.TP
+\fB\-\-synscan\fR
+Match if the connection was a TCP half-open discovery (SYN scan), i.e. the
+connection was torn down after the 2nd packet in the 3-way handshake.
+.TP
+\fB\-\-cnscan\fR
+Match if the connection was a TCP full open discovery (connect scan), i.e. the
+connection was torn down after completion of the 3-way handshake.
+.TP
+\fB\-\-grscan\fR
+Match if data in the connection only flew in the direction of the remote side,
+e.g. if the connection was terminated after a locally running daemon sent its
+identification. (E.g. openssh, smtp, ftpd.) This may falsely trigger on
+warranted single-direction data flows, usually bulk data transfers such as
+FTP DATA connections or IRC DCC. Grab Scan Detection should only be used on
+ports where a protocol runs that is guaranteed to do a bidirectional exchange
+of bytes.
+.PP
+NOTE: Some clients (Windows XP for example) may do what looks like a SYN scan,
+so be advised to carefully use xt_lscan in conjunction with blocking rules,
+as it may lock out your very own internal network.

--- a/release/src/router/iptables-1.4.x/extensions/libxt_pknock.c
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_pknock.c
@@ -0,0 +1,344 @@
+/*
+ * Shared library add-on to iptables to add Port Knocking and SPA matching
+ * support.
+ *
+ * (C) 2006-2009 J. Federico Hernandez <fede.hernandez@gmail.com>
+ * (C) 2006 Luis Floreani <luis.floreani@gmail.com>
+ *
+ * This program is released under the terms of GNU GPL version 2.
+ */
+#include <getopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <xtables.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include "xt_pknock.h"
+#include "compat_user.h"
+
+static const struct option pknock_mt_opts[] = {
+	/* .name, .has_arg, .flag, .val */
+	{.name = "knockports",  .has_arg = true,  .val = 'k'},
+	{.name = "time",        .has_arg = true,  .val = 't'},
+	{.name = "autoclose",   .has_arg = true,  .val = 'a'},
+	{.name = "name",        .has_arg = true,  .val = 'n'},
+	{.name = "opensecret",  .has_arg = true,  .val = 'o'},
+	{.name = "closesecret", .has_arg = true,  .val = 'z'},
+	{.name = "strict",      .has_arg = false, .val = 'x'},
+	{.name = "checkip",     .has_arg = false, .val = 'c'},
+	{NULL},
+};
+
+static void pknock_mt_help(void)
+{
+	printf("pknock match options:\n"
+		" --knockports port[,port,port,...]	"
+			"Matches destination port(s).\n"
+		" --time seconds\n"
+			"Max allowed time between knocks.\n"
+		" --autoclose minutes\n"
+			"Time after which to automatically close opened\n"
+			"\t\t\t\t\tport(s).\n"
+		" --strict				"
+			"Knocks sequence must be exact.\n"
+		" --name rule_name			"
+			"Rule name.\n"
+		" --checkip				"
+			"Matches if the source ip is in the list.\n"
+		);
+}
+
+static unsigned int
+parse_ports(const char *portstring, uint16_t *ports, const char *proto)
+{
+	char *buffer, *cp, *next;
+	unsigned int i;
+
+	buffer = strdup(portstring);
+	if (buffer == NULL)
+		xtables_error(OTHER_PROBLEM, "strdup failed");
+
+	for (cp = buffer, i = 0; cp != NULL && i < XT_PKNOCK_MAX_PORTS; cp = next, ++i)
+	{
+		next=strchr(cp, ',');
+		if (next != NULL)
+			*next++ = '\0';
+		ports[i] = xtables_parse_port(cp, proto);
+	}
+
+	if (cp != NULL)
+		xtables_error(PARAMETER_PROBLEM, "too many ports specified");
+
+	free(buffer);
+	return i;
+}
+
+static char *
+proto_to_name(uint8_t proto)
+{
+	switch (proto) {
+	case IPPROTO_TCP:
+		return "tcp";
+	case IPPROTO_UDP:
+		return "udp";
+	default:
+		return NULL;
+	}
+}
+
+static const char *
+check_proto(uint16_t pnum, uint8_t invflags)
+{
+	char *proto;
+
+	if (invflags & XT_INV_PROTO)
+		xtables_error(PARAMETER_PROBLEM, PKNOCK "only works with TCP and UDP.");
+
+	if ((proto = proto_to_name(pnum)) != NULL)
+		return proto;
+	else if (pnum == 0)
+		xtables_error(PARAMETER_PROBLEM, PKNOCK "needs `-p tcp' or `-p udp'");
+	else
+		xtables_error(PARAMETER_PROBLEM, PKNOCK "only works with TCP and UDP.");
+}
+
+static int
+__pknock_parse(int c, char **argv, int invert, unsigned int *flags,
+		struct xt_entry_match **match, uint16_t pnum,
+		uint16_t invflags)
+{
+	const char *proto;
+	struct xt_pknock_mtinfo *info = (void *)(*match)->data;
+	unsigned int tmp;
+
+	switch (c) {
+	case 'k': /* --knockports */
+		if (*flags & XT_PKNOCK_KNOCKPORT)
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"cannot use --knockports twice.\n");
+		proto = check_proto(pnum, invflags);
+
+		info->ports_count = parse_ports(optarg, info->port, proto);
+		info->option |= XT_PKNOCK_KNOCKPORT;
+		*flags |= XT_PKNOCK_KNOCKPORT;
+#if DEBUG
+		printf("ports_count: %d\n", info->ports_count);
+#endif
+		break;
+
+	case 't': /* --time */
+		if (*flags & XT_PKNOCK_TIME)
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"cannot use --time twice.\n");
+		info->max_time = atoi(optarg);
+		if (info->max_time == 0)
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"--time number must be > 0.\n");
+		info->option |= XT_PKNOCK_TIME;
+		*flags |= XT_PKNOCK_TIME;
+		break;
+
+        case 'a': /* --autoclose */
+		if (*flags & XT_PKNOCK_AUTOCLOSE)
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"cannot use --autoclose twice.\n");
+		if (!xtables_strtoui(optarg, NULL, &tmp, 0, ~0U))
+			xtables_param_act(XTF_BAD_VALUE, PKNOCK,
+				"--autoclose", optarg);
+                info->autoclose_time = tmp;
+                info->option |= XT_PKNOCK_AUTOCLOSE;
+                *flags |= XT_PKNOCK_AUTOCLOSE;
+                break;
+
+	case 'n': /* --name */
+		if (*flags & XT_PKNOCK_NAME)
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"cannot use --name twice.\n");
+		memset(info->rule_name, 0, sizeof(info->rule_name));
+		strncpy(info->rule_name, optarg, sizeof(info->rule_name) - 1);
+
+		info->rule_name_len = strlen(info->rule_name);
+		info->option |= XT_PKNOCK_NAME;
+		*flags |= XT_PKNOCK_NAME;
+#if DEBUG
+		printf("info->rule_name: %s\n", info->rule_name);
+#endif
+		break;
+
+	case 'o': /* --opensecret */
+		if (*flags & XT_PKNOCK_OPENSECRET)
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"cannot use --opensecret twice.\n");
+		memset(info->open_secret, 0, sizeof(info->open_secret));
+		strncpy(info->open_secret, optarg, sizeof(info->open_secret) - 1);
+
+		info->open_secret_len = strlen(info->open_secret);
+		info->option |= XT_PKNOCK_OPENSECRET;
+		*flags |= XT_PKNOCK_OPENSECRET;
+		break;
+
+	case 'z': /* --closesecret */
+		if (*flags & XT_PKNOCK_CLOSESECRET)
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"cannot use --closesecret twice.\n");
+		memset(info->close_secret, 0, sizeof(info->close_secret));
+		strncpy(info->close_secret, optarg, sizeof(info->close_secret) - 1);
+
+		info->close_secret_len = strlen(info->close_secret);
+		info->option |= XT_PKNOCK_CLOSESECRET;
+		*flags |= XT_PKNOCK_CLOSESECRET;
+		break;
+
+	case 'c': /* --checkip */
+		if (*flags & XT_PKNOCK_CHECKIP)
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"cannot use --checkip twice.\n");
+		info->option |= XT_PKNOCK_CHECKIP;
+		*flags |= XT_PKNOCK_CHECKIP;
+		break;
+
+	case 'x': /* --strict */
+		if (*flags & XT_PKNOCK_STRICT)
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"cannot use --strict twice.\n");
+		info->option |= XT_PKNOCK_STRICT;
+		*flags |= XT_PKNOCK_STRICT;
+		break;
+
+	default:
+		return 0;
+	}
+
+	if (invert)
+		xtables_error(PARAMETER_PROBLEM, PKNOCK "does not support invert.");
+
+	return 1;
+}
+
+static int pknock_mt_parse(int c, char **argv, int invert, unsigned int *flags,
+                		const void *e, struct xt_entry_match **match)
+{
+	const struct ipt_entry *entry = e;
+	return __pknock_parse(c, argv, invert, flags, match,
+			entry->ip.proto, entry->ip.invflags);
+}
+
+static void pknock_mt_check(unsigned int flags)
+{
+	if (!(flags & XT_PKNOCK_NAME))
+		xtables_error(PARAMETER_PROBLEM, PKNOCK
+			"--name option is required.\n");
+
+	if (flags & XT_PKNOCK_KNOCKPORT) {
+		if (flags & XT_PKNOCK_CHECKIP)
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"cannot specify --knockports with --checkip.\n");
+		if ((flags & XT_PKNOCK_OPENSECRET)
+			&& !(flags & XT_PKNOCK_CLOSESECRET))
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"--opensecret must go with --closesecret.\n");
+		if ((flags & XT_PKNOCK_CLOSESECRET)
+			&& !(flags & XT_PKNOCK_OPENSECRET))
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"--closesecret must go with --opensecret.\n");
+	}
+
+	if (flags & XT_PKNOCK_CHECKIP) {
+		if (flags & XT_PKNOCK_KNOCKPORT)
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"cannot specify --checkip with --knockports.\n");
+		if ((flags & XT_PKNOCK_OPENSECRET)
+			|| (flags & XT_PKNOCK_CLOSESECRET))
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"cannot specify --opensecret and"
+				" --closesecret with --checkip.\n");
+		if (flags & XT_PKNOCK_TIME)
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"cannot specify --time with --checkip.\n");
+		if (flags & XT_PKNOCK_AUTOCLOSE)
+			xtables_error(PARAMETER_PROBLEM, PKNOCK
+				"cannot specify --autoclose with --checkip.\n");
+	} else if (!(flags & (XT_PKNOCK_OPENSECRET | XT_PKNOCK_TIME))) {
+		xtables_error(PARAMETER_PROBLEM, PKNOCK
+			"you must specify --time.\n");
+	}
+}
+
+static void pknock_mt_print(const void *ip,
+						const struct xt_entry_match *match, int numeric)
+{
+	const struct xt_pknock_mtinfo *info = (void *)match->data;
+	int i;
+
+	printf(" pknock ");
+	if (info->option & XT_PKNOCK_KNOCKPORT) {
+		printf("knockports ");
+		for (i = 0; i < info->ports_count; ++i)
+			printf("%s%d", i ? "," : "", info->port[i]);
+		printf(" ");
+	}
+	if (info->option & XT_PKNOCK_TIME)
+		printf("time %ld ", (long)info->max_time);
+	if (info->option & XT_PKNOCK_AUTOCLOSE)
+		printf("autoclose %lu ", (unsigned long)info->autoclose_time);
+	if (info->option & XT_PKNOCK_NAME)
+		printf("name %s ", info->rule_name);
+	if (info->option & XT_PKNOCK_OPENSECRET)
+		printf("opensecret ");
+	if (info->option & XT_PKNOCK_CLOSESECRET)
+		printf("closesecret ");
+	if (info->option & XT_PKNOCK_STRICT)
+		printf("strict ");
+	if (info->option & XT_PKNOCK_CHECKIP)
+		printf("checkip ");
+}
+
+static void pknock_mt_save(const void *ip, const struct xt_entry_match *match)
+{
+	int i;
+	const struct xt_pknock_mtinfo *info = (void *)match->data;
+
+	if (info->option & XT_PKNOCK_KNOCKPORT) {
+		printf(" --knockports ");
+		for (i = 0; i < info->ports_count; ++i)
+			printf("%s%d", i ? "," : "", info->port[i]);
+		printf(" ");
+	}
+	if (info->option & XT_PKNOCK_TIME)
+		printf(" --time %ld ", (long)info->max_time);
+	if (info->option & XT_PKNOCK_AUTOCLOSE)
+		printf(" --autoclose %lu ",
+		       (unsigned long)info->autoclose_time);
+	if (info->option & XT_PKNOCK_NAME)
+		printf(" --name %s ", info->rule_name);
+	if (info->option & XT_PKNOCK_OPENSECRET)
+		printf(" --opensecret ");
+	if (info->option & XT_PKNOCK_CLOSESECRET)
+		printf(" --closesecret ");
+	if (info->option & XT_PKNOCK_STRICT)
+		printf(" --strict ");
+	if (info->option & XT_PKNOCK_CHECKIP)
+		printf(" --checkip ");
+}
+
+static struct xtables_match pknock_mt_reg = {
+	.name		= "pknock",
+	.version	= XTABLES_VERSION,
+	.revision      = 1,
+	.family        = NFPROTO_IPV4,
+	.size          = XT_ALIGN(sizeof(struct xt_pknock_mtinfo)),
+	.userspacesize = XT_ALIGN(sizeof(struct xt_pknock_mtinfo)),
+	.help          = pknock_mt_help,
+	.parse         = pknock_mt_parse,
+	.final_check   = pknock_mt_check,
+	.print         = pknock_mt_print,
+	.save          = pknock_mt_save,
+	.extra_opts    = pknock_mt_opts,
+};
+
+static __attribute__((constructor)) void pknock_mt_ldr(void)
+{
+	xtables_register_match(&pknock_mt_reg);
+}

--- a/release/src/router/iptables-1.4.x/extensions/libxt_pknock.man
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_pknock.man
@@ -0,0 +1,113 @@
+Pknock match implements so-called "port knocking", a stealthy system
+for network authentication: a client sends packets to selected
+ports in a specific sequence (= simple mode, see example 1 below), or a HMAC
+payload to a single port (= complex mode, see example 2 below),
+to a target machine that has pknock rule(s) installed. The target machine
+then decides whether to unblock or block (again) the pknock-protected port(s).
+This can be used, for instance, to avoid brute force
+attacks on ssh or ftp services.
+.PP
+Example prerequisites:
+.IP
+modprobe cn
+.IP
+modprobe xt_pknock
+.PP
+Example 1 (TCP mode, manual closing of opened port not possible):
+.IP
+iptables -P INPUT DROP
+.IP
+iptables -A INPUT -p tcp -m pknock --knockports 4002,4001,4004 --strict
+--name SSH --time 10 --autoclose 60 --dport 22 -j ACCEPT
+.PP
+The rule will allow tcp port 22 for the attempting IP address after the successful reception of TCP SYN packets
+to ports 4002, 4001 and 4004, in this order (a.k.a. port-knocking).
+Port numbers in the connect sequence must follow the exact specification, no
+other ports may be "knocked" inbetween. The rule is named '\fBSSH\fP' \(em a file of
+the same name for tracking port knocking states will be created in
+\fB/proc/net/xt_pknock\fP .
+Successive port knocks must occur with delay of at most 10 seconds. Port 22 (from the example) will
+be automatiaclly dropped after 60 minutes after it was previously allowed.
+.PP
+Example 2 (UDP mode \(em non-replayable and non-spoofable, manual closing
+of opened port possible, secure, also called "SPA" = Secure Port
+Authorization):
+.IP
+iptables -A INPUT -p udp -m pknock --knockports 4000 --name FTP
+--opensecret foo --closesecret bar --autoclose 240 -j DROP
+.IP
+iptables -A INPUT -p tcp -m pknock --checkip --name FTP --dport 21 -j ACCEPT
+.PP
+The first rule will create an "ALLOWED" record in /proc/net/xt_pknock/FTP after
+the successful reception of an UDP packet to port 4000. The packet payload must be
+constructed as a HMAC256 using "foo" as a key. The HMAC content is the particular client's IP address as a 32-bit network byteorder quantity,
+plus the number of minutes since the Unix epoch, also as a 32-bit value.
+(This is known as Simple Packet Authorization, also called "SPA".)
+In such case, any subsequent attempt to connect to port 21 from the client's IP
+address will cause such packets to be accepted in the second rule.
+.PP
+Similarly, upon reception of an UDP packet constructed the same way, but with
+the key "bar", the first rule will remove a previously installed "ALLOWED" state
+record from /proc/net/xt_pknock/FTP, which means that the second rule will
+stop matching for subsequent connection attempts to port 21.
+In case no close-secret packet is received within 4 hours, the first rule
+will remove "ALLOWED" record from /proc/net/xt_pknock/FTP itself.
+.PP
+Things worth noting:
+.PP
+\fBGeneral\fP:
+.PP
+Specifying \fB--autoclose 0\fP means that no automatic close will be performed at all.
+.PP
+xt_pknock is capable of sending information about successful matches
+via a netlink socket to userspace, should you need to implement your own
+way of receiving and handling portknock notifications.
+Be sure to read the documentation in the doc/pknock/ directory,
+or visit the original site \(em http://portknocko.berlios.de/ .
+.PP
+\fBTCP mode\fP:
+.PP
+This mode is not immune against eavesdropping, spoofing and
+replaying of the port knock sequence by someone else (but its use may still
+be sufficient for scenarios where these factors are not necessarily
+this important, such as bare shielding of the SSH port from brute-force attacks).
+However, if you need these features, you should use UDP mode.
+.PP
+It is always wise to specify three or more ports that are not monotonically
+increasing or decreasing with a small stepsize (e.g. 1024,1025,1026)
+to avoid accidentally triggering
+the rule by a portscan.
+.PP
+Specifying the inter-knock timeout with \fB--time\fP is mandatory in TCP mode,
+to avoid permanent denial of services by clogging up the peer knock-state tracking table
+that xt_pknock internally keeps, should there be a DDoS on the
+first-in-row knock port from more hostile IP addresses than what the actual size
+of this table is (defaults to 16, can be changed via the "peer_hasht_ents" module parameter).
+It is also wise to use as short a time as possible (1 second) for \fB--time\fP
+for this very reason. You may also consider increasing the size
+of the peer knock-state tracking table. Using \fB--strict\fP also helps,
+as it requires the knock sequence to be exact. This means that if the
+hostile client sends more knocks to the same port, xt_pknock will
+mark such attempt as failed knock sequence and will forget it immediately.
+To completely thwart this kind of DDoS, knock-ports would need to have
+an additional rate-limit protection. Or you may consider using UDP mode.
+.PP
+\fBUDP mode\fP:
+.PP
+This mode is immune against eavesdropping, replaying and spoofing attacks.
+It is also immune against DDoS attack on the knockport.
+.PP
+For this mode to work, the clock difference on the client and on the server
+must be below 1 minute. Synchronizing time on both ends by means
+of NTP or rdate is strongly suggested.
+.PP
+There is a rate limiter built into xt_pknock which blocks any subsequent
+open attempt in UDP mode should the request arrive within less than one
+minute since the first successful open. This is intentional;
+it thwarts eventual spoofing attacks.
+.PP
+Because the payload value of an UDP knock packet is influenced by client's IP address,
+UDP mode cannot be used across NAT.
+.PP
+For sending UDP "SPA" packets, you may use either \fBknock.sh\fP or
+\fBknock-orig.sh\fP. These may be found in doc/pknock/util.

--- a/release/src/router/iptables-1.4.x/extensions/libxt_psd.c
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_psd.c
@@ -0,0 +1,161 @@
+/*
+  Shared library add-on to iptables to add PSD support
+
+  Copyright (C) 2000,2001 astaro AG
+
+  This file is distributed under the terms of the GNU General Public
+  License (GPL). Copies of the GPL can be obtained from:
+     ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+  2000-05-04 Markus Hennig <hennig@astaro.de> : initial
+  2000-08-18 Dennis Koslowski <koslowski@astaro.de> : first release
+  2000-12-01 Dennis Koslowski <koslowski@astaro.de> : UDP scans detection added
+  2001-02-04 Jan Rekorajski <baggins@pld.org.pl> : converted from target to match
+  2003-03-02 Harald Welte <laforge@netfilter.org>: fix 'storage' bug
+  2008-04-03 Mohd Nawawi <nawawi@tracenetworkcorporation.com>: update to 2.6.24 / 1.4 code
+  2008-06-24 Mohd Nawawi <nawawi@tracenetworkcorporation.com>: update to 2.6.24 / 1.4.1 code
+  2009-08-07 Mohd Nawawi Mohamad Jamili <nawawi@tracenetworkcorporation.com> : ported to xtables-addons
+*/
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <xtables.h>
+#include <linux/netfilter/x_tables.h>
+#include "xt_psd.h"
+#include "compat_user.h"
+
+#define SCAN_DELAY_THRESHOLD		300
+
+/* Function which prints out usage message. */
+static void psd_mt_help(void) {
+	printf(
+		"psd match options:\n"
+		" --psd-weight-threshold threshhold  Portscan detection weight threshold\n"
+		" --psd-delay-threshold  delay       Portscan detection delay threshold\n"
+		" --psd-lo-ports-weight  lo          Privileged ports weight\n"
+		" --psd-hi-ports-weight  hi          High ports weight\n\n");
+}
+
+static const struct option psd_mt_opts[] = {
+	{.name = "psd-weight-threshold", .has_arg = true, .val = '1'},
+	{.name = "psd-delay-threshold", .has_arg = true, .val = '2'},
+	{.name = "psd-lo-ports-weight", .has_arg = true, .val = '3'},
+	{.name = "psd-hi-ports-weight", .has_arg = true, .val = '4'},
+	{NULL}
+};
+
+/* Initialize the target. */
+static void psd_mt_init(struct xt_entry_match *match) {
+	struct xt_psd_info *psdinfo = (struct xt_psd_info *)match->data;
+	psdinfo->weight_threshold = SCAN_WEIGHT_THRESHOLD;
+	psdinfo->delay_threshold = SCAN_DELAY_THRESHOLD;
+	psdinfo->lo_ports_weight = PORT_WEIGHT_PRIV;
+	psdinfo->hi_ports_weight = PORT_WEIGHT_HIGH;
+}
+
+#define XT_PSD_OPT_CTRESH 0x01
+#define XT_PSD_OPT_DTRESH 0x02
+#define XT_PSD_OPT_LPWEIGHT 0x04
+#define XT_PSD_OPT_HPWEIGHT 0x08
+
+static int psd_mt_parse(int c, char **argv, int invert, unsigned int *flags,
+                     const void *entry, struct xt_entry_match **match)
+{
+	struct xt_psd_info *psdinfo = (struct xt_psd_info *)(*match)->data;
+	unsigned int num;
+
+	switch (c) {
+		/* PSD-weight-threshold */
+		case '1':
+			if (*flags & XT_PSD_OPT_CTRESH)
+				xtables_error(PARAMETER_PROBLEM,"Can't specify --psd-weight-threshold twice");
+			if (!xtables_strtoui(optarg, NULL, &num, 0, PSD_MAX_RATE))
+				xtables_error(PARAMETER_PROBLEM, "bad --psd-weight-threshold '%s'", optarg);
+			psdinfo->weight_threshold = num;
+			*flags |= XT_PSD_OPT_CTRESH;
+			return true;
+
+		/* PSD-delay-threshold */
+		case '2':
+			if (*flags & XT_PSD_OPT_DTRESH)
+				xtables_error(PARAMETER_PROBLEM, "Can't specify --psd-delay-threshold twice");
+			if (!xtables_strtoui(optarg, NULL, &num, 0, PSD_MAX_RATE))
+				xtables_error(PARAMETER_PROBLEM, "bad --psd-delay-threshold '%s'", optarg);
+			psdinfo->delay_threshold = num;
+			*flags |= XT_PSD_OPT_DTRESH;
+			return true;
+
+		/* PSD-lo-ports-weight */
+		case '3':
+			if (*flags & XT_PSD_OPT_LPWEIGHT)
+				xtables_error(PARAMETER_PROBLEM, "Can't specify --psd-lo-ports-weight twice");
+			if (!xtables_strtoui(optarg, NULL, &num, 0, PSD_MAX_RATE))
+				xtables_error(PARAMETER_PROBLEM, "bad --psd-lo-ports-weight '%s'", optarg);
+			psdinfo->lo_ports_weight = num;
+			*flags |= XT_PSD_OPT_LPWEIGHT;
+			return true;
+
+		/* PSD-hi-ports-weight */
+		case '4':
+			if (*flags & XT_PSD_OPT_HPWEIGHT)
+				xtables_error(PARAMETER_PROBLEM, "Can't specify --psd-hi-ports-weight twice");
+			if (!xtables_strtoui(optarg, NULL, &num, 0, PSD_MAX_RATE))
+				xtables_error(PARAMETER_PROBLEM, "bad --psd-hi-ports-weight '%s'", optarg);
+			psdinfo->hi_ports_weight = num;
+			*flags |= XT_PSD_OPT_HPWEIGHT;
+			return true;
+	}
+	return false;
+}
+
+/* Final check; nothing. */
+static void psd_mt_final_check(unsigned int flags) {}
+
+/* Prints out the targinfo. */
+static void psd_mt_print(const void *ip, const struct xt_entry_match *match, int numeric)
+{
+	const struct xt_psd_info *psdinfo = (const struct xt_psd_info *)match->data;
+	printf(" psd ");
+	printf("weight-threshold: %u ", psdinfo->weight_threshold);
+	printf("delay-threshold: %u ", psdinfo->delay_threshold);
+	printf("lo-ports-weight: %u ", psdinfo->lo_ports_weight);
+	printf("hi-ports-weight: %u ", psdinfo->hi_ports_weight);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void psd_mt_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_psd_info *psdinfo = (const struct xt_psd_info *)match->data;
+	printf(" --psd-weight-threshold %u ", psdinfo->weight_threshold);
+	printf("--psd-delay-threshold %u ", psdinfo->delay_threshold);
+	printf("--psd-lo-ports-weight %u ", psdinfo->lo_ports_weight);
+	printf("--psd-hi-ports-weight %u ", psdinfo->hi_ports_weight);
+}
+
+static struct xtables_match psd_mt_reg = {
+	.name           = "psd",
+	.version        = XTABLES_VERSION,
+	.revision       = 1,
+	.family         = NFPROTO_UNSPEC,
+	.size           = XT_ALIGN(sizeof(struct xt_psd_info)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_psd_info)),
+	.help           = psd_mt_help,
+	.init           = psd_mt_init,
+	.parse          = psd_mt_parse,
+	.final_check    = psd_mt_final_check,
+	.print          = psd_mt_print,
+	.save           = psd_mt_save,
+	.extra_opts     = psd_mt_opts,
+};
+
+static __attribute__((constructor)) void psd_mt_ldr(void)
+{
+	xtables_register_match(&psd_mt_reg);
+}
+

--- a/release/src/router/iptables-1.4.x/extensions/libxt_psd.man
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_psd.man
@@ -0,0 +1,18 @@
+Attempt to detect TCP and UDP port scans. This match was derived from
+Solar Designer's scanlogd.
+.TP
+\fB\-\-psd\-weight\-threshold\fP \fIthreshold\fP
+Total weight of the latest TCP/UDP packets with different
+destination ports coming from the same host to be treated as port
+scan sequence.
+.TP
+\fB\-\-psd\-delay\-threshold\fP \fIdelay\fP
+Delay (in hundredths of second) for the packets with different
+destination ports coming from the same host to be treated as
+possible port scan subsequence.
+.TP
+\fB\-\-psd\-lo\-ports\-weight\fP \fIweight\fP
+Weight of the packet with privileged (<=1024) destination port.
+.TP
+\fB\-\-psd\-hi\-ports\-weight\fP \fIweight\fP
+Weight of the packet with non-priviliged destination port.

--- a/release/src/router/iptables-1.4.x/extensions/libxt_quota2.c
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_quota2.c
@@ -0,0 +1,153 @@
+/*
+ *	"quota2" match extension for iptables
+ *	Sam Johnston <samj [at] samj net>
+ *	Jan Engelhardt <jengelh [at] medozas de>, 2008
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <getopt.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <xtables.h>
+#include "xt_quota2.h"
+#include "compat_user.h"
+
+enum {
+	FL_QUOTA     = 1 << 0,
+	FL_NAME      = 1 << 1,
+	FL_GROW      = 1 << 2,
+	FL_PACKET    = 1 << 3,
+	FL_NO_CHANGE = 1 << 4,
+};
+
+static const struct option quota_mt2_opts[] = {
+	{.name = "grow",      .has_arg = false, .val = 'g'},
+	{.name = "no-change", .has_arg = false, .val = 'c'},
+	{.name = "name",      .has_arg = true,  .val = 'n'},
+	{.name = "quota",     .has_arg = true,  .val = 'q'},
+	{.name = "packets",   .has_arg = false, .val = 'p'},
+	{NULL},
+};
+
+static void quota_mt2_help(void)
+{
+	printf(
+	"quota match options:\n"
+	"    --grow           provide an increasing counter\n"
+	"    --no-change      never change counter/quota value for matching packets\n"
+	"    --name name      name for the file in sysfs\n"
+	"[!] --quota quota    initial quota (bytes or packets)\n"
+	"    --packets        count packets instead of bytes\n"
+	);
+}
+
+static int
+quota_mt2_parse(int c, char **argv, int invert, unsigned int *flags,
+	        const void *entry, struct xt_entry_match **match)
+{
+	struct xt_quota_mtinfo2 *info = (void *)(*match)->data;
+	char *end;
+
+	switch (c) {
+	case 'g':
+		xtables_param_act(XTF_ONLY_ONCE, "quota", "--grow", *flags & FL_GROW);
+		xtables_param_act(XTF_NO_INVERT, "quota", "--grow", invert);
+		info->flags |= XT_QUOTA_GROW;
+		*flags |= FL_GROW;
+		return true;
+	case 'c': /* no-change */
+		xtables_param_act(XTF_ONLY_ONCE, "quota", "--no-change", *flags & FL_NO_CHANGE);
+		xtables_param_act(XTF_NO_INVERT, "quota", "--no-change", invert);
+		info->flags |= XT_QUOTA_NO_CHANGE;
+		*flags |= FL_NO_CHANGE;
+		return true;
+	case 'n':
+		/* zero termination done on behalf of the kernel module */
+		xtables_param_act(XTF_ONLY_ONCE, "quota", "--name", *flags & FL_NAME);
+		xtables_param_act(XTF_NO_INVERT, "quota", "--name", invert);
+		strncpy(info->name, optarg, sizeof(info->name));
+		*flags |= FL_NAME;
+		return true;
+	case 'p':
+		xtables_param_act(XTF_ONLY_ONCE, "quota", "--packets", *flags & FL_PACKET);
+		xtables_param_act(XTF_NO_INVERT, "quota", "--packets", invert);
+		info->flags |= XT_QUOTA_PACKET;
+		*flags |= FL_PACKET;
+		return true;
+	case 'q':
+		xtables_param_act(XTF_ONLY_ONCE, "quota", "--quota", *flags & FL_QUOTA);
+		if (invert)
+			info->flags |= XT_QUOTA_INVERT;
+		info->quota = strtoull(optarg, &end, 0);
+		if (*end != '\0')
+			xtables_error(PARAMETER_PROBLEM, "quota match: "
+			           "invalid value for --quota");
+		*flags |= FL_QUOTA;
+		return true;
+	}
+	return false;
+}
+
+static void
+quota_mt2_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_quota_mtinfo2 *q = (void *)match->data;
+
+	if (q->flags & XT_QUOTA_INVERT)
+		printf(" !");
+	if (q->flags & XT_QUOTA_GROW)
+		printf(" --grow ");
+	if (q->flags & XT_QUOTA_NO_CHANGE)
+		printf(" --no-change ");
+	if (q->flags & XT_QUOTA_PACKET)
+		printf(" --packets ");
+	if (*q->name != '\0')
+		printf(" --name %s ", q->name);
+	printf(" --quota %llu ", (unsigned long long)q->quota);
+}
+
+static void quota_mt2_print(const void *ip, const struct xt_entry_match *match,
+                            int numeric)
+{
+	const struct xt_quota_mtinfo2 *q = (const void *)match->data;
+
+	if (q->flags & XT_QUOTA_INVERT)
+		printf(" !");
+	if (q->flags & XT_QUOTA_GROW)
+		printf(" counter");
+	else
+		printf(" quota");
+	if (*q->name != '\0')
+		printf(" %s:", q->name);
+	printf(" %llu ", (unsigned long long)q->quota);
+	if (q->flags & XT_QUOTA_PACKET)
+		printf("packets ");
+	else
+		printf("bytes ");
+	if (q->flags & XT_QUOTA_NO_CHANGE)
+		printf("(no-change mode) ");
+}
+
+static struct xtables_match quota_mt2_reg = {
+	.family        = NFPROTO_UNSPEC,
+	.revision      = 3,
+	.name          = "quota2",
+	.version       = XTABLES_VERSION,
+	.size          = XT_ALIGN(sizeof (struct xt_quota_mtinfo2)),
+	.userspacesize = offsetof(struct xt_quota_mtinfo2, quota),
+	.help          = quota_mt2_help,
+	.parse         = quota_mt2_parse,
+	.print         = quota_mt2_print,
+	.save          = quota_mt2_save,
+	.extra_opts    = quota_mt2_opts,
+};
+
+static __attribute__((constructor)) void quota2_mt_ldr(void)
+{
+	xtables_register_match(&quota_mt2_reg);
+}

--- a/release/src/router/iptables-1.4.x/extensions/libxt_quota2.man
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_quota2.man
@@ -0,0 +1,37 @@
+The "quota2" implements a named counter which can be increased or decreased
+on a per-match basis. Available modes are packet counting or byte counting.
+The value of the counter can be read and reset through procfs, thereby making
+this match a minimalist accounting tool.
+.PP
+When counting down from the initial quota, the counter will stop at 0 and
+the match will return false, just like the original "quota" match. In growing
+(upcounting) mode, it will always return true.
+.TP
+\fB\-\-grow\fP
+Count upwards instead of downwards.
+.TP
+\fB\-\-no\-change\fP
+Makes it so the counter or quota amount is never changed by packets matching
+this rule. This is only really useful in "quota" mode, as it will allow you to
+use complex prerouting rules in association with the quota system, without
+counting a packet twice.
+.TP
+\fB\-\-name\fP \fIname\fP
+Assign the counter a specific name. This option must be present, as an empty
+name is not allowed. Names starting with a dot or names containing a slash are
+prohibited.
+.TP
+[\fB!\fP] \fB\-\-quota\fP \fIiq\fP
+Specify the initial quota for this counter. If the counter already exists,
+it is not reset. An "!" may be used to invert the result of the match. The
+negation has no effect when \fB\-\-grow\fP is used.
+.TP
+\fB\-\-packets\fP
+Count packets instead of bytes that passed the quota2 match.
+.PP
+Because counters in quota2 can be shared, you can combine them for various
+purposes, for example, a bytebucket filter that only lets as much traffic go
+out as has come in:
+.PP
+\-A INPUT \-p tcp \-\-dport 6881 \-m quota \-\-name bt \-\-grow;
+\-A OUTPUT \-p tcp \-\-sport 6881 \-m quota \-\-name bt;

--- a/release/src/router/iptables-1.4.x/extensions/libxt_RAWDNAT.c
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_RAWDNAT.c
@@ -0,0 +1,189 @@
+/*
+ *	"RAWNAT" target extension for iptables
+ *	Copyright © Jan Engelhardt, 2008 - 2009
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <netinet/in.h>
+#include <getopt.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include <xtables.h>
+#include <linux/netfilter.h>
+#include "xt_RAWNAT.h"
+#include "compat_user.h"
+
+enum {
+	FLAGS_TO = 1 << 0,
+};
+
+static const struct option rawdnat_tg_opts[] = {
+	{.name = "to-destination", .has_arg = true, .val = 't'},
+	{},
+};
+
+static void rawdnat_tg_help(void)
+{
+	printf(
+"RAWDNAT target options:\n"
+"    --to-destination addr[/mask]    Address or network to map to\n"
+);
+}
+
+static int
+rawdnat_tg4_parse(int c, char **argv, int invert, unsigned int *flags,
+                  const void *entry, struct xt_entry_target **target)
+{
+	struct xt_rawnat_tginfo *info = (void *)(*target)->data;
+	struct in_addr *a;
+	unsigned int mask;
+	char *end;
+
+	switch (c) {
+	case 't':
+		info->mask = 32;
+		end = strchr(optarg, '/');
+		if (end != NULL) {
+			*end++ = '\0';
+			if (!xtables_strtoui(end, NULL, &mask, 0, 32))
+				xtables_param_act(XTF_BAD_VALUE, "RAWDNAT",
+					"--to-destination", optarg);
+			info->mask = mask;
+		}
+		a = xtables_numeric_to_ipaddr(optarg);
+		if (a == NULL)
+			xtables_param_act(XTF_BAD_VALUE, "RAWDNAT",
+				"--to-destination", optarg);
+		memcpy(&info->addr.in, a, sizeof(*a));
+		*flags |= FLAGS_TO;
+		return true;
+	}
+	return false;
+}
+
+static int
+rawdnat_tg6_parse(int c, char **argv, int invert, unsigned int *flags,
+                  const void *entry, struct xt_entry_target **target)
+{
+	struct xt_rawnat_tginfo *info = (void *)(*target)->data;
+	struct in6_addr *a;
+	unsigned int mask;
+	char *end;
+
+	switch (c) {
+	case 't':
+		info->mask = 128;
+		end = strchr(optarg, '/');
+		if (end != NULL) {
+			*end++ = '\0';
+			if (!xtables_strtoui(end, NULL, &mask, 0, 128))
+				xtables_param_act(XTF_BAD_VALUE, "RAWDNAT",
+					"--to-destination", optarg);
+			info->mask = mask;
+		}
+		a = xtables_numeric_to_ip6addr(optarg);
+		if (a == NULL)
+			xtables_param_act(XTF_BAD_VALUE, "RAWDNAT",
+				"--to-destination", optarg);
+		memcpy(&info->addr.in6, a, sizeof(*a));
+		*flags |= FLAGS_TO;
+		return true;
+	}
+	return false;
+}
+
+static void rawdnat_tg_check(unsigned int flags)
+{
+	if (!(flags & FLAGS_TO))
+		xtables_error(PARAMETER_PROBLEM, "RAWDNAT: "
+			"\"--to-destination\" is required.");
+}
+
+static void
+rawdnat_tg4_print(const void *entry, const struct xt_entry_target *target,
+                  int numeric)
+{
+	const struct xt_rawnat_tginfo *info = (const void *)target->data;
+
+	if (!numeric && info->mask == 32)
+		printf(" to-destination %s ",
+		       xtables_ipaddr_to_anyname(&info->addr.in));
+	else
+		printf(" to-destination %s/%u ",
+		       xtables_ipaddr_to_numeric(&info->addr.in), info->mask);
+}
+
+static void
+rawdnat_tg6_print(const void *entry, const struct xt_entry_target *target,
+                  int numeric)
+{
+	const struct xt_rawnat_tginfo *info = (const void *)target->data;
+
+	if (!numeric && info->mask == 128)
+		printf(" to-destination %s ",
+		       xtables_ip6addr_to_anyname(&info->addr.in6));
+	else
+		printf(" to-destination %s/%u ",
+		       xtables_ip6addr_to_numeric(&info->addr.in6), info->mask);
+}
+
+static void
+rawdnat_tg4_save(const void *entry, const struct xt_entry_target *target)
+{
+	const struct xt_rawnat_tginfo *info = (const void *)target->data;
+
+	printf(" --to-destination %s/%u ",
+	       xtables_ipaddr_to_numeric(&info->addr.in),
+	       info->mask);
+}
+
+static void
+rawdnat_tg6_save(const void *entry, const struct xt_entry_target *target)
+{
+	const struct xt_rawnat_tginfo *info = (const void *)target->data;
+
+	printf(" --to-destination %s/%u ",
+	       xtables_ip6addr_to_numeric(&info->addr.in6),
+	       info->mask);
+}
+
+static struct xtables_target rawdnat_tg_reg[] = {
+	{
+		.version       = XTABLES_VERSION,
+		.name          = "RAWDNAT",
+		.revision      = 0,
+		.family        = NFPROTO_IPV4,
+		.size          = XT_ALIGN(sizeof(struct xt_rawnat_tginfo)),
+		.userspacesize = XT_ALIGN(sizeof(struct xt_rawnat_tginfo)),
+		.help          = rawdnat_tg_help,
+		.parse         = rawdnat_tg4_parse,
+		.final_check   = rawdnat_tg_check,
+		.print         = rawdnat_tg4_print,
+		.save          = rawdnat_tg4_save,
+		.extra_opts    = rawdnat_tg_opts,
+	},
+	{
+		.version       = XTABLES_VERSION,
+		.name          = "RAWDNAT",
+		.revision      = 0,
+		.family        = NFPROTO_IPV6,
+		.size          = XT_ALIGN(sizeof(struct xt_rawnat_tginfo)),
+		.userspacesize = XT_ALIGN(sizeof(struct xt_rawnat_tginfo)),
+		.help          = rawdnat_tg_help,
+		.parse         = rawdnat_tg6_parse,
+		.final_check   = rawdnat_tg_check,
+		.print         = rawdnat_tg6_print,
+		.save          = rawdnat_tg6_save,
+		.extra_opts    = rawdnat_tg_opts,
+	},
+};
+
+static __attribute__((constructor)) void rawdnat_tg_ldr(void)
+{
+	xtables_register_targets(rawdnat_tg_reg,
+		sizeof(rawdnat_tg_reg) / sizeof(*rawdnat_tg_reg));
+}

--- a/release/src/router/iptables-1.4.x/extensions/libxt_RAWDNAT.man
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_RAWDNAT.man
@@ -0,0 +1,10 @@
+The \fBRAWDNAT\fR target will rewrite the destination address in the IP header,
+much like the \fBNETMAP\fR target.
+.TP
+\fB\-\-to\-destination\fR \fIaddr\fR[\fB/\fR\fImask\fR]
+Network address to map to. The resulting address will be constructed the
+following way: All 'one' bits in the \fImask\fR are filled in from the new
+\fIaddress\fR. All bits that are zero in the mask are filled in from the
+original address.
+.PP
+See the \fBRAWSNAT\fR help entry for examples and constraints.

--- a/release/src/router/iptables-1.4.x/extensions/libxt_RAWSNAT.c
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_RAWSNAT.c
@@ -0,0 +1,189 @@
+/*
+ *	"RAWNAT" target extension for iptables
+ *	Copyright © Jan Engelhardt, 2008 - 2009
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <netinet/in.h>
+#include <getopt.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include <xtables.h>
+#include <linux/netfilter.h>
+#include "xt_RAWNAT.h"
+#include "compat_user.h"
+
+enum {
+	FLAGS_TO = 1 << 0,
+};
+
+static const struct option rawsnat_tg_opts[] = {
+	{.name = "to-source", .has_arg = true, .val = 't'},
+	{},
+};
+
+static void rawsnat_tg_help(void)
+{
+	printf(
+"RAWSNAT target options:\n"
+"    --to-source addr[/mask]    Address or network to map to\n"
+);
+}
+
+static int
+rawsnat_tg4_parse(int c, char **argv, int invert, unsigned int *flags,
+                  const void *entry, struct xt_entry_target **target)
+{
+	struct xt_rawnat_tginfo *info = (void *)(*target)->data;
+	struct in_addr *a;
+	unsigned int mask;
+	char *end;
+
+	switch (c) {
+	case 't':
+		info->mask = 32;
+		end = strchr(optarg, '/');
+		if (end != NULL) {
+			*end++ = '\0';
+			if (!xtables_strtoui(end, NULL, &mask, 0, 32))
+				xtables_param_act(XTF_BAD_VALUE, "RAWSNAT",
+					"--to-source", optarg);
+			info->mask = mask;
+		}
+		a = xtables_numeric_to_ipaddr(optarg);
+		if (a == NULL)
+			xtables_param_act(XTF_BAD_VALUE, "RAWSNAT",
+				"--to-source", optarg);
+		memcpy(&info->addr.in, a, sizeof(*a));
+		*flags |= FLAGS_TO;
+		return true;
+	}
+	return false;
+}
+
+static int
+rawsnat_tg6_parse(int c, char **argv, int invert, unsigned int *flags,
+                  const void *entry, struct xt_entry_target **target)
+{
+	struct xt_rawnat_tginfo *info = (void *)(*target)->data;
+	struct in6_addr *a;
+	unsigned int mask;
+	char *end;
+
+	switch (c) {
+	case 't':
+		info->mask = 128;
+		end = strchr(optarg, '/');
+		if (end != NULL) {
+			*end++ = '\0';
+			if (!xtables_strtoui(end, NULL, &mask, 0, 128))
+				xtables_param_act(XTF_BAD_VALUE, "RAWSNAT",
+					"--to-source", optarg);
+			info->mask = mask;
+		}
+		a = xtables_numeric_to_ip6addr(optarg);
+		if (a == NULL)
+			xtables_param_act(XTF_BAD_VALUE, "RAWSNAT",
+				"--to-source", optarg);
+		memcpy(&info->addr.in6, a, sizeof(*a));
+		*flags |= FLAGS_TO;
+		return true;
+	}
+	return false;
+}
+
+static void rawsnat_tg_check(unsigned int flags)
+{
+	if (!(flags & FLAGS_TO))
+		xtables_error(PARAMETER_PROBLEM, "RAWSNAT: "
+			"\"--to-source\" is required.");
+}
+
+static void
+rawsnat_tg4_print(const void *entry, const struct xt_entry_target *target,
+                  int numeric)
+{
+	const struct xt_rawnat_tginfo *info = (const void *)target->data;
+
+	if (!numeric && info->mask == 32)
+		printf(" to-source %s ",
+		       xtables_ipaddr_to_anyname(&info->addr.in));
+	else
+		printf(" to-source %s/%u ",
+		       xtables_ipaddr_to_numeric(&info->addr.in), info->mask);
+}
+
+static void
+rawsnat_tg6_print(const void *entry, const struct xt_entry_target *target,
+                  int numeric)
+{
+	const struct xt_rawnat_tginfo *info = (const void *)target->data;
+
+	if (!numeric && info->mask == 128)
+		printf(" to-source %s ",
+		       xtables_ip6addr_to_anyname(&info->addr.in6));
+	else
+		printf(" to-source %s/%u ",
+		       xtables_ip6addr_to_numeric(&info->addr.in6), info->mask);
+}
+
+static void
+rawsnat_tg4_save(const void *entry, const struct xt_entry_target *target)
+{
+	const struct xt_rawnat_tginfo *info = (const void *)target->data;
+
+	printf(" --to-source %s/%u ",
+	       xtables_ipaddr_to_numeric(&info->addr.in),
+	       info->mask);
+}
+
+static void
+rawsnat_tg6_save(const void *entry, const struct xt_entry_target *target)
+{
+	const struct xt_rawnat_tginfo *info = (const void *)target->data;
+
+	printf(" --to-source %s/%u ",
+	       xtables_ip6addr_to_numeric(&info->addr.in6),
+	       info->mask);
+}
+
+static struct xtables_target rawsnat_tg_reg[] = {
+	{
+		.version       = XTABLES_VERSION,
+		.name          = "RAWSNAT",
+		.revision      = 0,
+		.family        = NFPROTO_IPV4,
+		.size          = XT_ALIGN(sizeof(struct xt_rawnat_tginfo)),
+		.userspacesize = XT_ALIGN(sizeof(struct xt_rawnat_tginfo)),
+		.help          = rawsnat_tg_help,
+		.parse         = rawsnat_tg4_parse,
+		.final_check   = rawsnat_tg_check,
+		.print         = rawsnat_tg4_print,
+		.save          = rawsnat_tg4_save,
+		.extra_opts    = rawsnat_tg_opts,
+	},
+	{
+		.version       = XTABLES_VERSION,
+		.name          = "RAWSNAT",
+		.revision      = 0,
+		.family        = NFPROTO_IPV6,
+		.size          = XT_ALIGN(sizeof(struct xt_rawnat_tginfo)),
+		.userspacesize = XT_ALIGN(sizeof(struct xt_rawnat_tginfo)),
+		.help          = rawsnat_tg_help,
+		.parse         = rawsnat_tg6_parse,
+		.final_check   = rawsnat_tg_check,
+		.print         = rawsnat_tg6_print,
+		.save          = rawsnat_tg6_save,
+		.extra_opts    = rawsnat_tg_opts,
+	},
+};
+
+static __attribute__((constructor)) void rawsnat_tg_ldr(void)
+{
+	xtables_register_targets(rawsnat_tg_reg,
+		sizeof(rawsnat_tg_reg) / sizeof(*rawsnat_tg_reg));
+}

--- a/release/src/router/iptables-1.4.x/extensions/libxt_RAWSNAT.man
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_RAWSNAT.man
@@ -0,0 +1,38 @@
+The \fBRAWSNAT\fR and \fBRAWDNAT\fP targets provide stateless network address
+translation.
+.PP
+The \fBRAWSNAT\fR target will rewrite the source address in the IP header, much
+like the \fBNETMAP\fP target. \fBRAWSNAT\fP (and \fBRAWDNAT\fP) may only be
+used in the \fBraw\fP or \fBrawpost\fP tables, but can be used in all chains,
+which makes it possible to change the source address either when the packet
+enters the machine or when it leaves it. The reason for this table constraint
+is that RAWNAT must happen outside of connection tracking.
+.TP
+\fB\-\-to\-source\fR \fIaddr\fR[\fB/\fR\fImask\fR]
+Network address to map to. The resulting address will be constructed the
+following way: All 'one' bits in the \fImask\fR are filled in from the new
+\fIaddress\fR. All bits that are zero in the mask are filled in from the
+original address.
+.PP
+As an example, changing the destination for packets forwarded from an internal
+LAN to the internet:
+.IP
+\-t raw \-A PREROUTING \-i lan0 \-d 212.201.100.135 \-j RAWDNAT \-\-to\-destination 199.181.132.250;
+\-t rawpost \-A POSTROUTING \-o lan0 \-s 199.181.132.250 \-j RAWSNAT \-\-to\-source 212.201.100.135;
+.PP
+Note that changing addresses may influence the route selection! Specifically,
+it statically NATs packets, not connections, like the normal DNAT/SNAT targets
+would do. Also note that it can transform already-NATed connections \(em as
+said, it is completely external to Netfilter's connection tracking/NAT.
+.PP
+If the machine itself generates packets that are to be rawnat'ed, you need a
+rule in the OUTPUT chain instead, just like you would with the stateful NAT
+targets.
+.PP
+It may be necessary that in doing so, you also need an extra RAWSNAT rule, to
+override the automatic source address selection that the routing code does
+before passing packets to iptables. If the connecting socket has not been
+explicitly bound to an address, as is the common mode of operation, the address
+that will be chosen is the primary address of the device through which the
+packet would be routed with its initial destination address - the address as
+seen before any RAWNAT takes place.

--- a/release/src/router/iptables-1.4.x/extensions/libxt_STEAL.c
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_STEAL.c
@@ -0,0 +1,32 @@
+#include <stdio.h>
+#include <xtables.h>
+#include "compat_user.h"
+
+static void steal_tg_help(void)
+{
+	printf("STEAL takes no options\n\n");
+}
+
+static int steal_tg_parse(int c, char **argv, int invert, unsigned int *flags,
+                          const void *entry, struct xt_entry_target **target)
+{
+	return 0;
+}
+
+static void steal_tg_check(unsigned int flags)
+{
+}
+
+static struct xtables_target steal_tg_reg = {
+	.version       = XTABLES_VERSION,
+	.name          = "STEAL",
+	.family        = NFPROTO_UNSPEC,
+	.help          = steal_tg_help,
+	.parse         = steal_tg_parse,
+	.final_check   = steal_tg_check,
+};
+
+static __attribute__((constructor)) void steal_tg_ldr(void)
+{
+	xtables_register_target(&steal_tg_reg);
+}

--- a/release/src/router/iptables-1.4.x/extensions/libxt_STEAL.man
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_STEAL.man
@@ -0,0 +1,2 @@
+Like the DROP target, but does not throw an error like DROP when used in the
+\fBOUTPUT\fP chain.

--- a/release/src/router/iptables-1.4.x/extensions/libxt_TARPIT.c
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_TARPIT.c
@@ -0,0 +1,123 @@
+/*
+ *	"TARPIT" target extension to iptables
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License; either
+ *	version 2 of the License, or any later version, as published by the
+ *	Free Software Foundation.
+ */
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <getopt.h>
+#include <string.h>
+#include <xtables.h>
+#include <linux/netfilter/x_tables.h>
+#include "xt_TARPIT.h"
+#include "compat_user.h"
+
+enum {
+	F_TARPIT   = 1 << 0,
+	F_HONEYPOT = 1 << 1,
+	F_RESET    = 1 << 2,
+};
+
+static const struct option tarpit_tg_opts[] = {
+	{.name = "tarpit",   .has_arg = false, .val = 't'},
+	{.name = "honeypot", .has_arg = false, .val = 'h'},
+	{.name = "reset",    .has_arg = false, .val = 'r'},
+	{NULL},
+};
+
+static void tarpit_tg_help(void)
+{
+	printf(
+		"TARPIT target options:\n"
+		"  --tarpit      Enable classic 0-window tarpit (default)\n"
+		"  --honeypot    Enable honeypot option\n"
+		"  --reset       Enable inline resets\n");
+}
+
+static int tarpit_tg_parse(int c, char **argv, int invert, unsigned int *flags,
+                           const void *entry, struct xt_entry_target **target)
+{
+	struct xt_tarpit_tginfo *info = (void *)(*target)->data;
+
+	switch (c) {
+	case 't':
+		info->variant = XTTARPIT_TARPIT;
+		*flags |= F_TARPIT;
+		return true;
+	case 'h':
+		info->variant = XTTARPIT_HONEYPOT;
+		*flags |= F_HONEYPOT;
+		return true;
+	case 'r':
+		info->variant = XTTARPIT_RESET;
+		*flags |= F_RESET;
+		return true;
+	}
+	return false;
+}
+
+static void tarpit_tg_check(unsigned int flags)
+{
+	if (flags == (F_TARPIT | F_HONEYPOT | F_RESET))
+		xtables_error(PARAMETER_PROBLEM,
+			"TARPIT: only one action can be used at a time");
+}
+
+static void tarpit_tg_print(const void *ip,
+    const struct xt_entry_target *target, int numeric)
+{
+	const struct xt_tarpit_tginfo *info = (void *)target->data;
+
+	switch (info->variant) {
+	case XTTARPIT_HONEYPOT:
+		printf(" honeypot mode ");
+		break;
+	case XTTARPIT_RESET:
+		printf(" reset mode ");
+		break;
+	default:
+		printf(" tarpit mode ");
+		break;
+	}
+}
+
+static void tarpit_tg_save(const void *ip,
+    const struct xt_entry_target *target)
+{
+	const struct xt_tarpit_tginfo *info = (const void *)target->data;
+
+	switch (info->variant) {
+	case XTTARPIT_TARPIT:
+		printf(" --tarpit ");
+		break;
+	case XTTARPIT_HONEYPOT:
+		printf(" --honeypot ");
+		break;
+	case XTTARPIT_RESET:
+		printf(" --reset ");
+		break;
+	}
+}
+
+static struct xtables_target tarpit_tg_reg = {
+	.version       = XTABLES_VERSION,
+	.name          = "TARPIT",
+	.family        = NFPROTO_UNSPEC,
+	.size          = XT_ALIGN(sizeof(struct xt_tarpit_tginfo)),
+	.userspacesize = XT_ALIGN(sizeof(struct xt_tarpit_tginfo)),
+	.help          = tarpit_tg_help,
+	.parse         = tarpit_tg_parse,
+	.final_check   = tarpit_tg_check,
+	.print         = tarpit_tg_print,
+	.save          = tarpit_tg_save,
+	.extra_opts    = tarpit_tg_opts,
+};
+
+static __attribute__((constructor)) void tarpit_tg_ldr(void)
+{
+	xtables_register_target(&tarpit_tg_reg);
+}

--- a/release/src/router/iptables-1.4.x/extensions/libxt_TARPIT.man
+++ b/release/src/router/iptables-1.4.x/extensions/libxt_TARPIT.man
@@ -0,0 +1,59 @@
+Captures and holds incoming TCP connections using no local per-connection
+resources.
+.PP
+TARPIT only works at the TCP level, and is totally application agnostic. This
+module will answer a TCP request and play along like a listening server, but
+aside from sending an ACK or RST, no data is sent. Incoming packets are ignored
+and dropped. The attacker will terminate the session eventually. This module
+allows the initial packets of an attack to be captured by other software for
+inspection. In most cases this is sufficient to determine the nature of the
+attack.
+.PP
+This offers similar functionality to LaBrea
+<http://www.hackbusters.net/LaBrea/> but does not require dedicated hardware or
+IPs. Any TCP port that you would normally DROP or REJECT can instead become a
+tarpit.
+.TP
+\fB\-\-tarpit\fP
+This mode completes a connection with the attacker but limits the window size
+to 0, thus keeping the attacker waiting long periods of time. While he is
+maintaining state of the connection and trying to continue every 60-240
+seconds, we keep none, so it is very lightweight. Attempts to close the
+connection are ignored, forcing the remote side to time out the connection in
+12-24 minutes. This mode is the default.
+.TP
+\fB\-\-honeypot\fP
+This mode completes a connection with the attacker, but signals a normal window
+size, so that the remote side will attempt to send data, often with some very
+nasty exploit attempts. We can capture these packets for decoding and further
+analysis. The module does not send any data, so if the remote expects an
+application level response, the game is up.
+.TP
+\fB\-\-reset\fP
+This mode is handy because we can send an inline RST (reset). It has no other
+function.
+.PP
+To tarpit connections to TCP port 80 destined for the current machine:
+.IP
+\-A INPUT \-p tcp \-m tcp \-\-dport 80 \-j TARPIT
+.PP
+To significantly slow down Code Red/Nimda-style scans of unused address space,
+forward unused ip addresses to a Linux box not acting as a router (e.g. "ip
+route 10.0.0.0 255.0.0.0 ip.of.linux.box" on a Cisco), enable IP forwarding on
+the Linux box, and add:
+.IP
+\-A FORWARD \-p tcp \-j TARPIT
+.IP
+\-A FORWARD \-j DROP
+.PP
+NOTE:
+If you use the conntrack module while you are using TARPIT, you should also use
+unset tracking on the packet, or the kernel will unnecessarily allocate
+resources for each TARPITted connection. To TARPIT incoming connections to the
+standard IRC port while using conntrack, you could:
+.IP
+\-t raw \-A PREROUTING \-p tcp \-\-dport 6667 \-j CT \-\-notrack
+.IP
+\-A INPUT \-p tcp \-\-dport 6667 \-j NFLOG
+.IP
+\-A INPUT \-p tcp \-\-dport 6667 \-j TARPIT

--- a/release/src/router/iptables-1.4.x/extensions/xt_CHAOS.h
+++ b/release/src/router/iptables-1.4.x/extensions/xt_CHAOS.h
@@ -0,0 +1,14 @@
+#ifndef _LINUX_NETFILTER_XT_CHAOS_H
+#define _LINUX_NETFILTER_XT_CHAOS_H 1
+
+enum xt_chaos_target_variant {
+	XTCHAOS_NORMAL,
+	XTCHAOS_TARPIT,
+	XTCHAOS_DELUDE,
+};
+
+struct xt_chaos_tginfo {
+	uint8_t variant;
+};
+
+#endif /* _LINUX_NETFILTER_XT_CHAOS_H */

--- a/release/src/router/iptables-1.4.x/extensions/xt_fuzzy.h
+++ b/release/src/router/iptables-1.4.x/extensions/xt_fuzzy.h
@@ -0,0 +1,20 @@
+#ifndef _LINUX_NETFILTER_XT_FUZZY_H
+#define _LINUX_NETFILTER_XT_FUZZY_H 1
+
+enum {
+	FUZZY_MIN_RATE = 3,
+	FUZZY_MAX_RATE = 10000000,
+};
+
+struct xt_fuzzy_mtinfo {
+	uint32_t minimum_rate;
+	uint32_t maximum_rate;
+	uint32_t packets_total;
+	uint32_t bytes_total;
+	uint32_t previous_time;
+	uint32_t present_time;
+	uint32_t mean_rate;
+	uint8_t acceptance_rate;
+};
+
+#endif /* _LINUX_NETFILTER_XT_FUZZY_H */

--- a/release/src/router/iptables-1.4.x/extensions/xt_iface.h
+++ b/release/src/router/iptables-1.4.x/extensions/xt_iface.h
@@ -0,0 +1,26 @@
+#ifndef _LINUX_NETFILTER_XT_IFACE_H
+#define _LINUX_NETFILTER_XT_IFACE_H 1
+
+enum {
+	XT_IFACE_UP          = 1 << 0,
+	XT_IFACE_BROADCAST   = 1 << 1,
+	XT_IFACE_LOOPBACK    = 1 << 2,
+	XT_IFACE_POINTOPOINT = 1 << 3,
+	XT_IFACE_RUNNING     = 1 << 4,
+	XT_IFACE_NOARP       = 1 << 5,
+	XT_IFACE_PROMISC     = 1 << 6,
+	XT_IFACE_MULTICAST   = 1 << 7,
+	XT_IFACE_DYNAMIC     = 1 << 8,
+	XT_IFACE_LOWER_UP    = 1 << 9,
+	XT_IFACE_DORMANT     = 1 << 10,
+	XT_IFACE_DEV_IN      = 1 << 11,
+	XT_IFACE_DEV_OUT     = 1 << 12,
+};
+
+struct xt_iface_mtinfo {
+	char ifname[IFNAMSIZ];
+	__u16 flags;
+	__u16 invflags;
+};
+
+#endif

--- a/release/src/router/iptables-1.4.x/extensions/xt_ipv4options.h
+++ b/release/src/router/iptables-1.4.x/extensions/xt_ipv4options.h
@@ -0,0 +1,26 @@
+#ifndef _LINUX_NETFILTER_XT_IPV4OPTIONS_H
+#define _LINUX_NETFILTER_XT_IPV4OPTIONS_H 1
+
+/* IPv4 allows for a 5-bit option number - 32 options */
+
+/**
+ * %XT_V4OPTS_ALL:	all options in @map must be present (respecting @invert)
+ * %XT_V4OPTS_ANY:	any of the option in @map
+ */
+enum xt_ipv4options_flags {
+	XT_V4OPTS_ALL = 1 << 0,
+	XT_V4OPTS_ANY = 1 << 1,
+};
+
+/**
+ * @map:	bitmask of options that should appear
+ * @invert:	inversion map
+ * @flags:	see above
+ */
+struct xt_ipv4options_mtinfo1 {
+	__u32 map;
+	__u32 invert;
+	__u8 flags;
+};
+
+#endif /* _LINUX_NETFILTER_XT_IPV4OPTIONS_H */

--- a/release/src/router/iptables-1.4.x/extensions/xt_lscan.h
+++ b/release/src/router/iptables-1.4.x/extensions/xt_lscan.h
@@ -0,0 +1,8 @@
+#ifndef _LINUX_NETFILTER_XT_LSCAN_H
+#define _LINUX_NETFILTER_XT_LSCAN_H 1
+
+struct xt_lscan_mtinfo {
+	uint8_t match_stealth, match_syn, match_cn, match_gr;
+};
+
+#endif /* _LINUX_NETFILTER_XT_LSCAN_H */

--- a/release/src/router/iptables-1.4.x/extensions/xt_pknock.h
+++ b/release/src/router/iptables-1.4.x/extensions/xt_pknock.h
@@ -0,0 +1,53 @@
+/*
+ * Kernel module to implement Port Knocking and SPA matching support.
+ *
+ * (C) 2006-2008 J. Federico Hernandez <fede.hernandez@gmail.com>
+ * (C) 2006 Luis Floreani <luis.floreani@gmail.com>
+ *
+ * $Id$
+ *
+ * This program is released under the terms of GNU GPL version 2.
+ */
+#ifndef _XT_PKNOCK_H
+#define _XT_PKNOCK_H
+
+#define PKNOCK "xt_pknock: "
+
+enum {
+	XT_PKNOCK_KNOCKPORT   = 1 << 0,
+	XT_PKNOCK_TIME        = 1 << 1,
+	XT_PKNOCK_NAME        = 1 << 2,
+	XT_PKNOCK_STRICT      = 1 << 3,
+	XT_PKNOCK_CHECKIP     = 1 << 4,
+	XT_PKNOCK_OPENSECRET  = 1 << 5,
+	XT_PKNOCK_CLOSESECRET = 1 << 6,
+	XT_PKNOCK_AUTOCLOSE   = 1 << 7,
+
+	/* Can never change these, as they are make up the user protocol. */
+	XT_PKNOCK_MAX_PORTS      = 15,
+	XT_PKNOCK_MAX_BUF_LEN    = 31,
+	XT_PKNOCK_MAX_PASSWD_LEN = 31,
+};
+
+#define DEBUG 1
+
+struct xt_pknock_mtinfo {
+	char rule_name[XT_PKNOCK_MAX_BUF_LEN+1];
+	uint32_t			rule_name_len;
+	char open_secret[XT_PKNOCK_MAX_PASSWD_LEN+1];
+	uint32_t			open_secret_len;
+	char close_secret[XT_PKNOCK_MAX_PASSWD_LEN+1];
+	uint32_t			close_secret_len;
+	uint8_t	option;		/* --time, --knock-port, ... */
+	uint8_t	ports_count;	/* number of ports */
+	uint16_t	port[XT_PKNOCK_MAX_PORTS]; /* port[,port,port,...] */
+	uint32_t	max_time;	/* max matching time between ports */
+	uint32_t autoclose_time;
+};
+
+struct xt_pknock_nl_msg {
+	char rule_name[XT_PKNOCK_MAX_BUF_LEN+1];
+	__be32 peer_ip;
+};
+
+#endif /* _XT_PKNOCK_H */

--- a/release/src/router/iptables-1.4.x/extensions/xt_psd.h
+++ b/release/src/router/iptables-1.4.x/extensions/xt_psd.h
@@ -0,0 +1,30 @@
+#ifndef _LINUX_NETFILTER_XT_PSD_H
+#define _LINUX_NETFILTER_XT_PSD_H 1
+
+#include <linux/param.h>
+#include <linux/types.h>
+
+/*
+ * High port numbers have a lower weight to reduce the frequency of false
+ * positives, such as from passive mode FTP transfers.
+ */
+#define PORT_WEIGHT_PRIV		3
+#define PORT_WEIGHT_HIGH		1
+#define	PSD_MAX_RATE			10000
+
+/*
+ * Port scan detection thresholds: at least COUNT ports need to be scanned
+ * from the same source, with no longer than DELAY ticks between ports.
+ */
+#define SCAN_MIN_COUNT			7
+#define SCAN_MAX_COUNT			(SCAN_MIN_COUNT * PORT_WEIGHT_PRIV)
+#define SCAN_WEIGHT_THRESHOLD		SCAN_MAX_COUNT
+
+struct xt_psd_info {
+	__u32 weight_threshold;
+	__u32 delay_threshold;
+	__u16 lo_ports_weight;
+	__u16 hi_ports_weight;
+};
+
+#endif /*_LINUX_NETFILTER_XT_PSD_H*/

--- a/release/src/router/iptables-1.4.x/extensions/xt_quota2.h
+++ b/release/src/router/iptables-1.4.x/extensions/xt_quota2.h
@@ -0,0 +1,25 @@
+#ifndef _XT_QUOTA_H
+#define _XT_QUOTA_H
+
+enum xt_quota_flags {
+	XT_QUOTA_INVERT    = 1 << 0,
+	XT_QUOTA_GROW      = 1 << 1,
+	XT_QUOTA_PACKET    = 1 << 2,
+	XT_QUOTA_NO_CHANGE = 1 << 3,
+	XT_QUOTA_MASK      = 0x0F,
+};
+
+struct xt_quota_counter;
+
+struct xt_quota_mtinfo2 {
+	char name[15];
+	u_int8_t flags;
+
+	/* Comparison-invariant */
+	aligned_u64 quota;
+
+	/* Used internally by the kernel */
+	struct xt_quota_counter *master __attribute__((aligned(8)));
+};
+
+#endif /* _XT_QUOTA_H */

--- a/release/src/router/iptables-1.4.x/extensions/xt_RAWNAT.h
+++ b/release/src/router/iptables-1.4.x/extensions/xt_RAWNAT.h
@@ -0,0 +1,9 @@
+#ifndef _LINUX_NETFILTER_XT_TARGET_RAWNAT
+#define _LINUX_NETFILTER_XT_TARGET_RAWNAT 1
+
+struct xt_rawnat_tginfo {
+	union nf_inet_addr addr;
+	__u8 mask;
+};
+
+#endif /* _LINUX_NETFILTER_XT_TARGET_RAWNAT */

--- a/release/src/router/iptables-1.4.x/extensions/xt_TARPIT.h
+++ b/release/src/router/iptables-1.4.x/extensions/xt_TARPIT.h
@@ -0,0 +1,14 @@
+#ifndef _LINUX_NETFILTER_XT_TARPIT_H
+#define _LINUX_NETFILTER_XT_TARPIT_H 1
+
+enum xt_tarpit_target_variant {
+	XTTARPIT_TARPIT,
+	XTTARPIT_HONEYPOT,
+	XTTARPIT_RESET,
+};
+
+struct xt_tarpit_tginfo {
+	uint8_t variant;
+};
+
+#endif /* _LINUX_NETFILTER_XT_TARPIT_H */
--- a/release/src-rt/Makefile
+++ b/release/src-rt/Makefile
@@ -2551,12 +2551,6 @@
 	else \
 		echo "CONFIG_LINUX_MTD=$(LINUX_MTD)" >>$(1); \
 	fi; \
-	sed -i "/CONFIG_NF_CONNTRACK_EVENTS/d" $(1); \
-	if [ "$(BWDPI)" = "y" ]; then \
-		echo "CONFIG_NF_CONNTRACK_EVENTS=y" >>$(1); \
-	else \
-		echo "# CONFIG_NF_CONNTRACK_EVENTS is not set" >>$(1); \
-	fi; \
 	if [ "$(USB_DEBUG)" = "y" ]; then \
 		sed -i "/CONFIG_USB_DEBUG/d" $(1); \
 		echo "CONFIG_USB_DEBUG=y" >>$(1); \
--- a/release/src-rt/target.mak
+++ b/release/src-rt/target.mak
@@ -1,98 +1,98 @@
 # Broadcom MIPS platform
 export RT-N66U := IPV6SUPP=y HTTPS=y MIPS32=r2 BCM57=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=3.6.x \
-                  MEDIASRV=y MODEM=y MODEMPIN=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y WEBDAV=y CLOUDSYNC=y \
-                  SWEBDAVCLIENT=y DROPBOXCLIENT=y FTPCLIENT=y SAMBACLIENT=y \
+                  MEDIASRV=n MODEM=y MODEMPIN=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y WEBDAV=n CLOUDSYNC=n \
+                  SWEBDAVCLIENT=n DROPBOXCLIENT=n FTPCLIENT=y SAMBACLIENT=y \
                   USB="USB" GRO=n APP="network" BUILD_NAME="RT-N66U" DNSMQ=y LFP=y NVRAM_64K=y NFS=y STAINFO=y \
                   RTN66U=y BECEEM=y ODMPID=y OPENVPN=y OPTIMIZE_XBOX=y JFFS2=y SSH=y DISK_MONITOR=y BCMWL6=y \
                   USER_LOW_RSSI=y  TIMEMACHINE=n MDNS=n VPNC=y JFFS2LOG=n JFFS2USERICON=y \
-                  PROXYSTA=y AUTODICT=y CFE_NVRAM_CHK=y DUMP_OOPS_MSG=y DEBUGFS=n SNMPD=y ROG=y \
-                  TFAT=n HFS="none" NTFS="paragon" IPSECMOD=y REPEATER=y DUALWAN=y YANDEXDNS=n DNSFILTER=y \
-                  CLOUDCHECK=y NATNL=y REBOOT_SCHEDULE=y MULTICASTIPTV=y QUAGGA=y LAN50=y ATCOVER=y GETREALIP=y \
+                  PROXYSTA=y AUTODICT=y CFE_NVRAM_CHK=y DUMP_OOPS_MSG=y DEBUGFS=n SNMPD=n ROG=y \
+                  TFAT=n HFS="none" NTFS="paragon" IPSECMOD=y REPEATER=y DUALWAN=n YANDEXDNS=n DNSFILTER=n \
+                  CLOUDCHECK=n NATNL=y REBOOT_SCHEDULE=y MULTICASTIPTV=y QUAGGA=y LAN50=y ATCOVER=y GETREALIP=y \
                   TOR=y UPNPIGD2=n DNSSEC=y NANO=y
 
 export RT-AC66U := IPV6SUPP=y HTTPS=y MIPS32=r2 BCM57=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=3.6.x STAINFO=y \
-                   MEDIASRV=y MODEM=y MODEMPIN=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y WEBDAV=y \
-                   CLOUDSYNC=y SWEBDAVCLIENT=y DROPBOXCLIENT=y FTPCLIENT=y SAMBACLIENT=y \
+                   MEDIASRV=n MODEM=y MODEMPIN=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y WEBDAV=n \
+                   CLOUDSYNC=n SWEBDAVCLIENT=n DROPBOXCLIENT=n FTPCLIENT=y SAMBACLIENT=y \
                    USB="USB" GRO=n APP="network" BUILD_NAME="RT-AC66U" DNSMQ=y LFP=y NVRAM_64K=y ROG=y \
                    RTAC66U=y BCMWL6=y BCMNAND=y PROXYSTA=y BECEEM=y ODMPID=y OPENVPN=y JFFS2=y AUTODICT=y \
-                   SSH=y BOOTLZMA=y DUAL_TRX=n DISK_MONITOR=y OPTIMIZE_XBOX=y NFS=y USER_LOW_RSSI=y SNMPD=y \
+                   SSH=y BOOTLZMA=y DUAL_TRX=n DISK_MONITOR=y OPTIMIZE_XBOX=y NFS=y USER_LOW_RSSI=y SNMPD=n \
                    TIMEMACHINE=n MDNS=n VPNC=y JFFS2LOG=y DUMP_OOPS_MSG=y DEBUGFS=n TEMPROOTFS=y \
-                   TOR=y UPNPIGD2=n STAINFO=y CLOUDCHECK=y NATNL=y \
+                   TOR=y UPNPIGD2=n STAINFO=y CLOUDCHECK=n NATNL=y \
                    REBOOT_SCHEDULE=y TFAT=n HFS="none" NTFS="paragon" MULTICASTIPTV=y QUAGGA=y JFFS2USERICON=y \
                    LAN50=y ATCOVER=y GETREALIP=y \
-                   IPSECMOD=y REPEATER=y DUALWAN=y YANDEXDNS=n DNSFILTER=y DNSSEC=y NANO=y
+                   IPSECMOD=y REPEATER=y DUALWAN=n YANDEXDNS=n DNSFILTER=n DNSSEC=y NANO=y
 
 # Broadcom ARM platform
 export RT-AC68U_BASE := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y \
-                        SAMBA3=3.6.x MEDIASRV=y MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y STAINFO=y \
-                        WEBDAV=y USB="USB" GRO=y APP="network" PROXYSTA=y JFFS2USERICON=y \
-                        CLOUDSYNC=y SWEBDAVCLIENT=y DROPBOXCLIENT=y FTPCLIENT=y SAMBACLIENT=y \
+                        SAMBA3=3.6.x MEDIASRV=n MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y STAINFO=y \
+                        WEBDAV=n USB="USB" GRO=y APP="network" PROXYSTA=y JFFS2USERICON=y \
+                        CLOUDSYNC=n SWEBDAVCLIENT=n DROPBOXCLIENT=n FTPCLIENT=y SAMBACLIENT=y \
                         DNSMQ=y SHP=y NVRAM_64K=y RTAC68U=y BCMWL6=y BCMWL6A=y TUNEK="n" BCM5301X=y DISK_MONITOR=y \
-                        BTN_WIFITOG=y LOGO_LED=y OPTIMIZE_XBOX=y ODMPID=y LED_BTN=y ROG=y SSD=n EMAIL=y \
+                        BTN_WIFITOG=y LOGO_LED=y OPTIMIZE_XBOX=y ODMPID=y LED_BTN=y ROG=y SSD=n EMAIL=n \
                         BCMSMP=y XHCI=y SSH=y JFFS2=y NFS=y OPENVPN=y USER_LOW_RSSI=y \
-                        TIMEMACHINE=y MDNS=y VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y BWDPI=y HSPOT=y \
-                        DUMP_OOPS_MSG=y LINUX_MTD="64" BCM7=n TEMPROOTFS=y DEBUGFS=y SNMPD=y TOR=y \
+                        TIMEMACHINE=n MDNS=n VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y BWDPI=n HSPOT=n \
+                        DUMP_OOPS_MSG=y LINUX_MTD="64" BCM7=n TEMPROOTFS=y DEBUGFS=y SNMPD=n TOR=y \
                         MULTICASTIPTV=y QUAGGA=y BCM_RECVFILE=y LAN50=y ATCOVER=y GETREALIP=y \
-                        BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=y NATNL=y REBOOT_SCHEDULE=y \
-                        TFAT=y HFS="tuxera" NTFS="tuxera" IPSECMOD=n REPEATER=y DUALWAN=y DNSFILTER=y UPNPIGD2=n \
+                        BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=n NATNL=y REBOOT_SCHEDULE=y \
+                        TFAT=y HFS="tuxera" NTFS="tuxera" IPSECMOD=n REPEATER=y DUALWAN=n DNSFILTER=n UPNPIGD2=n \
                         DNSSEC=y NANO=y
 
 export RT-AC68U := $(RT-AC68U_BASE) FAKEHDR=y FORCE_SN=380 FORCE_EN=1031
 export RT-AC68U += BUILD_NAME="RT-AC68U"
 
 export RT-AC56U := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y ROMCCODE=y \
-                   SAMBA3=3.6.x MEDIASRV=y MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y STAINFO=y \
-                   WEBDAV=y USB="USB" GRO=y APP="network" BUILD_NAME="RT-AC56U" PROXYSTA=y BCM_RECVFILE=y \
-                   CLOUDSYNC=y SWEBDAVCLIENT=y DROPBOXCLIENT=y FTPCLIENT=y SAMBACLIENT=y \
+                   SAMBA3=3.6.x MEDIASRV=n MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y STAINFO=y \
+                   WEBDAV=n USB="USB" GRO=y APP="network" BUILD_NAME="RT-AC56U" PROXYSTA=y BCM_RECVFILE=y \
+                   CLOUDSYNC=n SWEBDAVCLIENT=n DROPBOXCLIENT=n FTPCLIENT=y SAMBACLIENT=y \
                    DNSMQ=y SHP=y NVRAM_64K=y RTAC56U=y BCMWL6=y BCMWL6A=y TUNEK="n" BCM5301X=y DISK_MONITOR=y \
                    BTN_WIFITOG=y TURBO=y BCM4352_5G=y LANWAN_LED=y OPTIMIZE_XBOX=y ODMPID=y BCMSMP=y \
-                   LED_ALL=y XHCI=y SSH=y JFFS2=y NFS=y OPENVPN=y LINUX_MTD="64" USER_LOW_RSSI=y ROG=y EMAIL=y \
-                   TIMEMACHINE=y MDNS=y VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y XHCIMODE=y LAN50=y ATCOVER=y GETREALIP=y \
-                   TEMPROOTFS=y SNMPD=y DEBUGFS=y BWDPI=y TOR=y \
-                   BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=y DUMP_OOPS_MSG=y REBOOT_SCHEDULE=y MULTICASTIPTV=y QUAGGA=y \
-                   TFAT=y HFS="tuxera" NTFS="tuxera" IPSECMOD=n REPEATER=y DUALWAN=y DNSFILTER=y UPNPIGD2=n \
+                   LED_ALL=y XHCI=y SSH=y JFFS2=y NFS=y OPENVPN=y LINUX_MTD="64" USER_LOW_RSSI=y ROG=y EMAIL=n \
+                   TIMEMACHINE=n MDNS=n VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y XHCIMODE=y LAN50=y ATCOVER=y GETREALIP=y \
+                   TEMPROOTFS=y SNMPD=n DEBUGFS=y BWDPI=n TOR=y \
+                   BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=n DUMP_OOPS_MSG=y REBOOT_SCHEDULE=y MULTICASTIPTV=y QUAGGA=y \
+                   TFAT=y HFS="tuxera" NTFS="tuxera" IPSECMOD=n REPEATER=y DUALWAN=n DNSFILTER=n UPNPIGD2=n \
                    DNSSEC=y NANO=y
 
 export RT-AC87U := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y WPS_DUALBAND=y ROG=y \
-                   SAMBA3=3.6.x MEDIASRV=y MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y STAINFO=y \
-                   WEBDAV=y USB="USB" GRO=y APP="network" BUILD_NAME="RT-AC87U" PROXYSTA=y \
-                   CLOUDSYNC=y SWEBDAVCLIENT=y DROPBOXCLIENT=y FTPCLIENT=y SAMBACLIENT=y \
+                   SAMBA3=3.6.x MEDIASRV=n MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y STAINFO=y \
+                   WEBDAV=n USB="USB" GRO=y APP="network" BUILD_NAME="RT-AC87U" PROXYSTA=y \
+                   CLOUDSYNC=n SWEBDAVCLIENT=n DROPBOXCLIENT=n FTPCLIENT=y SAMBACLIENT=y \
                    DNSMQ=y SHP=y NVRAM_64K=y BCMWL6=y BCMWL6A=y TUNEK="n" BCM5301X=y DISK_MONITOR=y JFFS2=y BCM_RECVFILE=y \
                    BTN_WIFITOG=y OPTIMIZE_XBOX=y ODMPID=y LED_BTN=y LED2_BTN=y DUMP_OOPS_MSG=y \
-                   BCMSMP=y XHCI=y DUALWAN=y REPEATER=y USER_LOW_RSSI=y OPENVPN=y TIMEMACHINE=y EMAIL=y \
-                   MDNS=y VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y RGMII_BCM_FA=y XHCIMODE=y DISABLE_REPEATER_UI=y \
-                   QTN=y TFTP=y LINUX_MTD="64" RGMII_BRCM5301X=y BWDPI=y RTAC87U=y EXT_LED_WPS=y DEBUGFS=y \
-                   BCM5301X_TRAFFIC_MONITOR=n NATNL=y JFFS2USERICON=y CLOUDCHECK=y LACP=n HW_DUALWAN=y \
-                   TEMPROOTFS=y JFFS2ND_BACKUP=y SNMPD=y TOR=y REBOOT_SCHEDULE=y \
+                   BCMSMP=y XHCI=y DUALWAN=n REPEATER=y USER_LOW_RSSI=y OPENVPN=y TIMEMACHINE=n EMAIL=n \
+                   MDNS=n VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y RGMII_BCM_FA=y XHCIMODE=y DISABLE_REPEATER_UI=y \
+                   QTN=y TFTP=y LINUX_MTD="64" RGMII_BRCM5301X=y BWDPI=n RTAC87U=y EXT_LED_WPS=y DEBUGFS=y \
+                   BCM5301X_TRAFFIC_MONITOR=n NATNL=y JFFS2USERICON=y CLOUDCHECK=n LACP=n HW_DUALWAN=n \
+                   TEMPROOTFS=y JFFS2ND_BACKUP=y SNMPD=n TOR=y REBOOT_SCHEDULE=y \
                    MULTICASTIPTV=y QUAGGA=y LAN50=y ATCOVER=y GETREALIP=y NANO=y \
-                   TFAT=y HFS="tuxera" NTFS="tuxera" NFS=y SSH=y IPSECMOD=n DNSFILTER=y UPNPIGD2=n DNSSEC=y
+                   TFAT=y HFS="tuxera" NTFS="tuxera" NFS=y SSH=y IPSECMOD=n DNSFILTER=n UPNPIGD2=n DNSSEC=y
 
-export RT-AC3200 := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=3.6.x MEDIASRV=y \
-                    MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y WEBDAV=y \
-                    CLOUDSYNC=y SWEBDAVCLIENT=y DROPBOXCLIENT=y FTPCLIENT=y SAMBACLIENT=y \
+export RT-AC3200 := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=3.6.x MEDIASRV=n \
+                    MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y WEBDAV=n \
+                    CLOUDSYNC=n SWEBDAVCLIENT=n DROPBOXCLIENT=n FTPCLIENT=y SAMBACLIENT=y \
                     USB="USB" GRO=y APP="network" BUILD_NAME="RT-AC3200" PROXYSTA=y DNSMQ=y SHP=y NVRAM_64K=y STAINFO=y \
                     RTAC3200=y BCMWL6=y BCMWL6A=y BCM7=y TUNEK="n" BCM5301X=y DISK_MONITOR=y BTN_WIFITOG=y OPTIMIZE_XBOX=y \
-                    ODMPID=y LED_BTN=y BCMSMP=y DUALWAN=y REPEATER=y USER_LOW_RSSI=y OPENVPN=y \
-                    TIMEMACHINE=y MDNS=y TFAT=y NTFS="tuxera" HFS="tuxera" VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y \
-                    XHCI=y BWDPI=y DUMP_OOPS_MSG=y DHDAP=y GMAC3=y HSPOT=n LINUX_MTD="64" DEBUGFS=y NVSIZE="64" \
-                    TEMPROOTFS=y SSH=y NOWL=y EMAIL=y BCM_RECVFILE=y REBOOT_SCHEDULE=y JFFS2USERICON=y \
-                    BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=y NATNL=y DISABLE_REPEATER_UI=y \
+                    ODMPID=y LED_BTN=y BCMSMP=y DUALWAN=n REPEATER=y USER_LOW_RSSI=y OPENVPN=y \
+                    TIMEMACHINE=n MDNS=n TFAT=y NTFS="tuxera" HFS="tuxera" VPNC=y BRCM_NAND_JFFS2=y JFFS2LOG=y BCMFA=y \
+                    XHCI=y BWDPI=n DUMP_OOPS_MSG=y DHDAP=y GMAC3=y HSPOT=n LINUX_MTD="64" DEBUGFS=y NVSIZE="64" \
+                    TEMPROOTFS=y SSH=y NOWL=y EMAIL=n BCM_RECVFILE=y REBOOT_SCHEDULE=y JFFS2USERICON=y \
+                    BCM5301X_TRAFFIC_MONITOR=n CLOUDCHECK=n NATNL=y DISABLE_REPEATER_UI=y \
                     MULTICASTIPTV=y QUAGGA=y LAN50=y ATCOVER=y GETREALIP=y NANO=y \
-                    NFS=y IPSECMOD=n DNSFILTER=y SNMPD=y TOR=y UPNPIGD2=n DNSSEC=y
+                    NFS=y IPSECMOD=n DNSFILTER=n SNMPD=n TOR=y UPNPIGD2=n DNSSEC=y
 
 
-export RT-AC88U_BASE := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=3.6.x MEDIASRV=y \
-                        MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=y ACCEL_PPTPD=y PRINTER=y WEBDAV=y \
-                        CLOUDSYNC=y SWEBDAVCLIENT=y DROPBOXCLIENT=y FTPCLIENT=y SAMBACLIENT=y \
+export RT-AC88U_BASE := IPV6SUPP=y HTTPS=y ARM=y BCM57=y AUTODICT=y BBEXTRAS=y USBEXTRAS=y EBTABLES=y SAMBA3=3.6.x MEDIASRV=n \
+                        MODEM=y MODEMPIN=y BECEEM=y PARENTAL2=n ACCEL_PPTPD=y PRINTER=y WEBDAV=n \
+                        CLOUDSYNC=n SWEBDAVCLIENT=n DROPBOXCLIENT=n FTPCLIENT=y SAMBACLIENT=y \
                         USB="USB" GRO=y APP="network" DNSMQ=y SHP=y BCMWL6=y BCMWL6A=y TUNEK="n" BCM5301X=y JFFS2USERICON=y \
                         DISK_MONITOR=y BTN_WIFITOG=y OPTIMIZE_XBOX=y LED_BTN=y ODMPID=y BCMSMP=y XHCI=y \
-                        DUALWAN=y REPEATER=y USER_LOW_RSSI=y OPENVPN=y TIMEMACHINE=y MDNS=y VPNC=y BRCM_NAND_JFFS2=y \
+                        DUALWAN=n REPEATER=y USER_LOW_RSSI=y OPENVPN=y TIMEMACHINE=n MDNS=n VPNC=y BRCM_NAND_JFFS2=y \
                         REBOOT_SCHEDULE=y FORCE_AUTO_UPGRADE=n FAKEID=n MULTICASTIPTV=y QUAGGA=y \
-                        JFFS2LOG=y BWDPI=y DUMP_OOPS_MSG=y LINUX_MTD="64" DEBUGFS=y TEMPROOTFS=y SSH=y WIFILOGO=n \
-                        EMAIL=y ROG=y SSD=n STAINFO=y BCM5301X_TRAFFIC_MONITOR=n PROXYSTA=y \
-                        BCM_RECVFILE=y TFAT=y NTFS="tuxera" HFS="tuxera" CFEZ=y NATNL=y ERPTEST=n CLOUDCHECK=y \
+                        JFFS2LOG=y BWDPI=n DUMP_OOPS_MSG=y LINUX_MTD="64" DEBUGFS=y TEMPROOTFS=y SSH=y WIFILOGO=n \
+                        EMAIL=n ROG=y SSD=n STAINFO=y BCM5301X_TRAFFIC_MONITOR=n PROXYSTA=y \
+                        BCM_RECVFILE=y TFAT=y NTFS="tuxera" HFS="tuxera" CFEZ=y NATNL=y ERPTEST=n CLOUDCHECK=n \
                         ASPMD=n BCMEVENT=n WLCLMLOAD=n BCM_MUMIMO=y LAN50=y ATCOVER=y GETREALIP=y \
-                        NFS=y IPSECMOD=n DNSFILTER=y SNMPD=y TOR=y UPNPIGD2=n DNSSEC=y NANO=y
+                        NFS=y IPSECMOD=n DNSFILTER=n SNMPD=n TOR=y UPNPIGD2=n DNSSEC=y NANO=y
 
 export RT-AC88U := $(RT-AC88U_BASE)
 export RT-AC88U += BUILD_NAME="RT-AC88U" RGMII_BRCM5301X=y SWITCH2="RTL8365MB" BCM_MMC=n BCM_7114=y NOWLALL=n \
--- a/release/src/router/config_base
+++ b/release/src/router/config_base
@@ -298,7 +298,7 @@
 # RTCONFIG_MULTICAST_IPTV is not set
 # RTCONFIG_DYN_MODEM is not set
 # RTCONFIG_NOTIFICATION_CENTER is not set
-RTCONFIG_PROTECTION_SERVER=y
+# RTCONFIG_PROTECTION_SERVER is not set
 RTCONFIG_6RELAYD=y
 # RTCONFIG_BCMASPMD is not set
 # RTCONFIG_WLCLMLOAD is not set
--- a/release/src/router/Makefile
+++ b/release/src/router/Makefile
@@ -394,6 +394,131 @@
 obj-y += iproute2
 endif
 
+######################################################################
+#
+# Blackfuel addons
+#
+ASUSWRT_DIR="`readlink -f $(TOP)`/../../.."
+BLACKFUEL_ADDON="blackfuel-addon"
+BLACKFUEL_DIR="$(ASUSWRT_DIR)/$(BLACKFUEL_ADDON)"
+
+RTCONFIG_APCUPSD=y
+ifeq ($(RTCONFIG_APCUPSD),y)
+RTCONFIG_APCUPSD_CGI=y
+obj-y += apcupsd
+obj-y += libgd
+obj-y += freetype
+obj-y += libtiff
+obj-y += libpng
+obj-y += bzip2
+obj-y += jpeg
+obj-y += zlib
+endif
+
+RTCONFIG_TRANSMISSION=openssl
+ifeq ($(RTCONFIG_TRANSMISSION),openssl)
+obj-y += transmission-openssl
+else
+ifeq ($(RTCONFIG_TRANSMISSION),mbedtls)
+obj-y += transmission-mbedtls
+obj-y += mbedtls
+endif
+endif
+
+RTCONFIG_CRYPTSETUP=gcrypt
+ifeq ($(RTCONFIG_CRYPTSETUP),gcrypt)
+obj-y += cryptsetup-gcrypt
+obj-y += libgcrypt
+obj-y += libgpg-error
+obj-y += lvm2
+obj-y += util-linux
+obj-y += popt
+else
+ifeq ($(RTCONFIG_CRYPTSETUP),openssl)
+obj-y += cryptsetup-openssl
+obj-y += lvm2
+obj-y += util-linux
+obj-y += popt
+else
+ifeq ($(RTCONFIG_CRYPTSETUP),nettle)
+obj-y += cryptsetup-nettle
+obj-y += lvm2
+obj-y += util-linux
+obj-y += popt
+else
+ifeq ($(RTCONFIG_CRYPTSETUP),kernel)
+obj-y += cryptsetup-kernel
+obj-y += lvm2
+obj-y += util-linux
+obj-y += popt
+endif
+endif
+endif
+endif
+
+RTCONFIG_RTLENTROPY=y
+ifeq ($(RTCONFIG_RTLENTROPY),y)
+obj-y += rtl-entropy
+
+LIBS_DL=`$(if $(RTCONFIG_BCMARM),arm-brcm-linux-uclibcgnueabi-gcc -print-file-name=,mipsel-linux-uclibc-cpp -print-file-name=)libdl.a`
+LIBS_PTHREAD=`$(if $(RTCONFIG_BCMARM),arm-brcm-linux-uclibcgnueabi-gcc -print-file-name=,mipsel-linux-uclibc-cpp -print-file-name=)libpthread.a`
+LIBS_M=`$(if $(RTCONFIG_BCMARM),arm-brcm-linux-uclibcgnueabi-gcc -print-file-name=,mipsel-linux-uclibc-cpp -print-file-name=)libm.a`
+LIBS_RT=`$(if $(RTCONFIG_BCMARM),arm-brcm-linux-uclibcgnueabi-gcc -print-file-name=,mipsel-linux-uclibc-cpp -print-file-name=)librt.a`
+LIBS_C=`$(if $(RTCONFIG_BCMARM),arm-brcm-linux-uclibcgnueabi-gcc -print-file-name=,mipsel-linux-uclibc-cpp -print-file-name=)libc.a`
+endif
+
+RTCONFIG_NTP=y
+ifeq ($(RTCONFIG_NTP),y)
+obj-y += ntp
+obj-y += libcap
+obj-y += util-linux
+obj-y += pps-tools
+obj-y += setserial
+endif
+
+RTCONFIG_FINDUTILS=y
+ifeq ($(RTCONFIG_FINDUTILS),y)
+obj-y += findutils
+endif
+
+RTCONFIG_WHOIS=y
+ifeq ($(RTCONFIG_WHOIS),y)
+obj-y += whois
+endif
+
+RTCONFIG_WIPE=y
+ifeq ($(RTCONFIG_WIPE),y)
+obj-y += wipe
+endif
+
+RTCONFIG_DNSCRYPT=y
+ifeq ($(RTCONFIG_DNSCRYPT),y)
+obj-y += dnscrypt
+obj-y += libsodium
+endif
+
+RTCONFIG_HAVEGED=y
+ifeq ($(RTCONFIG_HAVEGED),y)
+obj-y += haveged
+endif
+
+RTCONFIG_DIEHARDER=y
+ifeq ($(RTCONFIG_DIEHARDER),y)
+obj-y += dieharder
+obj-y += gsl
+endif
+
+RTCONFIG_RNGTOOLS=y
+ifeq ($(RTCONFIG_RNGTOOLS),y)
+obj-y += rng-tools
+obj-y += libgcrypt
+obj-y += libgpg-error
+obj-y += argp-standalone
+endif
+
+
+######################################################################
+
 obj-$(RTCONFIG_BWDPI) += sqlite
 obj-$(RTCONFIG_BWDPI) += bwdpi
 obj-$(RTCONFIG_BWDPI) += bwdpi_sqlite
@@ -807,6 +932,8 @@
 obj-y += openssl
 obj-y += zlib
 obj-y += libevent-2.0.21
+obj-y += xzutils
+obj-y += zstd
 obj-y += tor
 endif
 
@@ -1107,6 +1234,7 @@
 endif
 
 	@cd $(TARGETDIR) && $(TOP)/others/rootprep${BCMEX}.sh
+	[ ! -d $(BLACKFUEL_DIR)/staging ] || cp -afv $(BLACKFUEL_DIR)/staging/* $(TARGETDIR)
 	@echo ---
 
 ifeq ($(RTCONFIG_QCA),y)
@@ -1156,7 +1284,7 @@
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/bluetooth $(PLATFORMDIR)/extras/bluetooth/drivers/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/net/bluetooth $(PLATFORMDIR)/extras/bluetooth/net/ || true
 
-	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbserial.*o $(PLATFORMDIR)/extras/ || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbserial.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/option.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/*acm.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/cdc-wdm.*o $(PLATFORMDIR)/extras/ || true
@@ -1171,9 +1299,9 @@
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/net/usb/ipheth.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_USB_MODEM),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/sierra.*o $(PLATFORMDIR)/extras/ || true
 
-	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbkbd.*o $(PLATFORMDIR)/extras/ || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbkbd.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/usbmouse.*o $(PLATFORMDIR)/extras/ || true
-	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/hid*.*o $(PLATFORMDIR)/extras/ || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/hid*.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/ipw.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/audio.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/usb/ov51*.*o $(PLATFORMDIR)/extras/ || true
@@ -1186,15 +1314,13 @@
 	@rm -rf $(TARGETDIR)/lib/modules/*/kernel/drivers/sound || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/sound/* $(PLATFORMDIR)/extras/ || true
 	@rm -rf $(TARGETDIR)/lib/modules/*/kernel/sound || true
-	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/input/* $(PLATFORMDIR)/extras/ || true
-	@rm -rf $(TARGETDIR)/lib/modules/*/kernel/drivers/input || true
-	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/hid/* $(PLATFORMDIR)/extras/ || true
-	@rm -rf $(TARGETDIR)/lib/modules/*/kernel/drivers/hid || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/input/* $(PLATFORMDIR)/extras/ || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/hid/* $(PLATFORMDIR)/extras/ || true
 	@cp -f $(TARGETDIR)/lib/modules/*/kernel/drivers/net/bcm57*.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_PPTP),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/net/pptp.*o $(PLATFORMDIR)/extras/ || true
 	$(if $(RTCONFIG_L2TP),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/drivers/net/pppol2tp.*o $(PLATFORMDIR)/extras/ || true
 	@mv $(TARGETDIR)/lib/modules/*/kernel/drivers/net/ppp_deflate.*o  $(PLATFORMDIR)/extras/ || true
-	$(if $(RTCONFIG_IPSEC),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/crypto/* $(PLATFORMDIR)/extras/ || true
+	@cp -f $(TARGETDIR)/lib/modules/*/kernel/crypto/* $(PLATFORMDIR)/extras/ || true
 	[ ! -f $(TARGETDIR)/lib/modules/*/kernel/crypto/* ] && rm -rf $(TARGETDIR)/lib/modules/*/kernel/crypto || true
 
 	$(if $(NEED_EX_NLS),@cp -f,@mv) $(TARGETDIR)/lib/modules/*/kernel/fs/nls_cp9*.*o $(PLATFORMDIR)/extras/ || true
@@ -1351,6 +1477,54 @@
 	rm -rf $(PLATFORMDIR)/extras
 	rm -rf kernel_header
 
+	# Blackfuel packages and updates
+	if [ ! -d "$(BLACKFUEL_DIR)" ]; then \
+		ln -sf ../$(BLACKFUEL_ADDON) "$(BLACKFUEL_DIR)"; \
+	fi; \
+	if [ ! -d "$(BLACKFUEL_DIR)/packages" ]; then \
+		echo "The blackfuel packages directory is missing: $(BLACKFUEL_DIR)/packages"; \
+		false; \
+	else \
+		rm -rf "$(TOP)/xzutils"; \
+		rm -rf "$(TOP)/zstd"; \
+		rm -rf "$(TOP)/tor"; \
+		rm -rf "$(TOP)/nettle"; \
+		rm -rf "$(TOP)/curl"; \
+		rm -rf "$(TOP)/findutils"; \
+		rm -rf "$(TOP)/whois"; \
+		rm -rf "$(TOP)/libsodium"; \
+		rm -rf "$(TOP)/dnscrypt"; \
+		rm -rf "$(TOP)/haveged"; \
+		rm -rf "$(TOP)/wipe"; \
+		rm -rf "$(TOP)/gsl"; \
+		rm -rf "$(TOP)/dieharder"; \
+		rm -rf "$(TOP)/popt"; \
+		rm -rf "$(TOP)/libgpg-error"; \
+		rm -rf "$(TOP)/util-linux"; \
+		rm -rf "$(TOP)/lvm2"; \
+		rm -rf "$(TOP)/libgcrypt"; \
+		rm -rf "$(TOP)/cryptsetup-gcrypt $(TOP)/cryptsetup-openssl $(TOP)/cryptsetup-nettle $(TOP)/cryptsetup-kernel"; \
+		rm -rf "$(TOP)/pps-tools"; \
+		rm -rf "$(TOP)/setserial"; \
+		rm -rf "$(TOP)/ntp"; \
+		rm -rf "$(TOP)/argp-standalone"; \
+		rm -rf "$(TOP)/libcap"; \
+		rm -rf "$(TOP)/rtl-sdr"; \
+		rm -rf "$(TOP)/rtl-entropy"; \
+		rm -rf "$(TOP)/ncurses"; \
+		rm -rf "$(TOP)/transmission-openssl $(TOP)/transmission-mbedtls"; \
+		rm -rf "$(TOP)/mbedtls"; \
+		rm -rf "$(TOP)/wget"; \
+		rm -rf "$(TOP)/apcupsd"; \
+		rm -rf "$(TOP)/libgd"; \
+		rm -rf "$(TOP)/jpeg"; \
+		rm -rf "$(TOP)/libpng"; \
+		rm -rf "$(TOP)/libtiff"; \
+		rm -rf "$(TOP)/freetype"; \
+		rm -rf "$(TOP)/bzip2"; \
+		true; \
+	fi
+
 distclean: clean
 ifneq ($(INSIDE_MAK),1)
 	$(MAKE) -C $(SRCBASE) $@ INSIDE_MAK=1
@@ -1446,20 +1620,6 @@
 busybox-config:
 	$(MAKE) -C busybox menuconfig
 
-e2fsprogs/Makefile: e2fsprogs/Makefile.in
-ifeq ($(RTCONFIG_BCMARM),y)
-	cd e2fsprogs && CFLAGS="-Os $(EXTRACFLAGS)" \
-	$(CONFIGURE) --prefix=/usr --sysconfdir=/etc --enable-elf-shlibs ac_cv_lib_pthread_sem_init=no \
-		--disable-tls --disable-rpath --disable-nls \
-		--disable-debugfs --disable-imager --disable-resizer --disable-defrag --disable-uuidd
-else
-	cd e2fsprogs && CFLAGS="-Os $(EXTRACFLAGS)" \
-	$(CONFIGURE) LDFLAGS="$(if $(QCA),-ldl)" \
-		--prefix=/usr --sysconfdir=/etc --enable-elf-shlibs \
-		--disable-tls --disable-rpath --disable-nls \
-		--disable-debugfs --disable-imager --disable-resizer --disable-defrag --disable-uuidd
-endif
-
 6relayd: 6relayd/Makefile
 	@EXT_CFLAGS="-Os -Wall $(EXTRACFLAGS) -ffunction-sections -fdata-sections -fPIC" \
 	EXT_LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections" \
@@ -1473,25 +1633,50 @@
 6relayd-clean:
 	-@$(MAKE) -C 6relayd clean
 
-e2fsprogs: e2fsprogs/Makefile
+e2fsprogs: util-linux e2fsprogs/Makefile
 	$(MAKE) -C $@ $(PARALLEL_BUILD)
 
+e2fsprogs/Makefile: e2fsprogs/Makefile.in
+ifeq ($(RTCONFIG_BCMARM),y)
+	cd e2fsprogs && \
+	PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+	CFLAGS="$(CFLAGS) -Os $(EXTRACFLAGS) -I$(STAGEDIR)/usr/include" \
+	CPPFLAGS="$(CPPFLAGS) -Os $(EXTRACFLAGS) -I$(STAGEDIR)/usr/include" \
+	LDFLAGS="$(LDFLAGS) -L$(STAGEDIR)/usr/lib" \
+	LIBS="-luuid -L$(STAGEDIR)/usr/lib" \
+	$(CONFIGURE) --prefix=$(STAGEDIR)/usr --sysconfdir=/etc --enable-elf-shlibs ac_cv_lib_pthread_sem_init=no \
+		--disable-tls --disable-rpath --disable-nls \
+		--disable-debugfs --disable-imager --disable-resizer --disable-defrag --disable-uuidd \
+		--disable-libuuid --disable-libblkid
+else
+	cd e2fsprogs && \
+	PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+	CFLAGS="$(CFLAGS) -Os $(EXTRACFLAGS) -I$(STAGEDIR)/usr/include" \
+	CPPFLAGS="$(CPPFLAGS) -Os $(EXTRACFLAGS) -I$(STAGEDIR)/usr/include" \
+	LDFLAGS="$(LDFLAGS) $(if $(QCA),-ldl) -L$(STAGEDIR)/usr/lib" \
+	LIBS="-luuid -L$(STAGEDIR)/usr/lib" \
+	$(CONFIGURE) --prefix=$(STAGEDIR)/usr --sysconfdir=/etc --enable-elf-shlibs \
+		--disable-tls --disable-rpath --disable-nls \
+		--disable-debugfs --disable-imager --disable-resizer --disable-defrag --disable-uuidd \
+		--disable-libuuid --disable-libblkid
+endif
+
 e2fsprogs-clean:
 	-@$(MAKE) -C e2fsprogs clean
 	@rm -f e2fsprogs/Makefile
 
 e2fsprogs-install:
-	install -D e2fsprogs/lib/libblkid.so.1.0 $(INSTALLDIR)/e2fsprogs/usr/lib/libblkid.so.1.0
+	#install -D e2fsprogs/lib/libblkid.so.1.0 $(INSTALLDIR)/e2fsprogs/usr/lib/libblkid.so.1.0
 	install -D e2fsprogs/lib/libcom_err.so.2.1 $(INSTALLDIR)/e2fsprogs/usr/lib/libcom_err.so.2.1
 	install -D e2fsprogs/lib/libe2p.so.2.3 $(INSTALLDIR)/e2fsprogs/usr/lib/libe2p.so.2.3
 	install -D e2fsprogs/lib/libext2fs.so.2.4 $(INSTALLDIR)/e2fsprogs/usr/lib/libext2fs.so.2.4
-	install -D e2fsprogs/lib/libuuid.so.1.2 $(INSTALLDIR)/e2fsprogs/usr/lib/libuuid.so.1.2
+	#install -D e2fsprogs/lib/libuuid.so.1.2 $(INSTALLDIR)/e2fsprogs/usr/lib/libuuid.so.1.2
 	$(STRIP) $(INSTALLDIR)/e2fsprogs/usr/lib/*.so.*
-	ln -sf libblkid.so.1.0 $(INSTALLDIR)/e2fsprogs/usr/lib/libblkid.so.1
+	#ln -sf libblkid.so.1.0 $(INSTALLDIR)/e2fsprogs/usr/lib/libblkid.so.1
 	ln -sf libcom_err.so.2.1 $(INSTALLDIR)/e2fsprogs/usr/lib/libcom_err.so.2
 	ln -sf libe2p.so.2.3 $(INSTALLDIR)/e2fsprogs/usr/lib/libe2p.so.2
 	ln -sf libext2fs.so.2.4 $(INSTALLDIR)/e2fsprogs/usr/lib/libext2fs.so.2
-	ln -sf libuuid.so.1.2 $(INSTALLDIR)/e2fsprogs/usr/lib/libuuid.so.1
+	#ln -sf libuuid.so.1.2 $(INSTALLDIR)/e2fsprogs/usr/lib/libuuid.so.1
 	install -D e2fsprogs/e2fsck/e2fsck $(INSTALLDIR)/e2fsprogs/usr/sbin/e2fsck
 	install -D e2fsprogs/misc/mke2fs $(INSTALLDIR)/e2fsprogs/usr/sbin/mke2fs
 	install -D e2fsprogs/misc/tune2fs $(INSTALLDIR)/e2fsprogs/usr/sbin/tune2fs
@@ -1553,11 +1738,17 @@
 	@$(MAKE) -C www install INSTALLDIR=$(INSTALLDIR)/www TOMATO_EXPERIMENTAL=$(TOMATO_EXPERIMENTAL)
 
 ifeq ($(RTCONFIG_OPENVPN),y)
+ifneq ($(RTCONFIG_TRANSMISSION),openssl)
 OPENSSL_CIPHERS:=enable-rc5 no-rc4
 else
+OPENSSL_CIPHERS:=enable-rc5
+endif
+else
+ifneq ($(RTCONFIG_TRANSMISSION),openssl)
 #OPENSSL_CIPHERS:=no-dh no-idea no-rc2 no-rc5 no-aes no-aes192 no-cast no-des no-modes no-tls1 no-tlsext
 OPENSSL_CIPHERS:=no-rc4
 endif
+endif
 
 #OPENSSL_CIPHERS:=enable-aes enable-tls1 enable-tlsext
 
@@ -1827,22 +2018,29 @@
 		$(if $(RTCONFIG_IPV6),-DUSE_IPV6,-DNO_IPV6) \
 		$(if $(RTCONFIG_USB_EXTRAS)||$(RTCONFIG_TR069),,-DNO_SCRIPT) \
 		$(if $(RTCONFIG_USB_EXTRAS),,-DNO_TFTP) \
-		$(if $(RTCONFIG_DNSSEC),-I$(TOP)/nettle/include -I$(TOP)/gmp -DHAVE_DNSSEC -DHAVE_DNSSEC_STATIC,)" \
+		$(if $(RTCONFIG_DNSSEC),-I$(STAGEDIR)/usr/include -I$(TOP)/gmp -DHAVE_DNSSEC -DHAVE_DNSSEC_STATIC,)" \
 	CFLAGS="-Os -ffunction-sections -fdata-sections $(EXTRACFLAGS)" \
 	LDFLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections \
-		$(if $(RTCONFIG_DNSSEC),-L$(TOP)/nettle/lib -L$(TOP)/gmp/.libs,)" \
-	$(if $(RTCONFIG_DNSSEC),PKG_CONFIG_PATH="$(TOP)/nettle/lib/pkgconfig",)
+		$(if $(RTCONFIG_DNSSEC),-L$(STAGEDIR)/usr/lib -L$(TOP)/gmp/.libs,)" \
+	$(if $(RTCONFIG_DNSSEC),PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig",)
 
 dnsmasq-install:
 	install -D dnsmasq/src/dnsmasq $(INSTALLDIR)/dnsmasq/usr/sbin/dnsmasq
 	$(STRIP) $(INSTALLDIR)/dnsmasq/usr/sbin/dnsmasq
 
-nettle/stamp-h1:
+nettle/stamp-h1: nettle-unpack
 	@cd nettle && \
-	CPPFLAGS="-I$(TOP)/gmp" \
-	CFLAGS="-O2 -Wall $(EXTRACFLAGS) -fPIC -ffunction-sections -fdata-sections" \
-	LDFLAGS="-L$(TOP)/gmp/.libs -ffunction-sections -fdata-sections -Wl,--gc-sections -fPIC" \
-	$(CONFIGURE) prefix=$(TOP)/nettle --enable-mini-gmp --disable-documentation --disable-shared
+	PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+	CFLAGS="$(CFLAGS) $(EXTRACFLAGS) -I$(STAGEDIR)/usr/include -I$(STAGEDIR)/usr/include/nettle -I$(TOP)/gmp" \
+	CXXFLAGS="$(CXXFLAGS) $(EXTRACFLAGS) -I$(STAGEDIR)/usr/include -I$(STAGEDIR)/usr/include/nettle -I$(TOP)/gmp" \
+	CPPFLAGS="$(CPPFLAGS) $(EXTRACFLAGS) -I$(STAGEDIR)/usr/include -I$(STAGEDIR)/usr/include/nettle -I$(TOP)/gmp" \
+	LDFLAGS="$(LDFLAGS) -L$(STAGEDIR)/usr/lib -L$(TOP)/gmp/.libs" \
+	$(CONFIGURE) \
+	--prefix="$(STAGEDIR)/usr" \
+	--disable-shared \
+	--enable-static \
+	--enable-mini-gmp \
+	--disable-documentation
 	@touch nettle/stamp-h1
 
 nettle: nettle/stamp-h1
@@ -2006,14 +2204,14 @@
 	cd miniupnpd && ./genconfig.sh --vendorcfg --leasefile --portinuse
 endif
 
-miniupnpd: $(IPTABLES) e2fsprogs miniupnpd/config.h
+miniupnpd: $(IPTABLES) util-linux miniupnpd/config.h
 	@$(SEP)
 	cp -f ./shared/version.h miniupnpd$(MUVER)/.
 	PKG_CONFIG=false ARCH=$(PLATFORM) \
 	$(MAKE) -C $@ -f Makefile.merlin $(PARALLEL_BUILD) \
 	    IPTABLESPATH=$(TOP)/$(IPTABLES) \
-	    EXTRACFLAGS="-Os $(EXTRACFLAGS) -idirafter$(KERNEL_HEADER_DIR) -ffunction-sections -fdata-sections -I$(TOP)/e2fsprogs/lib" \
-	    LDFLAGS="$(EXTRALDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(IPTC_LIBDIR) -L$(TOP)/e2fsprogs/lib" \
+	    EXTRACFLAGS="-Os $(EXTRACFLAGS) -idirafter$(KERNEL_HEADER_DIR) -ffunction-sections -fdata-sections -I$(STAGEDIR)/usr/include" \
+	    LDFLAGS="$(EXTRALDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(IPTC_LIBDIR) -L$(STAGEDIR)/usr/lib" \
 	    LDLIBS="-Wl,--as-needed $(IPTC_LIBS) -luuid"
 
 miniupnpd-clean:
@@ -2168,7 +2366,8 @@
 	touch $@
 
 libusb10: libusb10/stamp-h1
-	$(MAKE) -C $@
+	$(MAKE) -C $@ && \
+	DESTDIR="$(STAGEDIR)" $(MAKE) -C $@ install
 
 libusb10-install: libusb10
 	install -D libusb10/libusb/.libs/libusb-1.0.so.0.0.0 $(INSTALLDIR)/libusb10/usr/lib/libusb-1.0.so.0
@@ -2298,44 +2497,44 @@
 mtd-utils-clean:
 	$(MAKE) -C mtd-utils clean
 
-util-linux: util-linux/Makefile
-	$(MAKE) -C $@/libuuid/src && $(MAKE) $@-stage
-
-util-linux/Makefile: util-linux/configure
-	$(MAKE) util-linux-configure
-
-util-linux/configure:
-	( cd util-linux ; ./autogen.sh )
-
-util-linux-configure:
-	( export scanf_cv_alloc_modifier=no; \
-		cd util-linux ; \
-		$(CONFIGURE) \
-		--prefix=/usr \
-		--bindir=/usr/sbin \
-		--libdir=/usr/lib \
-		--enable-libuuid \
-		--disable-nls --disable-tls --disable-libblkid --disable-mount --disable-libmount \
-		--disable-fsck --disable-cramfs --disable-partx --disable-uuidd --disable-mountpoint \
-		--disable-fallocate --disable-unshare --disable-agetty \
-		--disable-cramfs --disable-switch_root --disable-pivot_root \
-		--disable-kill --disable-rename --disable-chsh-only-listed \
-		--disable-schedutils --disable-wall --disable-pg-bell --disable-require-password \
-		--disable-use-tty-group --disable-makeinstall-chown --disable-makeinstall-setuid\
-		--without-ncurses --without-selinux --without-audit \
-	)
-
-util-linux-stage:
-	$(MAKE) -C util-linux/libuuid/src DESTDIR=$(STAGEDIR) \
-		install-usrlib_execLTLIBRARIES install-uuidincHEADERS
-
-util-linux-install: util-linux
-	install -D $(STAGEDIR)/usr/lib/libuuid.so.1 $(INSTALLDIR)/util-linux/usr/lib/libuuid.so.1
-	$(STRIP) $(INSTALLDIR)/util-linux/usr/lib/*.so*
-
-util-linux-clean:
-	[ ! -f util-linux/Makefile ] || $(MAKE) -C util-linux distclean
-	@rm -f util-linux/Makefile
+#util-linux: util-linux/Makefile
+#	$(MAKE) -C $@/libuuid/src && $(MAKE) $@-stage
+#
+#util-linux/Makefile: util-linux/configure
+#	$(MAKE) util-linux-configure
+#
+#util-linux/configure:
+#	( cd util-linux ; ./autogen.sh )
+#
+#util-linux-configure:
+#	( export scanf_cv_alloc_modifier=no; \
+#		cd util-linux ; \
+#		$(CONFIGURE) \
+#		--prefix=/usr \
+#		--bindir=/usr/sbin \
+#		--libdir=/usr/lib \
+#		--enable-libuuid \
+#		--disable-nls --disable-tls --disable-libblkid --disable-mount --disable-libmount \
+#		--disable-fsck --disable-cramfs --disable-partx --disable-uuidd --disable-mountpoint \
+#		--disable-fallocate --disable-unshare --disable-agetty \
+#		--disable-cramfs --disable-switch_root --disable-pivot_root \
+#		--disable-kill --disable-rename --disable-chsh-only-listed \
+#		--disable-schedutils --disable-wall --disable-pg-bell --disable-require-password \
+#		--disable-use-tty-group --disable-makeinstall-chown --disable-makeinstall-setuid\
+#		--without-ncurses --without-selinux --without-audit \
+#	)
+#
+#util-linux-stage:
+#	$(MAKE) -C util-linux/libuuid/src DESTDIR=$(STAGEDIR) \
+#		install-usrlib_execLTLIBRARIES install-uuidincHEADERS
+#
+#util-linux-install: util-linux
+#	install -D $(STAGEDIR)/usr/lib/libuuid.so.1 $(INSTALLDIR)/util-linux/usr/lib/libuuid.so.1
+#	$(STRIP) $(INSTALLDIR)/util-linux/usr/lib/*.so*
+#
+#util-linux-clean:
+#	[ ! -f util-linux/Makefile ] || $(MAKE) -C util-linux distclean
+#	@rm -f util-linux/Makefile
 
 odhcp6c: odhcp6c/Makefile
 	@EXT_CFLAGS="-Os -Wall $(EXTRACFLAGS) -ffunction-sections -fdata-sections -fPIC" \
@@ -2828,20 +3027,1961 @@
 	[ ! -f libevent-2.0.21/Makefile ] || $(MAKE) -C libevent-2.0.21 clean
 	@rm -f libevent-2.0.21/Makefile
 
-tor: openssl zlib libevent-2.0.21 tor/Makefile
+#######################################################################################
+#
+# Blackfuel addons
+#
+
+### xzutils
+
+xzutils: xzutils/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+xzutils/Makefile: xzutils-unpack xzutils/configure
+	@[ -f $@ ] || $(MAKE) xzutils-configure
+
+xzutils/configure:
+	@[ -f $@ ] || ( cd xzutils ; ./autogen.sh )
+
+xzutils-configure:
+	@[ ! -d xzutils ] || [ -f "$(STAGEDIR)/usr/lib/liblzma.so" ] || ( cd xzutils ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-nls \
+		--disable-rpath \
+		--enable-threads=posix \
+		--disable-silent-rules)
+
+xzutils-stage:
+	@echo xzutils
+	@[ ! -d xzutils ] || $(MAKE) -C xzutils $(PARALLEL_BUILD) install
+
+xzutils-clean:
+	[ ! -f xzutils/Makefile ] || $(MAKE) -C xzutils clean
+	@rm -f xzutils/Makefile
+
+xzutils-install:
+	install -d $(INSTALLDIR)/xzutils/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/liblzma.so* $(INSTALLDIR)/xzutils/usr/lib/
+	chmod u+w $(INSTALLDIR)/xzutils/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/xzutils/usr/lib/liblzma.so*
+
+### zstd
+
+zstd: xzutils zstd/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+zstd/Makefile:
+	@[ ! -d zstd ] && $(MAKE) zstd-unpack
+
+zstd-stage:
+	@echo zstd
+	@[ ! -d zstd ] || [ -f "$(STAGEDIR)/usr/lib/libzstd.so" ] || \
+		PREFIX="$(STAGEDIR)/usr" \
+		DESTDIR="" \
+		LIBDIR="$(STAGEDIR)/usr/lib" \
+		INCLUDEDIR="$(STAGEDIR)/usr/include" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread" \
+		$(MAKE) -C zstd $(PARALLEL_BUILD) install
+
+zstd-clean:
+	[ ! -f zstd/Makefile ] || $(MAKE) -C zstd clean
+
+zstd-install:
+	install -d $(INSTALLDIR)/zstd/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libzstd.so* $(INSTALLDIR)/zstd/usr/lib/
+	chmod u+w $(INSTALLDIR)/zstd/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/zstd/usr/lib/libzstd.so*
+
+### findutils
+
+findutils: findutils/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+findutils/Makefile: findutils-unpack findutils/configure
+	@[ -f $@ ] || $(MAKE) findutils-configure
+
+findutils/configure:
+	@[ -f $@ ] || ( cd findutils ; ./autogen.sh )
+
+findutils-configure:
+	@[ ! -d findutils ] || [ -f "$(STAGEDIR)/usr/bin/find" ] || ( cd findutils ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-threads=posix \
+		--disable-silent-rules \
+		--disable-rpath)
+
+findutils-stage:
+	@echo findutils
+	@[ ! -d findutils ] || ( \
+		$(MAKE) -C findutils $(PARALLEL_BUILD) && \
+		$(MAKE) -C findutils install )
+
+findutils-clean:
+	[ ! -f findutils/Makefile ] || $(MAKE) -C findutils clean
+	@rm -f findutils/Makefile
+
+findutils-install:
+	install -d $(INSTALLDIR)/findutils/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/find $(INSTALLDIR)/findutils/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/xargs $(INSTALLDIR)/findutils/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/locate $(INSTALLDIR)/findutils/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/updatedb $(INSTALLDIR)/findutils/usr/bin/
+	$(STRIP) $(INSTALLDIR)/findutils/usr/bin/find
+	$(STRIP) $(INSTALLDIR)/findutils/usr/bin/xargs
+	$(STRIP) $(INSTALLDIR)/findutils/usr/bin/locate
+
+### libsodium
+
+libsodium: libsodium/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libsodium/Makefile: libsodium-unpack libsodium/configure
+	@[ -f $@ ] || $(MAKE) libsodium-configure
+
+libsodium/configure:
+	@[ -f $@ ] || ( cd libsodium ; ./autogen.sh )
+
+libsodium-configure:
+	@[ ! -d libsodium ] || [ -f "$(STAGEDIR)/usr/lib/libsodium.so" ] || ( cd libsodium ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--disable-static \
+		--enable-shared \
+		--disable-silent-rules \
+		--enable-opt \
+		--with-pthreads)
+
+libsodium-stage:
+	@echo libsodium
+	@[ ! -d libsodium ] || ( \
+		$(MAKE) -C libsodium $(PARALLEL_BUILD) && \
+		$(MAKE) -C libsodium install )
+
+libsodium-clean:
+	[ ! -f libsodium/Makefile ] || $(MAKE) -C libsodium clean
+	@rm -f libsodium/Makefile
+
+libsodium-install:
+	install -d $(INSTALLDIR)/libsodium/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libsodium.so* $(INSTALLDIR)/libsodium/usr/lib/
+	chmod u+w $(INSTALLDIR)/libsodium/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/libsodium/usr/lib/libsodium.so*
+
+### dnscrypt
+
+dnscrypt: libsodium dnscrypt/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+dnscrypt/Makefile: dnscrypt-unpack dnscrypt/configure
+	@[ -f $@ ] || $(MAKE) dnscrypt-configure
+
+dnscrypt/configure:
+	@[ -f $@ ] || ( cd dnscrypt ; ./autogen.sh )
+
+dnscrypt-configure:
+	@[ ! -d dnscrypt ] || [ -f "$(STAGEDIR)/usr/sbin/dnscrypt-proxy" ] || ( cd dnscrypt ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--disable-static \
+		--enable-shared \
+		--disable-silent-rules)
+
+dnscrypt-stage:
+	@echo dnscrypt
+	@[ ! -d dnscrypt ] || ( \
+		$(MAKE) -C dnscrypt $(PARALLEL_BUILD) && \
+		$(MAKE) -C dnscrypt install )
+
+dnscrypt-clean:
+	[ ! -f dnscrypt/Makefile ] || $(MAKE) -C dnscrypt clean
+	@rm -f dnscrypt/Makefile
+
+dnscrypt-install:
+	install -d $(INSTALLDIR)/dnscrypt/usr/bin/
+	install -d $(INSTALLDIR)/dnscrypt/usr/share/dnscrypt-proxy/
+	install -D $(STAGEDIR)/usr/sbin/dnscrypt-proxy $(INSTALLDIR)/dnscrypt/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/hostip $(INSTALLDIR)/dnscrypt/usr/bin/
+	install -D $(STAGEDIR)/usr/share/dnscrypt-proxy/dnscrypt-resolvers.csv $(INSTALLDIR)/dnscrypt/usr/share/dnscrypt-proxy/
+	$(STRIP) $(INSTALLDIR)/dnscrypt/usr/bin/dnscrypt-proxy
+	$(STRIP) $(INSTALLDIR)/dnscrypt/usr/bin/hostip
+
+### wipe
+
+wipe: wipe/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+wipe/Makefile: wipe-unpack wipe/configure
+	@[ -f $@ ] || $(MAKE) wipe-configure
+
+wipe/configure:
+	@[ -f $@ ] || ( cd wipe ; ./autogen.sh )
+
+wipe-configure:
+	@[ ! -d wipe ] || [ -f "$(STAGEDIR)/usr/bin/wipe" ] || ( cd wipe ; \
+		CC="arm-brcm-linux-uclibcgnueabi-gcc" \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(CXXFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread" \
+		$(CONFIGURE) \
+		--host=arm-linux \
+		--build=x86_64-linux \
+		--prefix=$(STAGEDIR)/usr \
+		--mandir=$(STAGEDIR)/usr/share/man \
+		--enable-static \
+		--enable-shared)
+
+wipe-stage:
+	@echo wipe
+	@[ ! -d wipe ] || ( cd wipe ; \
+		$(MAKE) $(PARALLEL_BUILD) ; \
+		install -d $(STAGEDIR)/usr/bin ; \
+		install -D wipe $(STAGEDIR)/usr/bin/ ; \
+		$(STRIP) $(STAGEDIR)/usr/bin/wipe ; \
+		install -d $(STAGEDIR)/usr/share/man/man1 ; \
+		install wipe.1 $(STAGEDIR)/usr/share/man/man1/ ; \
+		rm -rf $(STAGEDIR)/usr/share/doc/wipe* ; \
+		install -d $(STAGEDIR)/usr/share/doc/wipe ; \
+		for file in LICENSE copyright CHANGES README TODO INSTALL TESTING; do \
+			install $$file $(STAGEDIR)/usr/share/doc/wipe/; \
+		done )
+
+wipe-clean:
+	[ ! -f wipe/Makefile ] || $(MAKE) -C wipe clean
+	@rm -f wipe/Makefile
+
+wipe-install:
+	install -d $(INSTALLDIR)/wipe/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/wipe $(INSTALLDIR)/wipe/usr/bin/
+	$(STRIP) $(INSTALLDIR)/wipe/usr/bin/wipe
+
+### haveged
+
+haveged: haveged/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+haveged/Makefile: haveged-unpack haveged/configure
+	@[ -f $@ ] || $(MAKE) haveged-configure
+
+haveged/configure:
+	@[ -f $@ ] || ( cd haveged ; ./autogen.sh )
+
+haveged-configure:
+	@[ ! -d haveged ] || [ -f "$(STAGEDIR)/usr/sbin/haveged" ] || ( cd haveged ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-static \
+		--enable-shared \
+		--enable-daemon=yes \
+		--enable-threads=no \
+		--enable-olt=no)
+
+haveged-stage:
+	@echo haveged
+	@[ ! -d haveged ] || ( \
+		$(MAKE) -C haveged $(PARALLEL_BUILD) && \
+		$(MAKE) -C haveged install )
+
+haveged-clean:
+	[ ! -f haveged/Makefile ] || $(MAKE) -C haveged clean
+	@rm -f haveged/Makefile
+
+haveged-install:
+	install -d $(INSTALLDIR)/haveged/usr/bin/
+	install -d $(INSTALLDIR)/haveged/usr/lib/
+	install -D $(STAGEDIR)/usr/sbin/haveged $(INSTALLDIR)/haveged/usr/bin/
+	cp -df $(STAGEDIR)/usr/lib/libhavege.so* $(INSTALLDIR)/haveged/usr/lib/
+	chmod u+w $(INSTALLDIR)/haveged/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/haveged/usr/bin/haveged
+	$(STRIP) $(INSTALLDIR)/haveged/usr/lib/libhavege.so*
+
+### gsl
+
+gsl: gsl/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+gsl/Makefile: gsl-unpack gsl/configure
+	@[ -f $@ ] || $(MAKE) gsl-configure
+
+gsl/configure:
+	@[ -f $@ ] || ( cd gsl ; ./autogen.sh )
+
+gsl-configure:
+	@[ ! -d gsl ] || [ -f "$(STAGEDIR)/usr/lib/libgsl.so" ] || ( cd gsl ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-static \
+		--enable-shared \
+		--disable-silent-rules)
+
+gsl-stage:
+	@echo gsl
+	@[ ! -d gsl ] || ( \
+		$(MAKE) -C gsl $(PARALLEL_BUILD) && \
+		$(MAKE) -C gsl install )
+
+gsl-clean:
+	[ ! -f gsl/Makefile ] || $(MAKE) -C gsl clean
+	@rm -f gsl/Makefile
+
+gsl-install:
+	install -d $(INSTALLDIR)/gsl/usr/bin/
+	install -d $(INSTALLDIR)/gsl/usr/lib/
+	install -D $(STAGEDIR)/usr/bin/gsl-randist $(INSTALLDIR)/gsl/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/gsl-histogram $(INSTALLDIR)/gsl/usr/bin/
+	cp -df $(STAGEDIR)/usr/lib/libgsl.so* $(INSTALLDIR)/gsl/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libgslcblas.so* $(INSTALLDIR)/gsl/usr/lib/
+	chmod u+w $(INSTALLDIR)/gsl/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/gsl/usr/bin/gsl-randist
+	$(STRIP) $(INSTALLDIR)/gsl/usr/bin/gsl-histogram
+	$(STRIP) $(INSTALLDIR)/gsl/usr/lib/libgsl.so*
+	$(STRIP) $(INSTALLDIR)/gsl/usr/lib/libgslcblas.so*
+
+### dieharder
+
+dieharder: gsl dieharder/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+dieharder/Makefile: dieharder-unpack dieharder/configure
+	$(MAKE) dieharder-configure
+
+dieharder/configure:
+	@[ -f $@ ] || ( cd dieharder ; ./autogen.sh )
+
+dieharder-configure:
+	@[ ! -d dieharder ] || [ -f "$(STAGEDIR)/usr/bin/dieharder" ] || ( cd dieharder ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		ac_cv_c_endian=little \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-static \
+		--enable-shared)
+
+dieharder-stage:
+	@echo dieharder
+	@[ ! -d dieharder ] || $(MAKE) -C dieharder $(PARALLEL_BUILD) install
+
+dieharder-clean:
+	[ ! -f dieharder/Makefile ] || $(MAKE) -C dieharder clean
+	@rm -f dieharder/Makefile
+
+dieharder-install:
+	install -d $(INSTALLDIR)/dieharder/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/dieharder $(INSTALLDIR)/dieharder/usr/bin/
+	$(STRIP) $(INSTALLDIR)/dieharder/usr/bin/dieharder
+	install -d $(INSTALLDIR)/dieharder/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libdieharder.so* $(INSTALLDIR)/dieharder/usr/lib/
+	chmod u+w $(INSTALLDIR)/dieharder/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/dieharder/usr/lib/libdieharder.so*
+
+### whois
+
+whois: whois-unpack
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+whois-stage:
+	@echo whois
+	@[ ! -d whois ] || [ -f "$(STAGEDIR)/usr/bin/whois" ] || ( cd whois ; \
+		CC="arm-brcm-linux-uclibcgnueabi-gcc" \
+		BASEDIR="$(STAGEDIR)/usr" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread" \
+		$(MAKE) $(PARALLEL_BUILD) ; \
+		install -d $(STAGEDIR)/usr/bin/ ; \
+		install -d $(STAGEDIR)/usr/share/man/man1/ ; \
+		install -d $(STAGEDIR)/usr/share/man/man5/ ; \
+		install whois $(STAGEDIR)/usr/bin/ ; \
+		install whois.1 $(STAGEDIR)/usr/share/man/man1/ ; \
+		install whois.conf.5 $(STAGEDIR)/usr/share/man/man5/)
+
+whois-clean:
+	-@$(MAKE) -C whois clean
+
+whois-install:
+	install -d $(INSTALLDIR)/whois/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/whois $(INSTALLDIR)/whois/usr/bin/
+	$(STRIP) $(INSTALLDIR)/whois/usr/bin/whois
+
+### argp-standalone
+
+argp-standalone: argp-standalone/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+argp-standalone/Makefile: argp-standalone-unpack argp-standalone/configure
+	@[ -f $@ ] || $(MAKE) argp-standalone-configure
+
+argp-standalone/configure:
+	@[ -f $@ ] || ( cd argp-standalone ; autoreconf -i -f )
+
+argp-standalone-configure:
+	@[ ! -d argp-standalone ] || [ -f "$(STAGEDIR)/usr/lib/libargp.a" ] || ( cd argp-standalone ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" )
+
+argp-standalone-stage:
+	@echo argp-standalone
+	@[ ! -d argp-standalone ] || ( cd argp-standalone ; \
+		$(MAKE) $(PARALLEL_BUILD) ; \
+		install -d $(STAGEDIR)/usr/lib/ ; \
+		install -D libargp.a $(STAGEDIR)/usr/lib/ ; \
+		install -d $(STAGEDIR)/usr/include/ ; \
+		install -D argp.h $(STAGEDIR)/usr/include/ ; \
+		install -D argp-fmtstream.h $(STAGEDIR)/usr/include/ ; \
+		install -D argp-namefrob.h $(STAGEDIR)/usr/include/ )
+
+argp-standalone-clean:
+	[ ! -f argp-standalone/Makefile ] || $(MAKE) -C argp-standalone clean
+	@rm -f argp-standalone/Makefile
+
+argp-standalone-install:
+	@echo "argp-standalone is static library, nothing to install"
+
+### libgpg-error
+
+libgpg-error: libgpg-error/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libgpg-error/Makefile: libgpg-error-unpack libgpg-error/configure
+	@[ -f $@ ] || $(MAKE) libgpg-error-configure
+
+libgpg-error/configure:
+	@[ -f $@ ] || ( cd libgpg-error ; ./autogen.sh )
+
+libgpg-error-configure:
+	@[ ! -d libgpg-error ] || [ -f "$(STAGEDIR)/usr/lib/libgpg-error.so" ] || ( cd libgpg-error ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-nls \
+		--disable-rpath)
+
+libgpg-error-stage:
+	@echo libgpg-error
+	@[ ! -d libgpg-error ] || ( \
+		$(MAKE) -C libgpg-error $(PARALLEL_BUILD) && \
+		$(MAKE) -C libgpg-error install )
+
+libgpg-error-clean:
+	[ ! -f libgpg-error/Makefile ] || $(MAKE) -C libgpg-error clean
+	@rm -f libgpg-error/Makefile
+
+libgpg-error-install:
+	install -d $(INSTALLDIR)/libgpg-error/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libgpg-error.so* $(INSTALLDIR)/libgpg-error/usr/lib/
+	chmod u+w $(INSTALLDIR)/libgpg-error/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/libgpg-error/usr/lib/libgpg-error.so*
+
+### libgcrypt
+
+libgcrypt: libgpg-error libgcrypt/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libgcrypt/Makefile: libgcrypt-unpack libgcrypt/configure
+	@[ -f $@ ] || $(MAKE) libgcrypt-configure
+
+libgcrypt/configure:
+	@[ -f $@ ] || ( cd libgcrypt ; ./autogen.sh )
+
+libgcrypt-configure:
+	@[ ! -d libgcrypt ] || [ -f "$(STAGEDIR)/usr/lib/libgcrypt.so" ] || ( cd libgcrypt ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-amd64-as-feature-detection \
+		--with-gpg-error-prefix="$(STAGEDIR)/usr" )
+
+libgcrypt-stage:
+	@echo libgcrypt
+	@[ ! -d libgcrypt ] || ( \
+		$(MAKE) -C libgcrypt $(PARALLEL_BUILD) && \
+		$(MAKE) -C libgcrypt install )
+
+libgcrypt-clean:
+	[ ! -f libgcrypt/Makefile ] || $(MAKE) -C libgcrypt clean
+	@rm -f libgcrypt/Makefile
+
+libgcrypt-install:
+	install -d $(INSTALLDIR)/libgcrypt/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libgcrypt.so* $(INSTALLDIR)/libgcrypt/usr/lib/
+	chmod u+w $(INSTALLDIR)/libgcrypt/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/libgcrypt/usr/lib/libgcrypt.so*
+
+### rng-tools
+
+rng-tools: argp-standalone libgpg-error libgcrypt rng-tools/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+rng-tools/Makefile: rng-tools-unpack rng-tools/configure
+	@[ -f $@ ] || $(MAKE) rng-tools-configure
+
+rng-tools/configure:
+	@[ -f $@ ] || ( cd rng-tools ; ./autogen.sh )
+
+rng-tools-configure:
+	@[ ! -d rng-tools ] || [ -f "$(STAGEDIR)/usr/bin/rngtest" ] || ( cd rng-tools ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-largp" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--disable-silent-rules )
+
+rng-tools-stage:
+	@echo rng-tools
+	@[ ! -d rng-tools ] || ( \
+		$(MAKE) -C rng-tools $(PARALLEL_BUILD) && \
+		$(MAKE) -C rng-tools install )
+
+rng-tools-clean:
+	[ ! -f rng-tools/Makefile ] || $(MAKE) -C rng-tools clean
+	@rm -f rng-tools/Makefile
+
+rng-tools-install:
+	install -d $(INSTALLDIR)/rng-tools/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/rngtest $(INSTALLDIR)/rng-tools/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/rngd $(INSTALLDIR)/rng-tools/usr/bin/
+	$(STRIP) $(INSTALLDIR)/rng-tools/usr/bin/rngtest
+	$(STRIP) $(INSTALLDIR)/rng-tools/usr/bin/rngd
+
+### popt
+
+popt: popt/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+popt/Makefile: popt-unpack popt/configure
+	@[ -f $@ ] || $(MAKE) popt-configure
+
+popt/configure:
+	@[ -f $@ ] || ( cd popt ; ./autogen.sh )
+
+popt-configure:
+	@[ ! -d popt ] || [ -f "$(STAGEDIR)/usr/lib/libpopt.so" ] || ( cd popt ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-nls \
+		--disable-rpath )
+
+popt-stage:
+	@echo popt
+	@[ ! -d popt ] || ( \
+		$(MAKE) -C popt $(PARALLEL_BUILD) && \
+		$(MAKE) -C popt install )
+
+popt-clean:
+	[ ! -f popt/Makefile ] || $(MAKE) -C popt clean
+	@rm -f popt/Makefile
+
+popt-install:
+	install -d $(INSTALLDIR)/popt/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libpopt.so* $(INSTALLDIR)/popt/usr/lib/
+	chmod u+w $(INSTALLDIR)/popt/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/popt/usr/lib/libpopt.so*
+
+### util-linux
+
+util-linux: ncurses libgcrypt util-linux/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+util-linux/Makefile: util-linux-unpack util-linux/configure
+	@[ -f $@ ] || $(MAKE) util-linux-configure
+
+util-linux/configure:
+	@[ -f $@ ] || ( cd util-linux ; ./autogen.sh )
+
+util-linux-configure:
+	@[ ! -d util-linux ] || [ -f "$(STAGEDIR)/usr/lib/libuuid.so" ] || ( \
+		cd util-linux ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fno-data-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include -lm" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fno-data-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include -lm" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fno-data-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lm $(if $(RTCONFIG_BCMARM),-lncursesw,-lncurses) -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-rpath \
+		--disable-silent-rules \
+		--disable-bash-completion \
+		--disable-makeinstall-chown \
+		--disable-makeinstall-setuid \
+		--disable-agetty \
+		$(if $(RTCONFIG_BCMARM),--with-ncursesw --without-ncurses,--with-ncurses --without-ncursesw) \
+		--enable-libuuid \
+		--enable-libblkid )
+
+util-linux-stage:
+	@echo util-linux
+	@[ ! -d util-linux ] || ( \
+		$(MAKE) -C util-linux $(PARALLEL_BUILD) && \
+		$(MAKE) -C util-linux install )
+
+util-linux-clean:
+	[ ! -f util-linux/Makefile ] || $(MAKE) -C util-linux clean
+	@rm -f util-linux/Makefile
+
+util-linux-install:
+	install -d $(INSTALLDIR)/util-linux/usr/lib/
+	install -d $(INSTALLDIR)/util-linux/usr/bin/
+	# /usr/lib
+	cp -df $(STAGEDIR)/usr/lib/libuuid.so* $(INSTALLDIR)/util-linux/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libblkid.so* $(INSTALLDIR)/util-linux/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libsmartcols.so* $(INSTALLDIR)/util-linux/usr/lib/
+	chmod u+w $(INSTALLDIR)/util-linux/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/util-linux/usr/lib/libuuid.so*
+	$(STRIP) $(INSTALLDIR)/util-linux/usr/lib/libblkid.so*
+	$(STRIP) $(INSTALLDIR)/util-linux/usr/lib/libsmartcols.so*
+	# /usr/bin
+	install -D $(STAGEDIR)/usr/bin/fallocate $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/hexdump $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/cal $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/whereis $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/rename $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/ldattach $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/losetup $(INSTALLDIR)/util-linux/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/hwclock $(INSTALLDIR)/util-linux/usr/bin/
+	$(STRIP) $(INSTALLDIR)/util-linux/usr/bin/fallocate
+	$(STRIP) $(INSTALLDIR)/util-linux/usr/bin/hexdump
+	$(STRIP) $(INSTALLDIR)/util-linux/usr/bin/cal
+	$(STRIP) $(INSTALLDIR)/util-linux/usr/bin/whereis
+	$(STRIP) $(INSTALLDIR)/util-linux/usr/bin/rename
+	$(STRIP) $(INSTALLDIR)/util-linux/usr/bin/ldattach
+	$(STRIP) $(INSTALLDIR)/util-linux/usr/bin/losetup
+	$(STRIP) $(INSTALLDIR)/util-linux/usr/bin/hwclock
+
+### lvm2
+
+lvm2: lvm2/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+lvm2/Makefile: lvm2-unpack lvm2/configure
+	@[ -f $@ ] || $(MAKE) lvm2-configure
+
+lvm2/configure:
+	@[ -f $@ ] || ( cd lvm2 ; ./autogen.sh )
+
+lvm2-configure:
+	@[ ! -d lvm2 ] || [ -f "$(STAGEDIR)/usr/lib/libdevmapper.so" ] || ( cd lvm2 ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(CXXFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		BLKID_CFLAGS="$(BLKID_CFLAGS) -I$(STAGEDIR)/usr/include/blkid -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L../libdm/ioctl -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread -luuid -lm -L../libdm/ioctl -L$(STAGEDIR)/usr/lib" \
+		BLKID_LIBS="-lblkid -L$(STAGEDIR)/usr/lib" \
+		ac_cv_func_malloc_0_nonnull=yes ac_cv_func_realloc_0_nonnull=yes \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--with-confdir=$(STAGEDIR)/usr/etc \
+		--with-default-system-dir=$(STAGEDIR)/usr/etc/lvm \
+		--enable-static_link \
+		--disable-nls \
+		--enable-pkgconfig ; \
+		mkdir -p $(STAGEDIR)/usr/lib/pkgconfig; \
+		cp -pf "libdm/libdevmapper.pc" $(STAGEDIR)/usr/lib/pkgconfig; \
+		ln -sf libdevmapper.pc $(STAGEDIR)/usr/lib/pkgconfig/devmapper.pc )
+
+lvm2-stage:
+	@echo lvm2
+	@[ ! -d lvm2 ] || ( \
+		$(MAKE) -C lvm2 $(PARALLEL_BUILD) && \
+		$(MAKE) -C lvm2 install )
+
+lvm2-clean:
+	[ ! -f lvm2/Makefile ] || $(MAKE) -C lvm2 clean
+	@rm -f lvm2/Makefile
+
+lvm2-install:
+	install -d $(INSTALLDIR)/lvm2/usr/lib/
+	install -d $(INSTALLDIR)/lvm2/usr/bin/
+	install -d $(INSTALLDIR)/lvm2/usr/sbin/
+	cp -df $(STAGEDIR)/usr/lib/libdevmapper.so* $(INSTALLDIR)/lvm2/usr/lib/
+	chmod u+w $(INSTALLDIR)/lvm2/usr/lib/*
+	install -D $(STAGEDIR)/usr/sbin/dmsetup $(INSTALLDIR)/lvm2/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/lvm $(INSTALLDIR)/lvm2/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/lvmconf $(INSTALLDIR)/lvm2/usr/sbin/
+	install -D $(STAGEDIR)/usr/sbin/lvmdump $(INSTALLDIR)/lvm2/usr/sbin/
+	for FILE in $(STAGEDIR)/usr/sbin/*; do \
+		if [ -h "$$FILE" ] && [ "`readlink $$FILE`" = "lvm" ]; then \
+			cp -df "$$FILE" "$(INSTALLDIR)/lvm2/usr/bin/"; \
+		fi; \
+	done
+	$(STRIP) $(INSTALLDIR)/lvm2/usr/bin/dmsetup
+	$(STRIP) $(INSTALLDIR)/lvm2/usr/bin/lvm
+	$(STRIP) $(INSTALLDIR)/lvm2/usr/lib/libdevmapper.so*
+
+### cryptsetup-gcrypt
+
+cryptsetup-gcrypt: popt util-linux lvm2 libgpg-error libgcrypt cryptsetup-gcrypt/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+cryptsetup-gcrypt/Makefile: cryptsetup-gcrypt-unpack cryptsetup-gcrypt/configure
+	@[ -f $@ ] || $(MAKE) cryptsetup-gcrypt-configure
+
+cryptsetup-gcrypt/configure:
+	@[ -f $@ ] || ( cd cryptsetup-gcrypt ; autoreconf -i -f )
+
+cryptsetup-gcrypt-configure:
+	@[ ! -d cryptsetup-gcrypt ] || [ -f "$(STAGEDIR)/usr/lib/libcryptsetup.so" ] || ( cd cryptsetup-gcrypt ; \
+		IF_ALG_H="$(BLACKFUEL_DIR)/packages/cryptsetup/linux/if_alg.h"; \
+		STAGEDIR_INCLUDE_LINUX="$(STAGEDIR)/usr/include/linux"; \
+		if [ -f "$$IF_ALG_H" ]; then \
+		  mkdir -p "$$STAGEDIR_INCLUDE_LINUX"; \
+		  cp -pn "$$IF_ALG_H" "$$STAGEDIR_INCLUDE_LINUX"; \
+		fi; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread -lgpg-error -luuid -lblkid -ldl -lgcrypt -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-nls \
+		--disable-rpath \
+		--enable-cryptsetup-reencrypt \
+		--with-crypto_backend=gcrypt \
+		--enable-static-cryptsetup \
+		--with-libgcrypt-prefix=$(STAGEDIR)/usr )
+
+cryptsetup-gcrypt-stage: cryptsetup-gcrypt-configure
+	@echo cryptsetup-gcrypt
+	@[ ! -d cryptsetup-gcrypt ] || ( \
+		$(MAKE) -C cryptsetup-gcrypt $(PARALLEL_BUILD) && \
+		$(MAKE) -C cryptsetup-gcrypt install )
+
+cryptsetup-gcrypt-clean:
+	[ ! -f cryptsetup-gcrypt/Makefile ] || $(MAKE) -C cryptsetup-gcrypt clean
+	@rm -f cryptsetup-gcrypt/Makefile
+
+cryptsetup-gcrypt-install:
+	install -d $(INSTALLDIR)/cryptsetup-gcrypt/usr/lib/
+	install -d $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/
+	cp -df $(STAGEDIR)/usr/lib/libcryptsetup.so* $(INSTALLDIR)/cryptsetup-gcrypt/usr/lib/
+	chmod u+w $(INSTALLDIR)/cryptsetup-gcrypt/usr/lib/*
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup-reencrypt $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/veritysetup $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/
+	$(STRIP) $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/cryptsetup
+	$(STRIP) $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/cryptsetup-reencrypt
+	$(STRIP) $(INSTALLDIR)/cryptsetup-gcrypt/usr/bin/veritysetup
+	$(STRIP) $(INSTALLDIR)/cryptsetup-gcrypt/usr/lib/libcryptsetup.so*
+
+### cryptsetup-openssl
+
+cryptsetup-openssl: popt util-linux lvm2 openssl cryptsetup-openssl/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+cryptsetup-openssl/Makefile: cryptsetup-openssl-unpack cryptsetup-openssl/configure
+	@[ -f $@ ] || $(MAKE) cryptsetup-openssl-configure
+
+cryptsetup-openssl/configure:
+	@[ -f $@ ] || ( cd cryptsetup-openssl ; autoreconf -i -f )
+
+cryptsetup-openssl-configure:
+	@[ ! -d cryptsetup-openssl ] || [ -f "$(STAGEDIR)/usr/lib/libcryptsetup.so" ] || ( cd cryptsetup-openssl ; \
+		IF_ALG_H="$(BLACKFUEL_DIR)/packages/cryptsetup/linux/if_alg.h"; \
+		STAGEDIR_INCLUDE_LINUX="$(STAGEDIR)/usr/include/linux"; \
+		if [ -f "$$IF_ALG_H" ]; then \
+		  mkdir -p "$$STAGEDIR_INCLUDE_LINUX"; \
+		  cp -pn "$$IF_ALG_H" "$$STAGEDIR_INCLUDE_LINUX"; \
+		fi; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread -lssl -lcrypto -lz -luuid -lblkid -ldl -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-nls \
+		--disable-rpath \
+		--enable-cryptsetup-reencrypt \
+		--with-crypto_backend=openssl \
+		--enable-static-cryptsetup )
+
+cryptsetup-openssl-stage: cryptsetup-openssl-configure
+	@echo cryptsetup-openssl
+	@[ ! -d cryptsetup-openssl ] || ( \
+		$(MAKE) -C cryptsetup-openssl $(PARALLEL_BUILD) && \
+		$(MAKE) -C cryptsetup-openssl install )
+
+cryptsetup-openssl-clean:
+	[ ! -f cryptsetup-openssl/Makefile ] || $(MAKE) -C cryptsetup-openssl clean
+	@rm -f cryptsetup-openssl/Makefile
+
+cryptsetup-openssl-install:
+	install -d $(INSTALLDIR)/cryptsetup-openssl/usr/lib/
+	install -d $(INSTALLDIR)/cryptsetup-openssl/usr/bin/
+	cp -df $(STAGEDIR)/usr/lib/libcryptsetup.so* $(INSTALLDIR)/cryptsetup-openssl/usr/lib/
+	chmod u+w $(INSTALLDIR)/cryptsetup-openssl/usr/lib/*
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup $(INSTALLDIR)/cryptsetup-openssl/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup-reencrypt $(INSTALLDIR)/cryptsetup-openssl/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/veritysetup $(INSTALLDIR)/cryptsetup-openssl/usr/bin/
+	$(STRIP) $(INSTALLDIR)/cryptsetup-openssl/usr/bin/cryptsetup
+	$(STRIP) $(INSTALLDIR)/cryptsetup-openssl/usr/bin/cryptsetup-reencrypt
+	$(STRIP) $(INSTALLDIR)/cryptsetup-openssl/usr/bin/veritysetup
+	$(STRIP) $(INSTALLDIR)/cryptsetup-openssl/usr/lib/libcryptsetup.so*
+
+### cryptsetup-nettle
+
+cryptsetup-nettle: popt util-linux lvm2 nettle cryptsetup-nettle/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+cryptsetup-nettle/Makefile: cryptsetup-nettle-unpack cryptsetup-nettle/configure
+	@[ -f $@ ] || $(MAKE) cryptsetup-nettle-configure
+
+cryptsetup-nettle/configure:
+	@[ -f $@ ] || ( cd cryptsetup-nettle ; autoreconf -i -f )
+
+cryptsetup-nettle-configure:
+	@[ ! -d cryptsetup-nettle ] || [ -f "$(STAGEDIR)/usr/lib/libcryptsetup.so" ] || ( cd cryptsetup-nettle ; \
+		IF_ALG_H="$(BLACKFUEL_DIR)/packages/cryptsetup/linux/if_alg.h"; \
+		STAGEDIR_INCLUDE_LINUX="$(STAGEDIR)/usr/include/linux"; \
+		if [ -f "$$IF_ALG_H" ]; then \
+		  mkdir -p "$$STAGEDIR_INCLUDE_LINUX"; \
+		  cp -pn "$$IF_ALG_H" "$$STAGEDIR_INCLUDE_LINUX"; \
+		fi; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread -luuid -lblkid -ldl -lnettle -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-nls \
+		--disable-rpath \
+		--enable-cryptsetup-reencrypt \
+		--with-crypto_backend=nettle \
+		--enable-static-cryptsetup )
+
+cryptsetup-nettle-stage: cryptsetup-nettle-configure
+	@echo cryptsetup-nettle
+	@[ ! -d cryptsetup-nettle ] || ( \
+		$(MAKE) -C cryptsetup-nettle $(PARALLEL_BUILD) && \
+		$(MAKE) -C cryptsetup-nettle install )
+
+cryptsetup-nettle-clean:
+	[ ! -f cryptsetup-nettle/Makefile ] || $(MAKE) -C cryptsetup-nettle clean
+	@rm -f cryptsetup-nettle/Makefile
+
+cryptsetup-nettle-install:
+	install -d $(INSTALLDIR)/cryptsetup-nettle/usr/lib/
+	install -d $(INSTALLDIR)/cryptsetup-nettle/usr/bin/
+	cp -df $(STAGEDIR)/usr/lib/libcryptsetup.so* $(INSTALLDIR)/cryptsetup-nettle/usr/lib/
+	chmod u+w $(INSTALLDIR)/cryptsetup-nettle/usr/lib/*
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup $(INSTALLDIR)/cryptsetup-nettle/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup-reencrypt $(INSTALLDIR)/cryptsetup-nettle/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/veritysetup $(INSTALLDIR)/cryptsetup-nettle/usr/bin/
+	$(STRIP) $(INSTALLDIR)/cryptsetup-nettle/usr/bin/cryptsetup
+	$(STRIP) $(INSTALLDIR)/cryptsetup-nettle/usr/bin/cryptsetup-reencrypt
+	$(STRIP) $(INSTALLDIR)/cryptsetup-nettle/usr/bin/veritysetup
+	$(STRIP) $(INSTALLDIR)/cryptsetup-nettle/usr/lib/libcryptsetup.so*
+
+### cryptsetup-kernel
+
+cryptsetup-kernel: popt util-linux lvm2 cryptsetup-kernel/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+cryptsetup-kernel/Makefile: cryptsetup-kernel-unpack cryptsetup-kernel/configure
+	@[ -f $@ ] || $(MAKE) cryptsetup-kernel-configure
+
+cryptsetup-kernel/configure:
+	@[ -f $@ ] || ( cd cryptsetup-kernel ; autoreconf -i -f )
+
+cryptsetup-kernel-configure:
+	@[ ! -d cryptsetup-kernel ] || [ -f "$(STAGEDIR)/usr/lib/libcryptsetup.so" ] || ( cd cryptsetup-kernel ; \
+		IF_ALG_H="$(BLACKFUEL_DIR)/packages/cryptsetup/linux/if_alg.h"; \
+		STAGEDIR_INCLUDE_LINUX="$(STAGEDIR)/usr/include/linux"; \
+		if [ -f "$$IF_ALG_H" ]; then \
+		  mkdir -p "$$STAGEDIR_INCLUDE_LINUX"; \
+		  cp -pn "$$IF_ALG_H" "$$STAGEDIR_INCLUDE_LINUX"; \
+		fi; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread -luuid -lblkid -ldl -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-nls \
+		--disable-rpath \
+		--enable-cryptsetup-reencrypt \
+		--with-crypto_backend=kernel \
+		--enable-static-cryptsetup )
+
+cryptsetup-kernel-stage: cryptsetup-kernel-configure
+	@echo cryptsetup-kernel
+	@[ ! -d cryptsetup-kernel ] || ( \
+		$(MAKE) -C cryptsetup-kernel $(PARALLEL_BUILD) && \
+		$(MAKE) -C cryptsetup-kernel install )
+
+cryptsetup-kernel-clean:
+	[ ! -f cryptsetup-kernel/Makefile ] || $(MAKE) -C cryptsetup-kernel clean
+	@rm -f cryptsetup-kernel/Makefile
+
+cryptsetup-kernel-install:
+	install -d $(INSTALLDIR)/cryptsetup-kernel/usr/lib/
+	install -d $(INSTALLDIR)/cryptsetup-kernel/usr/bin/
+	cp -df $(STAGEDIR)/usr/lib/libcryptsetup.so* $(INSTALLDIR)/cryptsetup-kernel/usr/lib/
+	chmod u+w $(INSTALLDIR)/cryptsetup-kernel/usr/lib/*
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup $(INSTALLDIR)/cryptsetup-kernel/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/cryptsetup-reencrypt $(INSTALLDIR)/cryptsetup-kernel/usr/bin/
+	install -D $(STAGEDIR)/usr/sbin/veritysetup $(INSTALLDIR)/cryptsetup-kernel/usr/bin/
+	$(STRIP) $(INSTALLDIR)/cryptsetup-kernel/usr/bin/cryptsetup
+	$(STRIP) $(INSTALLDIR)/cryptsetup-kernel/usr/bin/cryptsetup-reencrypt
+	$(STRIP) $(INSTALLDIR)/cryptsetup-kernel/usr/bin/veritysetup
+	$(STRIP) $(INSTALLDIR)/cryptsetup-kernel/usr/lib/libcryptsetup.so*
+
+### pps-tools
+
+pps-tools: pps-tools-unpack
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+pps-tools-stage:
+	@echo pps-tools
+	@[ ! -d pps-tools ] || [ -f "$(STAGEDIR)/usr/bin/ppsctl" ] || ( cd pps-tools ; \
+		CC="arm-brcm-linux-uclibcgnueabi-gcc" \
+		CFLAGS="$(CFLAGS) -DN_PPS=18 -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		DESTDIR="$(STAGEDIR)" \
+		$(MAKE) install && \
+		[ -f "$(STAGEDIR)/usr/include/timepps.h" ] || \
+		[ ! -f "$(STAGEDIR)/usr/include/sys/timepps.h" ] || \
+		cp -p "$(STAGEDIR)/usr/include/sys/timepps.h" "$(STAGEDIR)/usr/include" )
+
+pps-tools-clean:
+	-@$(MAKE) -C pps-tools clean
+
+pps-tools-install:
+	install -d $(INSTALLDIR)/pps-tools/usr/bin/
+	install -d $(INSTALLDIR)/pps-tools/usr/sbin/
+	install -D $(STAGEDIR)/usr/bin/ppsctl $(INSTALLDIR)/pps-tools/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ppstest $(INSTALLDIR)/pps-tools/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ppswatch $(INSTALLDIR)/pps-tools/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ppsldisc $(INSTALLDIR)/pps-tools/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ppsfind $(INSTALLDIR)/pps-tools/usr/sbin/
+	$(STRIP) $(INSTALLDIR)/pps-tools/usr/bin/ppsctl
+	$(STRIP) $(INSTALLDIR)/pps-tools/usr/bin/ppstest
+	$(STRIP) $(INSTALLDIR)/pps-tools/usr/bin/ppswatch
+	$(STRIP) $(INSTALLDIR)/pps-tools/usr/bin/ppsldisc
+
+### setserial
+
+setserial: setserial/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+setserial/Makefile: setserial-unpack setserial/configure
+	@[ -f $@ ] || $(MAKE) setserial-configure
+
+setserial/configure:
+	@[ -f $@ ] || ( cd setserial ; autoreconf -i -f )
+
+setserial-configure:
+	@[ ! -d setserial ] || [ -f "$(STAGEDIR)/usr/bin/setserial" ] || ( cd setserial ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CC="arm-brcm-linux-uclibcgnueabi-gcc" \
+		STRIP="arm-brcm-linux-uclibcgnueabi-strip" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--host=arm-linux \
+		--build=x86_64-linux \
+		--prefix="$(STAGEDIR)/usr" \
+		--mandir="$(STAGEDIR)/usr/share/man" )
+
+setserial-stage:
+	@echo setserial
+	@[ ! -d setserial ] || ( \
+		$(MAKE) -C setserial $(PARALLEL_BUILD) && \
+		mkdir -p "$(STAGEDIR)/temp_setserial/bin" "$(STAGEDIR)/temp_setserial/usr/man/man8" && \
+		DESTDIR="$(STAGEDIR)/temp_setserial" $(MAKE) -C setserial install && \
+		mkdir -p "$(STAGEDIR)/usr/bin" "$(STAGEDIR)/usr/share/man/man8" && \
+		mv "$(STAGEDIR)/temp_setserial/bin/setserial" "$(STAGEDIR)/usr/bin/" && \
+		mv "$(STAGEDIR)/temp_setserial/usr/man/man8/setserial.8" "$(STAGEDIR)/usr/share/man/man8/" && \
+		rm -rf "$(STAGEDIR)/temp_setserial" )
+
+setserial-clean:
+	[ ! -f setserial/Makefile ] || $(MAKE) -C setserial clean
+	@rm -f setserial/Makefile
+
+setserial-install:
+	install -d $(INSTALLDIR)/setserial/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/setserial $(INSTALLDIR)/setserial/usr/bin/
+	$(STRIP) $(INSTALLDIR)/setserial/usr/bin/setserial
+
+### ntp
+
+ntp: pps-tools setserial util-linux openssl libcap ntp/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+ntp/Makefile: ntp-unpack ntp/configure
+	@[ -f $@ ] || $(MAKE) ntp-configure
+
+ntp/configure:
+	@[ -f $@ ] || ( cd ntp ; autoreconf -i -f )
+
+ntp-configure:
+	@[ ! -d ntp ] || [ -f "$(STAGEDIR)/usr/bin/ntpd" ] || ( cd ntp ; \
+		if [ ! -f "$(STAGEDIR)/usr/include/timepps.h" ]; then \
+			echo "timepps.h is not installed.  Verify that pps-tools was installed properly."; \
+			false; \
+		else \
+			PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+			CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+			CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+			LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+			LIBS="-lpthread" \
+			ac_cv_header_md5_h=no ac_cv_lib_rt_sched_setscheduler=no ac_cv_header_dns_sd_h=no hw_cv_func_snprintf_c99=yes hw_cv_func_vsnprintf_c99=yes ac_cv_make_ntptime=yes \
+			$(CONFIGURE) \
+			--prefix="$(STAGEDIR)/usr" \
+			--enable-static \
+			--enable-shared \
+			--enable-local-libopts \
+			--enable-local-libevent \
+			--enable-accurate-adjtime \
+			--without-ntpsnmpd \
+			--without-lineeditlibs \
+			--enable-linuxcaps \
+			--with-crypto \
+			--with-openssl-libdir="$(STAGEDIR)/etc/lib" \
+			--with-openssl-incdir="$(STAGEDIR)/etc/include" \
+			--enable-autokey \
+			--enable-openssl-random \
+			--enable-thread-support \
+			--with-threads \
+			--with-yielding-select=yes \
+			--without-rpath \
+			--disable-silent-rules \
+			--disable-all-clocks \
+			--disable-parse-clocks \
+			--enable-NMEA \
+			--enable-ATOM \
+			--enable-LOCAL-CLOCK \
+			--enable-SHM \
+			--enable-WWV \
+			--enable-GPSD; \
+		fi )
+
+ntp-stage:
+	@echo ntp
+	@[ ! -d ntp ] || ( \
+		$(MAKE) -C ntp $(PARALLEL_BUILD) && \
+		$(MAKE) -C ntp install )
+
+ntp-clean:
+	[ ! -f ntp/Makefile ] || $(MAKE) -C ntp clean
+	@rm -f ntp/Makefile
+
+ntp-install:
+	install -d $(INSTALLDIR)/ntp/usr/bin/
+	install -d $(INSTALLDIR)/ntp/usr/sbin/
+	install -D $(STAGEDIR)/usr/bin/ntpd $(INSTALLDIR)/ntp/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ntpdate $(INSTALLDIR)/ntp/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ntpdc $(INSTALLDIR)/ntp/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ntp-keygen $(INSTALLDIR)/ntp/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ntpq $(INSTALLDIR)/ntp/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ntptime $(INSTALLDIR)/ntp/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/ntptrace $(INSTALLDIR)/ntp/usr/sbin/
+	install -D $(STAGEDIR)/usr/bin/ntp-wait $(INSTALLDIR)/ntp/usr/sbin/
+	$(STRIP) $(INSTALLDIR)/ntp/usr/bin/ntpd
+	$(STRIP) $(INSTALLDIR)/ntp/usr/bin/ntpdate
+	$(STRIP) $(INSTALLDIR)/ntp/usr/bin/ntpdc
+	$(STRIP) $(INSTALLDIR)/ntp/usr/bin/ntp-keygen
+	$(STRIP) $(INSTALLDIR)/ntp/usr/bin/ntpq
+	$(STRIP) $(INSTALLDIR)/ntp/usr/bin/ntptime
+
+### libcap
+
+libcap: libcap-unpack
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libcap-stage:
+	@echo libcap
+	@[ ! -d libcap ] || [ -f "$(STAGEDIR)/usr/lib/libcap.so" ] || ( cd libcap ; \
+		$(MAKE) install \
+		DESTDIR="$(STAGEDIR)/usr" \
+		prefix="" \
+		CC="arm-brcm-linux-uclibcgnueabi-gcc" \
+		AR="arm-brcm-linux-uclibcgnueabi-ar" \
+		RANLIB="arm-brcm-linux-uclibcgnueabi-ranlib" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$$PWD/libcap/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(LIBS_DL) $(LIBS_DL) -L$(LIBS_PTHREAD) $(LIBS_PTHREAD) -L$(LIBS_M) $(LIBS_M) -L$(LIBS_RT) $(LIBS_RT) -L$(LIBS_C) $(LIBS_C) -L$(STAGEDIR)/usr/lib" \
+		BUILD_CC="gcc" \
+		BUILD_CFLAGS="-I$$PWD/libcap/include" \
+		INDENT="| true" \
+		PAM_CAP="no" \
+		RAISE_SETFCAP="no" \
+		DYNAMIC="yes" \
+		lib="lib" )
+
+libcap-clean:
+	-@$(MAKE) -C libcap clean
+
+libcap-install:
+	install -d $(INSTALLDIR)/libcap/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libcap.so* $(INSTALLDIR)/libcap/usr/lib/
+	chmod u+w $(INSTALLDIR)/libcap/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/libcap/usr/lib/libcap.so*
+
+### rtl-sdr
+
+rtl-sdr: libusb10 rtl-sdr/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+rtl-sdr/Makefile: rtl-sdr-unpack rtl-sdr/configure
+	@[ -f $@ ] || $(MAKE) rtl-sdr-configure
+
+rtl-sdr/configure:
+	@[ -f $@ ] || ( cd rtl-sdr ; autoreconf -i -f )
+
+rtl-sdr-configure:
+	@[ ! -d rtl-sdr ] || [ -f "$(STAGEDIR)/usr/lib/librtlsdr.a" ] || ( cd rtl-sdr ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(CXXFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib/libusb-1.0.a $(STAGEDIR)/usr/lib/libusb-1.0.a -L$(LIBS_DL) $(LIBS_DL) -L$(LIBS_PTHREAD) $(LIBS_PTHREAD) -L$(LIBS_M) $(LIBS_M) -L$(LIBS_RT) $(LIBS_RT) -L$(LIBS_C) $(LIBS_C) -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-static \
+		--disable-shared \
+		--disable-silent-rules \
+		--enable-driver-detach )
+
+rtl-sdr-stage:
+	@echo rtl-sdr
+	@[ ! -d rtl-sdr ] || ( \
+		$(MAKE) -C rtl-sdr $(PARALLEL_BUILD) && \
+		$(MAKE) -C rtl-sdr install )
+
+rtl-sdr-clean:
+	[ ! -f rtl-sdr/Makefile ] || $(MAKE) -C rtl-sdr clean
+	@rm -f rtl-sdr/Makefile
+
+rtl-sdr-install:
+	@echo "rtl-sdr is static library, nothing to install"
+
+### rtl-entropy
+
+rtl-entropy: libcap rtl-sdr openssl rtl-entropy/build/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+rtl-entropy/build/Makefile: rtl-entropy-unpack
+	@[ -f $@ ] || ( cd rtl-entropy ; \
+		rm -rf build ; mkdir -p build ; cd build ; \
+		STATIC_LIBS_RTLENTROPY="-L$(STAGEDIR)/usr/lib/libcap.a $(STAGEDIR)/usr/lib/libcap.a -L$(STAGEDIR)/usr/lib/librtlsdr.a $(STAGEDIR)/usr/lib/librtlsdr.a -L$(STAGEDIR)/usr/lib/libusb-1.0.a $(STAGEDIR)/usr/lib/libusb-1.0.a  -L$(STAGEDIR)/etc/lib/libssl.a $(STAGEDIR)/etc/lib/libssl.a  -L$(STAGEDIR)/etc/lib/libcrypto.a $(STAGEDIR)/etc/lib/libcrypto.a -L$(LIBS_DL) $(LIBS_DL) -L$(LIBS_PTHREAD) $(LIBS_PTHREAD) -L$(LIBS_M) $(LIBS_M) -L$(LIBS_RT) $(LIBS_RT) -L$(LIBS_C) $(LIBS_C) -L$(STAGEDIR)/usr/lib -L$(STAGEDIR)/etc/lib"; \
+		ARM_COMPILER_FLAGS="-ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99"; \
+		ARM_LINKER_FLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections $$STATIC_LIBS_RTLENTROPY"; \
+		ARM_LINK_EXECUTABLE="arm-brcm-linux-uclibcgnueabi-gcc  -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -O3 -DNDEBUG  -ffunction-sections -fdata-sections -Wl,--gc-sections CMakeFiles/rtlentropylib.dir/fips.c.o CMakeFiles/rtlentropylib.dir/log.c.o CMakeFiles/rtlentropylib.dir/util.c.o CMakeFiles/rtl_entropy.dir/rtl_entropy.c.o  -o rtl_entropy -rdynamic $$STATIC_LIBS_RTLENTROPY"; \
+		cmake \
+		-DCMAKE_SYSTEM_NAME="Linux" \
+		-DCMAKE_SYSTEM_VERSION="2.6.36.4brcmarm" \
+		-DCMAKE_SYSTEM_VERSION="arm" \
+		-DCMAKE_FIND_ROOT_PATH="$(STAGEDIR)/usr" \
+		-DCMAKE_INSTALL_PREFIX="$(STAGEDIR)/usr" \
+		-DCMAKE_PREFIX_PATH="$(STAGEDIR)/usr" \
+		-DOPENSSL_LIBRARIES="$(STAGEDIR)/etc/lib" \
+		-DOPENSSL_INCLUDE_DIRS="$(STAGEDIR)/etc/include" \
+		-DCMAKE_C_COMPILER="/opt/brcm-arm/bin/arm-brcm-linux-uclibcgnueabi-gcc" \
+		-DCMAKE_CXX_COMPILER="/opt/brcm-arm/bin/arm-brcm-linux-uclibcgnueabi-g++" \
+		-DCMAKE_AR="/opt/brcm-arm/bin/arm-brcm-linux-uclibcgnueabi-ar" \
+		-DCMAKE_RANLIB="/opt/brcm-arm/bin/arm-brcm-linux-uclibcgnueabi-ranlib" \
+		-DCMAKE_STRIP="/opt/brcm-arm/bin/arm-brcm-linux-uclibcgnueabi-strip" \
+		-DCMAKE_C_FLAGS="$$ARM_COMPILER_FLAGS" \
+		-DCMAKE_SHARED_LINKER_FLAGS="$$ARM_LINKER_FLAGS" \
+		-DCMAKE_EXE_LINKER_FLAGS="$$ARM_LINKER_FLAGS" \
+		-DCMAKE_C_LINK_EXECUTABLE="$$ARM_LINK_EXECUTABLE" \
+		-DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
+		-DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
+		-DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
+		-DCMAKE_FIND_ROOT_PATH_MODE_PACKAGE=ONLY \
+		-DCMAKE_VERBOSE_MAKEFILE=TRUE \
+		../ )
+
+rtl-entropy-stage:
+	@echo rtl-entropy
+	@[ ! -f rtl-entropy/build/Makefile ] || [ -f "$(STAGEDIR)/usr/bin/rtl_entropy" ] || ( \
+		$(MAKE) -C rtl-entropy/build $(PARALLEL_BUILD) && \
+		$(MAKE) -C rtl-entropy/build install )
+
+rtl-entropy-clean:
+	[ ! -f rtl-entropy/build/Makefile ] || $(MAKE) -C rtl-entropy/build clean
+	@rm -rf rtl-entropy/build
+
+rtl-entropy-install:
+	install -d $(INSTALLDIR)/rtl-entropy/usr/bin/
+	install -D $(STAGEDIR)/usr/bin/rtl_entropy $(INSTALLDIR)/rtl-entropy/usr/bin/
+	$(STRIP) $(INSTALLDIR)/rtl-entropy/usr/bin/rtl_entropy
+
+### transmission-openssl
+
+transmission-openssl: openssl curl zlib libevent-2.0.21 transmission-openssl/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+transmission-openssl/Makefile: transmission-openssl-unpack
+	@[ -f $@ ] || $(MAKE) transmission-openssl-configure
+
+transmission-openssl-configure:
+	@[ ! -d transmission-openssl ] || [ -f "$(STAGEDIR)/usr/bin/transmission-daemon" ] || ( \
+		cd transmission-openssl ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig:$(STAGEDIR)/etc/lib/pkgconfig" \
+		DESTDIR="$(STAGEDIR)" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/etc/include -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(CXXFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/etc/include -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/etc/lib -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread" \
+		OPENSSL_CFLAGS="-I$(STAGEDIR)/etc/include" \
+		OPENSSL_LIBS="-L$(STAGEDIR)/etc/lib -lcrypto -lssl" \
+		CRYPTO_CFLAGS="-I$(STAGEDIR)/etc/include" \
+		CRYPTO_LIBS="-L$(STAGEDIR)/etc/lib -lcrypto -lssl" \
+		LIBCURL_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		LIBCURL_LIBS="-L$(STAGEDIR)/usr/lib -lcurl" \
+		LIBEVENT_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		LIBEVENT_LIBS="-L$(STAGEDIR)/usr/lib -levent" \
+		ZLIB_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		ZLIB_LIBS="-L$(STAGEDIR)/usr/lib -lz" \
+		./autogen.sh \
+		--host=arm-brcm-linux-uclibcgnueabi \
+		--build=x86_64-linux-gnu \
+		--prefix=/usr \
+		--disable-nls \
+		--disable-silent-rules \
+		--enable-daemon \
+		--enable-cli \
+		--without-gtk \
+		--enable-largefile \
+		--enable-lightweight \
+		--with-crypto=openssl \
+		)
+
+transmission-openssl-stage:
+	@echo transmission-openssl
+	@[ ! -d transmission-openssl ] || ( \
+		$(MAKE) -C transmission-openssl $(PARALLEL_BUILD) && \
+		$(MAKE) -C transmission-openssl DESTDIR="$(STAGEDIR)" install )
+
+transmission-openssl-clean:
+	[ ! -f transmission-openssl/Makefile ] || $(MAKE) -C transmission-openssl distclean
+	@rm -f transmission-openssl/Makefile
+
+transmission-openssl-install:
+	install -d $(INSTALLDIR)/transmission-openssl/usr/bin/
+	install -d $(INSTALLDIR)/transmission-openssl/usr/share/
+	install -D $(STAGEDIR)/usr/bin/transmission-daemon $(INSTALLDIR)/transmission-openssl/usr/bin/Transmission-daemon
+	install -D $(STAGEDIR)/usr/bin/transmission-remote $(INSTALLDIR)/transmission-openssl/usr/bin/Transmission-remote
+	#install -D $(STAGEDIR)/usr/bin/transmission-cli $(INSTALLDIR)/transmission-openssl/usr/bin/Transmission-cli
+	#install -D $(STAGEDIR)/usr/bin/transmission-create $(INSTALLDIR)/transmission-openssl/usr/bin/Transmission-create
+	#install -D $(STAGEDIR)/usr/bin/transmission-edit $(INSTALLDIR)/transmission-openssl/usr/bin/Transmission-edit
+	#install -D $(STAGEDIR)/usr/bin/transmission-show $(INSTALLDIR)/transmission-openssl/usr/bin/Transmission-show
+	cp -af $(STAGEDIR)/usr/share/transmission $(INSTALLDIR)/transmission-openssl/usr/share/
+	$(STRIP) $(INSTALLDIR)/transmission-openssl/usr/bin/*
+
+### transmission-mbedtls
+
+transmission-mbedtls: mbedtls curl zlib libevent-2.0.21 transmission-mbedtls/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+transmission-mbedtls/Makefile: transmission-mbedtls-unpack
+	@[ -f $@ ] || $(MAKE) transmission-mbedtls-configure
+
+transmission-mbedtls-configure:
+	@[ ! -d transmission-mbedtls ] || [ -f "$(STAGEDIR)/usr/bin/transmission-daemon" ] || ( \
+		cd transmission-mbedtls ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		DESTDIR="$(STAGEDIR)" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(CXXFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread" \
+		MBEDTLS_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		MBEDTLS_LIBS="-L$(STAGEDIR)/usr/lib -lmbedtls" \
+		LIBCURL_CFLAGS="-I$(STAGEDIR)/etc/include -I$(STAGEDIR)/usr/include" \
+		LIBCURL_LIBS="-L$(STAGEDIR)/etc/lib -L$(STAGEDIR)/usr/lib -lcrypto -lssl -lcurl" \
+		LIBEVENT_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		LIBEVENT_LIBS="-L$(STAGEDIR)/usr/lib -levent" \
+		ZLIB_CFLAGS="-I$(STAGEDIR)/usr/include" \
+		ZLIB_LIBS="-L$(STAGEDIR)/usr/lib -lz" \
+		./autogen.sh \
+		--host=arm-brcm-linux-uclibcgnueabi \
+		--build=x86_64-linux-gnu \
+		--prefix=/usr \
+		--disable-nls \
+		--disable-silent-rules \
+		--enable-daemon \
+		--enable-cli \
+		--without-gtk \
+		--enable-largefile \
+		--enable-lightweight \
+		--with-crypto=polarssl \
+		)
+
+transmission-mbedtls-stage:
+	@echo transmission-mbedtls
+	@[ ! -d transmission-mbedtls ] || ( \
+		$(MAKE) -C transmission-mbedtls $(PARALLEL_BUILD) && \
+		$(MAKE) -C transmission-mbedtls DESTDIR="$(STAGEDIR)" install )
+
+transmission-mbedtls-clean:
+	[ ! -f transmission-mbedtls/Makefile ] || $(MAKE) -C transmission-mbedtls distclean
+	@rm -f transmission-mbedtls/Makefile
+
+transmission-mbedtls-install:
+	install -d $(INSTALLDIR)/transmission-mbedtls/usr/bin/
+	install -d $(INSTALLDIR)/transmission-mbedtls/usr/share/
+	install -D $(STAGEDIR)/usr/bin/transmission-daemon $(INSTALLDIR)/transmission-mbedtls/usr/bin/Transmission-daemon
+	install -D $(STAGEDIR)/usr/bin/transmission-remote $(INSTALLDIR)/transmission-mbedtls/usr/bin/Transmission-remote
+	#install -D $(STAGEDIR)/usr/bin/transmission-cli $(INSTALLDIR)/transmission-mbedtls/usr/bin/Transmission-cli
+	#install -D $(STAGEDIR)/usr/bin/transmission-create $(INSTALLDIR)/transmission-mbedtls/usr/bin/Transmission-create
+	#install -D $(STAGEDIR)/usr/bin/transmission-edit $(INSTALLDIR)/transmission-mbedtls/usr/bin/Transmission-edit
+	#install -D $(STAGEDIR)/usr/bin/transmission-show $(INSTALLDIR)/transmission-mbedtls/usr/bin/Transmission-show
+	cp -af $(STAGEDIR)/usr/share/transmission $(INSTALLDIR)/transmission-mbedtls/usr/share/
+	$(STRIP) $(INSTALLDIR)/transmission-mbedtls/usr/bin/*
+
+### mbedtls
+
+mbedtls: mbedtls/build/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+mbedtls/build/Makefile: mbedtls-unpack
+	@[ -f $@ ] || ( cd mbedtls ; \
+		rm -rf build ; mkdir -p build ; cd build ; \
+		ARM_COMPILER_FLAGS="-ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99"; \
+		ARM_LINKER_FLAGS="-ffunction-sections -fdata-sections -Wl,--gc-sections"; \
+		cmake \
+		-DCMAKE_SYSTEM_NAME="Linux" \
+		-DCMAKE_SYSTEM_VERSION="2.6.36.4brcmarm" \
+		-DCMAKE_SYSTEM_VERSION="arm" \
+		-DCMAKE_FIND_ROOT_PATH="$(STAGEDIR)/usr" \
+		-DCMAKE_INSTALL_PREFIX="$(STAGEDIR)/usr" \
+		-DCMAKE_PREFIX_PATH="$(STAGEDIR)/usr" \
+		-DCMAKE_C_COMPILER="/opt/brcm-arm/bin/arm-brcm-linux-uclibcgnueabi-gcc" \
+		-DCMAKE_CXX_COMPILER="/opt/brcm-arm/bin/arm-brcm-linux-uclibcgnueabi-g++" \
+		-DCMAKE_AR="/opt/brcm-arm/bin/arm-brcm-linux-uclibcgnueabi-ar" \
+		-DCMAKE_RANLIB="/opt/brcm-arm/bin/arm-brcm-linux-uclibcgnueabi-ranlib" \
+		-DCMAKE_STRIP="/opt/brcm-arm/bin/arm-brcm-linux-uclibcgnueabi-strip" \
+		-DCMAKE_C_FLAGS="$$ARM_COMPILER_FLAGS" \
+		-DCMAKE_SHARED_LINKER_FLAGS="$$ARM_LINKER_FLAGS" \
+		-DCMAKE_EXE_LINKER_FLAGS="$$ARM_LINKER_FLAGS" \
+		-DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
+		-DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
+		-DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
+		-DCMAKE_FIND_ROOT_PATH_MODE_PACKAGE=ONLY \
+		-DCMAKE_VERBOSE_MAKEFILE=TRUE \
+		-DCMAKE_BUILD_TYPE:String="Release" \
+		-DUSE_SHARED_MBEDTLS_LIBRARY:Bool=ON \
+		-DENABLE_TESTING:Bool=OFF \
+		-DENABLE_PROGRAMS:Bool=OFF \
+		../ )
+
+mbedtls-stage:
+	@echo mbedtls
+	@[ ! -f mbedtls/build/Makefile ] || [ -f "$(STAGEDIR)/usr/lib/libmbedtls.so" ] || ( \
+		$(MAKE) -C mbedtls/build $(PARALLEL_BUILD) && \
+		$(MAKE) -C mbedtls/build install )
+
+mbedtls-clean:
+	[ ! -f mbedtls/build/Makefile ] || $(MAKE) -C mbedtls/build clean
+	@rm -rf mbedtls/build
+
+mbedtls-install:
+	install -d $(INSTALLDIR)/mbedtls/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libmbed*.so* $(INSTALLDIR)/mbedtls/usr/lib/
+	chmod u+w $(INSTALLDIR)/mbedtls/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/mbedtls/usr/lib/libmbed*.so*
+
+### apcupsd
+
+apcupsd: libusb-0.1.12 libgd apcupsd/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+apcupsd/Makefile: apcupsd-unpack
+	@[ -f $@ ] || $(MAKE) apcupsd-configure
+
+apcupsd-configure:
+	@[ ! -d apcupsd ] || [ -f "$(STAGEDIR)/usr/sbin/apcupsd" ] || \
+		(cd apcupsd ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		DESTDIR="$(STAGEDIR)" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(TOP)/libusb-0.1.12 -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(CXXFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE -I$(TOP)/libusb-0.1.12 -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(TOP)/libusb-0.1.12/.libs -L$(STAGEDIR)/usr/lib" \
+		LIBS="-lpthread -lusb -ljpeg -lpng -ltiff -lfreetype -lgd" \
+		$(CONFIGURE) \
+		--prefix=/usr \
+		--sbindir=/usr/sbin \
+		--sysconfdir=/usr/local/etc/apcupsd \
+		--with-cgi-bin=/usr/local/etc/apcupsd \
+		--datarootdir=/usr/share \
+		--with-distname=asuswrt \
+		--with-upstype=usb \
+		--with-upscable=usb \
+		--without-serial-dev \
+		--enable-apcsmart \
+		--enable-dumb \
+		--enable-test \
+		$(if $(RTCONFIG_APCUPSD_CGI),--enable-cgi,--disable-cgi) \
+		--enable-usb \
+		--enable-modbus \
+		--enable-modbus-usb \
+		--without-x)
+
+apcupsd-stage: apcupsd-configure
+	@echo apcupsd
+	@[ ! -d apcupsd ] || ( \
+		$(MAKE) -C apcupsd $(PARALLEL_BUILD) && \
+		$(MAKE) -C apcupsd DESTDIR="$(STAGEDIR)" STRIP='' install )
+
+apcupsd-clean:
+	[ ! -f apcupsd/Makefile ] || $(MAKE) -C apcupsd distclean
+	@rm -f apcupsd/Makefile
+
+apcupsd-install:
+	install -d $(INSTALLDIR)/apcupsd/usr/sbin/
+	install -D $(STAGEDIR)/usr/sbin/apcupsd $(INSTALLDIR)/apcupsd/usr/sbin/
+	install -D $(STAGEDIR)/usr/sbin/smtp $(INSTALLDIR)/apcupsd/usr/sbin/
+	install -D $(STAGEDIR)/usr/sbin/apctest $(INSTALLDIR)/apcupsd/usr/sbin/
+	install -D $(STAGEDIR)/usr/sbin/apcaccess $(INSTALLDIR)/apcupsd/usr/sbin/
+	$(STRIP) $(INSTALLDIR)/apcupsd/usr/sbin/*
+	install -d $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/apcupsd.conf $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/apcupsd_mail.conf $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/changeme $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/commfailure $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/commok $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/offbattery $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/onbattery $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(BLACKFUEL_DIR)/packages/apcupsd/files/apccontrol $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+ifeq ($(RTCONFIG_APCUPSD_CGI),y)
+	install -d $(INSTALLDIR)/apcupsd/www/cgi-bin/apcupsd
+	cp -pf $(STAGEDIR)/usr/local/etc/apcupsd/*.cgi $(INSTALLDIR)/apcupsd/www/cgi-bin/apcupsd/
+	install -D $(STAGEDIR)/usr/local/etc/apcupsd/apcupsd.css $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(STAGEDIR)/usr/local/etc/apcupsd/hosts.conf $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+	install -D $(STAGEDIR)/usr/local/etc/apcupsd/multimon.conf $(INSTALLDIR)/apcupsd/usr/local/etc/apcupsd/
+endif
+
+### libgd
+
+libgd: jpeg libpng libtiff freetype libgd/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libgd/Makefile: libgd-unpack
+	@[ -f $@ ] || $(MAKE) libgd-configure
+
+libgd-configure:
+	@[ ! -d libgd ] || [ -f "$(STAGEDIR)/usr/lib/libgd.so" ] || ( \
+		cd libgd ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include -I$(STAGEDIR)/usr/include/freetype2" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include -I$(STAGEDIR)/usr/include/freetype2" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="-ljpeg -lpng -ltiff -lfreetype" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-rpath \
+		--without-x \
+		--without-fontconfig \
+		--with-jpeg \
+		--with-png \
+		--with-tiff \
+		--with-freetype \
+		--without-xpm \
+		)
+
+libgd-stage:
+	@echo libgd
+	@[ ! -d libgd ] || ( \
+		$(MAKE) -C libgd $(PARALLEL_BUILD) && \
+		$(MAKE) -C libgd install )
+
+libgd-clean:
+	[ ! -f libgd/Makefile ] || $(MAKE) -C libgd distclean
+	@rm -f libgd/Makefile
+
+libgd-install:
+	install -d $(INSTALLDIR)/libgd/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libgd.so* $(INSTALLDIR)/libgd/usr/lib/
+	chmod u+w $(INSTALLDIR)/libgd/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/libgd/usr/lib/libgd.so*
+
+### jpeg
+
+jpeg: jpeg/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+jpeg/Makefile: jpeg-unpack
+	@[ -f $@ ] || $(MAKE) jpeg-configure
+
+jpeg-configure:
+	@[ ! -d jpeg ] || [ -f "$(STAGEDIR)/usr/lib/libjpeg.so" ] || ( \
+		cd jpeg ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(CXXFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-silent-rules \
+		--enable-maxmem=1 \
+		)
+
+jpeg-stage:
+	@echo jpeg
+	@[ ! -d jpeg ] || ( \
+		$(MAKE) -C jpeg $(PARALLEL_BUILD) && \
+		$(MAKE) -C jpeg install )
+
+jpeg-clean:
+	[ ! -f jpeg/Makefile ] || $(MAKE) -C jpeg distclean
+	@rm -f jpeg/Makefile
+
+jpeg-install:
+	install -d $(INSTALLDIR)/jpeg/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libjpeg.so* $(INSTALLDIR)/jpeg/usr/lib/
+	chmod u+w $(INSTALLDIR)/jpeg/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/jpeg/usr/lib/*
+
+### libpng
+
+libpng: libpng/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libpng/Makefile: libpng-unpack
+	@[ -f $@ ] || $(MAKE) libpng-configure
+
+libpng-configure:
+	@[ ! -d libpng ] || [ -f "$(STAGEDIR)/usr/lib/libpng.so" ] || ( \
+		cd libpng ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(CXXFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-silent-rules \
+		)
+
+libpng-stage:
+	@echo libpng
+	@[ ! -d libpng ] || ( \
+		$(MAKE) -C libpng $(PARALLEL_BUILD) && \
+		$(MAKE) -C libpng install )
+
+libpng-clean:
+	[ ! -f libpng/Makefile ] || $(MAKE) -C libpng distclean
+	@rm -f libpng/Makefile
+
+libpng-install:
+	install -d $(INSTALLDIR)/libpng/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libpng.so* $(INSTALLDIR)/libpng/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libpng16.so* $(INSTALLDIR)/libpng/usr/lib/
+	chmod u+w $(INSTALLDIR)/libpng/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/libpng/usr/lib/*
+
+### libtiff
+
+libtiff: libtiff/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+libtiff/Makefile: libtiff-unpack
+	@[ -f $@ ] || $(MAKE) libtiff-configure
+
+libtiff-configure:
+	@[ ! -d libtiff ] || [ -f "$(STAGEDIR)/usr/lib/libtiff.so" ] || ( \
+		cd libtiff ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		CXXFLAGS="$(CXXFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		LIBS="" \
+		$(CONFIGURE) \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--disable-silent-rules \
+		--enable-cxx \
+		--disable-lzma \
+		--enable-ccitt \
+		--enable-packbits \
+		--enable-lzw \
+		--enable-thunder \
+		--enable-next \
+		--enable-logluv \
+		--enable-mdi \
+		--enable-zlib \
+		--enable-jpeg \
+		--disable-old-jpeg \
+		--disable-jbig \
+		--without-x \
+		)
+
+libtiff-stage:
+	@echo libtiff
+	@[ ! -d libtiff ] || ( \
+		$(MAKE) -C libtiff $(PARALLEL_BUILD) && \
+		$(MAKE) -C libtiff install )
+
+libtiff-clean:
+	[ ! -f libtiff/Makefile ] || $(MAKE) -C libtiff distclean
+	@rm -f libtiff/Makefile
+
+libtiff-install:
+	install -d $(INSTALLDIR)/libtiff/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libtiff.so* $(INSTALLDIR)/libtiff/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libtiffxx.so* $(INSTALLDIR)/libtiff/usr/lib/
+	chmod u+w $(INSTALLDIR)/libtiff/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/libtiff/usr/lib/*
+
+### freetype
+
+freetype: zlib bzip2 freetype/Makefile
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+freetype/Makefile: freetype-unpack
+	@[ -f $@ ] || $(MAKE) freetype-configure
+
+freetype-configure:
+	@[ ! -d freetype ] || [ -f "$(STAGEDIR)/usr/lib/libfreetype.so" ] || ( \
+		cd freetype ; \
+		PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		$(CONFIGURE) \
+		--host=arm-brcm-linux-uclibcgnueabi \
+		--build='' \
+		--prefix="$(STAGEDIR)/usr" \
+		--enable-shared \
+		--enable-static \
+		--with-bzip2=yes \
+		--with-zlib=yes \
+		--with-png=no \
+		)
+
+freetype-stage: freetype-configure
+	@echo freetype
+	@[ ! -d freetype ] || [ -f "$(STAGEDIR)/usr/lib/libfreetype.so" ] || ( \
+		$(MAKE) -C freetype $(PARALLEL_BUILD) && \
+		$(MAKE) -C freetype install )
+
+freetype-clean:
+	[ ! -f freetype/Makefile ] || $(MAKE) -C freetype distclean
+	@rm -f freetype/Makefile
+
+freetype-install:
+	install -d $(INSTALLDIR)/freetype/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libfreetype.so* $(INSTALLDIR)/freetype/usr/lib/
+	chmod u+w $(INSTALLDIR)/freetype/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/freetype/usr/lib/*
+
+### bzip2
+
+bzip2: bzip2-unpack
+	@[ ! -d $@ ] || ( $(SEP); $(MAKE) $@-stage )
+
+bzip2-stage:
+	@echo bzip2
+	@[ ! -d bzip2 ] || [ -f "$(STAGEDIR)/usr/lib/libbz2.a" ] || ( cd bzip2 ; \
+		$(MAKE) $(PARALLEL_BUILD) \
+		PREFIX="$(STAGEDIR)/usr" \
+		CC="arm-brcm-linux-uclibcgnueabi-gcc" \
+		AR="arm-brcm-linux-uclibcgnueabi-ar" \
+		RANLIB="arm-brcm-linux-uclibcgnueabi-ranlib" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		install ; \
+		$(MAKE) $(PARALLEL_BUILD) -f Makefile-libbz2_so \
+		PREFIX="$(STAGEDIR)/usr" \
+		CC="arm-brcm-linux-uclibcgnueabi-gcc" \
+		AR="arm-brcm-linux-uclibcgnueabi-ar" \
+		RANLIB="arm-brcm-linux-uclibcgnueabi-ranlib" \
+		CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -D_GNU_SOURCE -I$(STAGEDIR)/usr/include" \
+		LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+		all ; \
+		cp -df libbz2.so* $(STAGEDIR)/usr/lib/ \
+		)
+
+bzip2-clean:
+	-@$(MAKE) -C bzip2 clean
+
+bzip2-install:
+	install -d $(INSTALLDIR)/bzip2/usr/lib/
+	cp -df $(STAGEDIR)/usr/lib/libbz2.so* $(INSTALLDIR)/bzip2/usr/lib/
+	chmod u+w $(INSTALLDIR)/bzip2/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/bzip2/usr/lib/*
+
+
+### package download and patches
+
+%-unpack:
+	PACKAGE_DIR="$*"; \
+	if [ ! -d "$$PACKAGE_DIR" ]; then \
+		PACKAGE_NAME="$$PACKAGE_DIR"; \
+		if [ "$$PACKAGE_DIR" = "xzutils" ]; then \
+			URL="https://tukaani.org/xz/xz-5.2.3.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "zstd" ]; then \
+			URL="https://github.com/facebook/zstd/archive/v1.3.2.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "tor" ]; then \
+			URL="https://www.torproject.org/dist/tor-0.3.1.8.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "nettle" ]; then \
+			URL="https://ftp.gnu.org/gnu/nettle/nettle-3.3.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "curl" ]; then \
+			URL="https://github.com/curl/curl/releases/download/curl-7_56_1/curl-7.56.1.tar.xz"; \
+		elif [ "$$PACKAGE_DIR" = "findutils" ]; then \
+			URL="https://ftp.gnu.org/pub/gnu/findutils/findutils-4.6.0.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "whois" ]; then \
+			URL="http://ftp.debian.org/debian/pool/main/w/whois/whois_5.2.18.tar.xz"; \
+		elif [ "$$PACKAGE_DIR" = "libsodium" ]; then \
+			URL="https://download.libsodium.org/libsodium/releases/libsodium-1.0.15.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "dnscrypt" ]; then \
+			URL="https://download.dnscrypt.org/dnscrypt-proxy/dnscrypt-proxy-1.9.5.tar.bz2"; \
+		elif [ "$$PACKAGE_DIR" = "haveged" ]; then \
+			URL="http://www.issihosts.com/haveged/haveged-1.9.1.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "wipe" ]; then \
+			URL="https://downloads.sourceforge.net/project/wipe/wipe/2.3.1/wipe-2.3.1.tar.bz2"; \
+		elif [ "$$PACKAGE_DIR" = "gsl" ]; then \
+			URL="https://ftp.heanet.ie/mirrors/gnu/gsl/gsl-2.4.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "dieharder" ]; then \
+			URL="http://www.phy.duke.edu/~rgb/General/dieharder/dieharder-3.31.1.tgz"; \
+		elif [ "$$PACKAGE_DIR" = "popt" ]; then \
+			URL="http://rpm5.org/files/popt/popt-1.16.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "libgpg-error" ]; then \
+			URL="https://gnupg.org/ftp/gcrypt/libgpg-error/libgpg-error-1.27.tar.bz2"; \
+		elif [ "$$PACKAGE_DIR" = "util-linux" ]; then \
+			URL="https://www.kernel.org/pub/linux/utils/util-linux/v2.31/util-linux-2.31.tar.xz"; \
+		elif [ "$$PACKAGE_DIR" = "lvm2" ]; then \
+			URL="https://mirrors.kernel.org/sourceware/lvm2/LVM2.2.02.176.tgz"; \
+		elif [ "$$PACKAGE_DIR" = "libgcrypt" ]; then \
+			URL="https://gnupg.org/ftp/gcrypt/libgcrypt/libgcrypt-1.8.1.tar.bz2"; \
+		elif [ "$$PACKAGE_DIR" = "cryptsetup-gcrypt" ] || \
+			[ "$$PACKAGE_DIR" = "cryptsetup-openssl" ] || \
+			[ "$$PACKAGE_DIR" = "cryptsetup-nettle" ] || \
+			[ "$$PACKAGE_DIR" = "cryptsetup-kernel" ]; then \
+			URL="https://www.kernel.org/pub/linux/utils/cryptsetup/v1.7/cryptsetup-1.7.5.tar.xz"; \
+			PACKAGE_NAME="cryptsetup"; \
+		elif [ "$$PACKAGE_DIR" = "pps-tools" ]; then \
+			URL="https://github.com/redlab-i/pps-tools/archive/v1.0.1.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "setserial" ]; then \
+			URL="https://downloads.sourceforge.net/project/setserial/setserial/2.17/setserial-2.17.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "ntp" ]; then \
+			URL="https://www.eecis.udel.edu/~ntp/ntp_spool/ntp4/ntp-4.2/ntp-4.2.8p10.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "argp-standalone" ]; then \
+			URL="https://www.lysator.liu.se/~nisse/misc/argp-standalone-1.3.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "rng-tools" ]; then \
+			URL="https://downloads.sourceforge.net/project/gkernel/rng-tools/5/rng-tools-5.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "libcap" ]; then \
+			URL="https://www.kernel.org/pub/linux/libs/security/linux-privs/libcap2/libcap-2.25.tar.xz"; \
+		elif [ "$$PACKAGE_DIR" = "rtl-sdr" ]; then \
+			URL="git://git.osmocom.org/rtl-sdr.git"; \
+			VERSION="b04c2f9f035c5aede43d731e5d58e4725d2f8bb4"; \
+		elif [ "$$PACKAGE_DIR" = "rtl-entropy" ]; then \
+			URL="git://github.com/pwarren/rtl-entropy.git"; \
+			VERSION="142df23630ea6216c17e00dada85d1cd245bc22f"; \
+		elif [ "$$PACKAGE_DIR" = "ncurses" ]; then \
+			URL="https://ftp.gnu.org/gnu/ncurses/ncurses-6.0.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "transmission-openssl" ] || \
+			[ "$$PACKAGE_DIR" = "transmission-mbedtls" ]; then \
+			URL="git://github.com/transmission/transmission.git"; \
+			VERSION="35fea28d1a37875ef7480ac061754df617805b19"; \
+			PACKAGE_NAME="transmission"; \
+		elif [ "$$PACKAGE_DIR" = "mbedtls" ]; then \
+			URL="https://tls.mbed.org/download/mbedtls-2.6.0-gpl.tgz"; \
+		elif [ "$$PACKAGE_DIR" = "wget" ]; then \
+			URL="https://ftp.gnu.org/gnu/wget/wget-1.19.2.tar.lz"; \
+		elif [ "$$PACKAGE_DIR" = "apcupsd" ]; then \
+			URL="https://downloads.sourceforge.net/project/apcupsd/apcupsd - Stable/3.14.14/apcupsd-3.14.14.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "libgd" ]; then \
+			URL="https://github.com/libgd/libgd/releases/download/gd-2.2.5/libgd-2.2.5.tar.xz"; \
+		elif [ "$$PACKAGE_DIR" = "jpeg" ]; then \
+			URL="http://www.ijg.org/files/jpegsrc.v9a.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "libpng" ]; then \
+			URL="https://sourceforge.net/projects/libpng/files/libpng16/1.6.34/libpng-1.6.34.tar.xz"; \
+		elif [ "$$PACKAGE_DIR" = "libtiff" ]; then \
+			URL="http://download.osgeo.org/libtiff/tiff-4.0.8.tar.gz"; \
+		elif [ "$$PACKAGE_DIR" = "freetype" ]; then \
+			URL="https://sourceforge.net/projects/freetype/files/freetype2/2.8.1/freetype-2.8.1.tar.bz2"; \
+		elif [ "$$PACKAGE_DIR" = "bzip2" ]; then \
+			URL="http://www.bzip.org/1.0.6/bzip2-1.0.6.tar.gz"; \
+		else \
+			URL="/$$PACKAGE_DIR-MISSING-URL"; \
+		fi; \
+		DL_DIR="$(BLACKFUEL_DIR)/downloads/$$PACKAGE_NAME"; \
+		PATCH_DIR="$(BLACKFUEL_DIR)/packages/$$PACKAGE_NAME/patches"; \
+		DL_FILE="$${URL##*/}"; \
+		DL_PATH="$$DL_DIR/$$DL_FILE"; \
+		if [ "$${DL_FILE%.git*}" != "$$DL_FILE" ]; then \
+			DL_NAME="$$PACKAGE_NAME"; \
+			[ -z "$$VERSION" ] && VERSION="master"; \
+			DL_FILE="$${DL_NAME}-$${VERSION}.tar.gz"; \
+			DL_PATH="$$DL_DIR/$$DL_FILE"; \
+			if [ ! -f "$$DL_PATH" ]; then \
+				git clone $$URL $$DL_DIR/temp/$$DL_NAME; \
+				while [ $$? -ne 0 ]; do \
+					sleep 10; git clone $$URL $$DL_DIR/temp/$$DL_NAME; \
+				done; \
+				ORIGDIR=$$PWD; \
+				cd $$DL_DIR/temp/$$DL_NAME; \
+				git checkout $$VERSION; \
+				while [ $$? -ne 0 ]; do \
+					sleep 10; git checkout $$VERSION; \
+				done; \
+				git submodule update --init --recursive; \
+				while [ $$? -ne 0 ]; do \
+					sleep 10; git submodule update --init --recursive; \
+				done; \
+				cd $$ORIGDIR; \
+				tar czvf $$DL_PATH -C $$DL_DIR/temp $$DL_NAME; \
+			fi; \
+		elif [ ! -f "$$DL_PATH" ]; then \
+			wget --tries=9999 --retry-connrefused --waitretry=5 --directory-prefix="$$DL_DIR" "$$URL"; \
+			while [ $$? -ne 0 ]; do \
+				sleep 10; \
+				[ ! -f "$$DL_PATH" ] || break; \
+				wget --tries=9999 --retry-connrefused --waitretry=5 --directory-prefix="$$DL_DIR" "$$URL"; \
+			done; \
+			rm -rf "$$PACKAGE_DIR" || true; \
+		fi; \
+		rm -rf "$$DL_DIR/temp"; \
+		mkdir -p "$$DL_DIR/temp"; \
+		if [ "$${DL_FILE%.tar.gz*}" != "$$DL_FILE" ] || [ "$${DL_FILE%.tgz*}" != "$$DL_FILE" ]; then \
+			tar xzvf "$$DL_PATH" -C "$$DL_DIR/temp"; \
+		elif [ "$${DL_FILE%.tar.bz2*}" != "$$DL_FILE" ]; then \
+			tar xjvf "$$DL_PATH" -C "$$DL_DIR/temp"; \
+		elif [ "$${DL_FILE%.tar.xz*}" != "$$DL_FILE" ]; then \
+			tar xJvf "$$DL_PATH" -C "$$DL_DIR/temp"; \
+		elif [ "$${DL_FILE%.tar.lz*}" != "$$DL_FILE" ]; then \
+			tar xlvf "$$DL_PATH" -C "$$DL_DIR/temp"; \
+		fi; \
+		mv -f "$$DL_DIR/temp/"* "$$PACKAGE_DIR"; \
+		rm -rf "$$DL_DIR/temp"; \
+		for PATCH_FILE in $$PATCH_DIR/*.patch; do \
+			if [ -f "$$PATCH_FILE" ]; then \
+				echo "Applying patch: $$PATCH_FILE"; \
+				patch --dry-run --silent -p1 -d "$$PACKAGE_DIR/" -i "$$PATCH_FILE" >/dev/null 2>&1 && \
+					patch -p1 -d "$$PACKAGE_DIR/" -i "$$PATCH_FILE" || \
+					  	echo "The patch was not applied."; \
+			else \
+				true; \
+			fi; \
+		done; \
+	else \
+		echo "$$PACKAGE_DIR was not unpacked because the directory exists."; \
+		true; \
+	fi
+
+#######################################################################################
+
+tor: openssl zlib libevent-2.0.21 zstd tor/Makefile
 	@$(SEP)
 	$(MAKE) -C $@ $(PARALLEL_BUILD)
 
-tor/Makefile:
-	(cd tor ; $(CONFIGURE) --enable-static-libevent --with-libevent-dir=$(STAGEDIR)/usr \
+tor/Makefile: tor-unpack
+	(cd tor ; PKG_CONFIG_PATH="$(STAGEDIR)/usr/lib/pkgconfig" \
+	          CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+	          CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include" \
+	          LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
+                  $(CONFIGURE) --enable-static-libevent --with-libevent-dir=$(STAGEDIR)/usr \
 					--with-openssl-dir=$(TOP)/openssl \
 					--with-zlib-dir=$(TOP)/zlib \
 					--disable-asciidoc --disable-unittests \
-					--disable-tool-name-check)
+					--disable-tool-name-check \
+					--enable-lzma --enable-zstd)
 
 tor-install:
 	install -D tor/src/or/tor $(INSTALLDIR)/tor/usr/sbin/Tor
 	$(STRIP) $(INSTALLDIR)/tor/usr/sbin/Tor
+	install -D tor/src/tools/tor-gencert $(INSTALLDIR)/tor/usr/sbin/Tor-gencert
+	$(STRIP) $(INSTALLDIR)/tor/usr/sbin/Tor-gencert
+	install -D tor/src/tools/tor-resolve $(INSTALLDIR)/tor/usr/sbin/Tor-resolve
+	$(STRIP) $(INSTALLDIR)/tor/usr/sbin/Tor-resolve
+	install -Dpv tor/src/config/geoip $(INSTALLDIR)/tor/rom/tor/geoip
+	install -Dpv tor/src/config/geoip6 $(INSTALLDIR)/tor/rom/tor/geoip6
 
 tor-clean:
 	[ ! -f tor/Makefile ] || $(MAKE) -C tor clean
@@ -3053,24 +5193,24 @@
 	$(STRIP) $(INSTALLDIR)/flac/usr/lib/libFLAC.so.8
 endif
 
-jpeg/stamp-h1:
-	cd jpeg && \
-	CFLAGS="-Os $(EXTRACFLAGS) -fPIC" CC=$(CC) AR2="touch" $(CONFIGURE) --enable-maxmem=1 --enable-shared --enable-static --prefix=''
-	touch $@
-
-jpeg: jpeg/stamp-h1
-	@$(MAKE) -C jpeg LIBTOOL="" O=o A=a CC=$(CC) AR2="touch" libjpeg.a libjpeg.so $(PARALLEL_BUILD)
-
-jpeg-clean:
-	-@$(MAKE) -C jpeg clean
-	@rm -f jpeg/stamp-h1
-
-jpeg-install:
-	@$(SEP)
-ifneq ($(MEDIA_SERVER_STATIC),y)
-	install -D jpeg/libjpeg.so $(INSTALLDIR)/jpeg/usr/lib/libjpeg.so
-	$(STRIP) $(INSTALLDIR)/jpeg/usr/lib/libjpeg.so
-endif
+#jpeg/stamp-h1:
+#	cd jpeg && \
+#	CFLAGS="-Os $(EXTRACFLAGS) -fPIC" CC=$(CC) AR2="touch" $(CONFIGURE) --enable-maxmem=1 --enable-shared --enable-static --prefix=''
+#	touch $@
+#
+#jpeg: jpeg/stamp-h1
+#	@$(MAKE) -C jpeg LIBTOOL="" O=o A=a CC=$(CC) AR2="touch" libjpeg.a libjpeg.so $(PARALLEL_BUILD)
+#
+#jpeg-clean:
+#	-@$(MAKE) -C jpeg clean
+#	@rm -f jpeg/stamp-h1
+#
+#jpeg-install:
+#	@$(SEP)
+#ifneq ($(MEDIA_SERVER_STATIC),y)
+#	install -D jpeg/libjpeg.so $(INSTALLDIR)/jpeg/usr/lib/libjpeg.so
+#	$(STRIP) $(INSTALLDIR)/jpeg/usr/lib/libjpeg.so
+#endif
 
 libexif/stamp-h1:
 	cd libexif && CFLAGS="-Os -Wall $(EXTRACFLAGS) -fPIC -ffunction-sections -fdata-sections" \
@@ -3978,23 +6118,34 @@
 curl: curl/Makefile
 	@$(MAKE) -C $@ $(PARALLEL_BUILD) && $(MAKE) $@-stage
 
-curl/Makefile: curl/configure
-	@cd curl && $(CONFIGURE) CC=$(CC) \
-		CFLAGS="-Os -Wall -ffunction-sections -fdata-sections" \
-		--prefix=/usr --bindir=/usr/sbin --libdir=/usr/lib \
-		--enable-http --with-ssl=$(TOP)/openssl/ssl \
-		$(if $(RTCONFIG_IPV6),--enable-ipv6) \
-		--disable-gopher --disable-dict --disable-telnet \
-		--disable-proxy --disable-manual --disable-libcurl-option \
-		CPPFLAGS='-I$(TOP)/openssl/include' \
-		LDFLAGS='$(LDFLAGS) -L$(TOP)/openssl' LIBS='-lcrypto -lssl -ldl' \
-		--with-ca-bundle=/etc/ssl/certs/ca-certificates.crt
+curl/Makefile: curl-unpack curl/configure
+	@cd curl && \
+	$(CONFIGURE) \
+	CC=$(CC) \
+	CFLAGS="$(CFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include -I$(TOP)/openssl/include" \
+	CXXFLAGS="$(CXXFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -I$(STAGEDIR)/usr/include -I$(TOP)/openssl/include" \
+	CPPFLAGS="$(CPPFLAGS) -ffunction-sections -fdata-sections -O3 -pipe -march=armv7-a -mtune=cortex-a9 -fno-caller-saves -mfloat-abi=soft -Wall -fPIC -std=gnu99 -I$(STAGEDIR)/usr/include -I$(TOP)/openssl/include" \
+	LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib -L$(TOP)/openssl" \
+	LIBS="-lcrypto -lssl -ldl" \
+	--prefix=/usr \
+	--bindir=/usr/sbin \
+	--libdir=/usr/lib \
+	--enable-http \
+	--with-ssl=$(TOP)/openssl \
+	$(if $(RTCONFIG_IPV6),--enable-ipv6) \
+	--disable-gopher \
+	--disable-dict \
+	--disable-telnet \
+	--disable-manual \
+	--disable-libcurl-option \
+	--with-ca-bundle=/etc/ssl/certs/ca-certificates.crt
 
 curl-install:
 	@$(SEP)
-	install -D curl/lib/.libs/libcurl.so.4.4.0 $(INSTALLDIR)/curl/usr/lib/libcurl.so.4.4.0
-	$(STRIP) $(INSTALLDIR)/curl/usr/lib/libcurl.so.4.4.0
-	cd $(INSTALLDIR)/curl/usr/lib && ln -sf libcurl.so.4.4.0 libcurl.so && ln -sf libcurl.so.4.4.0 libcurl.so.4
+	install -d $(INSTALLDIR)/curl/usr/lib/
+	cp -df curl/lib/.libs/libcurl.so* $(INSTALLDIR)/curl/usr/lib/
+	chmod u+w $(INSTALLDIR)/curl/usr/lib/*
+	$(STRIP) $(INSTALLDIR)/curl/usr/lib/libcurl.so*
 #ifeq ($(RTCONFIG_SPEEDTEST),y)
 	# for speedtest
 	install -D curl/src/.libs/curl $(INSTALLDIR)/curl/usr/sbin/curl
@@ -4410,21 +6561,29 @@
 	$(STRIP) $(INSTALLDIR)/ipset/usr/sbin/ipset
 
 ncurses/Makefile:
-	cd ncurses && CFLAGS="$(EXTRACFLAGS) -Os -I$(STAGEDIR)/usr/include -ffunction-sections -fdata-sections -fPIC" \
-	$(CONFIGURE) --prefix=/usr --without-cxx --without-cxx-binding \
-	LDFLAGS="$(LDFLAGS) -ffunction-sections -fdata-sections -Wl,--gc-sections -L$(STAGEDIR)/usr/lib" \
-	--enable-echo --enable-const --enable-overwrite --disable-rpath --without-ada \
+	cd ncurses && \
+	PKG_CONFIG_PATH="/usr/lib/pkgconfig" \
+	CFLAGS="$(CFLAGS) $(EXTRACFLAGS) -Os -I$(STAGEDIR)/usr/include" \
+	CXXFLAGS="$(CXXFLAGS) $(EXTRACFLAGS) -Os -I$(STAGEDIR)/usr/include" \
+	CPPFLAGS="$(CPPFLAGS) $(EXTRACFLAGS) -Os -I$(STAGEDIR)/usr/include" \
+	LDFLAGS="$(LDFLAGS) -L$(STAGEDIR)/usr/lib" \
+	$(CONFIGURE) \
+	--prefix=/usr \
+	--enable-echo --enable-const --disable-overwrite --disable-rpath --without-ada \
 	$(if $(RTCONFIG_BCMARM),--enable-widec,) \
-	--without-debug --without-manpages --without-profile --without-progs --without-tests \
+	--without-debug --without-manpages --without-profile --without-tests \
 	--disable-home-terminfo --with-normal --with-shared --with-build-cppflags=-D_GNU_SOURCE \
-	--enable-pc-files \
-	--disable-termcap --disable-database --with-fallbacks="xterm,vt100,vt200,linux,ansi,xterm-256color"
-
-#	--with-default-terminfo-dir=/usr/share/terminfo --with-terminfo-dirs=/usr/share/terminfo
-
-ncurses: ncurses/Makefile
-	@$(SEP)
-	cd ncurses && $(MAKE) -C ncurses && $(MAKE) -C misc pc-files
+	--enable-pc-files --with-pkg-config="/usr/lib/pkgconfig" \
+	--enable-termcap --with-fallbacks="xterm,vt100,vt200,linux,ansi,xterm-256color" \
+	--with-default-terminfo-dir=/usr/share/terminfo --with-terminfo-dirs=/usr/share/terminfo \
+	--with-install-prefix="$(STAGEDIR)" --with-pkg-config-libdir="/usr/lib/pkgconfig"
+
+ncurses: ncurses-unpack ncurses/Makefile
+	@$(SEP)
+#	cd ncurses && $(MAKE) -C ncurses && $(MAKE) -C misc pc-files && $(MAKE) install DESTDIR="$(STAGEDIR)"
+	cd ncurses && \
+	$(MAKE) DESTDIR="$(STAGEDIR)" && \
+	$(MAKE) install DESTDIR="$(STAGEDIR)"
 
 ncurses-clean:
 	-@$(MAKE) -C ncurses distclean
@@ -4449,7 +6608,7 @@
 nano/Makefile:
 	cd nano && \
 	autoreconf -i -f && $(CONFIGURE) --prefix=$(INSTALLDIR)/nano/usr \
-		CFLAGS="$(EXTRACFLAGS) -Os -I$(TOP)/ncurses/include -ffunction-sections -fdata-sections" \
+		CFLAGS="$(EXTRACFLAGS) -Os -I$(TOP)/ncurses/include -I$(STAGEDIR)/usr/include -ffunction-sections -fdata-sections" \
 		LDFLAGS="$(LDFLAGS) -L$(TOP)/ncurses/lib -ffunction-sections -fdata-sections -Wl,--gc-sections" \
 		PKG_CONFIG_LIBDIR="$(TOP)/ncurses/misc" PKG_CONFIG_PATH="$(TOP)/ncurses/misc" \
 		$(if $(RTCONFIG_BCMARM),ac_cv_lib_ncursesw_get_wch=yes,ac_cv_lib_ncursesw_get_wch=no) \
@@ -4892,29 +7051,29 @@
 	-@[ ! -f GeoIP-1.6.2/Makefile ] || $(MAKE) -C GeoIP-1.6.2 distclean
 	@rm -f GeoIP-1.6.2/stamp-h1
 
-Transmission-configure:
-	( cd Transmission && ./autogen.sh && \
-		$(CONFIGURE) --prefix=/usr --bindir=/usr/sbin --libdir=/usr/lib \
-			CFLAGS="$(CFLAGS) -I$(STAGEDIR)/usr/include" \
-			LDFLAGS="$(LDFLAGS) -L$(STAGEDIR)/usr/lib" \
-			--disable-nls --disable-gtk \
-	)
-
-Transmission/Makefile:
-	$(MAKE) Transmission-configure
-
-Transmission: curl libevent-2.0.21 Transmission/Makefile
-	@$(SEP)
-	$(MAKE) -C $@
-
-Transmission-install: Transmission
-	install -D $</daemon/transmission-daemon $(INSTALLDIR)/$</usr/sbin/transmission-daemon
-	install -D $</daemon/transmission-remote $(INSTALLDIR)/$</usr/sbin/transmission-remote
-	$(STRIP) $(INSTALLDIR)/$</usr/sbin/*
-
-Transmission-clean:
-	[ ! -f Transmission/Makefile ] || $(MAKE) -C distclean
-	@rm -f Transmission/Makefile
+#Transmission-configure:
+#	( cd Transmission && ./autogen.sh && \
+#		$(CONFIGURE) --prefix=/usr --bindir=/usr/sbin --libdir=/usr/lib \
+#			CFLAGS="$(CFLAGS) -I$(STAGEDIR)/usr/include" \
+#			LDFLAGS="$(LDFLAGS) -L$(STAGEDIR)/usr/lib" \
+#			--disable-nls --disable-gtk \
+#	)
+#
+#Transmission/Makefile:
+#	$(MAKE) Transmission-configure
+#
+#Transmission: curl libevent-2.0.21 Transmission/Makefile
+#	@$(SEP)
+#	$(MAKE) -C $@
+#
+#Transmission-install: Transmission
+#	install -D $</daemon/transmission-daemon $(INSTALLDIR)/$</usr/sbin/transmission-daemon
+#	install -D $</daemon/transmission-remote $(INSTALLDIR)/$</usr/sbin/transmission-remote
+#	$(STRIP) $(INSTALLDIR)/$</usr/sbin/*
+#
+#Transmission-clean:
+#	[ ! -f Transmission/Makefile ] || $(MAKE) -C distclean
+#	@rm -f Transmission/Makefile
 
 wget/Makefile.in: wget/Makefile.am
 	cd wget && autoreconf -fi
--- a/release/src/router/rc/Makefile
+++ b/release/src/router/rc/Makefile
@@ -708,10 +708,12 @@
 ate-broadcom.o:
 	@-cp -f ./prebuild/ate-broadcom.o .
 endif
+ifeq ($(BUILD_NAME), RT-AC5300)
 ifneq ($(wildcard ./prebuild/ate.o),)
 ate.o:
 	@-cp -f ./prebuild/ate.o .
 endif
+endif
 ifeq ($(BUILD_NAME), RT-AC68U)
 ifneq ($(wildcard ./prebuild/cfe.o),)
 cfe.o:
@@ -754,12 +756,12 @@
 endif
 endif
 
-ifeq ($(and $(CONFIG_BCMWL5),$(RTCONFIG_DUALWAN)),y)
-ifneq ($(wildcard ./prebuild/dualwan.o),)
-dualwan.o:
-	@-cp -f ./prebuild/dualwan.o .
-endif
-endif
+#ifeq ($(and $(CONFIG_BCMWL5),$(RTCONFIG_DUALWAN)),y)
+#ifneq ($(wildcard ./prebuild/dualwan.o),)
+#dualwan.o:
+#	@-cp -f ./prebuild/dualwan.o .
+#endif
+#endif
 
 %.o: %.c
 	@echo " [rc] CC $@"
--- a/release/src/router/rc/openvpn.c
+++ b/release/src/router/rc/openvpn.c
@@ -1488,11 +1488,11 @@
 		fprintf(fp, "#!/bin/sh\n");
 		sprintf(&buffer[0], "vpn_server%d_proto", serverNum);
 		strncpy(&buffer[0], nvram_safe_get(&buffer[0]), BUF_SIZE);
-		fprintf(fp, "iptables -t nat -I PREROUTING -p %s ", strtok(&buffer[0], "-"));
-		sprintf(&buffer[0], "vpn_server%d_port", serverNum);
-		fprintf(fp, "--dport %d -j ACCEPT\n", nvram_get_int(&buffer[0]));
-		sprintf(&buffer[0], "vpn_server%d_proto", serverNum);
-		strncpy(&buffer[0], nvram_safe_get(&buffer[0]), BUF_SIZE);
+//		fprintf(fp, "iptables -t nat -I PREROUTING -p %s ", strtok(&buffer[0], "-"));
+//		sprintf(&buffer[0], "vpn_server%d_port", serverNum);
+//		fprintf(fp, "--dport %d -j ACCEPT\n", nvram_get_int(&buffer[0]));
+//		sprintf(&buffer[0], "vpn_server%d_proto", serverNum);
+//		strncpy(&buffer[0], nvram_safe_get(&buffer[0]), BUF_SIZE);
 		fprintf(fp, "iptables -I INPUT -p %s ", strtok(&buffer[0], "-"));
 		sprintf(&buffer[0], "vpn_server%d_port", serverNum);
 		fprintf(fp, "--dport %d -j ACCEPT\n", nvram_get_int(&buffer[0]));
--- a/release/src/router/rc/services.c
+++ b/release/src/router/rc/services.c
@@ -9901,12 +9901,11 @@
 	remove("/tmp/torlog");
 
 #if (defined(RTCONFIG_JFFS2)||defined(RTCONFIG_BRCM_NAND_JFFS2))
-	if (f_exists("/tmp/.tordb/cached-microdesc-consensus") &&
-	    !f_exists("/jffs/.tordb/cached-microdesc-consensus"))
-	{
-		//logmessage("Tor", "Backing up database");
-		eval("cp", "-fa", "/tmp/.tordb", "/jffs/.tordb");
-	}
+	//logmessage("Tor", "Backing up database");
+	eval("/bin/sh", "-c", 	"if [ -d /tmp/.tordb ] ; then "
+				"  mkdir -p /jffs/.tordb ; "
+				"  cp -afu /tmp/.tordb/* /jffs/.tordb/ ;"
+				"fi");
 #endif
 }
 
@@ -9930,22 +9929,6 @@
 	if ((fp = fopen("/tmp/torrc", "w")) == NULL)
 		return;
 
-#if (defined(RTCONFIG_JFFS2)||defined(RTCONFIG_BRCM_NAND_JFFS2))
-	if (stat("/jffs/.tordb/cached-microdesc-consensus", &mdstat_jffs) != -1) {
-		if(difftime(time(NULL), mdstat_jffs.st_mtime) > 60*60*24*7) {
-			logmessage("Tor", "Removing stale DB backup");
-			eval("rm", "-rf", "/jffs/.tordb");
-		} else if (!f_exists("/tmp/.tordb/cached-microdesc-consensus")) {
-			_dprintf("Tor: restore microdescriptor directory\n");
-			pw = getpwuid(mdstat_jffs.st_uid);
-			if ((pw) && (strcmp(pw->pw_name, "tor"))){
-				eval("chown", "-R", "tor.tor","/jffs/.tordb");
-			}
-			eval("cp", "-fa", "/jffs/.tordb", "/tmp/.tordb");
-			sleep(1);
-		}
-	}
-#endif
 	if ((Socksport = nvram_get("Tor_socksport")) == NULL)	Socksport = "9050";
 	if ((Transport = nvram_get("Tor_transport")) == NULL)   Transport = "9040";
 	if ((Dnsport = nvram_get("Tor_dnsport")) == NULL)   	Dnsport = "9053";
@@ -9966,6 +9949,18 @@
 	use_custom_config("torrc", "/tmp/torrc");
 	run_postconf("torrc", "/tmp/torrc");
 
+#if (defined(RTCONFIG_JFFS2)||defined(RTCONFIG_BRCM_NAND_JFFS2))
+	//logmessage("Tor", "Restoring database");
+	eval("/bin/sh", "-c", 	"mkdir -p /tmp/.tordb ; "
+				"cp -afu /jffs/.tordb/* /tmp/.tordb/ ; "
+				"chown tor:tor /tmp/.tordb ; "
+				"chown -h tor:tor /tmp/.tordb ; "
+				"chown -R tor:tor /tmp/.tordb/* ; "
+				"chmod u=rwx,g-rwx,o-rwx /tmp/.tordb ; "
+				"chmod -R u+rw,g-rwx,o-rwx /tmp/.tordb/*");
+	sleep(1);
+#endif
+
 	_eval(Tor_argv, NULL, 0, &pid);
 }
 #endif
--- a/release/src/router/rc/wan.c
+++ b/release/src/router/rc/wan.c
@@ -3346,8 +3346,16 @@
 #endif
 
 #if LINUX_KERNEL_VERSION >= KERNEL_VERSION(2,6,36)
-	f_write_string("/proc/sys/net/bridge/bridge-nf-call-iptables", "0", 0, 0);
-	f_write_string("/proc/sys/net/bridge/bridge-nf-call-ip6tables", "0", 0, 0);
+	#ifdef RTCONFIG_BCMARM
+		// for ARM platform, we have enabled BRIDGE_NETFILTER and the default behaviour
+		// is to pass bridged IPv4 & IPv6 traffic to iptables' chains
+		f_write_string("/proc/sys/net/bridge/bridge-nf-call-iptables", "1", 0, 0);
+		f_write_string("/proc/sys/net/bridge/bridge-nf-call-ip6tables", "1", 0, 0);
+	#else
+		// for MIPS platform, the BRIDGE_NETFILTER feature is not yet enabled
+		f_write_string("/proc/sys/net/bridge/bridge-nf-call-iptables", "0", 0, 0);
+		f_write_string("/proc/sys/net/bridge/bridge-nf-call-ip6tables", "0", 0, 0);
+	#endif
 #endif
 
 	/* Report stats */
--- a/release/src/router/shared/misc.c
+++ b/release/src/router/shared/misc.c
@@ -2009,7 +2009,7 @@
 }
 #endif
 
-#ifdef RTCONFIG_BWDPI
+//#ifdef RTCONFIG_BWDPI
 /*
 	usage in rc or bwdpi for checking service
 */
@@ -2042,7 +2042,7 @@
 
 	return enabled;
 }
-#endif
+//#endif
 
 /*
 	transfer timestamp into date
--- a/release/src/router/shared/notify_rc.c
+++ b/release/src/router/shared/notify_rc.c
@@ -0,0 +1,164 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+ * This is the implementation of a routine to notify the rc driver that it
+ * should take some action.
+ *
+ * Copyright 2004, ASUSTeK Inc.
+ * All Rights Reserved.
+ *
+ * This is UNPUBLISHED PROPRIETARY SOURCE CODE of ASUSTeK Inc.;
+ * the contents of this file may not be disclosed to third parties, copied
+ * or duplicated in any form, in whole or in part, without the prior
+ * written permission of ASUSTeK Inc..
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/types.h>
+#include <signal.h>
+#include <unistd.h>
+#include <typedefs.h>
+#include <bcmnvram.h>
+#include "shutils.h"
+#include "shared.h"
+#include "notify_rc.h"
+
+static int notify_rc_internal(const char *event_name, bool do_wait, int wait);
+
+int notify_rc(const char *event_name)
+{
+	return notify_rc_internal(event_name, FALSE, 15);
+}
+
+int notify_rc_after_wait(const char *event_name)
+{
+	return notify_rc_internal(event_name, FALSE, 30);
+}
+
+int notify_rc_after_period_wait(const char *event_name, int wait)
+{
+	return notify_rc_internal(event_name, FALSE, wait);
+}
+
+int notify_rc_and_wait(const char *event_name)
+{
+	return notify_rc_internal(event_name, TRUE, 10);
+}
+
+int notify_rc_and_wait_1min(const char *event_name)
+{
+	return notify_rc_internal(event_name, TRUE, 60);
+}
+
+int notify_rc_and_wait_2min(const char *event_name)
+{
+	return notify_rc_internal(event_name, TRUE, 120);
+}
+
+int notify_rc_and_period_wait(const char *event_name, int wait)
+{
+	return notify_rc_internal(event_name, TRUE, wait);
+}
+
+/*
+ * int wait_rc_service(int wait)
+ * wait: seconds to wait and check
+ *
+ * @return:
+ * 0: no  right
+ * 1: get right
+ */
+int wait_rc_service(int wait)
+{
+	int i=wait;
+	int first_try = 1;
+	char p1[16];
+
+	psname(nvram_get_int("rc_service_pid"), p1, sizeof(p1));
+
+	while (*nvram_safe_get("rc_service")) {
+		if(--i < 0) {
+			/* now the dead go peace */
+			if(!*p1)
+				nvram_set("rc_service", "");
+			return 0;
+		}
+
+		if(first_try){
+			logmessage_normal("rc_service", "waitting \"%s\" via %s ...", nvram_safe_get("rc_service"), p1);
+			first_try = 0;
+		}
+
+		_dprintf("%d: wait for previous script(%d/%d): %s %d %s.\n", getpid(), i, wait, nvram_safe_get("rc_service"), nvram_get_int("rc_service_pid"), p1);
+		sleep(1);
+	}
+
+	return 1;
+}
+
+
+/* @return:
+ * 	0:	success
+ *     -1:	invalid parameter
+ *      1:	wait pending rc_service timeout
+ */
+static int notify_rc_internal(const char *event_name, bool do_wait, int wait)
+{
+	int i;
+	char p2[16];
+
+	if (!event_name || wait < 0)
+		return -1;
+
+	psname(getpid(), p2, sizeof(p2));
+	_dprintf("<rc_service> [i:%s] %d:notify_rc %s", p2, getpid(), event_name);
+	logmessage_normal("rc_service", "%s %d:notify_rc %s", p2, getpid(), event_name);
+
+	// finish the last rc_service as soon as possibly.
+	if(strstr(event_name, "reboot")){
+		_dprintf("%s: kill the shell scripts for reboot.\n", event_name);
+		eval("killall", "sh");
+	}
+
+	if (!wait_rc_service(wait)) {
+		logmessage_normal("rc_service", "skip the event: %s.", event_name);
+		_dprintf("rc_service: skip the event: %s.\n", event_name);
+		return 1;
+	}
+
+	nvram_set("rc_service", event_name);
+	nvram_set_int("rc_service_pid", getpid());
+	kill(1, SIGUSR1);
+
+	if(do_wait)
+	{
+		i = wait;
+		while((nvram_match("rc_service", (char *)event_name))&&(i-- > 0)) {
+			_dprintf("%s %d: waiting after %d/%d.\n", event_name, getpid(), i, wait);
+			sleep(1);
+		}
+		if(i == 0 && nvram_match("rc_service", (char *)event_name))
+			return 2;
+	}
+
+	return 0;
+}
+
+
--- a/release/src/router/busybox/config_base
+++ b/release/src/router/busybox/config_base
@@ -110,7 +110,7 @@
 CONFIG_FEATURE_EDITING_MAX_LEN=1024
 # CONFIG_FEATURE_EDITING_VI is not set
 CONFIG_FEATURE_EDITING_HISTORY=50
-CONFIG_FEATURE_EDITING_SAVEHISTORY=y
+# CONFIG_FEATURE_EDITING_SAVEHISTORY is not set
 # CONFIG_FEATURE_EDITING_SAVE_ON_EXIT is not set
 CONFIG_FEATURE_REVERSE_SEARCH=y
 CONFIG_FEATURE_TAB_COMPLETION=y
@@ -211,8 +211,8 @@
 # CONFIG_FEATURE_TR_EQUIV is not set
 # CONFIG_TRUNCATE is not set
 # CONFIG_UNLINK is not set
-# CONFIG_BASE64 is not set
-# CONFIG_WHO is not set
+CONFIG_BASE64=y
+CONFIG_WHO=y
 # CONFIG_USERS is not set
 # CONFIG_CAL is not set
 # CONFIG_CATV is not set
@@ -279,10 +279,10 @@
 CONFIG_RMDIR=y
 # CONFIG_FEATURE_RMDIR_LONG_OPTIONS is not set
 # CONFIG_SEQ is not set
-# CONFIG_SHA1SUM is not set
-# CONFIG_SHA256SUM is not set
-# CONFIG_SHA512SUM is not set
-# CONFIG_SHA3SUM is not set
+CONFIG_SHA1SUM=y
+CONFIG_SHA256SUM=y
+CONFIG_SHA512SUM=y
+CONFIG_SHA3SUM=y
 CONFIG_SLEEP=y
 CONFIG_FEATURE_FANCY_SLEEP=y
 # CONFIG_FEATURE_FLOAT_SLEEP is not set
@@ -290,7 +290,7 @@
 CONFIG_FEATURE_SORT_BIG=y
 # CONFIG_SPLIT is not set
 # CONFIG_FEATURE_SPLIT_FANCY is not set
-# CONFIG_STTY is not set
+CONFIG_STTY=y
 # CONFIG_SUM is not set
 # CONFIG_TAC is not set
 CONFIG_TAIL=y
@@ -305,11 +305,11 @@
 # CONFIG_FEATURE_UNEXPAND_LONG_OPTIONS is not set
 CONFIG_UNIQ=y
 CONFIG_USLEEP=y
-# CONFIG_UUDECODE is not set
-# CONFIG_UUENCODE is not set
+CONFIG_UUDECODE=y
+CONFIG_UUENCODE=y
 CONFIG_WC=y
 CONFIG_FEATURE_WC_LARGE=y
-# CONFIG_WHOAMI is not set
+CONFIG_WHOAMI=y
 # CONFIG_YES is not set
 
 #
@@ -411,9 +411,9 @@
 #
 # Finding Utilities
 #
-CONFIG_FIND=y
-CONFIG_FEATURE_FIND_PRINT0=y
-CONFIG_FEATURE_FIND_MTIME=y
+# CONFIG_FIND is not set
+# CONFIG_FEATURE_FIND_PRINT0 is not set
+# CONFIG_FEATURE_FIND_MTIME is not set
 # CONFIG_FEATURE_FIND_MMIN is not set
 # CONFIG_FEATURE_FIND_PERM is not set
 # CONFIG_FEATURE_FIND_TYPE is not set
@@ -421,11 +421,11 @@
 # CONFIG_FEATURE_FIND_MAXDEPTH is not set
 # CONFIG_FEATURE_FIND_NEWER is not set
 # CONFIG_FEATURE_FIND_INUM is not set
-CONFIG_FEATURE_FIND_EXEC=y
+# CONFIG_FEATURE_FIND_EXEC is not set
 # CONFIG_FEATURE_FIND_EXEC_PLUS is not set
 # CONFIG_FEATURE_FIND_USER is not set
 # CONFIG_FEATURE_FIND_GROUP is not set
-CONFIG_FEATURE_FIND_NOT=y
+# CONFIG_FEATURE_FIND_NOT is not set
 # CONFIG_FEATURE_FIND_DEPTH is not set
 # CONFIG_FEATURE_FIND_PAREN is not set
 # CONFIG_FEATURE_FIND_SIZE is not set
@@ -439,12 +439,12 @@
 CONFIG_FEATURE_GREP_EGREP_ALIAS=y
 CONFIG_FEATURE_GREP_FGREP_ALIAS=y
 CONFIG_FEATURE_GREP_CONTEXT=y
-CONFIG_XARGS=y
-CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION=y
-CONFIG_FEATURE_XARGS_SUPPORT_QUOTES=y
-CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT=y
-CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM=y
-CONFIG_FEATURE_XARGS_SUPPORT_REPL_STR=y
+# CONFIG_XARGS is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_QUOTES is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_REPL_STR is not set
 
 #
 # Init Utilities
@@ -870,9 +870,9 @@
 CONFIG_FEATURE_NETSTAT_WIDE=y
 # CONFIG_FEATURE_NETSTAT_PRG is not set
 CONFIG_NSLOOKUP=y
-CONFIG_NTPD=y
-CONFIG_FEATURE_NTPD_SERVER=y
-CONFIG_FEATURE_NTPD_CONF=y
+# CONFIG_NTPD is not set
+# CONFIG_FEATURE_NTPD_SERVER is not set
+# CONFIG_FEATURE_NTPD_CONF is not set
 CONFIG_PSCAN=y
 CONFIG_ROUTE=y
 # CONFIG_SLATTACH is not set
--- a/release/src/router/busybox/include/libbb.h
+++ b/release/src/router/busybox/include/libbb.h
@@ -1566,6 +1566,7 @@
  */
 int read_line_input(line_input_t *st, const char *prompt, char *command, int maxsize, int timeout) FAST_FUNC;
 void show_history(const line_input_t *st) FAST_FUNC;
+void clear_history(line_input_t *st) FAST_FUNC;
 # if ENABLE_FEATURE_EDITING_SAVE_ON_EXIT
 void save_history(line_input_t *st);
 # endif
--- a/release/src/router/busybox/libbb/lineedit.c
+++ b/release/src/router/busybox/libbb/lineedit.c
@@ -1341,6 +1341,41 @@
 		printf("%4d %s\n", i, st->history[i]);
 }
 
+// the function secure_memory_wipe(), aka OPENSSL_cleanse(), was stolen from 
+// OpenSSL because we need a way to securely wipe the ash command history from
+// memory without the compiler optimizing it away
+static unsigned char secure_memory_wipe_ctr = 0;
+static void secure_memory_wipe(void *ptr, size_t len)
+{
+	unsigned char *p = ptr;
+	size_t loop = len, ctr = secure_memory_wipe_ctr;
+	while(loop--)
+		{
+		*(p++) = (unsigned char)ctr;
+		ctr += (17 + ((size_t)p & 0xF));
+		}
+	p=memchr(ptr, (unsigned char)ctr, len);
+	if(p)
+		ctr += (63 + (size_t)p);
+	secure_memory_wipe_ctr = (unsigned char)ctr;
+}
+
+/* Clears command history. Used by shell 'history' builtins */
+void FAST_FUNC clear_history(line_input_t *st)
+{
+	int i;
+
+	if (!st)
+		return;
+
+	for (i = 0; i < st->cnt_history; i++) {
+		secure_memory_wipe(st->history[i], strlen(st->history[i]));
+		free(st->history[i]);
+		st->history[i] = NULL;
+	}
+	st->cur_history = st->cnt_history = 0;
+}
+
 # if ENABLE_FEATURE_EDITING_SAVEHISTORY
 /* We try to ensure that concurrent additions to the history
  * do not overwrite each other.
--- a/release/src/router/busybox/shell/ash.c
+++ b/release/src/router/busybox/shell/ash.c
@@ -12611,6 +12611,10 @@
 static int FAST_FUNC
 historycmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 {
+	if (nextopt("c") != '\0') {
+		clear_history(line_input_state);
+		return EXIT_SUCCESS;
+	}
 	show_history(line_input_state);
 	return EXIT_SUCCESS;
 }
--- a/release/src/router/busybox/shell/hush.c
+++ b/release/src/router/busybox/shell/hush.c
@@ -8715,6 +8715,15 @@
 #if MAX_HISTORY && ENABLE_FEATURE_EDITING
 static int FAST_FUNC builtin_history(char **argv UNUSED_PARAM)
 {
+	unsigned opts;
+
+	opts = getopt32(argv, "!c");
+	if (opts == (unsigned)-1)
+		return EXIT_FAILURE;
+	if (opts & 1) {
+		clear_history(G.line_input_state);
+		return EXIT_SUCCESS;
+	}
 	show_history(G.line_input_state);
 	return EXIT_SUCCESS;
 }
